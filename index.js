import {Transmit as lX} from "https://cdn.jsdelivr.net/npm/@adonisjs/transmit-client/+esm";
function cX(n, e) {
    for (var t = 0; t < e.length; t++) {
        const r = e[t];
        if (typeof r != "string" && !Array.isArray(r)) {
            for (const s in r)
                if (s !== "default" && !(s in n)) {
                    const i = Object.getOwnPropertyDescriptor(r, s);
                    i && Object.defineProperty(n, s, i.get ? i : {
                        enumerable: !0,
                        get: () => r[s]
                    })
                }
        }
    }
    return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, {
        value: "Module"
    }))
}
(function() {
    const e = document.createElement("link").relList;
    if (e && e.supports && e.supports("modulepreload"))
        return;
    for (const s of document.querySelectorAll('link[rel="modulepreload"]'))
        r(s);
    new MutationObserver(s => {
        for (const i of s)
            if (i.type === "childList")
                for (const o of i.addedNodes)
                    o.tagName === "LINK" && o.rel === "modulepreload" && r(o)
    }
    ).observe(document, {
        childList: !0,
        subtree: !0
    });
    function t(s) {
        const i = {};
        return s.integrity && (i.integrity = s.integrity),
        s.referrerPolicy && (i.referrerPolicy = s.referrerPolicy),
        s.crossOrigin === "use-credentials" ? i.credentials = "include" : s.crossOrigin === "anonymous" ? i.credentials = "omit" : i.credentials = "same-origin",
        i
    }
    function r(s) {
        if (s.ep)
            return;
        s.ep = !0;
        const i = t(s);
        fetch(s.href, i)
    }
}
)();
var To = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Fo(n) {
    return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n
}
function S8(n) {
    if (Object.prototype.hasOwnProperty.call(n, "__esModule"))
        return n;
    var e = n.default;
    if (typeof e == "function") {
        var t = function r() {
            var s = !1;
            try {
                s = this instanceof r
            } catch {}
            return s ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments)
        };
        t.prototype = e.prototype
    } else
        t = {};
    return Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    Object.keys(n).forEach(function(r) {
        var s = Object.getOwnPropertyDescriptor(n, r);
        Object.defineProperty(t, r, s.get ? s : {
            enumerable: !0,
            get: function() {
                return n[r]
            }
        })
    }),
    t
}
var dS = {
    exports: {}
}
  , Dm = {};
var LT;
function uX() {
    if (LT)
        return Dm;
    LT = 1;
    var n = Symbol.for("react.transitional.element")
      , e = Symbol.for("react.fragment");
    function t(r, s, i) {
        var o = null;
        if (i !== void 0 && (o = "" + i),
        s.key !== void 0 && (o = "" + s.key),
        "key"in s) {
            i = {};
            for (var a in s)
                a !== "key" && (i[a] = s[a])
        } else
            i = s;
        return s = i.ref,
        {
            $$typeof: n,
            type: r,
            key: o,
            ref: s !== void 0 ? s : null,
            props: i
        }
    }
    return Dm.Fragment = e,
    Dm.jsx = t,
    Dm.jsxs = t,
    Dm
}
var FT;
function A8() {
    return FT || (FT = 1,
    dS.exports = uX()),
    dS.exports
}
var m = A8()
  , fS = {
    exports: {}
}
  , kt = {};
var UT;
function dX() {
    if (UT)
        return kt;
    UT = 1;
    var n = Symbol.for("react.transitional.element")
      , e = Symbol.for("react.portal")
      , t = Symbol.for("react.fragment")
      , r = Symbol.for("react.strict_mode")
      , s = Symbol.for("react.profiler")
      , i = Symbol.for("react.consumer")
      , o = Symbol.for("react.context")
      , a = Symbol.for("react.forward_ref")
      , l = Symbol.for("react.suspense")
      , u = Symbol.for("react.memo")
      , d = Symbol.for("react.lazy")
      , h = Symbol.for("react.activity")
      , p = Symbol.iterator;
    function g($) {
        return $ === null || typeof $ != "object" ? null : ($ = p && $[p] || $["@@iterator"],
        typeof $ == "function" ? $ : null)
    }
    var w = {
        isMounted: function() {
            return !1
        },
        enqueueForceUpdate: function() {},
        enqueueReplaceState: function() {},
        enqueueSetState: function() {}
    }
      , b = Object.assign
      , v = {};
    function S($, D, U) {
        this.props = $,
        this.context = D,
        this.refs = v,
        this.updater = U || w
    }
    S.prototype.isReactComponent = {},
    S.prototype.setState = function($, D) {
        if (typeof $ != "object" && typeof $ != "function" && $ != null)
            throw Error("takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, $, D, "setState")
    }
    ,
    S.prototype.forceUpdate = function($) {
        this.updater.enqueueForceUpdate(this, $, "forceUpdate")
    }
    ;
    function N() {}
    N.prototype = S.prototype;
    function _($, D, U) {
        this.props = $,
        this.context = D,
        this.refs = v,
        this.updater = U || w
    }
    var I = _.prototype = new N;
    I.constructor = _,
    b(I, S.prototype),
    I.isPureReactComponent = !0;
    var k = Array.isArray;
    function B() {}
    var P = {
        H: null,
        A: null,
        T: null,
        S: null
    }
      , M = Object.prototype.hasOwnProperty;
    function R($, D, U) {
        var W = U.ref;
        return {
            $$typeof: n,
            type: $,
            key: D,
            ref: W !== void 0 ? W : null,
            props: U
        }
    }
    function L($, D) {
        return R($.type, D, $.props)
    }
    function q($) {
        return typeof $ == "object" && $ !== null && $.$$typeof === n
    }
    function H($) {
        var D = {
            "=": "=0",
            ":": "=2"
        };
        return "$" + $.replace(/[=:]/g, function(U) {
            return D[U]
        })
    }
    var j = /\/+/g;
    function A($, D) {
        return typeof $ == "object" && $ !== null && $.key != null ? H("" + $.key) : D.toString(36)
    }
    function E($) {
        switch ($.status) {
        case "fulfilled":
            return $.value;
        case "rejected":
            throw $.reason;
        default:
            switch (typeof $.status == "string" ? $.then(B, B) : ($.status = "pending",
            $.then(function(D) {
                $.status === "pending" && ($.status = "fulfilled",
                $.value = D)
            }, function(D) {
                $.status === "pending" && ($.status = "rejected",
                $.reason = D)
            })),
            $.status) {
            case "fulfilled":
                return $.value;
            case "rejected":
                throw $.reason
            }
        }
        throw $
    }
    function C($, D, U, W, Q) {
        var J = typeof $;
        (J === "undefined" || J === "boolean") && ($ = null);
        var ne = !1;
        if ($ === null)
            ne = !0;
        else
            switch (J) {
            case "bigint":
            case "string":
            case "number":
                ne = !0;
                break;
            case "object":
                switch ($.$$typeof) {
                case n:
                case e:
                    ne = !0;
                    break;
                case d:
                    return ne = $._init,
                    C(ne($._payload), D, U, W, Q)
                }
            }
        if (ne)
            return Q = Q($),
            ne = W === "" ? "." + A($, 0) : W,
            k(Q) ? (U = "",
            ne != null && (U = ne.replace(j, "$&/") + "/"),
            C(Q, D, U, "", function(xe) {
                return xe
            })) : Q != null && (q(Q) && (Q = L(Q, U + (Q.key == null || $ && $.key === Q.key ? "" : ("" + Q.key).replace(j, "$&/") + "/") + ne)),
            D.push(Q)),
            1;
        ne = 0;
        var ie = W === "" ? "." : W + ":";
        if (k($))
            for (var ae = 0; ae < $.length; ae++)
                W = $[ae],
                J = ie + A(W, ae),
                ne += C(W, D, U, J, Q);
        else if (ae = g($),
        typeof ae == "function")
            for ($ = ae.call($),
            ae = 0; !(W = $.next()).done; )
                W = W.value,
                J = ie + A(W, ae++),
                ne += C(W, D, U, J, Q);
        else if (J === "object") {
            if (typeof $.then == "function")
                return C(E($), D, U, W, Q);
            throw D = String($),
            Error("Objects are not valid as a React child (found: " + (D === "[object Object]" ? "object with keys {" + Object.keys($).join(", ") + "}" : D) + "). If you meant to render a collection of children, use an array instead.")
        }
        return ne
    }
    function O($, D, U) {
        if ($ == null)
            return $;
        var W = []
          , Q = 0;
        return C($, W, "", "", function(J) {
            return D.call(U, J, Q++)
        }),
        W
    }
    function z($) {
        if ($._status === -1) {
            var D = $._result;
            D = D(),
            D.then(function(U) {
                ($._status === 0 || $._status === -1) && ($._status = 1,
                $._result = U)
            }, function(U) {
                ($._status === 0 || $._status === -1) && ($._status = 2,
                $._result = U)
            }),
            $._status === -1 && ($._status = 0,
            $._result = D)
        }
        if ($._status === 1)
            return $._result.default;
        throw $._result
    }
    var G = typeof reportError == "function" ? reportError : function($) {
        if (typeof window == "object" && typeof window.ErrorEvent == "function") {
            var D = new window.ErrorEvent("error",{
                bubbles: !0,
                cancelable: !0,
                message: typeof $ == "object" && $ !== null && typeof $.message == "string" ? String($.message) : String($),
                error: $
            });
            if (!window.dispatchEvent(D))
                return
        } else if (typeof process == "object" && typeof process.emit == "function") {
            process.emit("uncaughtException", $);
            return
        }
        console.error($)
    }
      , Y = {
        map: O,
        forEach: function($, D, U) {
            O($, function() {
                D.apply(this, arguments)
            }, U)
        },
        count: function($) {
            var D = 0;
            return O($, function() {
                D++
            }),
            D
        },
        toArray: function($) {
            return O($, function(D) {
                return D
            }) || []
        },
        only: function($) {
            if (!q($))
                throw Error("React.Children.only expected to receive a single React element child.");
            return $
        }
    };
    return kt.Activity = h,
    kt.Children = Y,
    kt.Component = S,
    kt.Fragment = t,
    kt.Profiler = s,
    kt.PureComponent = _,
    kt.StrictMode = r,
    kt.Suspense = l,
    kt.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = P,
    kt.__COMPILER_RUNTIME = {
        __proto__: null,
        c: function($) {
            return P.H.useMemoCache($)
        }
    },
    kt.cache = function($) {
        return function() {
            return $.apply(null, arguments)
        }
    }
    ,
    kt.cacheSignal = function() {
        return null
    }
    ,
    kt.cloneElement = function($, D, U) {
        if ($ == null)
            throw Error("The argument must be a React element, but you passed " + $ + ".");
        var W = b({}, $.props)
          , Q = $.key;
        if (D != null)
            for (J in D.key !== void 0 && (Q = "" + D.key),
            D)
                !M.call(D, J) || J === "key" || J === "__self" || J === "__source" || J === "ref" && D.ref === void 0 || (W[J] = D[J]);
        var J = arguments.length - 2;
        if (J === 1)
            W.children = U;
        else if (1 < J) {
            for (var ne = Array(J), ie = 0; ie < J; ie++)
                ne[ie] = arguments[ie + 2];
            W.children = ne
        }
        return R($.type, Q, W)
    }
    ,
    kt.createContext = function($) {
        return $ = {
            $$typeof: o,
            _currentValue: $,
            _currentValue2: $,
            _threadCount: 0,
            Provider: null,
            Consumer: null
        },
        $.Provider = $,
        $.Consumer = {
            $$typeof: i,
            _context: $
        },
        $
    }
    ,
    kt.createElement = function($, D, U) {
        var W, Q = {}, J = null;
        if (D != null)
            for (W in D.key !== void 0 && (J = "" + D.key),
            D)
                M.call(D, W) && W !== "key" && W !== "__self" && W !== "__source" && (Q[W] = D[W]);
        var ne = arguments.length - 2;
        if (ne === 1)
            Q.children = U;
        else if (1 < ne) {
            for (var ie = Array(ne), ae = 0; ae < ne; ae++)
                ie[ae] = arguments[ae + 2];
            Q.children = ie
        }
        if ($ && $.defaultProps)
            for (W in ne = $.defaultProps,
            ne)
                Q[W] === void 0 && (Q[W] = ne[W]);
        return R($, J, Q)
    }
    ,
    kt.createRef = function() {
        return {
            current: null
        }
    }
    ,
    kt.forwardRef = function($) {
        return {
            $$typeof: a,
            render: $
        }
    }
    ,
    kt.isValidElement = q,
    kt.lazy = function($) {
        return {
            $$typeof: d,
            _payload: {
                _status: -1,
                _result: $
            },
            _init: z
        }
    }
    ,
    kt.memo = function($, D) {
        return {
            $$typeof: u,
            type: $,
            compare: D === void 0 ? null : D
        }
    }
    ,
    kt.startTransition = function($) {
        var D = P.T
          , U = {};
        P.T = U;
        try {
            var W = $()
              , Q = P.S;
            Q !== null && Q(U, W),
            typeof W == "object" && W !== null && typeof W.then == "function" && W.then(B, G)
        } catch (J) {
            G(J)
        } finally {
            D !== null && U.types !== null && (D.types = U.types),
            P.T = D
        }
    }
    ,
    kt.unstable_useCacheRefresh = function() {
        return P.H.useCacheRefresh()
    }
    ,
    kt.use = function($) {
        return P.H.use($)
    }
    ,
    kt.useActionState = function($, D, U) {
        return P.H.useActionState($, D, U)
    }
    ,
    kt.useCallback = function($, D) {
        return P.H.useCallback($, D)
    }
    ,
    kt.useContext = function($) {
        return P.H.useContext($)
    }
    ,
    kt.useDebugValue = function() {}
    ,
    kt.useDeferredValue = function($, D) {
        return P.H.useDeferredValue($, D)
    }
    ,
    kt.useEffect = function($, D) {
        return P.H.useEffect($, D)
    }
    ,
    kt.useEffectEvent = function($) {
        return P.H.useEffectEvent($)
    }
    ,
    kt.useId = function() {
        return P.H.useId()
    }
    ,
    kt.useImperativeHandle = function($, D, U) {
        return P.H.useImperativeHandle($, D, U)
    }
    ,
    kt.useInsertionEffect = function($, D) {
        return P.H.useInsertionEffect($, D)
    }
    ,
    kt.useLayoutEffect = function($, D) {
        return P.H.useLayoutEffect($, D)
    }
    ,
    kt.useMemo = function($, D) {
        return P.H.useMemo($, D)
    }
    ,
    kt.useOptimistic = function($, D) {
        return P.H.useOptimistic($, D)
    }
    ,
    kt.useReducer = function($, D, U) {
        return P.H.useReducer($, D, U)
    }
    ,
    kt.useRef = function($) {
        return P.H.useRef($)
    }
    ,
    kt.useState = function($) {
        return P.H.useState($)
    }
    ,
    kt.useSyncExternalStore = function($, D, U) {
        return P.H.useSyncExternalStore($, D, U)
    }
    ,
    kt.useTransition = function() {
        return P.H.useTransition()
    }
    ,
    kt.version = "19.2.0",
    kt
}
var zT;
function by() {
    return zT || (zT = 1,
    fS.exports = dX()),
    fS.exports
}
var V = by();
const ye = Fo(V)
  , X9 = cX({
    __proto__: null,
    default: ye
}, [V]);
var hS = {
    exports: {}
}
  , Tm = {}
  , pS = {
    exports: {}
}
  , mS = {};
var $T;
function fX() {
    return $T || ($T = 1,
    (function(n) {
        function e(C, O) {
            var z = C.length;
            C.push(O);
            e: for (; 0 < z; ) {
                var G = z - 1 >>> 1
                  , Y = C[G];
                if (0 < s(Y, O))
                    C[G] = O,
                    C[z] = Y,
                    z = G;
                else
                    break e
            }
        }
        function t(C) {
            return C.length === 0 ? null : C[0]
        }
        function r(C) {
            if (C.length === 0)
                return null;
            var O = C[0]
              , z = C.pop();
            if (z !== O) {
                C[0] = z;
                e: for (var G = 0, Y = C.length, $ = Y >>> 1; G < $; ) {
                    var D = 2 * (G + 1) - 1
                      , U = C[D]
                      , W = D + 1
                      , Q = C[W];
                    if (0 > s(U, z))
                        W < Y && 0 > s(Q, U) ? (C[G] = Q,
                        C[W] = z,
                        G = W) : (C[G] = U,
                        C[D] = z,
                        G = D);
                    else if (W < Y && 0 > s(Q, z))
                        C[G] = Q,
                        C[W] = z,
                        G = W;
                    else
                        break e
                }
            }
            return O
        }
        function s(C, O) {
            var z = C.sortIndex - O.sortIndex;
            return z !== 0 ? z : C.id - O.id
        }
        if (n.unstable_now = void 0,
        typeof performance == "object" && typeof performance.now == "function") {
            var i = performance;
            n.unstable_now = function() {
                return i.now()
            }
        } else {
            var o = Date
              , a = o.now();
            n.unstable_now = function() {
                return o.now() - a
            }
        }
        var l = []
          , u = []
          , d = 1
          , h = null
          , p = 3
          , g = !1
          , w = !1
          , b = !1
          , v = !1
          , S = typeof setTimeout == "function" ? setTimeout : null
          , N = typeof clearTimeout == "function" ? clearTimeout : null
          , _ = typeof setImmediate < "u" ? setImmediate : null;
        function I(C) {
            for (var O = t(u); O !== null; ) {
                if (O.callback === null)
                    r(u);
                else if (O.startTime <= C)
                    r(u),
                    O.sortIndex = O.expirationTime,
                    e(l, O);
                else
                    break;
                O = t(u)
            }
        }
        function k(C) {
            if (b = !1,
            I(C),
            !w)
                if (t(l) !== null)
                    w = !0,
                    B || (B = !0,
                    H());
                else {
                    var O = t(u);
                    O !== null && E(k, O.startTime - C)
                }
        }
        var B = !1
          , P = -1
          , M = 5
          , R = -1;
        function L() {
            return v ? !0 : !(n.unstable_now() - R < M)
        }
        function q() {
            if (v = !1,
            B) {
                var C = n.unstable_now();
                R = C;
                var O = !0;
                try {
                    e: {
                        w = !1,
                        b && (b = !1,
                        N(P),
                        P = -1),
                        g = !0;
                        var z = p;
                        try {
                            t: {
                                for (I(C),
                                h = t(l); h !== null && !(h.expirationTime > C && L()); ) {
                                    var G = h.callback;
                                    if (typeof G == "function") {
                                        h.callback = null,
                                        p = h.priorityLevel;
                                        var Y = G(h.expirationTime <= C);
                                        if (C = n.unstable_now(),
                                        typeof Y == "function") {
                                            h.callback = Y,
                                            I(C),
                                            O = !0;
                                            break t
                                        }
                                        h === t(l) && r(l),
                                        I(C)
                                    } else
                                        r(l);
                                    h = t(l)
                                }
                                if (h !== null)
                                    O = !0;
                                else {
                                    var $ = t(u);
                                    $ !== null && E(k, $.startTime - C),
                                    O = !1
                                }
                            }
                            break e
                        } finally {
                            h = null,
                            p = z,
                            g = !1
                        }
                        O = void 0
                    }
                } finally {
                    O ? H() : B = !1
                }
            }
        }
        var H;
        if (typeof _ == "function")
            H = function() {
                _(q)
            }
            ;
        else if (typeof MessageChannel < "u") {
            var j = new MessageChannel
              , A = j.port2;
            j.port1.onmessage = q,
            H = function() {
                A.postMessage(null)
            }
        } else
            H = function() {
                S(q, 0)
            }
            ;
        function E(C, O) {
            P = S(function() {
                C(n.unstable_now())
            }, O)
        }
        n.unstable_IdlePriority = 5,
        n.unstable_ImmediatePriority = 1,
        n.unstable_LowPriority = 4,
        n.unstable_NormalPriority = 3,
        n.unstable_Profiling = null,
        n.unstable_UserBlockingPriority = 2,
        n.unstable_cancelCallback = function(C) {
            C.callback = null
        }
        ,
        n.unstable_forceFrameRate = function(C) {
            0 > C || 125 < C ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : M = 0 < C ? Math.floor(1e3 / C) : 5
        }
        ,
        n.unstable_getCurrentPriorityLevel = function() {
            return p
        }
        ,
        n.unstable_next = function(C) {
            switch (p) {
            case 1:
            case 2:
            case 3:
                var O = 3;
                break;
            default:
                O = p
            }
            var z = p;
            p = O;
            try {
                return C()
            } finally {
                p = z
            }
        }
        ,
        n.unstable_requestPaint = function() {
            v = !0
        }
        ,
        n.unstable_runWithPriority = function(C, O) {
            switch (C) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                break;
            default:
                C = 3
            }
            var z = p;
            p = C;
            try {
                return O()
            } finally {
                p = z
            }
        }
        ,
        n.unstable_scheduleCallback = function(C, O, z) {
            var G = n.unstable_now();
            switch (typeof z == "object" && z !== null ? (z = z.delay,
            z = typeof z == "number" && 0 < z ? G + z : G) : z = G,
            C) {
            case 1:
                var Y = -1;
                break;
            case 2:
                Y = 250;
                break;
            case 5:
                Y = 1073741823;
                break;
            case 4:
                Y = 1e4;
                break;
            default:
                Y = 5e3
            }
            return Y = z + Y,
            C = {
                id: d++,
                callback: O,
                priorityLevel: C,
                startTime: z,
                expirationTime: Y,
                sortIndex: -1
            },
            z > G ? (C.sortIndex = z,
            e(u, C),
            t(l) === null && C === t(u) && (b ? (N(P),
            P = -1) : b = !0,
            E(k, z - G))) : (C.sortIndex = Y,
            e(l, C),
            w || g || (w = !0,
            B || (B = !0,
            H()))),
            C
        }
        ,
        n.unstable_shouldYield = L,
        n.unstable_wrapCallback = function(C) {
            var O = p;
            return function() {
                var z = p;
                p = O;
                try {
                    return C.apply(this, arguments)
                } finally {
                    p = z
                }
            }
        }
    }
    )(mS)),
    mS
}
var HT;
function hX() {
    return HT || (HT = 1,
    pS.exports = fX()),
    pS.exports
}
var gS = {
    exports: {}
}
  , ks = {};
var VT;
function pX() {
    if (VT)
        return ks;
    VT = 1;
    var n = by();
    function e(l) {
        var u = "https://react.dev/errors/" + l;
        if (1 < arguments.length) {
            u += "?args[]=" + encodeURIComponent(arguments[1]);
            for (var d = 2; d < arguments.length; d++)
                u += "&args[]=" + encodeURIComponent(arguments[d])
        }
        return "Minified React error #" + l + "; visit " + u + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    }
    function t() {}
    var r = {
        d: {
            f: t,
            r: function() {
                throw Error(e(522))
            },
            D: t,
            C: t,
            L: t,
            m: t,
            X: t,
            S: t,
            M: t
        },
        p: 0,
        findDOMNode: null
    }
      , s = Symbol.for("react.portal");
    function i(l, u, d) {
        var h = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
        return {
            $$typeof: s,
            key: h == null ? null : "" + h,
            children: l,
            containerInfo: u,
            implementation: d
        }
    }
    var o = n.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
    function a(l, u) {
        if (l === "font")
            return "";
        if (typeof u == "string")
            return u === "use-credentials" ? u : ""
    }
    return ks.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = r,
    ks.createPortal = function(l, u) {
        var d = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
        if (!u || u.nodeType !== 1 && u.nodeType !== 9 && u.nodeType !== 11)
            throw Error(e(299));
        return i(l, u, null, d)
    }
    ,
    ks.flushSync = function(l) {
        var u = o.T
          , d = r.p;
        try {
            if (o.T = null,
            r.p = 2,
            l)
                return l()
        } finally {
            o.T = u,
            r.p = d,
            r.d.f()
        }
    }
    ,
    ks.preconnect = function(l, u) {
        typeof l == "string" && (u ? (u = u.crossOrigin,
        u = typeof u == "string" ? u === "use-credentials" ? u : "" : void 0) : u = null,
        r.d.C(l, u))
    }
    ,
    ks.prefetchDNS = function(l) {
        typeof l == "string" && r.d.D(l)
    }
    ,
    ks.preinit = function(l, u) {
        if (typeof l == "string" && u && typeof u.as == "string") {
            var d = u.as
              , h = a(d, u.crossOrigin)
              , p = typeof u.integrity == "string" ? u.integrity : void 0
              , g = typeof u.fetchPriority == "string" ? u.fetchPriority : void 0;
            d === "style" ? r.d.S(l, typeof u.precedence == "string" ? u.precedence : void 0, {
                crossOrigin: h,
                integrity: p,
                fetchPriority: g
            }) : d === "script" && r.d.X(l, {
                crossOrigin: h,
                integrity: p,
                fetchPriority: g,
                nonce: typeof u.nonce == "string" ? u.nonce : void 0
            })
        }
    }
    ,
    ks.preinitModule = function(l, u) {
        if (typeof l == "string")
            if (typeof u == "object" && u !== null) {
                if (u.as == null || u.as === "script") {
                    var d = a(u.as, u.crossOrigin);
                    r.d.M(l, {
                        crossOrigin: d,
                        integrity: typeof u.integrity == "string" ? u.integrity : void 0,
                        nonce: typeof u.nonce == "string" ? u.nonce : void 0
                    })
                }
            } else
                u == null && r.d.M(l)
    }
    ,
    ks.preload = function(l, u) {
        if (typeof l == "string" && typeof u == "object" && u !== null && typeof u.as == "string") {
            var d = u.as
              , h = a(d, u.crossOrigin);
            r.d.L(l, d, {
                crossOrigin: h,
                integrity: typeof u.integrity == "string" ? u.integrity : void 0,
                nonce: typeof u.nonce == "string" ? u.nonce : void 0,
                type: typeof u.type == "string" ? u.type : void 0,
                fetchPriority: typeof u.fetchPriority == "string" ? u.fetchPriority : void 0,
                referrerPolicy: typeof u.referrerPolicy == "string" ? u.referrerPolicy : void 0,
                imageSrcSet: typeof u.imageSrcSet == "string" ? u.imageSrcSet : void 0,
                imageSizes: typeof u.imageSizes == "string" ? u.imageSizes : void 0,
                media: typeof u.media == "string" ? u.media : void 0
            })
        }
    }
    ,
    ks.preloadModule = function(l, u) {
        if (typeof l == "string")
            if (u) {
                var d = a(u.as, u.crossOrigin);
                r.d.m(l, {
                    as: typeof u.as == "string" && u.as !== "script" ? u.as : void 0,
                    crossOrigin: d,
                    integrity: typeof u.integrity == "string" ? u.integrity : void 0
                })
            } else
                r.d.m(l)
    }
    ,
    ks.requestFormReset = function(l) {
        r.d.r(l)
    }
    ,
    ks.unstable_batchedUpdates = function(l, u) {
        return l(u)
    }
    ,
    ks.useFormState = function(l, u, d) {
        return o.H.useFormState(l, u, d)
    }
    ,
    ks.useFormStatus = function() {
        return o.H.useHostTransitionStatus()
    }
    ,
    ks.version = "19.2.0",
    ks
}
var qT;
function Q9() {
    if (qT)
        return gS.exports;
    qT = 1;
    function n() {
        if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
            try {
                __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)
            } catch (e) {
                console.error(e)
            }
    }
    return n(),
    gS.exports = pX(),
    gS.exports
}
var GT;
function mX() {
    if (GT)
        return Tm;
    GT = 1;
    var n = hX()
      , e = by()
      , t = Q9();
    function r(c) {
        var f = "https://react.dev/errors/" + c;
        if (1 < arguments.length) {
            f += "?args[]=" + encodeURIComponent(arguments[1]);
            for (var y = 2; y < arguments.length; y++)
                f += "&args[]=" + encodeURIComponent(arguments[y])
        }
        return "Minified React error #" + c + "; visit " + f + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    }
    function s(c) {
        return !(!c || c.nodeType !== 1 && c.nodeType !== 9 && c.nodeType !== 11)
    }
    function i(c) {
        var f = c
          , y = c;
        if (c.alternate)
            for (; f.return; )
                f = f.return;
        else {
            c = f;
            do
                f = c,
                (f.flags & 4098) !== 0 && (y = f.return),
                c = f.return;
            while (c)
        }
        return f.tag === 3 ? y : null
    }
    function o(c) {
        if (c.tag === 13) {
            var f = c.memoizedState;
            if (f === null && (c = c.alternate,
            c !== null && (f = c.memoizedState)),
            f !== null)
                return f.dehydrated
        }
        return null
    }
    function a(c) {
        if (c.tag === 31) {
            var f = c.memoizedState;
            if (f === null && (c = c.alternate,
            c !== null && (f = c.memoizedState)),
            f !== null)
                return f.dehydrated
        }
        return null
    }
    function l(c) {
        if (i(c) !== c)
            throw Error(r(188))
    }
    function u(c) {
        var f = c.alternate;
        if (!f) {
            if (f = i(c),
            f === null)
                throw Error(r(188));
            return f !== c ? null : c
        }
        for (var y = c, x = f; ; ) {
            var T = y.return;
            if (T === null)
                break;
            var F = T.alternate;
            if (F === null) {
                if (x = T.return,
                x !== null) {
                    y = x;
                    continue
                }
                break
            }
            if (T.child === F.child) {
                for (F = T.child; F; ) {
                    if (F === y)
                        return l(T),
                        c;
                    if (F === x)
                        return l(T),
                        f;
                    F = F.sibling
                }
                throw Error(r(188))
            }
            if (y.return !== x.return)
                y = T,
                x = F;
            else {
                for (var Z = !1, te = T.child; te; ) {
                    if (te === y) {
                        Z = !0,
                        y = T,
                        x = F;
                        break
                    }
                    if (te === x) {
                        Z = !0,
                        x = T,
                        y = F;
                        break
                    }
                    te = te.sibling
                }
                if (!Z) {
                    for (te = F.child; te; ) {
                        if (te === y) {
                            Z = !0,
                            y = F,
                            x = T;
                            break
                        }
                        if (te === x) {
                            Z = !0,
                            x = F,
                            y = T;
                            break
                        }
                        te = te.sibling
                    }
                    if (!Z)
                        throw Error(r(189))
                }
            }
            if (y.alternate !== x)
                throw Error(r(190))
        }
        if (y.tag !== 3)
            throw Error(r(188));
        return y.stateNode.current === y ? c : f
    }
    function d(c) {
        var f = c.tag;
        if (f === 5 || f === 26 || f === 27 || f === 6)
            return c;
        for (c = c.child; c !== null; ) {
            if (f = d(c),
            f !== null)
                return f;
            c = c.sibling
        }
        return null
    }
    var h = Object.assign
      , p = Symbol.for("react.element")
      , g = Symbol.for("react.transitional.element")
      , w = Symbol.for("react.portal")
      , b = Symbol.for("react.fragment")
      , v = Symbol.for("react.strict_mode")
      , S = Symbol.for("react.profiler")
      , N = Symbol.for("react.consumer")
      , _ = Symbol.for("react.context")
      , I = Symbol.for("react.forward_ref")
      , k = Symbol.for("react.suspense")
      , B = Symbol.for("react.suspense_list")
      , P = Symbol.for("react.memo")
      , M = Symbol.for("react.lazy")
      , R = Symbol.for("react.activity")
      , L = Symbol.for("react.memo_cache_sentinel")
      , q = Symbol.iterator;
    function H(c) {
        return c === null || typeof c != "object" ? null : (c = q && c[q] || c["@@iterator"],
        typeof c == "function" ? c : null)
    }
    var j = Symbol.for("react.client.reference");
    function A(c) {
        if (c == null)
            return null;
        if (typeof c == "function")
            return c.$$typeof === j ? null : c.displayName || c.name || null;
        if (typeof c == "string")
            return c;
        switch (c) {
        case b:
            return "Fragment";
        case S:
            return "Profiler";
        case v:
            return "StrictMode";
        case k:
            return "Suspense";
        case B:
            return "SuspenseList";
        case R:
            return "Activity"
        }
        if (typeof c == "object")
            switch (c.$$typeof) {
            case w:
                return "Portal";
            case _:
                return c.displayName || "Context";
            case N:
                return (c._context.displayName || "Context") + ".Consumer";
            case I:
                var f = c.render;
                return c = c.displayName,
                c || (c = f.displayName || f.name || "",
                c = c !== "" ? "ForwardRef(" + c + ")" : "ForwardRef"),
                c;
            case P:
                return f = c.displayName || null,
                f !== null ? f : A(c.type) || "Memo";
            case M:
                f = c._payload,
                c = c._init;
                try {
                    return A(c(f))
                } catch {}
            }
        return null
    }
    var E = Array.isArray
      , C = e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE
      , O = t.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE
      , z = {
        pending: !1,
        data: null,
        method: null,
        action: null
    }
      , G = []
      , Y = -1;
    function $(c) {
        return {
            current: c
        }
    }
    function D(c) {
        0 > Y || (c.current = G[Y],
        G[Y] = null,
        Y--)
    }
    function U(c, f) {
        Y++,
        G[Y] = c.current,
        c.current = f
    }
    var W = $(null)
      , Q = $(null)
      , J = $(null)
      , ne = $(null);
    function ie(c, f) {
        switch (U(J, f),
        U(Q, c),
        U(W, null),
        f.nodeType) {
        case 9:
        case 11:
            c = (c = f.documentElement) && (c = c.namespaceURI) ? aT(c) : 0;
            break;
        default:
            if (c = f.tagName,
            f = f.namespaceURI)
                f = aT(f),
                c = lT(f, c);
            else
                switch (c) {
                case "svg":
                    c = 1;
                    break;
                case "math":
                    c = 2;
                    break;
                default:
                    c = 0
                }
        }
        D(W),
        U(W, c)
    }
    function ae() {
        D(W),
        D(Q),
        D(J)
    }
    function xe(c) {
        c.memoizedState !== null && U(ne, c);
        var f = W.current
          , y = lT(f, c.type);
        f !== y && (U(Q, c),
        U(W, y))
    }
    function ue(c) {
        Q.current === c && (D(W),
        D(Q)),
        ne.current === c && (D(ne),
        Cm._currentValue = z)
    }
    var ce, me;
    function Ee(c) {
        if (ce === void 0)
            try {
                throw Error()
            } catch (y) {
                var f = y.stack.trim().match(/\n( *(at )?)/);
                ce = f && f[1] || "",
                me = -1 < y.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < y.stack.indexOf("@") ? "@unknown:0:0" : ""
            }
        return `
` + ce + c + me
    }
    var Oe = !1;
    function mt(c, f) {
        if (!c || Oe)
            return "";
        Oe = !0;
        var y = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
            var x = {
                DetermineComponentFrameRoot: function() {
                    try {
                        if (f) {
                            var Te = function() {
                                throw Error()
                            };
                            if (Object.defineProperty(Te.prototype, "props", {
                                set: function() {
                                    throw Error()
                                }
                            }),
                            typeof Reflect == "object" && Reflect.construct) {
                                try {
                                    Reflect.construct(Te, [])
                                } catch (Ce) {
                                    var Se = Ce
                                }
                                Reflect.construct(c, [], Te)
                            } else {
                                try {
                                    Te.call()
                                } catch (Ce) {
                                    Se = Ce
                                }
                                c.call(Te.prototype)
                            }
                        } else {
                            try {
                                throw Error()
                            } catch (Ce) {
                                Se = Ce
                            }
                            (Te = c()) && typeof Te.catch == "function" && Te.catch(function() {})
                        }
                    } catch (Ce) {
                        if (Ce && Se && typeof Ce.stack == "string")
                            return [Ce.stack, Se.stack]
                    }
                    return [null, null]
                }
            };
            x.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
            var T = Object.getOwnPropertyDescriptor(x.DetermineComponentFrameRoot, "name");
            T && T.configurable && Object.defineProperty(x.DetermineComponentFrameRoot, "name", {
                value: "DetermineComponentFrameRoot"
            });
            var F = x.DetermineComponentFrameRoot()
              , Z = F[0]
              , te = F[1];
            if (Z && te) {
                var le = Z.split(`
`)
                  , ve = te.split(`
`);
                for (T = x = 0; x < le.length && !le[x].includes("DetermineComponentFrameRoot"); )
                    x++;
                for (; T < ve.length && !ve[T].includes("DetermineComponentFrameRoot"); )
                    T++;
                if (x === le.length || T === ve.length)
                    for (x = le.length - 1,
                    T = ve.length - 1; 1 <= x && 0 <= T && le[x] !== ve[T]; )
                        T--;
                for (; 1 <= x && 0 <= T; x--,
                T--)
                    if (le[x] !== ve[T]) {
                        if (x !== 1 || T !== 1)
                            do
                                if (x--,
                                T--,
                                0 > T || le[x] !== ve[T]) {
                                    var ke = `
` + le[x].replace(" at new ", " at ");
                                    return c.displayName && ke.includes("<anonymous>") && (ke = ke.replace("<anonymous>", c.displayName)),
                                    ke
                                }
                            while (1 <= x && 0 <= T);
                        break
                    }
            }
        } finally {
            Oe = !1,
            Error.prepareStackTrace = y
        }
        return (y = c ? c.displayName || c.name : "") ? Ee(y) : ""
    }
    function st(c, f) {
        switch (c.tag) {
        case 26:
        case 27:
        case 5:
            return Ee(c.type);
        case 16:
            return Ee("Lazy");
        case 13:
            return c.child !== f && f !== null ? Ee("Suspense Fallback") : Ee("Suspense");
        case 19:
            return Ee("SuspenseList");
        case 0:
        case 15:
            return mt(c.type, !1);
        case 11:
            return mt(c.type.render, !1);
        case 1:
            return mt(c.type, !0);
        case 31:
            return Ee("Activity");
        default:
            return ""
        }
    }
    function ot(c) {
        try {
            var f = ""
              , y = null;
            do
                f += st(c, y),
                y = c,
                c = c.return;
            while (c);
            return f
        } catch (x) {
            return `
Error generating stack: ` + x.message + `
` + x.stack
        }
    }
    var Ct = Object.prototype.hasOwnProperty
      , ct = n.unstable_scheduleCallback
      , Xe = n.unstable_cancelCallback
      , Et = n.unstable_shouldYield
      , St = n.unstable_requestPaint
      , ut = n.unstable_now
      , cn = n.unstable_getCurrentPriorityLevel
      , _t = n.unstable_ImmediatePriority
      , ee = n.unstable_UserBlockingPriority
      , K = n.unstable_NormalPriority
      , X = n.unstable_LowPriority
      , re = n.unstable_IdlePriority
      , se = n.log
      , fe = n.unstable_setDisableYieldValue
      , ge = null
      , _e = null;
    function Qe(c) {
        if (typeof se == "function" && fe(c),
        _e && typeof _e.setStrictMode == "function")
            try {
                _e.setStrictMode(ge, c)
            } catch {}
    }
    var Ve = Math.clz32 ? Math.clz32 : Qt
      , jt = Math.log
      , dt = Math.LN2;
    function Qt(c) {
        return c >>>= 0,
        c === 0 ? 32 : 31 - (jt(c) / dt | 0) | 0
    }
    var Nn = 256
      , ln = 262144
      , $t = 4194304;
    function $e(c) {
        var f = c & 42;
        if (f !== 0)
            return f;
        switch (c & -c) {
        case 1:
            return 1;
        case 2:
            return 2;
        case 4:
            return 4;
        case 8:
            return 8;
        case 16:
            return 16;
        case 32:
            return 32;
        case 64:
            return 64;
        case 128:
            return 128;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
            return c & 261888;
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return c & 3932160;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
            return c & 62914560;
        case 67108864:
            return 67108864;
        case 134217728:
            return 134217728;
        case 268435456:
            return 268435456;
        case 536870912:
            return 536870912;
        case 1073741824:
            return 0;
        default:
            return c
        }
    }
    function Ue(c, f, y) {
        var x = c.pendingLanes;
        if (x === 0)
            return 0;
        var T = 0
          , F = c.suspendedLanes
          , Z = c.pingedLanes;
        c = c.warmLanes;
        var te = x & 134217727;
        return te !== 0 ? (x = te & ~F,
        x !== 0 ? T = $e(x) : (Z &= te,
        Z !== 0 ? T = $e(Z) : y || (y = te & ~c,
        y !== 0 && (T = $e(y))))) : (te = x & ~F,
        te !== 0 ? T = $e(te) : Z !== 0 ? T = $e(Z) : y || (y = x & ~c,
        y !== 0 && (T = $e(y)))),
        T === 0 ? 0 : f !== 0 && f !== T && (f & F) === 0 && (F = T & -T,
        y = f & -f,
        F >= y || F === 32 && (y & 4194048) !== 0) ? f : T
    }
    function qe(c, f) {
        return (c.pendingLanes & ~(c.suspendedLanes & ~c.pingedLanes) & f) === 0
    }
    function At(c, f) {
        switch (c) {
        case 1:
        case 2:
        case 4:
        case 8:
        case 64:
            return f + 250;
        case 16:
        case 32:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return f + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
            return -1;
        case 67108864:
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
            return -1;
        default:
            return -1
        }
    }
    function De() {
        var c = $t;
        return $t <<= 1,
        ($t & 62914560) === 0 && ($t = 4194304),
        c
    }
    function Me(c) {
        for (var f = [], y = 0; 31 > y; y++)
            f.push(c);
        return f
    }
    function Je(c, f) {
        c.pendingLanes |= f,
        f !== 268435456 && (c.suspendedLanes = 0,
        c.pingedLanes = 0,
        c.warmLanes = 0)
    }
    function Pe(c, f, y, x, T, F) {
        var Z = c.pendingLanes;
        c.pendingLanes = y,
        c.suspendedLanes = 0,
        c.pingedLanes = 0,
        c.warmLanes = 0,
        c.expiredLanes &= y,
        c.entangledLanes &= y,
        c.errorRecoveryDisabledLanes &= y,
        c.shellSuspendCounter = 0;
        var te = c.entanglements
          , le = c.expirationTimes
          , ve = c.hiddenUpdates;
        for (y = Z & ~y; 0 < y; ) {
            var ke = 31 - Ve(y)
              , Te = 1 << ke;
            te[ke] = 0,
            le[ke] = -1;
            var Se = ve[ke];
            if (Se !== null)
                for (ve[ke] = null,
                ke = 0; ke < Se.length; ke++) {
                    var Ce = Se[ke];
                    Ce !== null && (Ce.lane &= -536870913)
                }
            y &= ~Te
        }
        x !== 0 && et(c, x, 0),
        F !== 0 && T === 0 && c.tag !== 0 && (c.suspendedLanes |= F & ~(Z & ~f))
    }
    function et(c, f, y) {
        c.pendingLanes |= f,
        c.suspendedLanes &= ~f;
        var x = 31 - Ve(f);
        c.entangledLanes |= f,
        c.entanglements[x] = c.entanglements[x] | 1073741824 | y & 261930
    }
    function Nt(c, f) {
        var y = c.entangledLanes |= f;
        for (c = c.entanglements; y; ) {
            var x = 31 - Ve(y)
              , T = 1 << x;
            T & f | c[x] & f && (c[x] |= f),
            y &= ~T
        }
    }
    function pt(c, f) {
        var y = f & -f;
        return y = (y & 42) !== 0 ? 1 : wt(y),
        (y & (c.suspendedLanes | f)) !== 0 ? 0 : y
    }
    function wt(c) {
        switch (c) {
        case 2:
            c = 1;
            break;
        case 8:
            c = 4;
            break;
        case 32:
            c = 16;
            break;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
            c = 128;
            break;
        case 268435456:
            c = 134217728;
            break;
        default:
            c = 0
        }
        return c
    }
    function Rn(c) {
        return c &= -c,
        2 < c ? 8 < c ? (c & 134217727) !== 0 ? 32 : 268435456 : 8 : 2
    }
    function Zt() {
        var c = O.p;
        return c !== 0 ? c : (c = window.event,
        c === void 0 ? 32 : IT(c.type))
    }
    function Jt(c, f) {
        var y = O.p;
        try {
            return O.p = c,
            f()
        } finally {
            O.p = y
        }
    }
    var oi = Math.random().toString(36).slice(2)
      , Dt = "__reactFiber$" + oi
      , Ht = "__reactProps$" + oi
      , ll = "__reactContainer$" + oi
      , Xn = "__reactEvents$" + oi
      , ar = "__reactListeners$" + oi
      , F0 = "__reactHandles$" + oi
      , rh = "__reactResources$" + oi
      , cl = "__reactMarker$" + oi;
    function fd(c) {
        delete c[Dt],
        delete c[Ht],
        delete c[Xn],
        delete c[ar],
        delete c[F0]
    }
    function ba(c) {
        var f = c[Dt];
        if (f)
            return f;
        for (var y = c.parentNode; y; ) {
            if (f = y[ll] || y[Dt]) {
                if (y = f.alternate,
                f.child !== null || y !== null && y.child !== null)
                    for (c = mT(c); c !== null; ) {
                        if (y = c[Dt])
                            return y;
                        c = mT(c)
                    }
                return f
            }
            c = y,
            y = c.parentNode
        }
        return null
    }
    function wa(c) {
        if (c = c[Dt] || c[ll]) {
            var f = c.tag;
            if (f === 5 || f === 6 || f === 13 || f === 31 || f === 26 || f === 27 || f === 3)
                return c
        }
        return null
    }
    function ul(c) {
        var f = c.tag;
        if (f === 5 || f === 26 || f === 27 || f === 6)
            return c.stateNode;
        throw Error(r(33))
    }
    function va(c) {
        var f = c[rh];
        return f || (f = c[rh] = {
            hoistableStyles: new Map,
            hoistableScripts: new Map
        }),
        f
    }
    function lr(c) {
        c[cl] = !0
    }
    var sh = new Set
      , ih = {};
    function $o(c, f) {
        xa(c, f),
        xa(c + "Capture", f)
    }
    function xa(c, f) {
        for (ih[c] = f,
        c = 0; c < f.length; c++)
            sh.add(f[c])
    }
    var U0 = RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$")
      , oh = {}
      , ah = {};
    function z0(c) {
        return Ct.call(ah, c) ? !0 : Ct.call(oh, c) ? !1 : U0.test(c) ? ah[c] = !0 : (oh[c] = !0,
        !1)
    }
    function Fc(c, f, y) {
        if (z0(f))
            if (y === null)
                c.removeAttribute(f);
            else {
                switch (typeof y) {
                case "undefined":
                case "function":
                case "symbol":
                    c.removeAttribute(f);
                    return;
                case "boolean":
                    var x = f.toLowerCase().slice(0, 5);
                    if (x !== "data-" && x !== "aria-") {
                        c.removeAttribute(f);
                        return
                    }
                }
                c.setAttribute(f, "" + y)
            }
    }
    function Uc(c, f, y) {
        if (y === null)
            c.removeAttribute(f);
        else {
            switch (typeof y) {
            case "undefined":
            case "function":
            case "symbol":
            case "boolean":
                c.removeAttribute(f);
                return
            }
            c.setAttribute(f, "" + y)
        }
    }
    function dl(c, f, y, x) {
        if (x === null)
            c.removeAttribute(y);
        else {
            switch (typeof x) {
            case "undefined":
            case "function":
            case "symbol":
            case "boolean":
                c.removeAttribute(y);
                return
            }
            c.setAttributeNS(f, y, "" + x)
        }
    }
    function so(c) {
        switch (typeof c) {
        case "bigint":
        case "boolean":
        case "number":
        case "string":
        case "undefined":
            return c;
        case "object":
            return c;
        default:
            return ""
        }
    }
    function Jk(c) {
        var f = c.type;
        return (c = c.nodeName) && c.toLowerCase() === "input" && (f === "checkbox" || f === "radio")
    }
    function tY(c, f, y) {
        var x = Object.getOwnPropertyDescriptor(c.constructor.prototype, f);
        if (!c.hasOwnProperty(f) && typeof x < "u" && typeof x.get == "function" && typeof x.set == "function") {
            var T = x.get
              , F = x.set;
            return Object.defineProperty(c, f, {
                configurable: !0,
                get: function() {
                    return T.call(this)
                },
                set: function(Z) {
                    y = "" + Z,
                    F.call(this, Z)
                }
            }),
            Object.defineProperty(c, f, {
                enumerable: x.enumerable
            }),
            {
                getValue: function() {
                    return y
                },
                setValue: function(Z) {
                    y = "" + Z
                },
                stopTracking: function() {
                    c._valueTracker = null,
                    delete c[f]
                }
            }
        }
    }
    function s3(c) {
        if (!c._valueTracker) {
            var f = Jk(c) ? "checked" : "value";
            c._valueTracker = tY(c, f, "" + c[f])
        }
    }
    function e6(c) {
        if (!c)
            return !1;
        var f = c._valueTracker;
        if (!f)
            return !0;
        var y = f.getValue()
          , x = "";
        return c && (x = Jk(c) ? c.checked ? "true" : "false" : c.value),
        c = x,
        c !== y ? (f.setValue(c),
        !0) : !1
    }
    function lb(c) {
        if (c = c || (typeof document < "u" ? document : void 0),
        typeof c > "u")
            return null;
        try {
            return c.activeElement || c.body
        } catch {
            return c.body
        }
    }
    var nY = /[\n"\\]/g;
    function io(c) {
        return c.replace(nY, function(f) {
            return "\\" + f.charCodeAt(0).toString(16) + " "
        })
    }
    function i3(c, f, y, x, T, F, Z, te) {
        c.name = "",
        Z != null && typeof Z != "function" && typeof Z != "symbol" && typeof Z != "boolean" ? c.type = Z : c.removeAttribute("type"),
        f != null ? Z === "number" ? (f === 0 && c.value === "" || c.value != f) && (c.value = "" + so(f)) : c.value !== "" + so(f) && (c.value = "" + so(f)) : Z !== "submit" && Z !== "reset" || c.removeAttribute("value"),
        f != null ? o3(c, Z, so(f)) : y != null ? o3(c, Z, so(y)) : x != null && c.removeAttribute("value"),
        T == null && F != null && (c.defaultChecked = !!F),
        T != null && (c.checked = T && typeof T != "function" && typeof T != "symbol"),
        te != null && typeof te != "function" && typeof te != "symbol" && typeof te != "boolean" ? c.name = "" + so(te) : c.removeAttribute("name")
    }
    function t6(c, f, y, x, T, F, Z, te) {
        if (F != null && typeof F != "function" && typeof F != "symbol" && typeof F != "boolean" && (c.type = F),
        f != null || y != null) {
            if (!(F !== "submit" && F !== "reset" || f != null)) {
                s3(c);
                return
            }
            y = y != null ? "" + so(y) : "",
            f = f != null ? "" + so(f) : y,
            te || f === c.value || (c.value = f),
            c.defaultValue = f
        }
        x = x ?? T,
        x = typeof x != "function" && typeof x != "symbol" && !!x,
        c.checked = te ? c.checked : !!x,
        c.defaultChecked = !!x,
        Z != null && typeof Z != "function" && typeof Z != "symbol" && typeof Z != "boolean" && (c.name = Z),
        s3(c)
    }
    function o3(c, f, y) {
        f === "number" && lb(c.ownerDocument) === c || c.defaultValue === "" + y || (c.defaultValue = "" + y)
    }
    function lh(c, f, y, x) {
        if (c = c.options,
        f) {
            f = {};
            for (var T = 0; T < y.length; T++)
                f["$" + y[T]] = !0;
            for (y = 0; y < c.length; y++)
                T = f.hasOwnProperty("$" + c[y].value),
                c[y].selected !== T && (c[y].selected = T),
                T && x && (c[y].defaultSelected = !0)
        } else {
            for (y = "" + so(y),
            f = null,
            T = 0; T < c.length; T++) {
                if (c[T].value === y) {
                    c[T].selected = !0,
                    x && (c[T].defaultSelected = !0);
                    return
                }
                f !== null || c[T].disabled || (f = c[T])
            }
            f !== null && (f.selected = !0)
        }
    }
    function n6(c, f, y) {
        if (f != null && (f = "" + so(f),
        f !== c.value && (c.value = f),
        y == null)) {
            c.defaultValue !== f && (c.defaultValue = f);
            return
        }
        c.defaultValue = y != null ? "" + so(y) : ""
    }
    function r6(c, f, y, x) {
        if (f == null) {
            if (x != null) {
                if (y != null)
                    throw Error(r(92));
                if (E(x)) {
                    if (1 < x.length)
                        throw Error(r(93));
                    x = x[0]
                }
                y = x
            }
            y == null && (y = ""),
            f = y
        }
        y = so(f),
        c.defaultValue = y,
        x = c.textContent,
        x === y && x !== "" && x !== null && (c.value = x),
        s3(c)
    }
    function ch(c, f) {
        if (f) {
            var y = c.firstChild;
            if (y && y === c.lastChild && y.nodeType === 3) {
                y.nodeValue = f;
                return
            }
        }
        c.textContent = f
    }
    var rY = new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));
    function s6(c, f, y) {
        var x = f.indexOf("--") === 0;
        y == null || typeof y == "boolean" || y === "" ? x ? c.setProperty(f, "") : f === "float" ? c.cssFloat = "" : c[f] = "" : x ? c.setProperty(f, y) : typeof y != "number" || y === 0 || rY.has(f) ? f === "float" ? c.cssFloat = y : c[f] = ("" + y).trim() : c[f] = y + "px"
    }
    function i6(c, f, y) {
        if (f != null && typeof f != "object")
            throw Error(r(62));
        if (c = c.style,
        y != null) {
            for (var x in y)
                !y.hasOwnProperty(x) || f != null && f.hasOwnProperty(x) || (x.indexOf("--") === 0 ? c.setProperty(x, "") : x === "float" ? c.cssFloat = "" : c[x] = "");
            for (var T in f)
                x = f[T],
                f.hasOwnProperty(T) && y[T] !== x && s6(c, T, x)
        } else
            for (var F in f)
                f.hasOwnProperty(F) && s6(c, F, f[F])
    }
    function a3(c) {
        if (c.indexOf("-") === -1)
            return !1;
        switch (c) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
            return !1;
        default:
            return !0
        }
    }
    var sY = new Map([["acceptCharset", "accept-charset"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"], ["crossOrigin", "crossorigin"], ["accentHeight", "accent-height"], ["alignmentBaseline", "alignment-baseline"], ["arabicForm", "arabic-form"], ["baselineShift", "baseline-shift"], ["capHeight", "cap-height"], ["clipPath", "clip-path"], ["clipRule", "clip-rule"], ["colorInterpolation", "color-interpolation"], ["colorInterpolationFilters", "color-interpolation-filters"], ["colorProfile", "color-profile"], ["colorRendering", "color-rendering"], ["dominantBaseline", "dominant-baseline"], ["enableBackground", "enable-background"], ["fillOpacity", "fill-opacity"], ["fillRule", "fill-rule"], ["floodColor", "flood-color"], ["floodOpacity", "flood-opacity"], ["fontFamily", "font-family"], ["fontSize", "font-size"], ["fontSizeAdjust", "font-size-adjust"], ["fontStretch", "font-stretch"], ["fontStyle", "font-style"], ["fontVariant", "font-variant"], ["fontWeight", "font-weight"], ["glyphName", "glyph-name"], ["glyphOrientationHorizontal", "glyph-orientation-horizontal"], ["glyphOrientationVertical", "glyph-orientation-vertical"], ["horizAdvX", "horiz-adv-x"], ["horizOriginX", "horiz-origin-x"], ["imageRendering", "image-rendering"], ["letterSpacing", "letter-spacing"], ["lightingColor", "lighting-color"], ["markerEnd", "marker-end"], ["markerMid", "marker-mid"], ["markerStart", "marker-start"], ["overlinePosition", "overline-position"], ["overlineThickness", "overline-thickness"], ["paintOrder", "paint-order"], ["panose-1", "panose-1"], ["pointerEvents", "pointer-events"], ["renderingIntent", "rendering-intent"], ["shapeRendering", "shape-rendering"], ["stopColor", "stop-color"], ["stopOpacity", "stop-opacity"], ["strikethroughPosition", "strikethrough-position"], ["strikethroughThickness", "strikethrough-thickness"], ["strokeDasharray", "stroke-dasharray"], ["strokeDashoffset", "stroke-dashoffset"], ["strokeLinecap", "stroke-linecap"], ["strokeLinejoin", "stroke-linejoin"], ["strokeMiterlimit", "stroke-miterlimit"], ["strokeOpacity", "stroke-opacity"], ["strokeWidth", "stroke-width"], ["textAnchor", "text-anchor"], ["textDecoration", "text-decoration"], ["textRendering", "text-rendering"], ["transformOrigin", "transform-origin"], ["underlinePosition", "underline-position"], ["underlineThickness", "underline-thickness"], ["unicodeBidi", "unicode-bidi"], ["unicodeRange", "unicode-range"], ["unitsPerEm", "units-per-em"], ["vAlphabetic", "v-alphabetic"], ["vHanging", "v-hanging"], ["vIdeographic", "v-ideographic"], ["vMathematical", "v-mathematical"], ["vectorEffect", "vector-effect"], ["vertAdvY", "vert-adv-y"], ["vertOriginX", "vert-origin-x"], ["vertOriginY", "vert-origin-y"], ["wordSpacing", "word-spacing"], ["writingMode", "writing-mode"], ["xmlnsXlink", "xmlns:xlink"], ["xHeight", "x-height"]])
      , iY = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
    function cb(c) {
        return iY.test("" + c) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : c
    }
    function fl() {}
    var l3 = null;
    function c3(c) {
        return c = c.target || c.srcElement || window,
        c.correspondingUseElement && (c = c.correspondingUseElement),
        c.nodeType === 3 ? c.parentNode : c
    }
    var uh = null
      , dh = null;
    function o6(c) {
        var f = wa(c);
        if (f && (c = f.stateNode)) {
            var y = c[Ht] || null;
            e: switch (c = f.stateNode,
            f.type) {
            case "input":
                if (i3(c, y.value, y.defaultValue, y.defaultValue, y.checked, y.defaultChecked, y.type, y.name),
                f = y.name,
                y.type === "radio" && f != null) {
                    for (y = c; y.parentNode; )
                        y = y.parentNode;
                    for (y = y.querySelectorAll('input[name="' + io("" + f) + '"][type="radio"]'),
                    f = 0; f < y.length; f++) {
                        var x = y[f];
                        if (x !== c && x.form === c.form) {
                            var T = x[Ht] || null;
                            if (!T)
                                throw Error(r(90));
                            i3(x, T.value, T.defaultValue, T.defaultValue, T.checked, T.defaultChecked, T.type, T.name)
                        }
                    }
                    for (f = 0; f < y.length; f++)
                        x = y[f],
                        x.form === c.form && e6(x)
                }
                break e;
            case "textarea":
                n6(c, y.value, y.defaultValue);
                break e;
            case "select":
                f = y.value,
                f != null && lh(c, !!y.multiple, f, !1)
            }
        }
    }
    var u3 = !1;
    function a6(c, f, y) {
        if (u3)
            return c(f, y);
        u3 = !0;
        try {
            var x = c(f);
            return x
        } finally {
            if (u3 = !1,
            (uh !== null || dh !== null) && (Xb(),
            uh && (f = uh,
            c = dh,
            dh = uh = null,
            o6(f),
            c)))
                for (f = 0; f < c.length; f++)
                    o6(c[f])
        }
    }
    function $0(c, f) {
        var y = c.stateNode;
        if (y === null)
            return null;
        var x = y[Ht] || null;
        if (x === null)
            return null;
        y = x[f];
        e: switch (f) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
            (x = !x.disabled) || (c = c.type,
            x = !(c === "button" || c === "input" || c === "select" || c === "textarea")),
            c = !x;
            break e;
        default:
            c = !1
        }
        if (c)
            return null;
        if (y && typeof y != "function")
            throw Error(r(231, f, typeof y));
        return y
    }
    var hl = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u")
      , d3 = !1;
    if (hl)
        try {
            var H0 = {};
            Object.defineProperty(H0, "passive", {
                get: function() {
                    d3 = !0
                }
            }),
            window.addEventListener("test", H0, H0),
            window.removeEventListener("test", H0, H0)
        } catch {
            d3 = !1
        }
    var zc = null
      , f3 = null
      , ub = null;
    function l6() {
        if (ub)
            return ub;
        var c, f = f3, y = f.length, x, T = "value"in zc ? zc.value : zc.textContent, F = T.length;
        for (c = 0; c < y && f[c] === T[c]; c++)
            ;
        var Z = y - c;
        for (x = 1; x <= Z && f[y - x] === T[F - x]; x++)
            ;
        return ub = T.slice(c, 1 < x ? 1 - x : void 0)
    }
    function db(c) {
        var f = c.keyCode;
        return "charCode"in c ? (c = c.charCode,
        c === 0 && f === 13 && (c = 13)) : c = f,
        c === 10 && (c = 13),
        32 <= c || c === 13 ? c : 0
    }
    function fb() {
        return !0
    }
    function c6() {
        return !1
    }
    function ai(c) {
        function f(y, x, T, F, Z) {
            this._reactName = y,
            this._targetInst = T,
            this.type = x,
            this.nativeEvent = F,
            this.target = Z,
            this.currentTarget = null;
            for (var te in c)
                c.hasOwnProperty(te) && (y = c[te],
                this[te] = y ? y(F) : F[te]);
            return this.isDefaultPrevented = (F.defaultPrevented != null ? F.defaultPrevented : F.returnValue === !1) ? fb : c6,
            this.isPropagationStopped = c6,
            this
        }
        return h(f.prototype, {
            preventDefault: function() {
                this.defaultPrevented = !0;
                var y = this.nativeEvent;
                y && (y.preventDefault ? y.preventDefault() : typeof y.returnValue != "unknown" && (y.returnValue = !1),
                this.isDefaultPrevented = fb)
            },
            stopPropagation: function() {
                var y = this.nativeEvent;
                y && (y.stopPropagation ? y.stopPropagation() : typeof y.cancelBubble != "unknown" && (y.cancelBubble = !0),
                this.isPropagationStopped = fb)
            },
            persist: function() {},
            isPersistent: fb
        }),
        f
    }
    var hd = {
        eventPhase: 0,
        bubbles: 0,
        cancelable: 0,
        timeStamp: function(c) {
            return c.timeStamp || Date.now()
        },
        defaultPrevented: 0,
        isTrusted: 0
    }, hb = ai(hd), V0 = h({}, hd, {
        view: 0,
        detail: 0
    }), oY = ai(V0), h3, p3, q0, pb = h({}, V0, {
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0,
        pageX: 0,
        pageY: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        getModifierState: g3,
        button: 0,
        buttons: 0,
        relatedTarget: function(c) {
            return c.relatedTarget === void 0 ? c.fromElement === c.srcElement ? c.toElement : c.fromElement : c.relatedTarget
        },
        movementX: function(c) {
            return "movementX"in c ? c.movementX : (c !== q0 && (q0 && c.type === "mousemove" ? (h3 = c.screenX - q0.screenX,
            p3 = c.screenY - q0.screenY) : p3 = h3 = 0,
            q0 = c),
            h3)
        },
        movementY: function(c) {
            return "movementY"in c ? c.movementY : p3
        }
    }), u6 = ai(pb), aY = h({}, pb, {
        dataTransfer: 0
    }), lY = ai(aY), cY = h({}, V0, {
        relatedTarget: 0
    }), m3 = ai(cY), uY = h({}, hd, {
        animationName: 0,
        elapsedTime: 0,
        pseudoElement: 0
    }), dY = ai(uY), fY = h({}, hd, {
        clipboardData: function(c) {
            return "clipboardData"in c ? c.clipboardData : window.clipboardData
        }
    }), hY = ai(fY), pY = h({}, hd, {
        data: 0
    }), d6 = ai(pY), mY = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
    }, gY = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
    }, yY = {
        Alt: "altKey",
        Control: "ctrlKey",
        Meta: "metaKey",
        Shift: "shiftKey"
    };
    function bY(c) {
        var f = this.nativeEvent;
        return f.getModifierState ? f.getModifierState(c) : (c = yY[c]) ? !!f[c] : !1
    }
    function g3() {
        return bY
    }
    var wY = h({}, V0, {
        key: function(c) {
            if (c.key) {
                var f = mY[c.key] || c.key;
                if (f !== "Unidentified")
                    return f
            }
            return c.type === "keypress" ? (c = db(c),
            c === 13 ? "Enter" : String.fromCharCode(c)) : c.type === "keydown" || c.type === "keyup" ? gY[c.keyCode] || "Unidentified" : ""
        },
        code: 0,
        location: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        repeat: 0,
        locale: 0,
        getModifierState: g3,
        charCode: function(c) {
            return c.type === "keypress" ? db(c) : 0
        },
        keyCode: function(c) {
            return c.type === "keydown" || c.type === "keyup" ? c.keyCode : 0
        },
        which: function(c) {
            return c.type === "keypress" ? db(c) : c.type === "keydown" || c.type === "keyup" ? c.keyCode : 0
        }
    })
      , vY = ai(wY)
      , xY = h({}, pb, {
        pointerId: 0,
        width: 0,
        height: 0,
        pressure: 0,
        tangentialPressure: 0,
        tiltX: 0,
        tiltY: 0,
        twist: 0,
        pointerType: 0,
        isPrimary: 0
    })
      , f6 = ai(xY)
      , EY = h({}, V0, {
        touches: 0,
        targetTouches: 0,
        changedTouches: 0,
        altKey: 0,
        metaKey: 0,
        ctrlKey: 0,
        shiftKey: 0,
        getModifierState: g3
    })
      , SY = ai(EY)
      , AY = h({}, hd, {
        propertyName: 0,
        elapsedTime: 0,
        pseudoElement: 0
    })
      , CY = ai(AY)
      , _Y = h({}, pb, {
        deltaX: function(c) {
            return "deltaX"in c ? c.deltaX : "wheelDeltaX"in c ? -c.wheelDeltaX : 0
        },
        deltaY: function(c) {
            return "deltaY"in c ? c.deltaY : "wheelDeltaY"in c ? -c.wheelDeltaY : "wheelDelta"in c ? -c.wheelDelta : 0
        },
        deltaZ: 0,
        deltaMode: 0
    })
      , kY = ai(_Y)
      , NY = h({}, hd, {
        newState: 0,
        oldState: 0
    })
      , DY = ai(NY)
      , TY = [9, 13, 27, 32]
      , y3 = hl && "CompositionEvent"in window
      , G0 = null;
    hl && "documentMode"in document && (G0 = document.documentMode);
    var IY = hl && "TextEvent"in window && !G0
      , h6 = hl && (!y3 || G0 && 8 < G0 && 11 >= G0)
      , p6 = " "
      , m6 = !1;
    function g6(c, f) {
        switch (c) {
        case "keyup":
            return TY.indexOf(f.keyCode) !== -1;
        case "keydown":
            return f.keyCode !== 229;
        case "keypress":
        case "mousedown":
        case "focusout":
            return !0;
        default:
            return !1
        }
    }
    function y6(c) {
        return c = c.detail,
        typeof c == "object" && "data"in c ? c.data : null
    }
    var fh = !1;
    function MY(c, f) {
        switch (c) {
        case "compositionend":
            return y6(f);
        case "keypress":
            return f.which !== 32 ? null : (m6 = !0,
            p6);
        case "textInput":
            return c = f.data,
            c === p6 && m6 ? null : c;
        default:
            return null
        }
    }
    function BY(c, f) {
        if (fh)
            return c === "compositionend" || !y3 && g6(c, f) ? (c = l6(),
            ub = f3 = zc = null,
            fh = !1,
            c) : null;
        switch (c) {
        case "paste":
            return null;
        case "keypress":
            if (!(f.ctrlKey || f.altKey || f.metaKey) || f.ctrlKey && f.altKey) {
                if (f.char && 1 < f.char.length)
                    return f.char;
                if (f.which)
                    return String.fromCharCode(f.which)
            }
            return null;
        case "compositionend":
            return h6 && f.locale !== "ko" ? null : f.data;
        default:
            return null
        }
    }
    var RY = {
        color: !0,
        date: !0,
        datetime: !0,
        "datetime-local": !0,
        email: !0,
        month: !0,
        number: !0,
        password: !0,
        range: !0,
        search: !0,
        tel: !0,
        text: !0,
        time: !0,
        url: !0,
        week: !0
    };
    function b6(c) {
        var f = c && c.nodeName && c.nodeName.toLowerCase();
        return f === "input" ? !!RY[c.type] : f === "textarea"
    }
    function w6(c, f, y, x) {
        uh ? dh ? dh.push(x) : dh = [x] : uh = x,
        f = r1(f, "onChange"),
        0 < f.length && (y = new hb("onChange","change",null,y,x),
        c.push({
            event: y,
            listeners: f
        }))
    }
    var W0 = null
      , Y0 = null;
    function OY(c) {
        tT(c, 0)
    }
    function mb(c) {
        var f = ul(c);
        if (e6(f))
            return c
    }
    function v6(c, f) {
        if (c === "change")
            return f
    }
    var x6 = !1;
    if (hl) {
        var b3;
        if (hl) {
            var w3 = "oninput"in document;
            if (!w3) {
                var E6 = document.createElement("div");
                E6.setAttribute("oninput", "return;"),
                w3 = typeof E6.oninput == "function"
            }
            b3 = w3
        } else
            b3 = !1;
        x6 = b3 && (!document.documentMode || 9 < document.documentMode)
    }
    function S6() {
        W0 && (W0.detachEvent("onpropertychange", A6),
        Y0 = W0 = null)
    }
    function A6(c) {
        if (c.propertyName === "value" && mb(Y0)) {
            var f = [];
            w6(f, Y0, c, c3(c)),
            a6(OY, f)
        }
    }
    function PY(c, f, y) {
        c === "focusin" ? (S6(),
        W0 = f,
        Y0 = y,
        W0.attachEvent("onpropertychange", A6)) : c === "focusout" && S6()
    }
    function jY(c) {
        if (c === "selectionchange" || c === "keyup" || c === "keydown")
            return mb(Y0)
    }
    function LY(c, f) {
        if (c === "click")
            return mb(f)
    }
    function FY(c, f) {
        if (c === "input" || c === "change")
            return mb(f)
    }
    function UY(c, f) {
        return c === f && (c !== 0 || 1 / c === 1 / f) || c !== c && f !== f
    }
    var Mi = typeof Object.is == "function" ? Object.is : UY;
    function K0(c, f) {
        if (Mi(c, f))
            return !0;
        if (typeof c != "object" || c === null || typeof f != "object" || f === null)
            return !1;
        var y = Object.keys(c)
          , x = Object.keys(f);
        if (y.length !== x.length)
            return !1;
        for (x = 0; x < y.length; x++) {
            var T = y[x];
            if (!Ct.call(f, T) || !Mi(c[T], f[T]))
                return !1
        }
        return !0
    }
    function C6(c) {
        for (; c && c.firstChild; )
            c = c.firstChild;
        return c
    }
    function _6(c, f) {
        var y = C6(c);
        c = 0;
        for (var x; y; ) {
            if (y.nodeType === 3) {
                if (x = c + y.textContent.length,
                c <= f && x >= f)
                    return {
                        node: y,
                        offset: f - c
                    };
                c = x
            }
            e: {
                for (; y; ) {
                    if (y.nextSibling) {
                        y = y.nextSibling;
                        break e
                    }
                    y = y.parentNode
                }
                y = void 0
            }
            y = C6(y)
        }
    }
    function k6(c, f) {
        return c && f ? c === f ? !0 : c && c.nodeType === 3 ? !1 : f && f.nodeType === 3 ? k6(c, f.parentNode) : "contains"in c ? c.contains(f) : c.compareDocumentPosition ? !!(c.compareDocumentPosition(f) & 16) : !1 : !1
    }
    function N6(c) {
        c = c != null && c.ownerDocument != null && c.ownerDocument.defaultView != null ? c.ownerDocument.defaultView : window;
        for (var f = lb(c.document); f instanceof c.HTMLIFrameElement; ) {
            try {
                var y = typeof f.contentWindow.location.href == "string"
            } catch {
                y = !1
            }
            if (y)
                c = f.contentWindow;
            else
                break;
            f = lb(c.document)
        }
        return f
    }
    function v3(c) {
        var f = c && c.nodeName && c.nodeName.toLowerCase();
        return f && (f === "input" && (c.type === "text" || c.type === "search" || c.type === "tel" || c.type === "url" || c.type === "password") || f === "textarea" || c.contentEditable === "true")
    }
    var zY = hl && "documentMode"in document && 11 >= document.documentMode
      , hh = null
      , x3 = null
      , X0 = null
      , E3 = !1;
    function D6(c, f, y) {
        var x = y.window === y ? y.document : y.nodeType === 9 ? y : y.ownerDocument;
        E3 || hh == null || hh !== lb(x) || (x = hh,
        "selectionStart"in x && v3(x) ? x = {
            start: x.selectionStart,
            end: x.selectionEnd
        } : (x = (x.ownerDocument && x.ownerDocument.defaultView || window).getSelection(),
        x = {
            anchorNode: x.anchorNode,
            anchorOffset: x.anchorOffset,
            focusNode: x.focusNode,
            focusOffset: x.focusOffset
        }),
        X0 && K0(X0, x) || (X0 = x,
        x = r1(x3, "onSelect"),
        0 < x.length && (f = new hb("onSelect","select",null,f,y),
        c.push({
            event: f,
            listeners: x
        }),
        f.target = hh)))
    }
    function pd(c, f) {
        var y = {};
        return y[c.toLowerCase()] = f.toLowerCase(),
        y["Webkit" + c] = "webkit" + f,
        y["Moz" + c] = "moz" + f,
        y
    }
    var ph = {
        animationend: pd("Animation", "AnimationEnd"),
        animationiteration: pd("Animation", "AnimationIteration"),
        animationstart: pd("Animation", "AnimationStart"),
        transitionrun: pd("Transition", "TransitionRun"),
        transitionstart: pd("Transition", "TransitionStart"),
        transitioncancel: pd("Transition", "TransitionCancel"),
        transitionend: pd("Transition", "TransitionEnd")
    }
      , S3 = {}
      , T6 = {};
    hl && (T6 = document.createElement("div").style,
    "AnimationEvent"in window || (delete ph.animationend.animation,
    delete ph.animationiteration.animation,
    delete ph.animationstart.animation),
    "TransitionEvent"in window || delete ph.transitionend.transition);
    function md(c) {
        if (S3[c])
            return S3[c];
        if (!ph[c])
            return c;
        var f = ph[c], y;
        for (y in f)
            if (f.hasOwnProperty(y) && y in T6)
                return S3[c] = f[y];
        return c
    }
    var I6 = md("animationend")
      , M6 = md("animationiteration")
      , B6 = md("animationstart")
      , $Y = md("transitionrun")
      , HY = md("transitionstart")
      , VY = md("transitioncancel")
      , R6 = md("transitionend")
      , O6 = new Map
      , A3 = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
    A3.push("scrollEnd");
    function Ho(c, f) {
        O6.set(c, f),
        $o(f, [c])
    }
    var gb = typeof reportError == "function" ? reportError : function(c) {
        if (typeof window == "object" && typeof window.ErrorEvent == "function") {
            var f = new window.ErrorEvent("error",{
                bubbles: !0,
                cancelable: !0,
                message: typeof c == "object" && c !== null && typeof c.message == "string" ? String(c.message) : String(c),
                error: c
            });
            if (!window.dispatchEvent(f))
                return
        } else if (typeof process == "object" && typeof process.emit == "function") {
            process.emit("uncaughtException", c);
            return
        }
        console.error(c)
    }
      , oo = []
      , mh = 0
      , C3 = 0;
    function yb() {
        for (var c = mh, f = C3 = mh = 0; f < c; ) {
            var y = oo[f];
            oo[f++] = null;
            var x = oo[f];
            oo[f++] = null;
            var T = oo[f];
            oo[f++] = null;
            var F = oo[f];
            if (oo[f++] = null,
            x !== null && T !== null) {
                var Z = x.pending;
                Z === null ? T.next = T : (T.next = Z.next,
                Z.next = T),
                x.pending = T
            }
            F !== 0 && P6(y, T, F)
        }
    }
    function bb(c, f, y, x) {
        oo[mh++] = c,
        oo[mh++] = f,
        oo[mh++] = y,
        oo[mh++] = x,
        C3 |= x,
        c.lanes |= x,
        c = c.alternate,
        c !== null && (c.lanes |= x)
    }
    function _3(c, f, y, x) {
        return bb(c, f, y, x),
        wb(c)
    }
    function gd(c, f) {
        return bb(c, null, null, f),
        wb(c)
    }
    function P6(c, f, y) {
        c.lanes |= y;
        var x = c.alternate;
        x !== null && (x.lanes |= y);
        for (var T = !1, F = c.return; F !== null; )
            F.childLanes |= y,
            x = F.alternate,
            x !== null && (x.childLanes |= y),
            F.tag === 22 && (c = F.stateNode,
            c === null || c._visibility & 1 || (T = !0)),
            c = F,
            F = F.return;
        return c.tag === 3 ? (F = c.stateNode,
        T && f !== null && (T = 31 - Ve(y),
        c = F.hiddenUpdates,
        x = c[T],
        x === null ? c[T] = [f] : x.push(f),
        f.lane = y | 536870912),
        F) : null
    }
    function wb(c) {
        if (50 < bm)
            throw bm = 0,
            OE = null,
            Error(r(185));
        for (var f = c.return; f !== null; )
            c = f,
            f = c.return;
        return c.tag === 3 ? c.stateNode : null
    }
    var gh = {};
    function qY(c, f, y, x) {
        this.tag = c,
        this.key = y,
        this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
        this.index = 0,
        this.refCleanup = this.ref = null,
        this.pendingProps = f,
        this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
        this.mode = x,
        this.subtreeFlags = this.flags = 0,
        this.deletions = null,
        this.childLanes = this.lanes = 0,
        this.alternate = null
    }
    function Bi(c, f, y, x) {
        return new qY(c,f,y,x)
    }
    function k3(c) {
        return c = c.prototype,
        !(!c || !c.isReactComponent)
    }
    function pl(c, f) {
        var y = c.alternate;
        return y === null ? (y = Bi(c.tag, f, c.key, c.mode),
        y.elementType = c.elementType,
        y.type = c.type,
        y.stateNode = c.stateNode,
        y.alternate = c,
        c.alternate = y) : (y.pendingProps = f,
        y.type = c.type,
        y.flags = 0,
        y.subtreeFlags = 0,
        y.deletions = null),
        y.flags = c.flags & 65011712,
        y.childLanes = c.childLanes,
        y.lanes = c.lanes,
        y.child = c.child,
        y.memoizedProps = c.memoizedProps,
        y.memoizedState = c.memoizedState,
        y.updateQueue = c.updateQueue,
        f = c.dependencies,
        y.dependencies = f === null ? null : {
            lanes: f.lanes,
            firstContext: f.firstContext
        },
        y.sibling = c.sibling,
        y.index = c.index,
        y.ref = c.ref,
        y.refCleanup = c.refCleanup,
        y
    }
    function j6(c, f) {
        c.flags &= 65011714;
        var y = c.alternate;
        return y === null ? (c.childLanes = 0,
        c.lanes = f,
        c.child = null,
        c.subtreeFlags = 0,
        c.memoizedProps = null,
        c.memoizedState = null,
        c.updateQueue = null,
        c.dependencies = null,
        c.stateNode = null) : (c.childLanes = y.childLanes,
        c.lanes = y.lanes,
        c.child = y.child,
        c.subtreeFlags = 0,
        c.deletions = null,
        c.memoizedProps = y.memoizedProps,
        c.memoizedState = y.memoizedState,
        c.updateQueue = y.updateQueue,
        c.type = y.type,
        f = y.dependencies,
        c.dependencies = f === null ? null : {
            lanes: f.lanes,
            firstContext: f.firstContext
        }),
        c
    }
    function vb(c, f, y, x, T, F) {
        var Z = 0;
        if (x = c,
        typeof c == "function")
            k3(c) && (Z = 1);
        else if (typeof c == "string")
            Z = XK(c, y, W.current) ? 26 : c === "html" || c === "head" || c === "body" ? 27 : 5;
        else
            e: switch (c) {
            case R:
                return c = Bi(31, y, f, T),
                c.elementType = R,
                c.lanes = F,
                c;
            case b:
                return yd(y.children, T, F, f);
            case v:
                Z = 8,
                T |= 24;
                break;
            case S:
                return c = Bi(12, y, f, T | 2),
                c.elementType = S,
                c.lanes = F,
                c;
            case k:
                return c = Bi(13, y, f, T),
                c.elementType = k,
                c.lanes = F,
                c;
            case B:
                return c = Bi(19, y, f, T),
                c.elementType = B,
                c.lanes = F,
                c;
            default:
                if (typeof c == "object" && c !== null)
                    switch (c.$$typeof) {
                    case _:
                        Z = 10;
                        break e;
                    case N:
                        Z = 9;
                        break e;
                    case I:
                        Z = 11;
                        break e;
                    case P:
                        Z = 14;
                        break e;
                    case M:
                        Z = 16,
                        x = null;
                        break e
                    }
                Z = 29,
                y = Error(r(130, c === null ? "null" : typeof c, "")),
                x = null
            }
        return f = Bi(Z, y, f, T),
        f.elementType = c,
        f.type = x,
        f.lanes = F,
        f
    }
    function yd(c, f, y, x) {
        return c = Bi(7, c, x, f),
        c.lanes = y,
        c
    }
    function N3(c, f, y) {
        return c = Bi(6, c, null, f),
        c.lanes = y,
        c
    }
    function L6(c) {
        var f = Bi(18, null, null, 0);
        return f.stateNode = c,
        f
    }
    function D3(c, f, y) {
        return f = Bi(4, c.children !== null ? c.children : [], c.key, f),
        f.lanes = y,
        f.stateNode = {
            containerInfo: c.containerInfo,
            pendingChildren: null,
            implementation: c.implementation
        },
        f
    }
    var F6 = new WeakMap;
    function ao(c, f) {
        if (typeof c == "object" && c !== null) {
            var y = F6.get(c);
            return y !== void 0 ? y : (f = {
                value: c,
                source: f,
                stack: ot(f)
            },
            F6.set(c, f),
            f)
        }
        return {
            value: c,
            source: f,
            stack: ot(f)
        }
    }
    var yh = []
      , bh = 0
      , xb = null
      , Q0 = 0
      , lo = []
      , co = 0
      , $c = null
      , Ea = 1
      , Sa = "";
    function ml(c, f) {
        yh[bh++] = Q0,
        yh[bh++] = xb,
        xb = c,
        Q0 = f
    }
    function U6(c, f, y) {
        lo[co++] = Ea,
        lo[co++] = Sa,
        lo[co++] = $c,
        $c = c;
        var x = Ea;
        c = Sa;
        var T = 32 - Ve(x) - 1;
        x &= ~(1 << T),
        y += 1;
        var F = 32 - Ve(f) + T;
        if (30 < F) {
            var Z = T - T % 5;
            F = (x & (1 << Z) - 1).toString(32),
            x >>= Z,
            T -= Z,
            Ea = 1 << 32 - Ve(f) + T | y << T | x,
            Sa = F + c
        } else
            Ea = 1 << F | y << T | x,
            Sa = c
    }
    function T3(c) {
        c.return !== null && (ml(c, 1),
        U6(c, 1, 0))
    }
    function I3(c) {
        for (; c === xb; )
            xb = yh[--bh],
            yh[bh] = null,
            Q0 = yh[--bh],
            yh[bh] = null;
        for (; c === $c; )
            $c = lo[--co],
            lo[co] = null,
            Sa = lo[--co],
            lo[co] = null,
            Ea = lo[--co],
            lo[co] = null
    }
    function z6(c, f) {
        lo[co++] = Ea,
        lo[co++] = Sa,
        lo[co++] = $c,
        Ea = f.id,
        Sa = f.overflow,
        $c = c
    }
    var is = null
      , $n = null
      , en = !1
      , Hc = null
      , uo = !1
      , M3 = Error(r(519));
    function Vc(c) {
        var f = Error(r(418, 1 < arguments.length && arguments[1] !== void 0 && arguments[1] ? "text" : "HTML", ""));
        throw Z0(ao(f, c)),
        M3
    }
    function $6(c) {
        var f = c.stateNode
          , y = c.type
          , x = c.memoizedProps;
        switch (f[Dt] = c,
        f[Ht] = x,
        y) {
        case "dialog":
            qt("cancel", f),
            qt("close", f);
            break;
        case "iframe":
        case "object":
        case "embed":
            qt("load", f);
            break;
        case "video":
        case "audio":
            for (y = 0; y < vm.length; y++)
                qt(vm[y], f);
            break;
        case "source":
            qt("error", f);
            break;
        case "img":
        case "image":
        case "link":
            qt("error", f),
            qt("load", f);
            break;
        case "details":
            qt("toggle", f);
            break;
        case "input":
            qt("invalid", f),
            t6(f, x.value, x.defaultValue, x.checked, x.defaultChecked, x.type, x.name, !0);
            break;
        case "select":
            qt("invalid", f);
            break;
        case "textarea":
            qt("invalid", f),
            r6(f, x.value, x.defaultValue, x.children)
        }
        y = x.children,
        typeof y != "string" && typeof y != "number" && typeof y != "bigint" || f.textContent === "" + y || x.suppressHydrationWarning === !0 || iT(f.textContent, y) ? (x.popover != null && (qt("beforetoggle", f),
        qt("toggle", f)),
        x.onScroll != null && qt("scroll", f),
        x.onScrollEnd != null && qt("scrollend", f),
        x.onClick != null && (f.onclick = fl),
        f = !0) : f = !1,
        f || Vc(c, !0)
    }
    function H6(c) {
        for (is = c.return; is; )
            switch (is.tag) {
            case 5:
            case 31:
            case 13:
                uo = !1;
                return;
            case 27:
            case 3:
                uo = !0;
                return;
            default:
                is = is.return
            }
    }
    function wh(c) {
        if (c !== is)
            return !1;
        if (!en)
            return H6(c),
            en = !0,
            !1;
        var f = c.tag, y;
        if ((y = f !== 3 && f !== 27) && ((y = f === 5) && (y = c.type,
        y = !(y !== "form" && y !== "button") || XE(c.type, c.memoizedProps)),
        y = !y),
        y && $n && Vc(c),
        H6(c),
        f === 13) {
            if (c = c.memoizedState,
            c = c !== null ? c.dehydrated : null,
            !c)
                throw Error(r(317));
            $n = pT(c)
        } else if (f === 31) {
            if (c = c.memoizedState,
            c = c !== null ? c.dehydrated : null,
            !c)
                throw Error(r(317));
            $n = pT(c)
        } else
            f === 27 ? (f = $n,
            su(c.type) ? (c = tS,
            tS = null,
            $n = c) : $n = f) : $n = is ? ho(c.stateNode.nextSibling) : null;
        return !0
    }
    function bd() {
        $n = is = null,
        en = !1
    }
    function B3() {
        var c = Hc;
        return c !== null && (di === null ? di = c : di.push.apply(di, c),
        Hc = null),
        c
    }
    function Z0(c) {
        Hc === null ? Hc = [c] : Hc.push(c)
    }
    var R3 = $(null)
      , wd = null
      , gl = null;
    function qc(c, f, y) {
        U(R3, f._currentValue),
        f._currentValue = y
    }
    function yl(c) {
        c._currentValue = R3.current,
        D(R3)
    }
    function O3(c, f, y) {
        for (; c !== null; ) {
            var x = c.alternate;
            if ((c.childLanes & f) !== f ? (c.childLanes |= f,
            x !== null && (x.childLanes |= f)) : x !== null && (x.childLanes & f) !== f && (x.childLanes |= f),
            c === y)
                break;
            c = c.return
        }
    }
    function P3(c, f, y, x) {
        var T = c.child;
        for (T !== null && (T.return = c); T !== null; ) {
            var F = T.dependencies;
            if (F !== null) {
                var Z = T.child;
                F = F.firstContext;
                e: for (; F !== null; ) {
                    var te = F;
                    F = T;
                    for (var le = 0; le < f.length; le++)
                        if (te.context === f[le]) {
                            F.lanes |= y,
                            te = F.alternate,
                            te !== null && (te.lanes |= y),
                            O3(F.return, y, c),
                            x || (Z = null);
                            break e
                        }
                    F = te.next
                }
            } else if (T.tag === 18) {
                if (Z = T.return,
                Z === null)
                    throw Error(r(341));
                Z.lanes |= y,
                F = Z.alternate,
                F !== null && (F.lanes |= y),
                O3(Z, y, c),
                Z = null
            } else
                Z = T.child;
            if (Z !== null)
                Z.return = T;
            else
                for (Z = T; Z !== null; ) {
                    if (Z === c) {
                        Z = null;
                        break
                    }
                    if (T = Z.sibling,
                    T !== null) {
                        T.return = Z.return,
                        Z = T;
                        break
                    }
                    Z = Z.return
                }
            T = Z
        }
    }
    function vh(c, f, y, x) {
        c = null;
        for (var T = f, F = !1; T !== null; ) {
            if (!F) {
                if ((T.flags & 524288) !== 0)
                    F = !0;
                else if ((T.flags & 262144) !== 0)
                    break
            }
            if (T.tag === 10) {
                var Z = T.alternate;
                if (Z === null)
                    throw Error(r(387));
                if (Z = Z.memoizedProps,
                Z !== null) {
                    var te = T.type;
                    Mi(T.pendingProps.value, Z.value) || (c !== null ? c.push(te) : c = [te])
                }
            } else if (T === ne.current) {
                if (Z = T.alternate,
                Z === null)
                    throw Error(r(387));
                Z.memoizedState.memoizedState !== T.memoizedState.memoizedState && (c !== null ? c.push(Cm) : c = [Cm])
            }
            T = T.return
        }
        c !== null && P3(f, c, y, x),
        f.flags |= 262144
    }
    function Eb(c) {
        for (c = c.firstContext; c !== null; ) {
            if (!Mi(c.context._currentValue, c.memoizedValue))
                return !0;
            c = c.next
        }
        return !1
    }
    function vd(c) {
        wd = c,
        gl = null,
        c = c.dependencies,
        c !== null && (c.firstContext = null)
    }
    function os(c) {
        return V6(wd, c)
    }
    function Sb(c, f) {
        return wd === null && vd(c),
        V6(c, f)
    }
    function V6(c, f) {
        var y = f._currentValue;
        if (f = {
            context: f,
            memoizedValue: y,
            next: null
        },
        gl === null) {
            if (c === null)
                throw Error(r(308));
            gl = f,
            c.dependencies = {
                lanes: 0,
                firstContext: f
            },
            c.flags |= 524288
        } else
            gl = gl.next = f;
        return y
    }
    var GY = typeof AbortController < "u" ? AbortController : function() {
        var c = []
          , f = this.signal = {
            aborted: !1,
            addEventListener: function(y, x) {
                c.push(x)
            }
        };
        this.abort = function() {
            f.aborted = !0,
            c.forEach(function(y) {
                return y()
            })
        }
    }
      , WY = n.unstable_scheduleCallback
      , YY = n.unstable_NormalPriority
      , Nr = {
        $$typeof: _,
        Consumer: null,
        Provider: null,
        _currentValue: null,
        _currentValue2: null,
        _threadCount: 0
    };
    function j3() {
        return {
            controller: new GY,
            data: new Map,
            refCount: 0
        }
    }
    function J0(c) {
        c.refCount--,
        c.refCount === 0 && WY(YY, function() {
            c.controller.abort()
        })
    }
    var em = null
      , L3 = 0
      , xh = 0
      , Eh = null;
    function KY(c, f) {
        if (em === null) {
            var y = em = [];
            L3 = 0,
            xh = zE(),
            Eh = {
                status: "pending",
                value: void 0,
                then: function(x) {
                    y.push(x)
                }
            }
        }
        return L3++,
        f.then(q6, q6),
        f
    }
    function q6() {
        if (--L3 === 0 && em !== null) {
            Eh !== null && (Eh.status = "fulfilled");
            var c = em;
            em = null,
            xh = 0,
            Eh = null;
            for (var f = 0; f < c.length; f++)
                (0,
                c[f])()
        }
    }
    function XY(c, f) {
        var y = []
          , x = {
            status: "pending",
            value: null,
            reason: null,
            then: function(T) {
                y.push(T)
            }
        };
        return c.then(function() {
            x.status = "fulfilled",
            x.value = f;
            for (var T = 0; T < y.length; T++)
                (0,
                y[T])(f)
        }, function(T) {
            for (x.status = "rejected",
            x.reason = T,
            T = 0; T < y.length; T++)
                (0,
                y[T])(void 0)
        }),
        x
    }
    var G6 = C.S;
    C.S = function(c, f) {
        DD = ut(),
        typeof f == "object" && f !== null && typeof f.then == "function" && KY(c, f),
        G6 !== null && G6(c, f)
    }
    ;
    var xd = $(null);
    function F3() {
        var c = xd.current;
        return c !== null ? c : On.pooledCache
    }
    function Ab(c, f) {
        f === null ? U(xd, xd.current) : U(xd, f.pool)
    }
    function W6() {
        var c = F3();
        return c === null ? null : {
            parent: Nr._currentValue,
            pool: c
        }
    }
    var Sh = Error(r(460))
      , U3 = Error(r(474))
      , Cb = Error(r(542))
      , _b = {
        then: function() {}
    };
    function Y6(c) {
        return c = c.status,
        c === "fulfilled" || c === "rejected"
    }
    function K6(c, f, y) {
        switch (y = c[y],
        y === void 0 ? c.push(f) : y !== f && (f.then(fl, fl),
        f = y),
        f.status) {
        case "fulfilled":
            return f.value;
        case "rejected":
            throw c = f.reason,
            Q6(c),
            c;
        default:
            if (typeof f.status == "string")
                f.then(fl, fl);
            else {
                if (c = On,
                c !== null && 100 < c.shellSuspendCounter)
                    throw Error(r(482));
                c = f,
                c.status = "pending",
                c.then(function(x) {
                    if (f.status === "pending") {
                        var T = f;
                        T.status = "fulfilled",
                        T.value = x
                    }
                }, function(x) {
                    if (f.status === "pending") {
                        var T = f;
                        T.status = "rejected",
                        T.reason = x
                    }
                })
            }
            switch (f.status) {
            case "fulfilled":
                return f.value;
            case "rejected":
                throw c = f.reason,
                Q6(c),
                c
            }
            throw Sd = f,
            Sh
        }
    }
    function Ed(c) {
        try {
            var f = c._init;
            return f(c._payload)
        } catch (y) {
            throw y !== null && typeof y == "object" && typeof y.then == "function" ? (Sd = y,
            Sh) : y
        }
    }
    var Sd = null;
    function X6() {
        if (Sd === null)
            throw Error(r(459));
        var c = Sd;
        return Sd = null,
        c
    }
    function Q6(c) {
        if (c === Sh || c === Cb)
            throw Error(r(483))
    }
    var Ah = null
      , tm = 0;
    function kb(c) {
        var f = tm;
        return tm += 1,
        Ah === null && (Ah = []),
        K6(Ah, c, f)
    }
    function nm(c, f) {
        f = f.props.ref,
        c.ref = f !== void 0 ? f : null
    }
    function Nb(c, f) {
        throw f.$$typeof === p ? Error(r(525)) : (c = Object.prototype.toString.call(f),
        Error(r(31, c === "[object Object]" ? "object with keys {" + Object.keys(f).join(", ") + "}" : c)))
    }
    function Z6(c) {
        function f(pe, de) {
            if (c) {
                var we = pe.deletions;
                we === null ? (pe.deletions = [de],
                pe.flags |= 16) : we.push(de)
            }
        }
        function y(pe, de) {
            if (!c)
                return null;
            for (; de !== null; )
                f(pe, de),
                de = de.sibling;
            return null
        }
        function x(pe) {
            for (var de = new Map; pe !== null; )
                pe.key !== null ? de.set(pe.key, pe) : de.set(pe.index, pe),
                pe = pe.sibling;
            return de
        }
        function T(pe, de) {
            return pe = pl(pe, de),
            pe.index = 0,
            pe.sibling = null,
            pe
        }
        function F(pe, de, we) {
            return pe.index = we,
            c ? (we = pe.alternate,
            we !== null ? (we = we.index,
            we < de ? (pe.flags |= 67108866,
            de) : we) : (pe.flags |= 67108866,
            de)) : (pe.flags |= 1048576,
            de)
        }
        function Z(pe) {
            return c && pe.alternate === null && (pe.flags |= 67108866),
            pe
        }
        function te(pe, de, we, Ne) {
            return de === null || de.tag !== 6 ? (de = N3(we, pe.mode, Ne),
            de.return = pe,
            de) : (de = T(de, we),
            de.return = pe,
            de)
        }
        function le(pe, de, we, Ne) {
            var yt = we.type;
            return yt === b ? ke(pe, de, we.props.children, Ne, we.key) : de !== null && (de.elementType === yt || typeof yt == "object" && yt !== null && yt.$$typeof === M && Ed(yt) === de.type) ? (de = T(de, we.props),
            nm(de, we),
            de.return = pe,
            de) : (de = vb(we.type, we.key, we.props, null, pe.mode, Ne),
            nm(de, we),
            de.return = pe,
            de)
        }
        function ve(pe, de, we, Ne) {
            return de === null || de.tag !== 4 || de.stateNode.containerInfo !== we.containerInfo || de.stateNode.implementation !== we.implementation ? (de = D3(we, pe.mode, Ne),
            de.return = pe,
            de) : (de = T(de, we.children || []),
            de.return = pe,
            de)
        }
        function ke(pe, de, we, Ne, yt) {
            return de === null || de.tag !== 7 ? (de = yd(we, pe.mode, Ne, yt),
            de.return = pe,
            de) : (de = T(de, we),
            de.return = pe,
            de)
        }
        function Te(pe, de, we) {
            if (typeof de == "string" && de !== "" || typeof de == "number" || typeof de == "bigint")
                return de = N3("" + de, pe.mode, we),
                de.return = pe,
                de;
            if (typeof de == "object" && de !== null) {
                switch (de.$$typeof) {
                case g:
                    return we = vb(de.type, de.key, de.props, null, pe.mode, we),
                    nm(we, de),
                    we.return = pe,
                    we;
                case w:
                    return de = D3(de, pe.mode, we),
                    de.return = pe,
                    de;
                case M:
                    return de = Ed(de),
                    Te(pe, de, we)
                }
                if (E(de) || H(de))
                    return de = yd(de, pe.mode, we, null),
                    de.return = pe,
                    de;
                if (typeof de.then == "function")
                    return Te(pe, kb(de), we);
                if (de.$$typeof === _)
                    return Te(pe, Sb(pe, de), we);
                Nb(pe, de)
            }
            return null
        }
        function Se(pe, de, we, Ne) {
            var yt = de !== null ? de.key : null;
            if (typeof we == "string" && we !== "" || typeof we == "number" || typeof we == "bigint")
                return yt !== null ? null : te(pe, de, "" + we, Ne);
            if (typeof we == "object" && we !== null) {
                switch (we.$$typeof) {
                case g:
                    return we.key === yt ? le(pe, de, we, Ne) : null;
                case w:
                    return we.key === yt ? ve(pe, de, we, Ne) : null;
                case M:
                    return we = Ed(we),
                    Se(pe, de, we, Ne)
                }
                if (E(we) || H(we))
                    return yt !== null ? null : ke(pe, de, we, Ne, null);
                if (typeof we.then == "function")
                    return Se(pe, de, kb(we), Ne);
                if (we.$$typeof === _)
                    return Se(pe, de, Sb(pe, we), Ne);
                Nb(pe, we)
            }
            return null
        }
        function Ce(pe, de, we, Ne, yt) {
            if (typeof Ne == "string" && Ne !== "" || typeof Ne == "number" || typeof Ne == "bigint")
                return pe = pe.get(we) || null,
                te(de, pe, "" + Ne, yt);
            if (typeof Ne == "object" && Ne !== null) {
                switch (Ne.$$typeof) {
                case g:
                    return pe = pe.get(Ne.key === null ? we : Ne.key) || null,
                    le(de, pe, Ne, yt);
                case w:
                    return pe = pe.get(Ne.key === null ? we : Ne.key) || null,
                    ve(de, pe, Ne, yt);
                case M:
                    return Ne = Ed(Ne),
                    Ce(pe, de, we, Ne, yt)
                }
                if (E(Ne) || H(Ne))
                    return pe = pe.get(we) || null,
                    ke(de, pe, Ne, yt, null);
                if (typeof Ne.then == "function")
                    return Ce(pe, de, we, kb(Ne), yt);
                if (Ne.$$typeof === _)
                    return Ce(pe, de, we, Sb(de, Ne), yt);
                Nb(de, Ne)
            }
            return null
        }
        function it(pe, de, we, Ne) {
            for (var yt = null, un = null, ft = de, It = de = 0, Yt = null; ft !== null && It < we.length; It++) {
                ft.index > It ? (Yt = ft,
                ft = null) : Yt = ft.sibling;
                var dn = Se(pe, ft, we[It], Ne);
                if (dn === null) {
                    ft === null && (ft = Yt);
                    break
                }
                c && ft && dn.alternate === null && f(pe, ft),
                de = F(dn, de, It),
                un === null ? yt = dn : un.sibling = dn,
                un = dn,
                ft = Yt
            }
            if (It === we.length)
                return y(pe, ft),
                en && ml(pe, It),
                yt;
            if (ft === null) {
                for (; It < we.length; It++)
                    ft = Te(pe, we[It], Ne),
                    ft !== null && (de = F(ft, de, It),
                    un === null ? yt = ft : un.sibling = ft,
                    un = ft);
                return en && ml(pe, It),
                yt
            }
            for (ft = x(ft); It < we.length; It++)
                Yt = Ce(ft, pe, It, we[It], Ne),
                Yt !== null && (c && Yt.alternate !== null && ft.delete(Yt.key === null ? It : Yt.key),
                de = F(Yt, de, It),
                un === null ? yt = Yt : un.sibling = Yt,
                un = Yt);
            return c && ft.forEach(function(cu) {
                return f(pe, cu)
            }),
            en && ml(pe, It),
            yt
        }
        function vt(pe, de, we, Ne) {
            if (we == null)
                throw Error(r(151));
            for (var yt = null, un = null, ft = de, It = de = 0, Yt = null, dn = we.next(); ft !== null && !dn.done; It++,
            dn = we.next()) {
                ft.index > It ? (Yt = ft,
                ft = null) : Yt = ft.sibling;
                var cu = Se(pe, ft, dn.value, Ne);
                if (cu === null) {
                    ft === null && (ft = Yt);
                    break
                }
                c && ft && cu.alternate === null && f(pe, ft),
                de = F(cu, de, It),
                un === null ? yt = cu : un.sibling = cu,
                un = cu,
                ft = Yt
            }
            if (dn.done)
                return y(pe, ft),
                en && ml(pe, It),
                yt;
            if (ft === null) {
                for (; !dn.done; It++,
                dn = we.next())
                    dn = Te(pe, dn.value, Ne),
                    dn !== null && (de = F(dn, de, It),
                    un === null ? yt = dn : un.sibling = dn,
                    un = dn);
                return en && ml(pe, It),
                yt
            }
            for (ft = x(ft); !dn.done; It++,
            dn = we.next())
                dn = Ce(ft, pe, It, dn.value, Ne),
                dn !== null && (c && dn.alternate !== null && ft.delete(dn.key === null ? It : dn.key),
                de = F(dn, de, It),
                un === null ? yt = dn : un.sibling = dn,
                un = dn);
            return c && ft.forEach(function(aX) {
                return f(pe, aX)
            }),
            en && ml(pe, It),
            yt
        }
        function In(pe, de, we, Ne) {
            if (typeof we == "object" && we !== null && we.type === b && we.key === null && (we = we.props.children),
            typeof we == "object" && we !== null) {
                switch (we.$$typeof) {
                case g:
                    e: {
                        for (var yt = we.key; de !== null; ) {
                            if (de.key === yt) {
                                if (yt = we.type,
                                yt === b) {
                                    if (de.tag === 7) {
                                        y(pe, de.sibling),
                                        Ne = T(de, we.props.children),
                                        Ne.return = pe,
                                        pe = Ne;
                                        break e
                                    }
                                } else if (de.elementType === yt || typeof yt == "object" && yt !== null && yt.$$typeof === M && Ed(yt) === de.type) {
                                    y(pe, de.sibling),
                                    Ne = T(de, we.props),
                                    nm(Ne, we),
                                    Ne.return = pe,
                                    pe = Ne;
                                    break e
                                }
                                y(pe, de);
                                break
                            } else
                                f(pe, de);
                            de = de.sibling
                        }
                        we.type === b ? (Ne = yd(we.props.children, pe.mode, Ne, we.key),
                        Ne.return = pe,
                        pe = Ne) : (Ne = vb(we.type, we.key, we.props, null, pe.mode, Ne),
                        nm(Ne, we),
                        Ne.return = pe,
                        pe = Ne)
                    }
                    return Z(pe);
                case w:
                    e: {
                        for (yt = we.key; de !== null; ) {
                            if (de.key === yt)
                                if (de.tag === 4 && de.stateNode.containerInfo === we.containerInfo && de.stateNode.implementation === we.implementation) {
                                    y(pe, de.sibling),
                                    Ne = T(de, we.children || []),
                                    Ne.return = pe,
                                    pe = Ne;
                                    break e
                                } else {
                                    y(pe, de);
                                    break
                                }
                            else
                                f(pe, de);
                            de = de.sibling
                        }
                        Ne = D3(we, pe.mode, Ne),
                        Ne.return = pe,
                        pe = Ne
                    }
                    return Z(pe);
                case M:
                    return we = Ed(we),
                    In(pe, de, we, Ne)
                }
                if (E(we))
                    return it(pe, de, we, Ne);
                if (H(we)) {
                    if (yt = H(we),
                    typeof yt != "function")
                        throw Error(r(150));
                    return we = yt.call(we),
                    vt(pe, de, we, Ne)
                }
                if (typeof we.then == "function")
                    return In(pe, de, kb(we), Ne);
                if (we.$$typeof === _)
                    return In(pe, de, Sb(pe, we), Ne);
                Nb(pe, we)
            }
            return typeof we == "string" && we !== "" || typeof we == "number" || typeof we == "bigint" ? (we = "" + we,
            de !== null && de.tag === 6 ? (y(pe, de.sibling),
            Ne = T(de, we),
            Ne.return = pe,
            pe = Ne) : (y(pe, de),
            Ne = N3(we, pe.mode, Ne),
            Ne.return = pe,
            pe = Ne),
            Z(pe)) : y(pe, de)
        }
        return function(pe, de, we, Ne) {
            try {
                tm = 0;
                var yt = In(pe, de, we, Ne);
                return Ah = null,
                yt
            } catch (ft) {
                if (ft === Sh || ft === Cb)
                    throw ft;
                var un = Bi(29, ft, null, pe.mode);
                return un.lanes = Ne,
                un.return = pe,
                un
            } finally {}
        }
    }
    var Ad = Z6(!0)
      , J6 = Z6(!1)
      , Gc = !1;
    function z3(c) {
        c.updateQueue = {
            baseState: c.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: {
                pending: null,
                lanes: 0,
                hiddenCallbacks: null
            },
            callbacks: null
        }
    }
    function $3(c, f) {
        c = c.updateQueue,
        f.updateQueue === c && (f.updateQueue = {
            baseState: c.baseState,
            firstBaseUpdate: c.firstBaseUpdate,
            lastBaseUpdate: c.lastBaseUpdate,
            shared: c.shared,
            callbacks: null
        })
    }
    function Wc(c) {
        return {
            lane: c,
            tag: 0,
            payload: null,
            callback: null,
            next: null
        }
    }
    function Yc(c, f, y) {
        var x = c.updateQueue;
        if (x === null)
            return null;
        if (x = x.shared,
        (mn & 2) !== 0) {
            var T = x.pending;
            return T === null ? f.next = f : (f.next = T.next,
            T.next = f),
            x.pending = f,
            f = wb(c),
            P6(c, null, y),
            f
        }
        return bb(c, x, f, y),
        wb(c)
    }
    function rm(c, f, y) {
        if (f = f.updateQueue,
        f !== null && (f = f.shared,
        (y & 4194048) !== 0)) {
            var x = f.lanes;
            x &= c.pendingLanes,
            y |= x,
            f.lanes = y,
            Nt(c, y)
        }
    }
    function H3(c, f) {
        var y = c.updateQueue
          , x = c.alternate;
        if (x !== null && (x = x.updateQueue,
        y === x)) {
            var T = null
              , F = null;
            if (y = y.firstBaseUpdate,
            y !== null) {
                do {
                    var Z = {
                        lane: y.lane,
                        tag: y.tag,
                        payload: y.payload,
                        callback: null,
                        next: null
                    };
                    F === null ? T = F = Z : F = F.next = Z,
                    y = y.next
                } while (y !== null);
                F === null ? T = F = f : F = F.next = f
            } else
                T = F = f;
            y = {
                baseState: x.baseState,
                firstBaseUpdate: T,
                lastBaseUpdate: F,
                shared: x.shared,
                callbacks: x.callbacks
            },
            c.updateQueue = y;
            return
        }
        c = y.lastBaseUpdate,
        c === null ? y.firstBaseUpdate = f : c.next = f,
        y.lastBaseUpdate = f
    }
    var V3 = !1;
    function sm() {
        if (V3) {
            var c = Eh;
            if (c !== null)
                throw c
        }
    }
    function im(c, f, y, x) {
        V3 = !1;
        var T = c.updateQueue;
        Gc = !1;
        var F = T.firstBaseUpdate
          , Z = T.lastBaseUpdate
          , te = T.shared.pending;
        if (te !== null) {
            T.shared.pending = null;
            var le = te
              , ve = le.next;
            le.next = null,
            Z === null ? F = ve : Z.next = ve,
            Z = le;
            var ke = c.alternate;
            ke !== null && (ke = ke.updateQueue,
            te = ke.lastBaseUpdate,
            te !== Z && (te === null ? ke.firstBaseUpdate = ve : te.next = ve,
            ke.lastBaseUpdate = le))
        }
        if (F !== null) {
            var Te = T.baseState;
            Z = 0,
            ke = ve = le = null,
            te = F;
            do {
                var Se = te.lane & -536870913
                  , Ce = Se !== te.lane;
                if (Ce ? (Wt & Se) === Se : (x & Se) === Se) {
                    Se !== 0 && Se === xh && (V3 = !0),
                    ke !== null && (ke = ke.next = {
                        lane: 0,
                        tag: te.tag,
                        payload: te.payload,
                        callback: null,
                        next: null
                    });
                    e: {
                        var it = c
                          , vt = te;
                        Se = f;
                        var In = y;
                        switch (vt.tag) {
                        case 1:
                            if (it = vt.payload,
                            typeof it == "function") {
                                Te = it.call(In, Te, Se);
                                break e
                            }
                            Te = it;
                            break e;
                        case 3:
                            it.flags = it.flags & -65537 | 128;
                        case 0:
                            if (it = vt.payload,
                            Se = typeof it == "function" ? it.call(In, Te, Se) : it,
                            Se == null)
                                break e;
                            Te = h({}, Te, Se);
                            break e;
                        case 2:
                            Gc = !0
                        }
                    }
                    Se = te.callback,
                    Se !== null && (c.flags |= 64,
                    Ce && (c.flags |= 8192),
                    Ce = T.callbacks,
                    Ce === null ? T.callbacks = [Se] : Ce.push(Se))
                } else
                    Ce = {
                        lane: Se,
                        tag: te.tag,
                        payload: te.payload,
                        callback: te.callback,
                        next: null
                    },
                    ke === null ? (ve = ke = Ce,
                    le = Te) : ke = ke.next = Ce,
                    Z |= Se;
                if (te = te.next,
                te === null) {
                    if (te = T.shared.pending,
                    te === null)
                        break;
                    Ce = te,
                    te = Ce.next,
                    Ce.next = null,
                    T.lastBaseUpdate = Ce,
                    T.shared.pending = null
                }
            } while (!0);
            ke === null && (le = Te),
            T.baseState = le,
            T.firstBaseUpdate = ve,
            T.lastBaseUpdate = ke,
            F === null && (T.shared.lanes = 0),
            Jc |= Z,
            c.lanes = Z,
            c.memoizedState = Te
        }
    }
    function eN(c, f) {
        if (typeof c != "function")
            throw Error(r(191, c));
        c.call(f)
    }
    function tN(c, f) {
        var y = c.callbacks;
        if (y !== null)
            for (c.callbacks = null,
            c = 0; c < y.length; c++)
                eN(y[c], f)
    }
    var Ch = $(null)
      , Db = $(0);
    function nN(c, f) {
        c = _l,
        U(Db, c),
        U(Ch, f),
        _l = c | f.baseLanes
    }
    function q3() {
        U(Db, _l),
        U(Ch, Ch.current)
    }
    function G3() {
        _l = Db.current,
        D(Ch),
        D(Db)
    }
    var Ri = $(null)
      , fo = null;
    function Kc(c) {
        var f = c.alternate;
        U(br, br.current & 1),
        U(Ri, c),
        fo === null && (f === null || Ch.current !== null || f.memoizedState !== null) && (fo = c)
    }
    function W3(c) {
        U(br, br.current),
        U(Ri, c),
        fo === null && (fo = c)
    }
    function rN(c) {
        c.tag === 22 ? (U(br, br.current),
        U(Ri, c),
        fo === null && (fo = c)) : Xc()
    }
    function Xc() {
        U(br, br.current),
        U(Ri, Ri.current)
    }
    function Oi(c) {
        D(Ri),
        fo === c && (fo = null),
        D(br)
    }
    var br = $(0);
    function Tb(c) {
        for (var f = c; f !== null; ) {
            if (f.tag === 13) {
                var y = f.memoizedState;
                if (y !== null && (y = y.dehydrated,
                y === null || JE(y) || eS(y)))
                    return f
            } else if (f.tag === 19 && (f.memoizedProps.revealOrder === "forwards" || f.memoizedProps.revealOrder === "backwards" || f.memoizedProps.revealOrder === "unstable_legacy-backwards" || f.memoizedProps.revealOrder === "together")) {
                if ((f.flags & 128) !== 0)
                    return f
            } else if (f.child !== null) {
                f.child.return = f,
                f = f.child;
                continue
            }
            if (f === c)
                break;
            for (; f.sibling === null; ) {
                if (f.return === null || f.return === c)
                    return null;
                f = f.return
            }
            f.sibling.return = f.return,
            f = f.sibling
        }
        return null
    }
    var bl = 0
      , Tt = null
      , Dn = null
      , Dr = null
      , Ib = !1
      , _h = !1
      , Cd = !1
      , Mb = 0
      , om = 0
      , kh = null
      , QY = 0;
    function cr() {
        throw Error(r(321))
    }
    function Y3(c, f) {
        if (f === null)
            return !1;
        for (var y = 0; y < f.length && y < c.length; y++)
            if (!Mi(c[y], f[y]))
                return !1;
        return !0
    }
    function K3(c, f, y, x, T, F) {
        return bl = F,
        Tt = f,
        f.memoizedState = null,
        f.updateQueue = null,
        f.lanes = 0,
        C.H = c === null || c.memoizedState === null ? UN : uE,
        Cd = !1,
        F = y(x, T),
        Cd = !1,
        _h && (F = iN(f, y, x, T)),
        sN(c),
        F
    }
    function sN(c) {
        C.H = cm;
        var f = Dn !== null && Dn.next !== null;
        if (bl = 0,
        Dr = Dn = Tt = null,
        Ib = !1,
        om = 0,
        kh = null,
        f)
            throw Error(r(300));
        c === null || Tr || (c = c.dependencies,
        c !== null && Eb(c) && (Tr = !0))
    }
    function iN(c, f, y, x) {
        Tt = c;
        var T = 0;
        do {
            if (_h && (kh = null),
            om = 0,
            _h = !1,
            25 <= T)
                throw Error(r(301));
            if (T += 1,
            Dr = Dn = null,
            c.updateQueue != null) {
                var F = c.updateQueue;
                F.lastEffect = null,
                F.events = null,
                F.stores = null,
                F.memoCache != null && (F.memoCache.index = 0)
            }
            C.H = zN,
            F = f(y, x)
        } while (_h);
        return F
    }
    function ZY() {
        var c = C.H
          , f = c.useState()[0];
        return f = typeof f.then == "function" ? am(f) : f,
        c = c.useState()[0],
        (Dn !== null ? Dn.memoizedState : null) !== c && (Tt.flags |= 1024),
        f
    }
    function X3() {
        var c = Mb !== 0;
        return Mb = 0,
        c
    }
    function Q3(c, f, y) {
        f.updateQueue = c.updateQueue,
        f.flags &= -2053,
        c.lanes &= ~y
    }
    function Z3(c) {
        if (Ib) {
            for (c = c.memoizedState; c !== null; ) {
                var f = c.queue;
                f !== null && (f.pending = null),
                c = c.next
            }
            Ib = !1
        }
        bl = 0,
        Dr = Dn = Tt = null,
        _h = !1,
        om = Mb = 0,
        kh = null
    }
    function Vs() {
        var c = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null
        };
        return Dr === null ? Tt.memoizedState = Dr = c : Dr = Dr.next = c,
        Dr
    }
    function wr() {
        if (Dn === null) {
            var c = Tt.alternate;
            c = c !== null ? c.memoizedState : null
        } else
            c = Dn.next;
        var f = Dr === null ? Tt.memoizedState : Dr.next;
        if (f !== null)
            Dr = f,
            Dn = c;
        else {
            if (c === null)
                throw Tt.alternate === null ? Error(r(467)) : Error(r(310));
            Dn = c,
            c = {
                memoizedState: Dn.memoizedState,
                baseState: Dn.baseState,
                baseQueue: Dn.baseQueue,
                queue: Dn.queue,
                next: null
            },
            Dr === null ? Tt.memoizedState = Dr = c : Dr = Dr.next = c
        }
        return Dr
    }
    function Bb() {
        return {
            lastEffect: null,
            events: null,
            stores: null,
            memoCache: null
        }
    }
    function am(c) {
        var f = om;
        return om += 1,
        kh === null && (kh = []),
        c = K6(kh, c, f),
        f = Tt,
        (Dr === null ? f.memoizedState : Dr.next) === null && (f = f.alternate,
        C.H = f === null || f.memoizedState === null ? UN : uE),
        c
    }
    function Rb(c) {
        if (c !== null && typeof c == "object") {
            if (typeof c.then == "function")
                return am(c);
            if (c.$$typeof === _)
                return os(c)
        }
        throw Error(r(438, String(c)))
    }
    function J3(c) {
        var f = null
          , y = Tt.updateQueue;
        if (y !== null && (f = y.memoCache),
        f == null) {
            var x = Tt.alternate;
            x !== null && (x = x.updateQueue,
            x !== null && (x = x.memoCache,
            x != null && (f = {
                data: x.data.map(function(T) {
                    return T.slice()
                }),
                index: 0
            })))
        }
        if (f == null && (f = {
            data: [],
            index: 0
        }),
        y === null && (y = Bb(),
        Tt.updateQueue = y),
        y.memoCache = f,
        y = f.data[f.index],
        y === void 0)
            for (y = f.data[f.index] = Array(c),
            x = 0; x < c; x++)
                y[x] = L;
        return f.index++,
        y
    }
    function wl(c, f) {
        return typeof f == "function" ? f(c) : f
    }
    function Ob(c) {
        var f = wr();
        return eE(f, Dn, c)
    }
    function eE(c, f, y) {
        var x = c.queue;
        if (x === null)
            throw Error(r(311));
        x.lastRenderedReducer = y;
        var T = c.baseQueue
          , F = x.pending;
        if (F !== null) {
            if (T !== null) {
                var Z = T.next;
                T.next = F.next,
                F.next = Z
            }
            f.baseQueue = T = F,
            x.pending = null
        }
        if (F = c.baseState,
        T === null)
            c.memoizedState = F;
        else {
            f = T.next;
            var te = Z = null
              , le = null
              , ve = f
              , ke = !1;
            do {
                var Te = ve.lane & -536870913;
                if (Te !== ve.lane ? (Wt & Te) === Te : (bl & Te) === Te) {
                    var Se = ve.revertLane;
                    if (Se === 0)
                        le !== null && (le = le.next = {
                            lane: 0,
                            revertLane: 0,
                            gesture: null,
                            action: ve.action,
                            hasEagerState: ve.hasEagerState,
                            eagerState: ve.eagerState,
                            next: null
                        }),
                        Te === xh && (ke = !0);
                    else if ((bl & Se) === Se) {
                        ve = ve.next,
                        Se === xh && (ke = !0);
                        continue
                    } else
                        Te = {
                            lane: 0,
                            revertLane: ve.revertLane,
                            gesture: null,
                            action: ve.action,
                            hasEagerState: ve.hasEagerState,
                            eagerState: ve.eagerState,
                            next: null
                        },
                        le === null ? (te = le = Te,
                        Z = F) : le = le.next = Te,
                        Tt.lanes |= Se,
                        Jc |= Se;
                    Te = ve.action,
                    Cd && y(F, Te),
                    F = ve.hasEagerState ? ve.eagerState : y(F, Te)
                } else
                    Se = {
                        lane: Te,
                        revertLane: ve.revertLane,
                        gesture: ve.gesture,
                        action: ve.action,
                        hasEagerState: ve.hasEagerState,
                        eagerState: ve.eagerState,
                        next: null
                    },
                    le === null ? (te = le = Se,
                    Z = F) : le = le.next = Se,
                    Tt.lanes |= Te,
                    Jc |= Te;
                ve = ve.next
            } while (ve !== null && ve !== f);
            if (le === null ? Z = F : le.next = te,
            !Mi(F, c.memoizedState) && (Tr = !0,
            ke && (y = Eh,
            y !== null)))
                throw y;
            c.memoizedState = F,
            c.baseState = Z,
            c.baseQueue = le,
            x.lastRenderedState = F
        }
        return T === null && (x.lanes = 0),
        [c.memoizedState, x.dispatch]
    }
    function tE(c) {
        var f = wr()
          , y = f.queue;
        if (y === null)
            throw Error(r(311));
        y.lastRenderedReducer = c;
        var x = y.dispatch
          , T = y.pending
          , F = f.memoizedState;
        if (T !== null) {
            y.pending = null;
            var Z = T = T.next;
            do
                F = c(F, Z.action),
                Z = Z.next;
            while (Z !== T);
            Mi(F, f.memoizedState) || (Tr = !0),
            f.memoizedState = F,
            f.baseQueue === null && (f.baseState = F),
            y.lastRenderedState = F
        }
        return [F, x]
    }
    function oN(c, f, y) {
        var x = Tt
          , T = wr()
          , F = en;
        if (F) {
            if (y === void 0)
                throw Error(r(407));
            y = y()
        } else
            y = f();
        var Z = !Mi((Dn || T).memoizedState, y);
        if (Z && (T.memoizedState = y,
        Tr = !0),
        T = T.queue,
        sE(cN.bind(null, x, T, c), [c]),
        T.getSnapshot !== f || Z || Dr !== null && Dr.memoizedState.tag & 1) {
            if (x.flags |= 2048,
            Nh(9, {
                destroy: void 0
            }, lN.bind(null, x, T, y, f), null),
            On === null)
                throw Error(r(349));
            F || (bl & 127) !== 0 || aN(x, f, y)
        }
        return y
    }
    function aN(c, f, y) {
        c.flags |= 16384,
        c = {
            getSnapshot: f,
            value: y
        },
        f = Tt.updateQueue,
        f === null ? (f = Bb(),
        Tt.updateQueue = f,
        f.stores = [c]) : (y = f.stores,
        y === null ? f.stores = [c] : y.push(c))
    }
    function lN(c, f, y, x) {
        f.value = y,
        f.getSnapshot = x,
        uN(f) && dN(c)
    }
    function cN(c, f, y) {
        return y(function() {
            uN(f) && dN(c)
        })
    }
    function uN(c) {
        var f = c.getSnapshot;
        c = c.value;
        try {
            var y = f();
            return !Mi(c, y)
        } catch {
            return !0
        }
    }
    function dN(c) {
        var f = gd(c, 2);
        f !== null && fi(f, c, 2)
    }
    function nE(c) {
        var f = Vs();
        if (typeof c == "function") {
            var y = c;
            if (c = y(),
            Cd) {
                Qe(!0);
                try {
                    y()
                } finally {
                    Qe(!1)
                }
            }
        }
        return f.memoizedState = f.baseState = c,
        f.queue = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: wl,
            lastRenderedState: c
        },
        f
    }
    function fN(c, f, y, x) {
        return c.baseState = y,
        eE(c, Dn, typeof x == "function" ? x : wl)
    }
    function JY(c, f, y, x, T) {
        if (Lb(c))
            throw Error(r(485));
        if (c = f.action,
        c !== null) {
            var F = {
                payload: T,
                action: c,
                next: null,
                isTransition: !0,
                status: "pending",
                value: null,
                reason: null,
                listeners: [],
                then: function(Z) {
                    F.listeners.push(Z)
                }
            };
            C.T !== null ? y(!0) : F.isTransition = !1,
            x(F),
            y = f.pending,
            y === null ? (F.next = f.pending = F,
            hN(f, F)) : (F.next = y.next,
            f.pending = y.next = F)
        }
    }
    function hN(c, f) {
        var y = f.action
          , x = f.payload
          , T = c.state;
        if (f.isTransition) {
            var F = C.T
              , Z = {};
            C.T = Z;
            try {
                var te = y(T, x)
                  , le = C.S;
                le !== null && le(Z, te),
                pN(c, f, te)
            } catch (ve) {
                rE(c, f, ve)
            } finally {
                F !== null && Z.types !== null && (F.types = Z.types),
                C.T = F
            }
        } else
            try {
                F = y(T, x),
                pN(c, f, F)
            } catch (ve) {
                rE(c, f, ve)
            }
    }
    function pN(c, f, y) {
        y !== null && typeof y == "object" && typeof y.then == "function" ? y.then(function(x) {
            mN(c, f, x)
        }, function(x) {
            return rE(c, f, x)
        }) : mN(c, f, y)
    }
    function mN(c, f, y) {
        f.status = "fulfilled",
        f.value = y,
        gN(f),
        c.state = y,
        f = c.pending,
        f !== null && (y = f.next,
        y === f ? c.pending = null : (y = y.next,
        f.next = y,
        hN(c, y)))
    }
    function rE(c, f, y) {
        var x = c.pending;
        if (c.pending = null,
        x !== null) {
            x = x.next;
            do
                f.status = "rejected",
                f.reason = y,
                gN(f),
                f = f.next;
            while (f !== x)
        }
        c.action = null
    }
    function gN(c) {
        c = c.listeners;
        for (var f = 0; f < c.length; f++)
            (0,
            c[f])()
    }
    function yN(c, f) {
        return f
    }
    function bN(c, f) {
        if (en) {
            var y = On.formState;
            if (y !== null) {
                e: {
                    var x = Tt;
                    if (en) {
                        if ($n) {
                            t: {
                                for (var T = $n, F = uo; T.nodeType !== 8; ) {
                                    if (!F) {
                                        T = null;
                                        break t
                                    }
                                    if (T = ho(T.nextSibling),
                                    T === null) {
                                        T = null;
                                        break t
                                    }
                                }
                                F = T.data,
                                T = F === "F!" || F === "F" ? T : null
                            }
                            if (T) {
                                $n = ho(T.nextSibling),
                                x = T.data === "F!";
                                break e
                            }
                        }
                        Vc(x)
                    }
                    x = !1
                }
                x && (f = y[0])
            }
        }
        return y = Vs(),
        y.memoizedState = y.baseState = f,
        x = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: yN,
            lastRenderedState: f
        },
        y.queue = x,
        y = jN.bind(null, Tt, x),
        x.dispatch = y,
        x = nE(!1),
        F = cE.bind(null, Tt, !1, x.queue),
        x = Vs(),
        T = {
            state: f,
            dispatch: null,
            action: c,
            pending: null
        },
        x.queue = T,
        y = JY.bind(null, Tt, T, F, y),
        T.dispatch = y,
        x.memoizedState = c,
        [f, y, !1]
    }
    function wN(c) {
        var f = wr();
        return vN(f, Dn, c)
    }
    function vN(c, f, y) {
        if (f = eE(c, f, yN)[0],
        c = Ob(wl)[0],
        typeof f == "object" && f !== null && typeof f.then == "function")
            try {
                var x = am(f)
            } catch (Z) {
                throw Z === Sh ? Cb : Z
            }
        else
            x = f;
        f = wr();
        var T = f.queue
          , F = T.dispatch;
        return y !== f.memoizedState && (Tt.flags |= 2048,
        Nh(9, {
            destroy: void 0
        }, eK.bind(null, T, y), null)),
        [x, F, c]
    }
    function eK(c, f) {
        c.action = f
    }
    function xN(c) {
        var f = wr()
          , y = Dn;
        if (y !== null)
            return vN(f, y, c);
        wr(),
        f = f.memoizedState,
        y = wr();
        var x = y.queue.dispatch;
        return y.memoizedState = c,
        [f, x, !1]
    }
    function Nh(c, f, y, x) {
        return c = {
            tag: c,
            create: y,
            deps: x,
            inst: f,
            next: null
        },
        f = Tt.updateQueue,
        f === null && (f = Bb(),
        Tt.updateQueue = f),
        y = f.lastEffect,
        y === null ? f.lastEffect = c.next = c : (x = y.next,
        y.next = c,
        c.next = x,
        f.lastEffect = c),
        c
    }
    function EN() {
        return wr().memoizedState
    }
    function Pb(c, f, y, x) {
        var T = Vs();
        Tt.flags |= c,
        T.memoizedState = Nh(1 | f, {
            destroy: void 0
        }, y, x === void 0 ? null : x)
    }
    function jb(c, f, y, x) {
        var T = wr();
        x = x === void 0 ? null : x;
        var F = T.memoizedState.inst;
        Dn !== null && x !== null && Y3(x, Dn.memoizedState.deps) ? T.memoizedState = Nh(f, F, y, x) : (Tt.flags |= c,
        T.memoizedState = Nh(1 | f, F, y, x))
    }
    function SN(c, f) {
        Pb(8390656, 8, c, f)
    }
    function sE(c, f) {
        jb(2048, 8, c, f)
    }
    function tK(c) {
        Tt.flags |= 4;
        var f = Tt.updateQueue;
        if (f === null)
            f = Bb(),
            Tt.updateQueue = f,
            f.events = [c];
        else {
            var y = f.events;
            y === null ? f.events = [c] : y.push(c)
        }
    }
    function AN(c) {
        var f = wr().memoizedState;
        return tK({
            ref: f,
            nextImpl: c
        }),
        function() {
            if ((mn & 2) !== 0)
                throw Error(r(440));
            return f.impl.apply(void 0, arguments)
        }
    }
    function CN(c, f) {
        return jb(4, 2, c, f)
    }
    function _N(c, f) {
        return jb(4, 4, c, f)
    }
    function kN(c, f) {
        if (typeof f == "function") {
            c = c();
            var y = f(c);
            return function() {
                typeof y == "function" ? y() : f(null)
            }
        }
        if (f != null)
            return c = c(),
            f.current = c,
            function() {
                f.current = null
            }
    }
    function NN(c, f, y) {
        y = y != null ? y.concat([c]) : null,
        jb(4, 4, kN.bind(null, f, c), y)
    }
    function iE() {}
    function DN(c, f) {
        var y = wr();
        f = f === void 0 ? null : f;
        var x = y.memoizedState;
        return f !== null && Y3(f, x[1]) ? x[0] : (y.memoizedState = [c, f],
        c)
    }
    function TN(c, f) {
        var y = wr();
        f = f === void 0 ? null : f;
        var x = y.memoizedState;
        if (f !== null && Y3(f, x[1]))
            return x[0];
        if (x = c(),
        Cd) {
            Qe(!0);
            try {
                c()
            } finally {
                Qe(!1)
            }
        }
        return y.memoizedState = [x, f],
        x
    }
    function oE(c, f, y) {
        return y === void 0 || (bl & 1073741824) !== 0 && (Wt & 261930) === 0 ? c.memoizedState = f : (c.memoizedState = y,
        c = ID(),
        Tt.lanes |= c,
        Jc |= c,
        y)
    }
    function IN(c, f, y, x) {
        return Mi(y, f) ? y : Ch.current !== null ? (c = oE(c, y, x),
        Mi(c, f) || (Tr = !0),
        c) : (bl & 42) === 0 || (bl & 1073741824) !== 0 && (Wt & 261930) === 0 ? (Tr = !0,
        c.memoizedState = y) : (c = ID(),
        Tt.lanes |= c,
        Jc |= c,
        f)
    }
    function MN(c, f, y, x, T) {
        var F = O.p;
        O.p = F !== 0 && 8 > F ? F : 8;
        var Z = C.T
          , te = {};
        C.T = te,
        cE(c, !1, f, y);
        try {
            var le = T()
              , ve = C.S;
            if (ve !== null && ve(te, le),
            le !== null && typeof le == "object" && typeof le.then == "function") {
                var ke = XY(le, x);
                lm(c, f, ke, Li(c))
            } else
                lm(c, f, x, Li(c))
        } catch (Te) {
            lm(c, f, {
                then: function() {},
                status: "rejected",
                reason: Te
            }, Li())
        } finally {
            O.p = F,
            Z !== null && te.types !== null && (Z.types = te.types),
            C.T = Z
        }
    }
    function nK() {}
    function aE(c, f, y, x) {
        if (c.tag !== 5)
            throw Error(r(476));
        var T = BN(c).queue;
        MN(c, T, f, z, y === null ? nK : function() {
            return RN(c),
            y(x)
        }
        )
    }
    function BN(c) {
        var f = c.memoizedState;
        if (f !== null)
            return f;
        f = {
            memoizedState: z,
            baseState: z,
            baseQueue: null,
            queue: {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: wl,
                lastRenderedState: z
            },
            next: null
        };
        var y = {};
        return f.next = {
            memoizedState: y,
            baseState: y,
            baseQueue: null,
            queue: {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: wl,
                lastRenderedState: y
            },
            next: null
        },
        c.memoizedState = f,
        c = c.alternate,
        c !== null && (c.memoizedState = f),
        f
    }
    function RN(c) {
        var f = BN(c);
        f.next === null && (f = c.alternate.memoizedState),
        lm(c, f.next.queue, {}, Li())
    }
    function lE() {
        return os(Cm)
    }
    function ON() {
        return wr().memoizedState
    }
    function PN() {
        return wr().memoizedState
    }
    function rK(c) {
        for (var f = c.return; f !== null; ) {
            switch (f.tag) {
            case 24:
            case 3:
                var y = Li();
                c = Wc(y);
                var x = Yc(f, c, y);
                x !== null && (fi(x, f, y),
                rm(x, f, y)),
                f = {
                    cache: j3()
                },
                c.payload = f;
                return
            }
            f = f.return
        }
    }
    function sK(c, f, y) {
        var x = Li();
        y = {
            lane: x,
            revertLane: 0,
            gesture: null,
            action: y,
            hasEagerState: !1,
            eagerState: null,
            next: null
        },
        Lb(c) ? LN(f, y) : (y = _3(c, f, y, x),
        y !== null && (fi(y, c, x),
        FN(y, f, x)))
    }
    function jN(c, f, y) {
        var x = Li();
        lm(c, f, y, x)
    }
    function lm(c, f, y, x) {
        var T = {
            lane: x,
            revertLane: 0,
            gesture: null,
            action: y,
            hasEagerState: !1,
            eagerState: null,
            next: null
        };
        if (Lb(c))
            LN(f, T);
        else {
            var F = c.alternate;
            if (c.lanes === 0 && (F === null || F.lanes === 0) && (F = f.lastRenderedReducer,
            F !== null))
                try {
                    var Z = f.lastRenderedState
                      , te = F(Z, y);
                    if (T.hasEagerState = !0,
                    T.eagerState = te,
                    Mi(te, Z))
                        return bb(c, f, T, 0),
                        On === null && yb(),
                        !1
                } catch {} finally {}
            if (y = _3(c, f, T, x),
            y !== null)
                return fi(y, c, x),
                FN(y, f, x),
                !0
        }
        return !1
    }
    function cE(c, f, y, x) {
        if (x = {
            lane: 2,
            revertLane: zE(),
            gesture: null,
            action: x,
            hasEagerState: !1,
            eagerState: null,
            next: null
        },
        Lb(c)) {
            if (f)
                throw Error(r(479))
        } else
            f = _3(c, y, x, 2),
            f !== null && fi(f, c, 2)
    }
    function Lb(c) {
        var f = c.alternate;
        return c === Tt || f !== null && f === Tt
    }
    function LN(c, f) {
        _h = Ib = !0;
        var y = c.pending;
        y === null ? f.next = f : (f.next = y.next,
        y.next = f),
        c.pending = f
    }
    function FN(c, f, y) {
        if ((y & 4194048) !== 0) {
            var x = f.lanes;
            x &= c.pendingLanes,
            y |= x,
            f.lanes = y,
            Nt(c, y)
        }
    }
    var cm = {
        readContext: os,
        use: Rb,
        useCallback: cr,
        useContext: cr,
        useEffect: cr,
        useImperativeHandle: cr,
        useLayoutEffect: cr,
        useInsertionEffect: cr,
        useMemo: cr,
        useReducer: cr,
        useRef: cr,
        useState: cr,
        useDebugValue: cr,
        useDeferredValue: cr,
        useTransition: cr,
        useSyncExternalStore: cr,
        useId: cr,
        useHostTransitionStatus: cr,
        useFormState: cr,
        useActionState: cr,
        useOptimistic: cr,
        useMemoCache: cr,
        useCacheRefresh: cr
    };
    cm.useEffectEvent = cr;
    var UN = {
        readContext: os,
        use: Rb,
        useCallback: function(c, f) {
            return Vs().memoizedState = [c, f === void 0 ? null : f],
            c
        },
        useContext: os,
        useEffect: SN,
        useImperativeHandle: function(c, f, y) {
            y = y != null ? y.concat([c]) : null,
            Pb(4194308, 4, kN.bind(null, f, c), y)
        },
        useLayoutEffect: function(c, f) {
            return Pb(4194308, 4, c, f)
        },
        useInsertionEffect: function(c, f) {
            Pb(4, 2, c, f)
        },
        useMemo: function(c, f) {
            var y = Vs();
            f = f === void 0 ? null : f;
            var x = c();
            if (Cd) {
                Qe(!0);
                try {
                    c()
                } finally {
                    Qe(!1)
                }
            }
            return y.memoizedState = [x, f],
            x
        },
        useReducer: function(c, f, y) {
            var x = Vs();
            if (y !== void 0) {
                var T = y(f);
                if (Cd) {
                    Qe(!0);
                    try {
                        y(f)
                    } finally {
                        Qe(!1)
                    }
                }
            } else
                T = f;
            return x.memoizedState = x.baseState = T,
            c = {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: c,
                lastRenderedState: T
            },
            x.queue = c,
            c = c.dispatch = sK.bind(null, Tt, c),
            [x.memoizedState, c]
        },
        useRef: function(c) {
            var f = Vs();
            return c = {
                current: c
            },
            f.memoizedState = c
        },
        useState: function(c) {
            c = nE(c);
            var f = c.queue
              , y = jN.bind(null, Tt, f);
            return f.dispatch = y,
            [c.memoizedState, y]
        },
        useDebugValue: iE,
        useDeferredValue: function(c, f) {
            var y = Vs();
            return oE(y, c, f)
        },
        useTransition: function() {
            var c = nE(!1);
            return c = MN.bind(null, Tt, c.queue, !0, !1),
            Vs().memoizedState = c,
            [!1, c]
        },
        useSyncExternalStore: function(c, f, y) {
            var x = Tt
              , T = Vs();
            if (en) {
                if (y === void 0)
                    throw Error(r(407));
                y = y()
            } else {
                if (y = f(),
                On === null)
                    throw Error(r(349));
                (Wt & 127) !== 0 || aN(x, f, y)
            }
            T.memoizedState = y;
            var F = {
                value: y,
                getSnapshot: f
            };
            return T.queue = F,
            SN(cN.bind(null, x, F, c), [c]),
            x.flags |= 2048,
            Nh(9, {
                destroy: void 0
            }, lN.bind(null, x, F, y, f), null),
            y
        },
        useId: function() {
            var c = Vs()
              , f = On.identifierPrefix;
            if (en) {
                var y = Sa
                  , x = Ea;
                y = (x & ~(1 << 32 - Ve(x) - 1)).toString(32) + y,
                f = "_" + f + "R_" + y,
                y = Mb++,
                0 < y && (f += "H" + y.toString(32)),
                f += "_"
            } else
                y = QY++,
                f = "_" + f + "r_" + y.toString(32) + "_";
            return c.memoizedState = f
        },
        useHostTransitionStatus: lE,
        useFormState: bN,
        useActionState: bN,
        useOptimistic: function(c) {
            var f = Vs();
            f.memoizedState = f.baseState = c;
            var y = {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: null,
                lastRenderedState: null
            };
            return f.queue = y,
            f = cE.bind(null, Tt, !0, y),
            y.dispatch = f,
            [c, f]
        },
        useMemoCache: J3,
        useCacheRefresh: function() {
            return Vs().memoizedState = rK.bind(null, Tt)
        },
        useEffectEvent: function(c) {
            var f = Vs()
              , y = {
                impl: c
            };
            return f.memoizedState = y,
            function() {
                if ((mn & 2) !== 0)
                    throw Error(r(440));
                return y.impl.apply(void 0, arguments)
            }
        }
    }
      , uE = {
        readContext: os,
        use: Rb,
        useCallback: DN,
        useContext: os,
        useEffect: sE,
        useImperativeHandle: NN,
        useInsertionEffect: CN,
        useLayoutEffect: _N,
        useMemo: TN,
        useReducer: Ob,
        useRef: EN,
        useState: function() {
            return Ob(wl)
        },
        useDebugValue: iE,
        useDeferredValue: function(c, f) {
            var y = wr();
            return IN(y, Dn.memoizedState, c, f)
        },
        useTransition: function() {
            var c = Ob(wl)[0]
              , f = wr().memoizedState;
            return [typeof c == "boolean" ? c : am(c), f]
        },
        useSyncExternalStore: oN,
        useId: ON,
        useHostTransitionStatus: lE,
        useFormState: wN,
        useActionState: wN,
        useOptimistic: function(c, f) {
            var y = wr();
            return fN(y, Dn, c, f)
        },
        useMemoCache: J3,
        useCacheRefresh: PN
    };
    uE.useEffectEvent = AN;
    var zN = {
        readContext: os,
        use: Rb,
        useCallback: DN,
        useContext: os,
        useEffect: sE,
        useImperativeHandle: NN,
        useInsertionEffect: CN,
        useLayoutEffect: _N,
        useMemo: TN,
        useReducer: tE,
        useRef: EN,
        useState: function() {
            return tE(wl)
        },
        useDebugValue: iE,
        useDeferredValue: function(c, f) {
            var y = wr();
            return Dn === null ? oE(y, c, f) : IN(y, Dn.memoizedState, c, f)
        },
        useTransition: function() {
            var c = tE(wl)[0]
              , f = wr().memoizedState;
            return [typeof c == "boolean" ? c : am(c), f]
        },
        useSyncExternalStore: oN,
        useId: ON,
        useHostTransitionStatus: lE,
        useFormState: xN,
        useActionState: xN,
        useOptimistic: function(c, f) {
            var y = wr();
            return Dn !== null ? fN(y, Dn, c, f) : (y.baseState = c,
            [c, y.queue.dispatch])
        },
        useMemoCache: J3,
        useCacheRefresh: PN
    };
    zN.useEffectEvent = AN;
    function dE(c, f, y, x) {
        f = c.memoizedState,
        y = y(x, f),
        y = y == null ? f : h({}, f, y),
        c.memoizedState = y,
        c.lanes === 0 && (c.updateQueue.baseState = y)
    }
    var fE = {
        enqueueSetState: function(c, f, y) {
            c = c._reactInternals;
            var x = Li()
              , T = Wc(x);
            T.payload = f,
            y != null && (T.callback = y),
            f = Yc(c, T, x),
            f !== null && (fi(f, c, x),
            rm(f, c, x))
        },
        enqueueReplaceState: function(c, f, y) {
            c = c._reactInternals;
            var x = Li()
              , T = Wc(x);
            T.tag = 1,
            T.payload = f,
            y != null && (T.callback = y),
            f = Yc(c, T, x),
            f !== null && (fi(f, c, x),
            rm(f, c, x))
        },
        enqueueForceUpdate: function(c, f) {
            c = c._reactInternals;
            var y = Li()
              , x = Wc(y);
            x.tag = 2,
            f != null && (x.callback = f),
            f = Yc(c, x, y),
            f !== null && (fi(f, c, y),
            rm(f, c, y))
        }
    };
    function $N(c, f, y, x, T, F, Z) {
        return c = c.stateNode,
        typeof c.shouldComponentUpdate == "function" ? c.shouldComponentUpdate(x, F, Z) : f.prototype && f.prototype.isPureReactComponent ? !K0(y, x) || !K0(T, F) : !0
    }
    function HN(c, f, y, x) {
        c = f.state,
        typeof f.componentWillReceiveProps == "function" && f.componentWillReceiveProps(y, x),
        typeof f.UNSAFE_componentWillReceiveProps == "function" && f.UNSAFE_componentWillReceiveProps(y, x),
        f.state !== c && fE.enqueueReplaceState(f, f.state, null)
    }
    function _d(c, f) {
        var y = f;
        if ("ref"in f) {
            y = {};
            for (var x in f)
                x !== "ref" && (y[x] = f[x])
        }
        if (c = c.defaultProps) {
            y === f && (y = h({}, y));
            for (var T in c)
                y[T] === void 0 && (y[T] = c[T])
        }
        return y
    }
    function VN(c) {
        gb(c)
    }
    function qN(c) {
        console.error(c)
    }
    function GN(c) {
        gb(c)
    }
    function Fb(c, f) {
        try {
            var y = c.onUncaughtError;
            y(f.value, {
                componentStack: f.stack
            })
        } catch (x) {
            setTimeout(function() {
                throw x
            })
        }
    }
    function WN(c, f, y) {
        try {
            var x = c.onCaughtError;
            x(y.value, {
                componentStack: y.stack,
                errorBoundary: f.tag === 1 ? f.stateNode : null
            })
        } catch (T) {
            setTimeout(function() {
                throw T
            })
        }
    }
    function hE(c, f, y) {
        return y = Wc(y),
        y.tag = 3,
        y.payload = {
            element: null
        },
        y.callback = function() {
            Fb(c, f)
        }
        ,
        y
    }
    function YN(c) {
        return c = Wc(c),
        c.tag = 3,
        c
    }
    function KN(c, f, y, x) {
        var T = y.type.getDerivedStateFromError;
        if (typeof T == "function") {
            var F = x.value;
            c.payload = function() {
                return T(F)
            }
            ,
            c.callback = function() {
                WN(f, y, x)
            }
        }
        var Z = y.stateNode;
        Z !== null && typeof Z.componentDidCatch == "function" && (c.callback = function() {
            WN(f, y, x),
            typeof T != "function" && (eu === null ? eu = new Set([this]) : eu.add(this));
            var te = x.stack;
            this.componentDidCatch(x.value, {
                componentStack: te !== null ? te : ""
            })
        }
        )
    }
    function iK(c, f, y, x, T) {
        if (y.flags |= 32768,
        x !== null && typeof x == "object" && typeof x.then == "function") {
            if (f = y.alternate,
            f !== null && vh(f, y, T, !0),
            y = Ri.current,
            y !== null) {
                switch (y.tag) {
                case 31:
                case 13:
                    return fo === null ? Qb() : y.alternate === null && ur === 0 && (ur = 3),
                    y.flags &= -257,
                    y.flags |= 65536,
                    y.lanes = T,
                    x === _b ? y.flags |= 16384 : (f = y.updateQueue,
                    f === null ? y.updateQueue = new Set([x]) : f.add(x),
                    LE(c, x, T)),
                    !1;
                case 22:
                    return y.flags |= 65536,
                    x === _b ? y.flags |= 16384 : (f = y.updateQueue,
                    f === null ? (f = {
                        transitions: null,
                        markerInstances: null,
                        retryQueue: new Set([x])
                    },
                    y.updateQueue = f) : (y = f.retryQueue,
                    y === null ? f.retryQueue = new Set([x]) : y.add(x)),
                    LE(c, x, T)),
                    !1
                }
                throw Error(r(435, y.tag))
            }
            return LE(c, x, T),
            Qb(),
            !1
        }
        if (en)
            return f = Ri.current,
            f !== null ? ((f.flags & 65536) === 0 && (f.flags |= 256),
            f.flags |= 65536,
            f.lanes = T,
            x !== M3 && (c = Error(r(422), {
                cause: x
            }),
            Z0(ao(c, y)))) : (x !== M3 && (f = Error(r(423), {
                cause: x
            }),
            Z0(ao(f, y))),
            c = c.current.alternate,
            c.flags |= 65536,
            T &= -T,
            c.lanes |= T,
            x = ao(x, y),
            T = hE(c.stateNode, x, T),
            H3(c, T),
            ur !== 4 && (ur = 2)),
            !1;
        var F = Error(r(520), {
            cause: x
        });
        if (F = ao(F, y),
        ym === null ? ym = [F] : ym.push(F),
        ur !== 4 && (ur = 2),
        f === null)
            return !0;
        x = ao(x, y),
        y = f;
        do {
            switch (y.tag) {
            case 3:
                return y.flags |= 65536,
                c = T & -T,
                y.lanes |= c,
                c = hE(y.stateNode, x, c),
                H3(y, c),
                !1;
            case 1:
                if (f = y.type,
                F = y.stateNode,
                (y.flags & 128) === 0 && (typeof f.getDerivedStateFromError == "function" || F !== null && typeof F.componentDidCatch == "function" && (eu === null || !eu.has(F))))
                    return y.flags |= 65536,
                    T &= -T,
                    y.lanes |= T,
                    T = YN(T),
                    KN(T, c, y, x),
                    H3(y, T),
                    !1
            }
            y = y.return
        } while (y !== null);
        return !1
    }
    var pE = Error(r(461))
      , Tr = !1;
    function as(c, f, y, x) {
        f.child = c === null ? J6(f, null, y, x) : Ad(f, c.child, y, x)
    }
    function XN(c, f, y, x, T) {
        y = y.render;
        var F = f.ref;
        if ("ref"in x) {
            var Z = {};
            for (var te in x)
                te !== "ref" && (Z[te] = x[te])
        } else
            Z = x;
        return vd(f),
        x = K3(c, f, y, Z, F, T),
        te = X3(),
        c !== null && !Tr ? (Q3(c, f, T),
        vl(c, f, T)) : (en && te && T3(f),
        f.flags |= 1,
        as(c, f, x, T),
        f.child)
    }
    function QN(c, f, y, x, T) {
        if (c === null) {
            var F = y.type;
            return typeof F == "function" && !k3(F) && F.defaultProps === void 0 && y.compare === null ? (f.tag = 15,
            f.type = F,
            ZN(c, f, F, x, T)) : (c = vb(y.type, null, x, f, f.mode, T),
            c.ref = f.ref,
            c.return = f,
            f.child = c)
        }
        if (F = c.child,
        !EE(c, T)) {
            var Z = F.memoizedProps;
            if (y = y.compare,
            y = y !== null ? y : K0,
            y(Z, x) && c.ref === f.ref)
                return vl(c, f, T)
        }
        return f.flags |= 1,
        c = pl(F, x),
        c.ref = f.ref,
        c.return = f,
        f.child = c
    }
    function ZN(c, f, y, x, T) {
        if (c !== null) {
            var F = c.memoizedProps;
            if (K0(F, x) && c.ref === f.ref)
                if (Tr = !1,
                f.pendingProps = x = F,
                EE(c, T))
                    (c.flags & 131072) !== 0 && (Tr = !0);
                else
                    return f.lanes = c.lanes,
                    vl(c, f, T)
        }
        return mE(c, f, y, x, T)
    }
    function JN(c, f, y, x) {
        var T = x.children
          , F = c !== null ? c.memoizedState : null;
        if (c === null && f.stateNode === null && (f.stateNode = {
            _visibility: 1,
            _pendingMarkers: null,
            _retryCache: null,
            _transitions: null
        }),
        x.mode === "hidden") {
            if ((f.flags & 128) !== 0) {
                if (F = F !== null ? F.baseLanes | y : y,
                c !== null) {
                    for (x = f.child = c.child,
                    T = 0; x !== null; )
                        T = T | x.lanes | x.childLanes,
                        x = x.sibling;
                    x = T & ~F
                } else
                    x = 0,
                    f.child = null;
                return eD(c, f, F, y, x)
            }
            if ((y & 536870912) !== 0)
                f.memoizedState = {
                    baseLanes: 0,
                    cachePool: null
                },
                c !== null && Ab(f, F !== null ? F.cachePool : null),
                F !== null ? nN(f, F) : q3(),
                rN(f);
            else
                return x = f.lanes = 536870912,
                eD(c, f, F !== null ? F.baseLanes | y : y, y, x)
        } else
            F !== null ? (Ab(f, F.cachePool),
            nN(f, F),
            Xc(),
            f.memoizedState = null) : (c !== null && Ab(f, null),
            q3(),
            Xc());
        return as(c, f, T, y),
        f.child
    }
    function um(c, f) {
        return c !== null && c.tag === 22 || f.stateNode !== null || (f.stateNode = {
            _visibility: 1,
            _pendingMarkers: null,
            _retryCache: null,
            _transitions: null
        }),
        f.sibling
    }
    function eD(c, f, y, x, T) {
        var F = F3();
        return F = F === null ? null : {
            parent: Nr._currentValue,
            pool: F
        },
        f.memoizedState = {
            baseLanes: y,
            cachePool: F
        },
        c !== null && Ab(f, null),
        q3(),
        rN(f),
        c !== null && vh(c, f, x, !0),
        f.childLanes = T,
        null
    }
    function Ub(c, f) {
        return f = $b({
            mode: f.mode,
            children: f.children
        }, c.mode),
        f.ref = c.ref,
        c.child = f,
        f.return = c,
        f
    }
    function tD(c, f, y) {
        return Ad(f, c.child, null, y),
        c = Ub(f, f.pendingProps),
        c.flags |= 2,
        Oi(f),
        f.memoizedState = null,
        c
    }
    function oK(c, f, y) {
        var x = f.pendingProps
          , T = (f.flags & 128) !== 0;
        if (f.flags &= -129,
        c === null) {
            if (en) {
                if (x.mode === "hidden")
                    return c = Ub(f, x),
                    f.lanes = 536870912,
                    um(null, c);
                if (W3(f),
                (c = $n) ? (c = hT(c, uo),
                c = c !== null && c.data === "&" ? c : null,
                c !== null && (f.memoizedState = {
                    dehydrated: c,
                    treeContext: $c !== null ? {
                        id: Ea,
                        overflow: Sa
                    } : null,
                    retryLane: 536870912,
                    hydrationErrors: null
                },
                y = L6(c),
                y.return = f,
                f.child = y,
                is = f,
                $n = null)) : c = null,
                c === null)
                    throw Vc(f);
                return f.lanes = 536870912,
                null
            }
            return Ub(f, x)
        }
        var F = c.memoizedState;
        if (F !== null) {
            var Z = F.dehydrated;
            if (W3(f),
            T)
                if (f.flags & 256)
                    f.flags &= -257,
                    f = tD(c, f, y);
                else if (f.memoizedState !== null)
                    f.child = c.child,
                    f.flags |= 128,
                    f = null;
                else
                    throw Error(r(558));
            else if (Tr || vh(c, f, y, !1),
            T = (y & c.childLanes) !== 0,
            Tr || T) {
                if (x = On,
                x !== null && (Z = pt(x, y),
                Z !== 0 && Z !== F.retryLane))
                    throw F.retryLane = Z,
                    gd(c, Z),
                    fi(x, c, Z),
                    pE;
                Qb(),
                f = tD(c, f, y)
            } else
                c = F.treeContext,
                $n = ho(Z.nextSibling),
                is = f,
                en = !0,
                Hc = null,
                uo = !1,
                c !== null && z6(f, c),
                f = Ub(f, x),
                f.flags |= 4096;
            return f
        }
        return c = pl(c.child, {
            mode: x.mode,
            children: x.children
        }),
        c.ref = f.ref,
        f.child = c,
        c.return = f,
        c
    }
    function zb(c, f) {
        var y = f.ref;
        if (y === null)
            c !== null && c.ref !== null && (f.flags |= 4194816);
        else {
            if (typeof y != "function" && typeof y != "object")
                throw Error(r(284));
            (c === null || c.ref !== y) && (f.flags |= 4194816)
        }
    }
    function mE(c, f, y, x, T) {
        return vd(f),
        y = K3(c, f, y, x, void 0, T),
        x = X3(),
        c !== null && !Tr ? (Q3(c, f, T),
        vl(c, f, T)) : (en && x && T3(f),
        f.flags |= 1,
        as(c, f, y, T),
        f.child)
    }
    function nD(c, f, y, x, T, F) {
        return vd(f),
        f.updateQueue = null,
        y = iN(f, x, y, T),
        sN(c),
        x = X3(),
        c !== null && !Tr ? (Q3(c, f, F),
        vl(c, f, F)) : (en && x && T3(f),
        f.flags |= 1,
        as(c, f, y, F),
        f.child)
    }
    function rD(c, f, y, x, T) {
        if (vd(f),
        f.stateNode === null) {
            var F = gh
              , Z = y.contextType;
            typeof Z == "object" && Z !== null && (F = os(Z)),
            F = new y(x,F),
            f.memoizedState = F.state !== null && F.state !== void 0 ? F.state : null,
            F.updater = fE,
            f.stateNode = F,
            F._reactInternals = f,
            F = f.stateNode,
            F.props = x,
            F.state = f.memoizedState,
            F.refs = {},
            z3(f),
            Z = y.contextType,
            F.context = typeof Z == "object" && Z !== null ? os(Z) : gh,
            F.state = f.memoizedState,
            Z = y.getDerivedStateFromProps,
            typeof Z == "function" && (dE(f, y, Z, x),
            F.state = f.memoizedState),
            typeof y.getDerivedStateFromProps == "function" || typeof F.getSnapshotBeforeUpdate == "function" || typeof F.UNSAFE_componentWillMount != "function" && typeof F.componentWillMount != "function" || (Z = F.state,
            typeof F.componentWillMount == "function" && F.componentWillMount(),
            typeof F.UNSAFE_componentWillMount == "function" && F.UNSAFE_componentWillMount(),
            Z !== F.state && fE.enqueueReplaceState(F, F.state, null),
            im(f, x, F, T),
            sm(),
            F.state = f.memoizedState),
            typeof F.componentDidMount == "function" && (f.flags |= 4194308),
            x = !0
        } else if (c === null) {
            F = f.stateNode;
            var te = f.memoizedProps
              , le = _d(y, te);
            F.props = le;
            var ve = F.context
              , ke = y.contextType;
            Z = gh,
            typeof ke == "object" && ke !== null && (Z = os(ke));
            var Te = y.getDerivedStateFromProps;
            ke = typeof Te == "function" || typeof F.getSnapshotBeforeUpdate == "function",
            te = f.pendingProps !== te,
            ke || typeof F.UNSAFE_componentWillReceiveProps != "function" && typeof F.componentWillReceiveProps != "function" || (te || ve !== Z) && HN(f, F, x, Z),
            Gc = !1;
            var Se = f.memoizedState;
            F.state = Se,
            im(f, x, F, T),
            sm(),
            ve = f.memoizedState,
            te || Se !== ve || Gc ? (typeof Te == "function" && (dE(f, y, Te, x),
            ve = f.memoizedState),
            (le = Gc || $N(f, y, le, x, Se, ve, Z)) ? (ke || typeof F.UNSAFE_componentWillMount != "function" && typeof F.componentWillMount != "function" || (typeof F.componentWillMount == "function" && F.componentWillMount(),
            typeof F.UNSAFE_componentWillMount == "function" && F.UNSAFE_componentWillMount()),
            typeof F.componentDidMount == "function" && (f.flags |= 4194308)) : (typeof F.componentDidMount == "function" && (f.flags |= 4194308),
            f.memoizedProps = x,
            f.memoizedState = ve),
            F.props = x,
            F.state = ve,
            F.context = Z,
            x = le) : (typeof F.componentDidMount == "function" && (f.flags |= 4194308),
            x = !1)
        } else {
            F = f.stateNode,
            $3(c, f),
            Z = f.memoizedProps,
            ke = _d(y, Z),
            F.props = ke,
            Te = f.pendingProps,
            Se = F.context,
            ve = y.contextType,
            le = gh,
            typeof ve == "object" && ve !== null && (le = os(ve)),
            te = y.getDerivedStateFromProps,
            (ve = typeof te == "function" || typeof F.getSnapshotBeforeUpdate == "function") || typeof F.UNSAFE_componentWillReceiveProps != "function" && typeof F.componentWillReceiveProps != "function" || (Z !== Te || Se !== le) && HN(f, F, x, le),
            Gc = !1,
            Se = f.memoizedState,
            F.state = Se,
            im(f, x, F, T),
            sm();
            var Ce = f.memoizedState;
            Z !== Te || Se !== Ce || Gc || c !== null && c.dependencies !== null && Eb(c.dependencies) ? (typeof te == "function" && (dE(f, y, te, x),
            Ce = f.memoizedState),
            (ke = Gc || $N(f, y, ke, x, Se, Ce, le) || c !== null && c.dependencies !== null && Eb(c.dependencies)) ? (ve || typeof F.UNSAFE_componentWillUpdate != "function" && typeof F.componentWillUpdate != "function" || (typeof F.componentWillUpdate == "function" && F.componentWillUpdate(x, Ce, le),
            typeof F.UNSAFE_componentWillUpdate == "function" && F.UNSAFE_componentWillUpdate(x, Ce, le)),
            typeof F.componentDidUpdate == "function" && (f.flags |= 4),
            typeof F.getSnapshotBeforeUpdate == "function" && (f.flags |= 1024)) : (typeof F.componentDidUpdate != "function" || Z === c.memoizedProps && Se === c.memoizedState || (f.flags |= 4),
            typeof F.getSnapshotBeforeUpdate != "function" || Z === c.memoizedProps && Se === c.memoizedState || (f.flags |= 1024),
            f.memoizedProps = x,
            f.memoizedState = Ce),
            F.props = x,
            F.state = Ce,
            F.context = le,
            x = ke) : (typeof F.componentDidUpdate != "function" || Z === c.memoizedProps && Se === c.memoizedState || (f.flags |= 4),
            typeof F.getSnapshotBeforeUpdate != "function" || Z === c.memoizedProps && Se === c.memoizedState || (f.flags |= 1024),
            x = !1)
        }
        return F = x,
        zb(c, f),
        x = (f.flags & 128) !== 0,
        F || x ? (F = f.stateNode,
        y = x && typeof y.getDerivedStateFromError != "function" ? null : F.render(),
        f.flags |= 1,
        c !== null && x ? (f.child = Ad(f, c.child, null, T),
        f.child = Ad(f, null, y, T)) : as(c, f, y, T),
        f.memoizedState = F.state,
        c = f.child) : c = vl(c, f, T),
        c
    }
    function sD(c, f, y, x) {
        return bd(),
        f.flags |= 256,
        as(c, f, y, x),
        f.child
    }
    var gE = {
        dehydrated: null,
        treeContext: null,
        retryLane: 0,
        hydrationErrors: null
    };
    function yE(c) {
        return {
            baseLanes: c,
            cachePool: W6()
        }
    }
    function bE(c, f, y) {
        return c = c !== null ? c.childLanes & ~y : 0,
        f && (c |= ji),
        c
    }
    function iD(c, f, y) {
        var x = f.pendingProps, T = !1, F = (f.flags & 128) !== 0, Z;
        if ((Z = F) || (Z = c !== null && c.memoizedState === null ? !1 : (br.current & 2) !== 0),
        Z && (T = !0,
        f.flags &= -129),
        Z = (f.flags & 32) !== 0,
        f.flags &= -33,
        c === null) {
            if (en) {
                if (T ? Kc(f) : Xc(),
                (c = $n) ? (c = hT(c, uo),
                c = c !== null && c.data !== "&" ? c : null,
                c !== null && (f.memoizedState = {
                    dehydrated: c,
                    treeContext: $c !== null ? {
                        id: Ea,
                        overflow: Sa
                    } : null,
                    retryLane: 536870912,
                    hydrationErrors: null
                },
                y = L6(c),
                y.return = f,
                f.child = y,
                is = f,
                $n = null)) : c = null,
                c === null)
                    throw Vc(f);
                return eS(c) ? f.lanes = 32 : f.lanes = 536870912,
                null
            }
            var te = x.children;
            return x = x.fallback,
            T ? (Xc(),
            T = f.mode,
            te = $b({
                mode: "hidden",
                children: te
            }, T),
            x = yd(x, T, y, null),
            te.return = f,
            x.return = f,
            te.sibling = x,
            f.child = te,
            x = f.child,
            x.memoizedState = yE(y),
            x.childLanes = bE(c, Z, y),
            f.memoizedState = gE,
            um(null, x)) : (Kc(f),
            wE(f, te))
        }
        var le = c.memoizedState;
        if (le !== null && (te = le.dehydrated,
        te !== null)) {
            if (F)
                f.flags & 256 ? (Kc(f),
                f.flags &= -257,
                f = vE(c, f, y)) : f.memoizedState !== null ? (Xc(),
                f.child = c.child,
                f.flags |= 128,
                f = null) : (Xc(),
                te = x.fallback,
                T = f.mode,
                x = $b({
                    mode: "visible",
                    children: x.children
                }, T),
                te = yd(te, T, y, null),
                te.flags |= 2,
                x.return = f,
                te.return = f,
                x.sibling = te,
                f.child = x,
                Ad(f, c.child, null, y),
                x = f.child,
                x.memoizedState = yE(y),
                x.childLanes = bE(c, Z, y),
                f.memoizedState = gE,
                f = um(null, x));
            else if (Kc(f),
            eS(te)) {
                if (Z = te.nextSibling && te.nextSibling.dataset,
                Z)
                    var ve = Z.dgst;
                Z = ve,
                x = Error(r(419)),
                x.stack = "",
                x.digest = Z,
                Z0({
                    value: x,
                    source: null,
                    stack: null
                }),
                f = vE(c, f, y)
            } else if (Tr || vh(c, f, y, !1),
            Z = (y & c.childLanes) !== 0,
            Tr || Z) {
                if (Z = On,
                Z !== null && (x = pt(Z, y),
                x !== 0 && x !== le.retryLane))
                    throw le.retryLane = x,
                    gd(c, x),
                    fi(Z, c, x),
                    pE;
                JE(te) || Qb(),
                f = vE(c, f, y)
            } else
                JE(te) ? (f.flags |= 192,
                f.child = c.child,
                f = null) : (c = le.treeContext,
                $n = ho(te.nextSibling),
                is = f,
                en = !0,
                Hc = null,
                uo = !1,
                c !== null && z6(f, c),
                f = wE(f, x.children),
                f.flags |= 4096);
            return f
        }
        return T ? (Xc(),
        te = x.fallback,
        T = f.mode,
        le = c.child,
        ve = le.sibling,
        x = pl(le, {
            mode: "hidden",
            children: x.children
        }),
        x.subtreeFlags = le.subtreeFlags & 65011712,
        ve !== null ? te = pl(ve, te) : (te = yd(te, T, y, null),
        te.flags |= 2),
        te.return = f,
        x.return = f,
        x.sibling = te,
        f.child = x,
        um(null, x),
        x = f.child,
        te = c.child.memoizedState,
        te === null ? te = yE(y) : (T = te.cachePool,
        T !== null ? (le = Nr._currentValue,
        T = T.parent !== le ? {
            parent: le,
            pool: le
        } : T) : T = W6(),
        te = {
            baseLanes: te.baseLanes | y,
            cachePool: T
        }),
        x.memoizedState = te,
        x.childLanes = bE(c, Z, y),
        f.memoizedState = gE,
        um(c.child, x)) : (Kc(f),
        y = c.child,
        c = y.sibling,
        y = pl(y, {
            mode: "visible",
            children: x.children
        }),
        y.return = f,
        y.sibling = null,
        c !== null && (Z = f.deletions,
        Z === null ? (f.deletions = [c],
        f.flags |= 16) : Z.push(c)),
        f.child = y,
        f.memoizedState = null,
        y)
    }
    function wE(c, f) {
        return f = $b({
            mode: "visible",
            children: f
        }, c.mode),
        f.return = c,
        c.child = f
    }
    function $b(c, f) {
        return c = Bi(22, c, null, f),
        c.lanes = 0,
        c
    }
    function vE(c, f, y) {
        return Ad(f, c.child, null, y),
        c = wE(f, f.pendingProps.children),
        c.flags |= 2,
        f.memoizedState = null,
        c
    }
    function oD(c, f, y) {
        c.lanes |= f;
        var x = c.alternate;
        x !== null && (x.lanes |= f),
        O3(c.return, f, y)
    }
    function xE(c, f, y, x, T, F) {
        var Z = c.memoizedState;
        Z === null ? c.memoizedState = {
            isBackwards: f,
            rendering: null,
            renderingStartTime: 0,
            last: x,
            tail: y,
            tailMode: T,
            treeForkCount: F
        } : (Z.isBackwards = f,
        Z.rendering = null,
        Z.renderingStartTime = 0,
        Z.last = x,
        Z.tail = y,
        Z.tailMode = T,
        Z.treeForkCount = F)
    }
    function aD(c, f, y) {
        var x = f.pendingProps
          , T = x.revealOrder
          , F = x.tail;
        x = x.children;
        var Z = br.current
          , te = (Z & 2) !== 0;
        if (te ? (Z = Z & 1 | 2,
        f.flags |= 128) : Z &= 1,
        U(br, Z),
        as(c, f, x, y),
        x = en ? Q0 : 0,
        !te && c !== null && (c.flags & 128) !== 0)
            e: for (c = f.child; c !== null; ) {
                if (c.tag === 13)
                    c.memoizedState !== null && oD(c, y, f);
                else if (c.tag === 19)
                    oD(c, y, f);
                else if (c.child !== null) {
                    c.child.return = c,
                    c = c.child;
                    continue
                }
                if (c === f)
                    break e;
                for (; c.sibling === null; ) {
                    if (c.return === null || c.return === f)
                        break e;
                    c = c.return
                }
                c.sibling.return = c.return,
                c = c.sibling
            }
        switch (T) {
        case "forwards":
            for (y = f.child,
            T = null; y !== null; )
                c = y.alternate,
                c !== null && Tb(c) === null && (T = y),
                y = y.sibling;
            y = T,
            y === null ? (T = f.child,
            f.child = null) : (T = y.sibling,
            y.sibling = null),
            xE(f, !1, T, y, F, x);
            break;
        case "backwards":
        case "unstable_legacy-backwards":
            for (y = null,
            T = f.child,
            f.child = null; T !== null; ) {
                if (c = T.alternate,
                c !== null && Tb(c) === null) {
                    f.child = T;
                    break
                }
                c = T.sibling,
                T.sibling = y,
                y = T,
                T = c
            }
            xE(f, !0, y, null, F, x);
            break;
        case "together":
            xE(f, !1, null, null, void 0, x);
            break;
        default:
            f.memoizedState = null
        }
        return f.child
    }
    function vl(c, f, y) {
        if (c !== null && (f.dependencies = c.dependencies),
        Jc |= f.lanes,
        (y & f.childLanes) === 0)
            if (c !== null) {
                if (vh(c, f, y, !1),
                (y & f.childLanes) === 0)
                    return null
            } else
                return null;
        if (c !== null && f.child !== c.child)
            throw Error(r(153));
        if (f.child !== null) {
            for (c = f.child,
            y = pl(c, c.pendingProps),
            f.child = y,
            y.return = f; c.sibling !== null; )
                c = c.sibling,
                y = y.sibling = pl(c, c.pendingProps),
                y.return = f;
            y.sibling = null
        }
        return f.child
    }
    function EE(c, f) {
        return (c.lanes & f) !== 0 ? !0 : (c = c.dependencies,
        !!(c !== null && Eb(c)))
    }
    function aK(c, f, y) {
        switch (f.tag) {
        case 3:
            ie(f, f.stateNode.containerInfo),
            qc(f, Nr, c.memoizedState.cache),
            bd();
            break;
        case 27:
        case 5:
            xe(f);
            break;
        case 4:
            ie(f, f.stateNode.containerInfo);
            break;
        case 10:
            qc(f, f.type, f.memoizedProps.value);
            break;
        case 31:
            if (f.memoizedState !== null)
                return f.flags |= 128,
                W3(f),
                null;
            break;
        case 13:
            var x = f.memoizedState;
            if (x !== null)
                return x.dehydrated !== null ? (Kc(f),
                f.flags |= 128,
                null) : (y & f.child.childLanes) !== 0 ? iD(c, f, y) : (Kc(f),
                c = vl(c, f, y),
                c !== null ? c.sibling : null);
            Kc(f);
            break;
        case 19:
            var T = (c.flags & 128) !== 0;
            if (x = (y & f.childLanes) !== 0,
            x || (vh(c, f, y, !1),
            x = (y & f.childLanes) !== 0),
            T) {
                if (x)
                    return aD(c, f, y);
                f.flags |= 128
            }
            if (T = f.memoizedState,
            T !== null && (T.rendering = null,
            T.tail = null,
            T.lastEffect = null),
            U(br, br.current),
            x)
                break;
            return null;
        case 22:
            return f.lanes = 0,
            JN(c, f, y, f.pendingProps);
        case 24:
            qc(f, Nr, c.memoizedState.cache)
        }
        return vl(c, f, y)
    }
    function lD(c, f, y) {
        if (c !== null)
            if (c.memoizedProps !== f.pendingProps)
                Tr = !0;
            else {
                if (!EE(c, y) && (f.flags & 128) === 0)
                    return Tr = !1,
                    aK(c, f, y);
                Tr = (c.flags & 131072) !== 0
            }
        else
            Tr = !1,
            en && (f.flags & 1048576) !== 0 && U6(f, Q0, f.index);
        switch (f.lanes = 0,
        f.tag) {
        case 16:
            e: {
                var x = f.pendingProps;
                if (c = Ed(f.elementType),
                f.type = c,
                typeof c == "function")
                    k3(c) ? (x = _d(c, x),
                    f.tag = 1,
                    f = rD(null, f, c, x, y)) : (f.tag = 0,
                    f = mE(null, f, c, x, y));
                else {
                    if (c != null) {
                        var T = c.$$typeof;
                        if (T === I) {
                            f.tag = 11,
                            f = XN(null, f, c, x, y);
                            break e
                        } else if (T === P) {
                            f.tag = 14,
                            f = QN(null, f, c, x, y);
                            break e
                        }
                    }
                    throw f = A(c) || c,
                    Error(r(306, f, ""))
                }
            }
            return f;
        case 0:
            return mE(c, f, f.type, f.pendingProps, y);
        case 1:
            return x = f.type,
            T = _d(x, f.pendingProps),
            rD(c, f, x, T, y);
        case 3:
            e: {
                if (ie(f, f.stateNode.containerInfo),
                c === null)
                    throw Error(r(387));
                x = f.pendingProps;
                var F = f.memoizedState;
                T = F.element,
                $3(c, f),
                im(f, x, null, y);
                var Z = f.memoizedState;
                if (x = Z.cache,
                qc(f, Nr, x),
                x !== F.cache && P3(f, [Nr], y, !0),
                sm(),
                x = Z.element,
                F.isDehydrated)
                    if (F = {
                        element: x,
                        isDehydrated: !1,
                        cache: Z.cache
                    },
                    f.updateQueue.baseState = F,
                    f.memoizedState = F,
                    f.flags & 256) {
                        f = sD(c, f, x, y);
                        break e
                    } else if (x !== T) {
                        T = ao(Error(r(424)), f),
                        Z0(T),
                        f = sD(c, f, x, y);
                        break e
                    } else {
                        switch (c = f.stateNode.containerInfo,
                        c.nodeType) {
                        case 9:
                            c = c.body;
                            break;
                        default:
                            c = c.nodeName === "HTML" ? c.ownerDocument.body : c
                        }
                        for ($n = ho(c.firstChild),
                        is = f,
                        en = !0,
                        Hc = null,
                        uo = !0,
                        y = J6(f, null, x, y),
                        f.child = y; y; )
                            y.flags = y.flags & -3 | 4096,
                            y = y.sibling
                    }
                else {
                    if (bd(),
                    x === T) {
                        f = vl(c, f, y);
                        break e
                    }
                    as(c, f, x, y)
                }
                f = f.child
            }
            return f;
        case 26:
            return zb(c, f),
            c === null ? (y = wT(f.type, null, f.pendingProps, null)) ? f.memoizedState = y : en || (y = f.type,
            c = f.pendingProps,
            x = s1(J.current).createElement(y),
            x[Dt] = f,
            x[Ht] = c,
            ls(x, y, c),
            lr(x),
            f.stateNode = x) : f.memoizedState = wT(f.type, c.memoizedProps, f.pendingProps, c.memoizedState),
            null;
        case 27:
            return xe(f),
            c === null && en && (x = f.stateNode = gT(f.type, f.pendingProps, J.current),
            is = f,
            uo = !0,
            T = $n,
            su(f.type) ? (tS = T,
            $n = ho(x.firstChild)) : $n = T),
            as(c, f, f.pendingProps.children, y),
            zb(c, f),
            c === null && (f.flags |= 4194304),
            f.child;
        case 5:
            return c === null && en && ((T = x = $n) && (x = jK(x, f.type, f.pendingProps, uo),
            x !== null ? (f.stateNode = x,
            is = f,
            $n = ho(x.firstChild),
            uo = !1,
            T = !0) : T = !1),
            T || Vc(f)),
            xe(f),
            T = f.type,
            F = f.pendingProps,
            Z = c !== null ? c.memoizedProps : null,
            x = F.children,
            XE(T, F) ? x = null : Z !== null && XE(T, Z) && (f.flags |= 32),
            f.memoizedState !== null && (T = K3(c, f, ZY, null, null, y),
            Cm._currentValue = T),
            zb(c, f),
            as(c, f, x, y),
            f.child;
        case 6:
            return c === null && en && ((c = y = $n) && (y = LK(y, f.pendingProps, uo),
            y !== null ? (f.stateNode = y,
            is = f,
            $n = null,
            c = !0) : c = !1),
            c || Vc(f)),
            null;
        case 13:
            return iD(c, f, y);
        case 4:
            return ie(f, f.stateNode.containerInfo),
            x = f.pendingProps,
            c === null ? f.child = Ad(f, null, x, y) : as(c, f, x, y),
            f.child;
        case 11:
            return XN(c, f, f.type, f.pendingProps, y);
        case 7:
            return as(c, f, f.pendingProps, y),
            f.child;
        case 8:
            return as(c, f, f.pendingProps.children, y),
            f.child;
        case 12:
            return as(c, f, f.pendingProps.children, y),
            f.child;
        case 10:
            return x = f.pendingProps,
            qc(f, f.type, x.value),
            as(c, f, x.children, y),
            f.child;
        case 9:
            return T = f.type._context,
            x = f.pendingProps.children,
            vd(f),
            T = os(T),
            x = x(T),
            f.flags |= 1,
            as(c, f, x, y),
            f.child;
        case 14:
            return QN(c, f, f.type, f.pendingProps, y);
        case 15:
            return ZN(c, f, f.type, f.pendingProps, y);
        case 19:
            return aD(c, f, y);
        case 31:
            return oK(c, f, y);
        case 22:
            return JN(c, f, y, f.pendingProps);
        case 24:
            return vd(f),
            x = os(Nr),
            c === null ? (T = F3(),
            T === null && (T = On,
            F = j3(),
            T.pooledCache = F,
            F.refCount++,
            F !== null && (T.pooledCacheLanes |= y),
            T = F),
            f.memoizedState = {
                parent: x,
                cache: T
            },
            z3(f),
            qc(f, Nr, T)) : ((c.lanes & y) !== 0 && ($3(c, f),
            im(f, null, null, y),
            sm()),
            T = c.memoizedState,
            F = f.memoizedState,
            T.parent !== x ? (T = {
                parent: x,
                cache: x
            },
            f.memoizedState = T,
            f.lanes === 0 && (f.memoizedState = f.updateQueue.baseState = T),
            qc(f, Nr, x)) : (x = F.cache,
            qc(f, Nr, x),
            x !== T.cache && P3(f, [Nr], y, !0))),
            as(c, f, f.pendingProps.children, y),
            f.child;
        case 29:
            throw f.pendingProps
        }
        throw Error(r(156, f.tag))
    }
    function xl(c) {
        c.flags |= 4
    }
    function SE(c, f, y, x, T) {
        if ((f = (c.mode & 32) !== 0) && (f = !1),
        f) {
            if (c.flags |= 16777216,
            (T & 335544128) === T)
                if (c.stateNode.complete)
                    c.flags |= 8192;
                else if (OD())
                    c.flags |= 8192;
                else
                    throw Sd = _b,
                    U3
        } else
            c.flags &= -16777217
    }
    function cD(c, f) {
        if (f.type !== "stylesheet" || (f.state.loading & 4) !== 0)
            c.flags &= -16777217;
        else if (c.flags |= 16777216,
        !AT(f))
            if (OD())
                c.flags |= 8192;
            else
                throw Sd = _b,
                U3
    }
    function Hb(c, f) {
        f !== null && (c.flags |= 4),
        c.flags & 16384 && (f = c.tag !== 22 ? De() : 536870912,
        c.lanes |= f,
        Mh |= f)
    }
    function dm(c, f) {
        if (!en)
            switch (c.tailMode) {
            case "hidden":
                f = c.tail;
                for (var y = null; f !== null; )
                    f.alternate !== null && (y = f),
                    f = f.sibling;
                y === null ? c.tail = null : y.sibling = null;
                break;
            case "collapsed":
                y = c.tail;
                for (var x = null; y !== null; )
                    y.alternate !== null && (x = y),
                    y = y.sibling;
                x === null ? f || c.tail === null ? c.tail = null : c.tail.sibling = null : x.sibling = null
            }
    }
    function Hn(c) {
        var f = c.alternate !== null && c.alternate.child === c.child
          , y = 0
          , x = 0;
        if (f)
            for (var T = c.child; T !== null; )
                y |= T.lanes | T.childLanes,
                x |= T.subtreeFlags & 65011712,
                x |= T.flags & 65011712,
                T.return = c,
                T = T.sibling;
        else
            for (T = c.child; T !== null; )
                y |= T.lanes | T.childLanes,
                x |= T.subtreeFlags,
                x |= T.flags,
                T.return = c,
                T = T.sibling;
        return c.subtreeFlags |= x,
        c.childLanes = y,
        f
    }
    function lK(c, f, y) {
        var x = f.pendingProps;
        switch (I3(f),
        f.tag) {
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
            return Hn(f),
            null;
        case 1:
            return Hn(f),
            null;
        case 3:
            return y = f.stateNode,
            x = null,
            c !== null && (x = c.memoizedState.cache),
            f.memoizedState.cache !== x && (f.flags |= 2048),
            yl(Nr),
            ae(),
            y.pendingContext && (y.context = y.pendingContext,
            y.pendingContext = null),
            (c === null || c.child === null) && (wh(f) ? xl(f) : c === null || c.memoizedState.isDehydrated && (f.flags & 256) === 0 || (f.flags |= 1024,
            B3())),
            Hn(f),
            null;
        case 26:
            var T = f.type
              , F = f.memoizedState;
            return c === null ? (xl(f),
            F !== null ? (Hn(f),
            cD(f, F)) : (Hn(f),
            SE(f, T, null, x, y))) : F ? F !== c.memoizedState ? (xl(f),
            Hn(f),
            cD(f, F)) : (Hn(f),
            f.flags &= -16777217) : (c = c.memoizedProps,
            c !== x && xl(f),
            Hn(f),
            SE(f, T, c, x, y)),
            null;
        case 27:
            if (ue(f),
            y = J.current,
            T = f.type,
            c !== null && f.stateNode != null)
                c.memoizedProps !== x && xl(f);
            else {
                if (!x) {
                    if (f.stateNode === null)
                        throw Error(r(166));
                    return Hn(f),
                    null
                }
                c = W.current,
                wh(f) ? $6(f) : (c = gT(T, x, y),
                f.stateNode = c,
                xl(f))
            }
            return Hn(f),
            null;
        case 5:
            if (ue(f),
            T = f.type,
            c !== null && f.stateNode != null)
                c.memoizedProps !== x && xl(f);
            else {
                if (!x) {
                    if (f.stateNode === null)
                        throw Error(r(166));
                    return Hn(f),
                    null
                }
                if (F = W.current,
                wh(f))
                    $6(f);
                else {
                    var Z = s1(J.current);
                    switch (F) {
                    case 1:
                        F = Z.createElementNS("http://www.w3.org/2000/svg", T);
                        break;
                    case 2:
                        F = Z.createElementNS("http://www.w3.org/1998/Math/MathML", T);
                        break;
                    default:
                        switch (T) {
                        case "svg":
                            F = Z.createElementNS("http://www.w3.org/2000/svg", T);
                            break;
                        case "math":
                            F = Z.createElementNS("http://www.w3.org/1998/Math/MathML", T);
                            break;
                        case "script":
                            F = Z.createElement("div"),
                            F.innerHTML = "<script><\/script>",
                            F = F.removeChild(F.firstChild);
                            break;
                        case "select":
                            F = typeof x.is == "string" ? Z.createElement("select", {
                                is: x.is
                            }) : Z.createElement("select"),
                            x.multiple ? F.multiple = !0 : x.size && (F.size = x.size);
                            break;
                        default:
                            F = typeof x.is == "string" ? Z.createElement(T, {
                                is: x.is
                            }) : Z.createElement(T)
                        }
                    }
                    F[Dt] = f,
                    F[Ht] = x;
                    e: for (Z = f.child; Z !== null; ) {
                        if (Z.tag === 5 || Z.tag === 6)
                            F.appendChild(Z.stateNode);
                        else if (Z.tag !== 4 && Z.tag !== 27 && Z.child !== null) {
                            Z.child.return = Z,
                            Z = Z.child;
                            continue
                        }
                        if (Z === f)
                            break e;
                        for (; Z.sibling === null; ) {
                            if (Z.return === null || Z.return === f)
                                break e;
                            Z = Z.return
                        }
                        Z.sibling.return = Z.return,
                        Z = Z.sibling
                    }
                    f.stateNode = F;
                    e: switch (ls(F, T, x),
                    T) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                        x = !!x.autoFocus;
                        break e;
                    case "img":
                        x = !0;
                        break e;
                    default:
                        x = !1
                    }
                    x && xl(f)
                }
            }
            return Hn(f),
            SE(f, f.type, c === null ? null : c.memoizedProps, f.pendingProps, y),
            null;
        case 6:
            if (c && f.stateNode != null)
                c.memoizedProps !== x && xl(f);
            else {
                if (typeof x != "string" && f.stateNode === null)
                    throw Error(r(166));
                if (c = J.current,
                wh(f)) {
                    if (c = f.stateNode,
                    y = f.memoizedProps,
                    x = null,
                    T = is,
                    T !== null)
                        switch (T.tag) {
                        case 27:
                        case 5:
                            x = T.memoizedProps
                        }
                    c[Dt] = f,
                    c = !!(c.nodeValue === y || x !== null && x.suppressHydrationWarning === !0 || iT(c.nodeValue, y)),
                    c || Vc(f, !0)
                } else
                    c = s1(c).createTextNode(x),
                    c[Dt] = f,
                    f.stateNode = c
            }
            return Hn(f),
            null;
        case 31:
            if (y = f.memoizedState,
            c === null || c.memoizedState !== null) {
                if (x = wh(f),
                y !== null) {
                    if (c === null) {
                        if (!x)
                            throw Error(r(318));
                        if (c = f.memoizedState,
                        c = c !== null ? c.dehydrated : null,
                        !c)
                            throw Error(r(557));
                        c[Dt] = f
                    } else
                        bd(),
                        (f.flags & 128) === 0 && (f.memoizedState = null),
                        f.flags |= 4;
                    Hn(f),
                    c = !1
                } else
                    y = B3(),
                    c !== null && c.memoizedState !== null && (c.memoizedState.hydrationErrors = y),
                    c = !0;
                if (!c)
                    return f.flags & 256 ? (Oi(f),
                    f) : (Oi(f),
                    null);
                if ((f.flags & 128) !== 0)
                    throw Error(r(558))
            }
            return Hn(f),
            null;
        case 13:
            if (x = f.memoizedState,
            c === null || c.memoizedState !== null && c.memoizedState.dehydrated !== null) {
                if (T = wh(f),
                x !== null && x.dehydrated !== null) {
                    if (c === null) {
                        if (!T)
                            throw Error(r(318));
                        if (T = f.memoizedState,
                        T = T !== null ? T.dehydrated : null,
                        !T)
                            throw Error(r(317));
                        T[Dt] = f
                    } else
                        bd(),
                        (f.flags & 128) === 0 && (f.memoizedState = null),
                        f.flags |= 4;
                    Hn(f),
                    T = !1
                } else
                    T = B3(),
                    c !== null && c.memoizedState !== null && (c.memoizedState.hydrationErrors = T),
                    T = !0;
                if (!T)
                    return f.flags & 256 ? (Oi(f),
                    f) : (Oi(f),
                    null)
            }
            return Oi(f),
            (f.flags & 128) !== 0 ? (f.lanes = y,
            f) : (y = x !== null,
            c = c !== null && c.memoizedState !== null,
            y && (x = f.child,
            T = null,
            x.alternate !== null && x.alternate.memoizedState !== null && x.alternate.memoizedState.cachePool !== null && (T = x.alternate.memoizedState.cachePool.pool),
            F = null,
            x.memoizedState !== null && x.memoizedState.cachePool !== null && (F = x.memoizedState.cachePool.pool),
            F !== T && (x.flags |= 2048)),
            y !== c && y && (f.child.flags |= 8192),
            Hb(f, f.updateQueue),
            Hn(f),
            null);
        case 4:
            return ae(),
            c === null && qE(f.stateNode.containerInfo),
            Hn(f),
            null;
        case 10:
            return yl(f.type),
            Hn(f),
            null;
        case 19:
            if (D(br),
            x = f.memoizedState,
            x === null)
                return Hn(f),
                null;
            if (T = (f.flags & 128) !== 0,
            F = x.rendering,
            F === null)
                if (T)
                    dm(x, !1);
                else {
                    if (ur !== 0 || c !== null && (c.flags & 128) !== 0)
                        for (c = f.child; c !== null; ) {
                            if (F = Tb(c),
                            F !== null) {
                                for (f.flags |= 128,
                                dm(x, !1),
                                c = F.updateQueue,
                                f.updateQueue = c,
                                Hb(f, c),
                                f.subtreeFlags = 0,
                                c = y,
                                y = f.child; y !== null; )
                                    j6(y, c),
                                    y = y.sibling;
                                return U(br, br.current & 1 | 2),
                                en && ml(f, x.treeForkCount),
                                f.child
                            }
                            c = c.sibling
                        }
                    x.tail !== null && ut() > Yb && (f.flags |= 128,
                    T = !0,
                    dm(x, !1),
                    f.lanes = 4194304)
                }
            else {
                if (!T)
                    if (c = Tb(F),
                    c !== null) {
                        if (f.flags |= 128,
                        T = !0,
                        c = c.updateQueue,
                        f.updateQueue = c,
                        Hb(f, c),
                        dm(x, !0),
                        x.tail === null && x.tailMode === "hidden" && !F.alternate && !en)
                            return Hn(f),
                            null
                    } else
                        2 * ut() - x.renderingStartTime > Yb && y !== 536870912 && (f.flags |= 128,
                        T = !0,
                        dm(x, !1),
                        f.lanes = 4194304);
                x.isBackwards ? (F.sibling = f.child,
                f.child = F) : (c = x.last,
                c !== null ? c.sibling = F : f.child = F,
                x.last = F)
            }
            return x.tail !== null ? (c = x.tail,
            x.rendering = c,
            x.tail = c.sibling,
            x.renderingStartTime = ut(),
            c.sibling = null,
            y = br.current,
            U(br, T ? y & 1 | 2 : y & 1),
            en && ml(f, x.treeForkCount),
            c) : (Hn(f),
            null);
        case 22:
        case 23:
            return Oi(f),
            G3(),
            x = f.memoizedState !== null,
            c !== null ? c.memoizedState !== null !== x && (f.flags |= 8192) : x && (f.flags |= 8192),
            x ? (y & 536870912) !== 0 && (f.flags & 128) === 0 && (Hn(f),
            f.subtreeFlags & 6 && (f.flags |= 8192)) : Hn(f),
            y = f.updateQueue,
            y !== null && Hb(f, y.retryQueue),
            y = null,
            c !== null && c.memoizedState !== null && c.memoizedState.cachePool !== null && (y = c.memoizedState.cachePool.pool),
            x = null,
            f.memoizedState !== null && f.memoizedState.cachePool !== null && (x = f.memoizedState.cachePool.pool),
            x !== y && (f.flags |= 2048),
            c !== null && D(xd),
            null;
        case 24:
            return y = null,
            c !== null && (y = c.memoizedState.cache),
            f.memoizedState.cache !== y && (f.flags |= 2048),
            yl(Nr),
            Hn(f),
            null;
        case 25:
            return null;
        case 30:
            return null
        }
        throw Error(r(156, f.tag))
    }
    function cK(c, f) {
        switch (I3(f),
        f.tag) {
        case 1:
            return c = f.flags,
            c & 65536 ? (f.flags = c & -65537 | 128,
            f) : null;
        case 3:
            return yl(Nr),
            ae(),
            c = f.flags,
            (c & 65536) !== 0 && (c & 128) === 0 ? (f.flags = c & -65537 | 128,
            f) : null;
        case 26:
        case 27:
        case 5:
            return ue(f),
            null;
        case 31:
            if (f.memoizedState !== null) {
                if (Oi(f),
                f.alternate === null)
                    throw Error(r(340));
                bd()
            }
            return c = f.flags,
            c & 65536 ? (f.flags = c & -65537 | 128,
            f) : null;
        case 13:
            if (Oi(f),
            c = f.memoizedState,
            c !== null && c.dehydrated !== null) {
                if (f.alternate === null)
                    throw Error(r(340));
                bd()
            }
            return c = f.flags,
            c & 65536 ? (f.flags = c & -65537 | 128,
            f) : null;
        case 19:
            return D(br),
            null;
        case 4:
            return ae(),
            null;
        case 10:
            return yl(f.type),
            null;
        case 22:
        case 23:
            return Oi(f),
            G3(),
            c !== null && D(xd),
            c = f.flags,
            c & 65536 ? (f.flags = c & -65537 | 128,
            f) : null;
        case 24:
            return yl(Nr),
            null;
        case 25:
            return null;
        default:
            return null
        }
    }
    function uD(c, f) {
        switch (I3(f),
        f.tag) {
        case 3:
            yl(Nr),
            ae();
            break;
        case 26:
        case 27:
        case 5:
            ue(f);
            break;
        case 4:
            ae();
            break;
        case 31:
            f.memoizedState !== null && Oi(f);
            break;
        case 13:
            Oi(f);
            break;
        case 19:
            D(br);
            break;
        case 10:
            yl(f.type);
            break;
        case 22:
        case 23:
            Oi(f),
            G3(),
            c !== null && D(xd);
            break;
        case 24:
            yl(Nr)
        }
    }
    function fm(c, f) {
        try {
            var y = f.updateQueue
              , x = y !== null ? y.lastEffect : null;
            if (x !== null) {
                var T = x.next;
                y = T;
                do {
                    if ((y.tag & c) === c) {
                        x = void 0;
                        var F = y.create
                          , Z = y.inst;
                        x = F(),
                        Z.destroy = x
                    }
                    y = y.next
                } while (y !== T)
            }
        } catch (te) {
            En(f, f.return, te)
        }
    }
    function Qc(c, f, y) {
        try {
            var x = f.updateQueue
              , T = x !== null ? x.lastEffect : null;
            if (T !== null) {
                var F = T.next;
                x = F;
                do {
                    if ((x.tag & c) === c) {
                        var Z = x.inst
                          , te = Z.destroy;
                        if (te !== void 0) {
                            Z.destroy = void 0,
                            T = f;
                            var le = y
                              , ve = te;
                            try {
                                ve()
                            } catch (ke) {
                                En(T, le, ke)
                            }
                        }
                    }
                    x = x.next
                } while (x !== F)
            }
        } catch (ke) {
            En(f, f.return, ke)
        }
    }
    function dD(c) {
        var f = c.updateQueue;
        if (f !== null) {
            var y = c.stateNode;
            try {
                tN(f, y)
            } catch (x) {
                En(c, c.return, x)
            }
        }
    }
    function fD(c, f, y) {
        y.props = _d(c.type, c.memoizedProps),
        y.state = c.memoizedState;
        try {
            y.componentWillUnmount()
        } catch (x) {
            En(c, f, x)
        }
    }
    function hm(c, f) {
        try {
            var y = c.ref;
            if (y !== null) {
                switch (c.tag) {
                case 26:
                case 27:
                case 5:
                    var x = c.stateNode;
                    break;
                case 30:
                    x = c.stateNode;
                    break;
                default:
                    x = c.stateNode
                }
                typeof y == "function" ? c.refCleanup = y(x) : y.current = x
            }
        } catch (T) {
            En(c, f, T)
        }
    }
    function Aa(c, f) {
        var y = c.ref
          , x = c.refCleanup;
        if (y !== null)
            if (typeof x == "function")
                try {
                    x()
                } catch (T) {
                    En(c, f, T)
                } finally {
                    c.refCleanup = null,
                    c = c.alternate,
                    c != null && (c.refCleanup = null)
                }
            else if (typeof y == "function")
                try {
                    y(null)
                } catch (T) {
                    En(c, f, T)
                }
            else
                y.current = null
    }
    function hD(c) {
        var f = c.type
          , y = c.memoizedProps
          , x = c.stateNode;
        try {
            e: switch (f) {
            case "button":
            case "input":
            case "select":
            case "textarea":
                y.autoFocus && x.focus();
                break e;
            case "img":
                y.src ? x.src = y.src : y.srcSet && (x.srcset = y.srcSet)
            }
        } catch (T) {
            En(c, c.return, T)
        }
    }
    function AE(c, f, y) {
        try {
            var x = c.stateNode;
            IK(x, c.type, y, f),
            x[Ht] = f
        } catch (T) {
            En(c, c.return, T)
        }
    }
    function pD(c) {
        return c.tag === 5 || c.tag === 3 || c.tag === 26 || c.tag === 27 && su(c.type) || c.tag === 4
    }
    function CE(c) {
        e: for (; ; ) {
            for (; c.sibling === null; ) {
                if (c.return === null || pD(c.return))
                    return null;
                c = c.return
            }
            for (c.sibling.return = c.return,
            c = c.sibling; c.tag !== 5 && c.tag !== 6 && c.tag !== 18; ) {
                if (c.tag === 27 && su(c.type) || c.flags & 2 || c.child === null || c.tag === 4)
                    continue e;
                c.child.return = c,
                c = c.child
            }
            if (!(c.flags & 2))
                return c.stateNode
        }
    }
    function _E(c, f, y) {
        var x = c.tag;
        if (x === 5 || x === 6)
            c = c.stateNode,
            f ? (y.nodeType === 9 ? y.body : y.nodeName === "HTML" ? y.ownerDocument.body : y).insertBefore(c, f) : (f = y.nodeType === 9 ? y.body : y.nodeName === "HTML" ? y.ownerDocument.body : y,
            f.appendChild(c),
            y = y._reactRootContainer,
            y != null || f.onclick !== null || (f.onclick = fl));
        else if (x !== 4 && (x === 27 && su(c.type) && (y = c.stateNode,
        f = null),
        c = c.child,
        c !== null))
            for (_E(c, f, y),
            c = c.sibling; c !== null; )
                _E(c, f, y),
                c = c.sibling
    }
    function Vb(c, f, y) {
        var x = c.tag;
        if (x === 5 || x === 6)
            c = c.stateNode,
            f ? y.insertBefore(c, f) : y.appendChild(c);
        else if (x !== 4 && (x === 27 && su(c.type) && (y = c.stateNode),
        c = c.child,
        c !== null))
            for (Vb(c, f, y),
            c = c.sibling; c !== null; )
                Vb(c, f, y),
                c = c.sibling
    }
    function mD(c) {
        var f = c.stateNode
          , y = c.memoizedProps;
        try {
            for (var x = c.type, T = f.attributes; T.length; )
                f.removeAttributeNode(T[0]);
            ls(f, x, y),
            f[Dt] = c,
            f[Ht] = y
        } catch (F) {
            En(c, c.return, F)
        }
    }
    var El = !1
      , Ir = !1
      , kE = !1
      , gD = typeof WeakSet == "function" ? WeakSet : Set
      , Yr = null;
    function uK(c, f) {
        if (c = c.containerInfo,
        YE = d1,
        c = N6(c),
        v3(c)) {
            if ("selectionStart"in c)
                var y = {
                    start: c.selectionStart,
                    end: c.selectionEnd
                };
            else
                e: {
                    y = (y = c.ownerDocument) && y.defaultView || window;
                    var x = y.getSelection && y.getSelection();
                    if (x && x.rangeCount !== 0) {
                        y = x.anchorNode;
                        var T = x.anchorOffset
                          , F = x.focusNode;
                        x = x.focusOffset;
                        try {
                            y.nodeType,
                            F.nodeType
                        } catch {
                            y = null;
                            break e
                        }
                        var Z = 0
                          , te = -1
                          , le = -1
                          , ve = 0
                          , ke = 0
                          , Te = c
                          , Se = null;
                        t: for (; ; ) {
                            for (var Ce; Te !== y || T !== 0 && Te.nodeType !== 3 || (te = Z + T),
                            Te !== F || x !== 0 && Te.nodeType !== 3 || (le = Z + x),
                            Te.nodeType === 3 && (Z += Te.nodeValue.length),
                            (Ce = Te.firstChild) !== null; )
                                Se = Te,
                                Te = Ce;
                            for (; ; ) {
                                if (Te === c)
                                    break t;
                                if (Se === y && ++ve === T && (te = Z),
                                Se === F && ++ke === x && (le = Z),
                                (Ce = Te.nextSibling) !== null)
                                    break;
                                Te = Se,
                                Se = Te.parentNode
                            }
                            Te = Ce
                        }
                        y = te === -1 || le === -1 ? null : {
                            start: te,
                            end: le
                        }
                    } else
                        y = null
                }
            y = y || {
                start: 0,
                end: 0
            }
        } else
            y = null;
        for (KE = {
            focusedElem: c,
            selectionRange: y
        },
        d1 = !1,
        Yr = f; Yr !== null; )
            if (f = Yr,
            c = f.child,
            (f.subtreeFlags & 1028) !== 0 && c !== null)
                c.return = f,
                Yr = c;
            else
                for (; Yr !== null; ) {
                    switch (f = Yr,
                    F = f.alternate,
                    c = f.flags,
                    f.tag) {
                    case 0:
                        if ((c & 4) !== 0 && (c = f.updateQueue,
                        c = c !== null ? c.events : null,
                        c !== null))
                            for (y = 0; y < c.length; y++)
                                T = c[y],
                                T.ref.impl = T.nextImpl;
                        break;
                    case 11:
                    case 15:
                        break;
                    case 1:
                        if ((c & 1024) !== 0 && F !== null) {
                            c = void 0,
                            y = f,
                            T = F.memoizedProps,
                            F = F.memoizedState,
                            x = y.stateNode;
                            try {
                                var it = _d(y.type, T);
                                c = x.getSnapshotBeforeUpdate(it, F),
                                x.__reactInternalSnapshotBeforeUpdate = c
                            } catch (vt) {
                                En(y, y.return, vt)
                            }
                        }
                        break;
                    case 3:
                        if ((c & 1024) !== 0) {
                            if (c = f.stateNode.containerInfo,
                            y = c.nodeType,
                            y === 9)
                                ZE(c);
                            else if (y === 1)
                                switch (c.nodeName) {
                                case "HEAD":
                                case "HTML":
                                case "BODY":
                                    ZE(c);
                                    break;
                                default:
                                    c.textContent = ""
                                }
                        }
                        break;
                    case 5:
                    case 26:
                    case 27:
                    case 6:
                    case 4:
                    case 17:
                        break;
                    default:
                        if ((c & 1024) !== 0)
                            throw Error(r(163))
                    }
                    if (c = f.sibling,
                    c !== null) {
                        c.return = f.return,
                        Yr = c;
                        break
                    }
                    Yr = f.return
                }
    }
    function yD(c, f, y) {
        var x = y.flags;
        switch (y.tag) {
        case 0:
        case 11:
        case 15:
            Al(c, y),
            x & 4 && fm(5, y);
            break;
        case 1:
            if (Al(c, y),
            x & 4)
                if (c = y.stateNode,
                f === null)
                    try {
                        c.componentDidMount()
                    } catch (Z) {
                        En(y, y.return, Z)
                    }
                else {
                    var T = _d(y.type, f.memoizedProps);
                    f = f.memoizedState;
                    try {
                        c.componentDidUpdate(T, f, c.__reactInternalSnapshotBeforeUpdate)
                    } catch (Z) {
                        En(y, y.return, Z)
                    }
                }
            x & 64 && dD(y),
            x & 512 && hm(y, y.return);
            break;
        case 3:
            if (Al(c, y),
            x & 64 && (c = y.updateQueue,
            c !== null)) {
                if (f = null,
                y.child !== null)
                    switch (y.child.tag) {
                    case 27:
                    case 5:
                        f = y.child.stateNode;
                        break;
                    case 1:
                        f = y.child.stateNode
                    }
                try {
                    tN(c, f)
                } catch (Z) {
                    En(y, y.return, Z)
                }
            }
            break;
        case 27:
            f === null && x & 4 && mD(y);
        case 26:
        case 5:
            Al(c, y),
            f === null && x & 4 && hD(y),
            x & 512 && hm(y, y.return);
            break;
        case 12:
            Al(c, y);
            break;
        case 31:
            Al(c, y),
            x & 4 && vD(c, y);
            break;
        case 13:
            Al(c, y),
            x & 4 && xD(c, y),
            x & 64 && (c = y.memoizedState,
            c !== null && (c = c.dehydrated,
            c !== null && (y = wK.bind(null, y),
            FK(c, y))));
            break;
        case 22:
            if (x = y.memoizedState !== null || El,
            !x) {
                f = f !== null && f.memoizedState !== null || Ir,
                T = El;
                var F = Ir;
                El = x,
                (Ir = f) && !F ? Cl(c, y, (y.subtreeFlags & 8772) !== 0) : Al(c, y),
                El = T,
                Ir = F
            }
            break;
        case 30:
            break;
        default:
            Al(c, y)
        }
    }
    function bD(c) {
        var f = c.alternate;
        f !== null && (c.alternate = null,
        bD(f)),
        c.child = null,
        c.deletions = null,
        c.sibling = null,
        c.tag === 5 && (f = c.stateNode,
        f !== null && fd(f)),
        c.stateNode = null,
        c.return = null,
        c.dependencies = null,
        c.memoizedProps = null,
        c.memoizedState = null,
        c.pendingProps = null,
        c.stateNode = null,
        c.updateQueue = null
    }
    var Qn = null
      , li = !1;
    function Sl(c, f, y) {
        for (y = y.child; y !== null; )
            wD(c, f, y),
            y = y.sibling
    }
    function wD(c, f, y) {
        if (_e && typeof _e.onCommitFiberUnmount == "function")
            try {
                _e.onCommitFiberUnmount(ge, y)
            } catch {}
        switch (y.tag) {
        case 26:
            Ir || Aa(y, f),
            Sl(c, f, y),
            y.memoizedState ? y.memoizedState.count-- : y.stateNode && (y = y.stateNode,
            y.parentNode.removeChild(y));
            break;
        case 27:
            Ir || Aa(y, f);
            var x = Qn
              , T = li;
            su(y.type) && (Qn = y.stateNode,
            li = !1),
            Sl(c, f, y),
            Em(y.stateNode),
            Qn = x,
            li = T;
            break;
        case 5:
            Ir || Aa(y, f);
        case 6:
            if (x = Qn,
            T = li,
            Qn = null,
            Sl(c, f, y),
            Qn = x,
            li = T,
            Qn !== null)
                if (li)
                    try {
                        (Qn.nodeType === 9 ? Qn.body : Qn.nodeName === "HTML" ? Qn.ownerDocument.body : Qn).removeChild(y.stateNode)
                    } catch (F) {
                        En(y, f, F)
                    }
                else
                    try {
                        Qn.removeChild(y.stateNode)
                    } catch (F) {
                        En(y, f, F)
                    }
            break;
        case 18:
            Qn !== null && (li ? (c = Qn,
            dT(c.nodeType === 9 ? c.body : c.nodeName === "HTML" ? c.ownerDocument.body : c, y.stateNode),
            Uh(c)) : dT(Qn, y.stateNode));
            break;
        case 4:
            x = Qn,
            T = li,
            Qn = y.stateNode.containerInfo,
            li = !0,
            Sl(c, f, y),
            Qn = x,
            li = T;
            break;
        case 0:
        case 11:
        case 14:
        case 15:
            Qc(2, y, f),
            Ir || Qc(4, y, f),
            Sl(c, f, y);
            break;
        case 1:
            Ir || (Aa(y, f),
            x = y.stateNode,
            typeof x.componentWillUnmount == "function" && fD(y, f, x)),
            Sl(c, f, y);
            break;
        case 21:
            Sl(c, f, y);
            break;
        case 22:
            Ir = (x = Ir) || y.memoizedState !== null,
            Sl(c, f, y),
            Ir = x;
            break;
        default:
            Sl(c, f, y)
        }
    }
    function vD(c, f) {
        if (f.memoizedState === null && (c = f.alternate,
        c !== null && (c = c.memoizedState,
        c !== null))) {
            c = c.dehydrated;
            try {
                Uh(c)
            } catch (y) {
                En(f, f.return, y)
            }
        }
    }
    function xD(c, f) {
        if (f.memoizedState === null && (c = f.alternate,
        c !== null && (c = c.memoizedState,
        c !== null && (c = c.dehydrated,
        c !== null))))
            try {
                Uh(c)
            } catch (y) {
                En(f, f.return, y)
            }
    }
    function dK(c) {
        switch (c.tag) {
        case 31:
        case 13:
        case 19:
            var f = c.stateNode;
            return f === null && (f = c.stateNode = new gD),
            f;
        case 22:
            return c = c.stateNode,
            f = c._retryCache,
            f === null && (f = c._retryCache = new gD),
            f;
        default:
            throw Error(r(435, c.tag))
        }
    }
    function qb(c, f) {
        var y = dK(c);
        f.forEach(function(x) {
            if (!y.has(x)) {
                y.add(x);
                var T = vK.bind(null, c, x);
                x.then(T, T)
            }
        })
    }
    function ci(c, f) {
        var y = f.deletions;
        if (y !== null)
            for (var x = 0; x < y.length; x++) {
                var T = y[x]
                  , F = c
                  , Z = f
                  , te = Z;
                e: for (; te !== null; ) {
                    switch (te.tag) {
                    case 27:
                        if (su(te.type)) {
                            Qn = te.stateNode,
                            li = !1;
                            break e
                        }
                        break;
                    case 5:
                        Qn = te.stateNode,
                        li = !1;
                        break e;
                    case 3:
                    case 4:
                        Qn = te.stateNode.containerInfo,
                        li = !0;
                        break e
                    }
                    te = te.return
                }
                if (Qn === null)
                    throw Error(r(160));
                wD(F, Z, T),
                Qn = null,
                li = !1,
                F = T.alternate,
                F !== null && (F.return = null),
                T.return = null
            }
        if (f.subtreeFlags & 13886)
            for (f = f.child; f !== null; )
                ED(f, c),
                f = f.sibling
    }
    var Vo = null;
    function ED(c, f) {
        var y = c.alternate
          , x = c.flags;
        switch (c.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
            ci(f, c),
            ui(c),
            x & 4 && (Qc(3, c, c.return),
            fm(3, c),
            Qc(5, c, c.return));
            break;
        case 1:
            ci(f, c),
            ui(c),
            x & 512 && (Ir || y === null || Aa(y, y.return)),
            x & 64 && El && (c = c.updateQueue,
            c !== null && (x = c.callbacks,
            x !== null && (y = c.shared.hiddenCallbacks,
            c.shared.hiddenCallbacks = y === null ? x : y.concat(x))));
            break;
        case 26:
            var T = Vo;
            if (ci(f, c),
            ui(c),
            x & 512 && (Ir || y === null || Aa(y, y.return)),
            x & 4) {
                var F = y !== null ? y.memoizedState : null;
                if (x = c.memoizedState,
                y === null)
                    if (x === null)
                        if (c.stateNode === null) {
                            e: {
                                x = c.type,
                                y = c.memoizedProps,
                                T = T.ownerDocument || T;
                                t: switch (x) {
                                case "title":
                                    F = T.getElementsByTagName("title")[0],
                                    (!F || F[cl] || F[Dt] || F.namespaceURI === "http://www.w3.org/2000/svg" || F.hasAttribute("itemprop")) && (F = T.createElement(x),
                                    T.head.insertBefore(F, T.querySelector("head > title"))),
                                    ls(F, x, y),
                                    F[Dt] = c,
                                    lr(F),
                                    x = F;
                                    break e;
                                case "link":
                                    var Z = ET("link", "href", T).get(x + (y.href || ""));
                                    if (Z) {
                                        for (var te = 0; te < Z.length; te++)
                                            if (F = Z[te],
                                            F.getAttribute("href") === (y.href == null || y.href === "" ? null : y.href) && F.getAttribute("rel") === (y.rel == null ? null : y.rel) && F.getAttribute("title") === (y.title == null ? null : y.title) && F.getAttribute("crossorigin") === (y.crossOrigin == null ? null : y.crossOrigin)) {
                                                Z.splice(te, 1);
                                                break t
                                            }
                                    }
                                    F = T.createElement(x),
                                    ls(F, x, y),
                                    T.head.appendChild(F);
                                    break;
                                case "meta":
                                    if (Z = ET("meta", "content", T).get(x + (y.content || ""))) {
                                        for (te = 0; te < Z.length; te++)
                                            if (F = Z[te],
                                            F.getAttribute("content") === (y.content == null ? null : "" + y.content) && F.getAttribute("name") === (y.name == null ? null : y.name) && F.getAttribute("property") === (y.property == null ? null : y.property) && F.getAttribute("http-equiv") === (y.httpEquiv == null ? null : y.httpEquiv) && F.getAttribute("charset") === (y.charSet == null ? null : y.charSet)) {
                                                Z.splice(te, 1);
                                                break t
                                            }
                                    }
                                    F = T.createElement(x),
                                    ls(F, x, y),
                                    T.head.appendChild(F);
                                    break;
                                default:
                                    throw Error(r(468, x))
                                }
                                F[Dt] = c,
                                lr(F),
                                x = F
                            }
                            c.stateNode = x
                        } else
                            ST(T, c.type, c.stateNode);
                    else
                        c.stateNode = xT(T, x, c.memoizedProps);
                else
                    F !== x ? (F === null ? y.stateNode !== null && (y = y.stateNode,
                    y.parentNode.removeChild(y)) : F.count--,
                    x === null ? ST(T, c.type, c.stateNode) : xT(T, x, c.memoizedProps)) : x === null && c.stateNode !== null && AE(c, c.memoizedProps, y.memoizedProps)
            }
            break;
        case 27:
            ci(f, c),
            ui(c),
            x & 512 && (Ir || y === null || Aa(y, y.return)),
            y !== null && x & 4 && AE(c, c.memoizedProps, y.memoizedProps);
            break;
        case 5:
            if (ci(f, c),
            ui(c),
            x & 512 && (Ir || y === null || Aa(y, y.return)),
            c.flags & 32) {
                T = c.stateNode;
                try {
                    ch(T, "")
                } catch (it) {
                    En(c, c.return, it)
                }
            }
            x & 4 && c.stateNode != null && (T = c.memoizedProps,
            AE(c, T, y !== null ? y.memoizedProps : T)),
            x & 1024 && (kE = !0);
            break;
        case 6:
            if (ci(f, c),
            ui(c),
            x & 4) {
                if (c.stateNode === null)
                    throw Error(r(162));
                x = c.memoizedProps,
                y = c.stateNode;
                try {
                    y.nodeValue = x
                } catch (it) {
                    En(c, c.return, it)
                }
            }
            break;
        case 3:
            if (a1 = null,
            T = Vo,
            Vo = i1(f.containerInfo),
            ci(f, c),
            Vo = T,
            ui(c),
            x & 4 && y !== null && y.memoizedState.isDehydrated)
                try {
                    Uh(f.containerInfo)
                } catch (it) {
                    En(c, c.return, it)
                }
            kE && (kE = !1,
            SD(c));
            break;
        case 4:
            x = Vo,
            Vo = i1(c.stateNode.containerInfo),
            ci(f, c),
            ui(c),
            Vo = x;
            break;
        case 12:
            ci(f, c),
            ui(c);
            break;
        case 31:
            ci(f, c),
            ui(c),
            x & 4 && (x = c.updateQueue,
            x !== null && (c.updateQueue = null,
            qb(c, x)));
            break;
        case 13:
            ci(f, c),
            ui(c),
            c.child.flags & 8192 && c.memoizedState !== null != (y !== null && y.memoizedState !== null) && (Wb = ut()),
            x & 4 && (x = c.updateQueue,
            x !== null && (c.updateQueue = null,
            qb(c, x)));
            break;
        case 22:
            T = c.memoizedState !== null;
            var le = y !== null && y.memoizedState !== null
              , ve = El
              , ke = Ir;
            if (El = ve || T,
            Ir = ke || le,
            ci(f, c),
            Ir = ke,
            El = ve,
            ui(c),
            x & 8192)
                e: for (f = c.stateNode,
                f._visibility = T ? f._visibility & -2 : f._visibility | 1,
                T && (y === null || le || El || Ir || kd(c)),
                y = null,
                f = c; ; ) {
                    if (f.tag === 5 || f.tag === 26) {
                        if (y === null) {
                            le = y = f;
                            try {
                                if (F = le.stateNode,
                                T)
                                    Z = F.style,
                                    typeof Z.setProperty == "function" ? Z.setProperty("display", "none", "important") : Z.display = "none";
                                else {
                                    te = le.stateNode;
                                    var Te = le.memoizedProps.style
                                      , Se = Te != null && Te.hasOwnProperty("display") ? Te.display : null;
                                    te.style.display = Se == null || typeof Se == "boolean" ? "" : ("" + Se).trim()
                                }
                            } catch (it) {
                                En(le, le.return, it)
                            }
                        }
                    } else if (f.tag === 6) {
                        if (y === null) {
                            le = f;
                            try {
                                le.stateNode.nodeValue = T ? "" : le.memoizedProps
                            } catch (it) {
                                En(le, le.return, it)
                            }
                        }
                    } else if (f.tag === 18) {
                        if (y === null) {
                            le = f;
                            try {
                                var Ce = le.stateNode;
                                T ? fT(Ce, !0) : fT(le.stateNode, !1)
                            } catch (it) {
                                En(le, le.return, it)
                            }
                        }
                    } else if ((f.tag !== 22 && f.tag !== 23 || f.memoizedState === null || f === c) && f.child !== null) {
                        f.child.return = f,
                        f = f.child;
                        continue
                    }
                    if (f === c)
                        break e;
                    for (; f.sibling === null; ) {
                        if (f.return === null || f.return === c)
                            break e;
                        y === f && (y = null),
                        f = f.return
                    }
                    y === f && (y = null),
                    f.sibling.return = f.return,
                    f = f.sibling
                }
            x & 4 && (x = c.updateQueue,
            x !== null && (y = x.retryQueue,
            y !== null && (x.retryQueue = null,
            qb(c, y))));
            break;
        case 19:
            ci(f, c),
            ui(c),
            x & 4 && (x = c.updateQueue,
            x !== null && (c.updateQueue = null,
            qb(c, x)));
            break;
        case 30:
            break;
        case 21:
            break;
        default:
            ci(f, c),
            ui(c)
        }
    }
    function ui(c) {
        var f = c.flags;
        if (f & 2) {
            try {
                for (var y, x = c.return; x !== null; ) {
                    if (pD(x)) {
                        y = x;
                        break
                    }
                    x = x.return
                }
                if (y == null)
                    throw Error(r(160));
                switch (y.tag) {
                case 27:
                    var T = y.stateNode
                      , F = CE(c);
                    Vb(c, F, T);
                    break;
                case 5:
                    var Z = y.stateNode;
                    y.flags & 32 && (ch(Z, ""),
                    y.flags &= -33);
                    var te = CE(c);
                    Vb(c, te, Z);
                    break;
                case 3:
                case 4:
                    var le = y.stateNode.containerInfo
                      , ve = CE(c);
                    _E(c, ve, le);
                    break;
                default:
                    throw Error(r(161))
                }
            } catch (ke) {
                En(c, c.return, ke)
            }
            c.flags &= -3
        }
        f & 4096 && (c.flags &= -4097)
    }
    function SD(c) {
        if (c.subtreeFlags & 1024)
            for (c = c.child; c !== null; ) {
                var f = c;
                SD(f),
                f.tag === 5 && f.flags & 1024 && f.stateNode.reset(),
                c = c.sibling
            }
    }
    function Al(c, f) {
        if (f.subtreeFlags & 8772)
            for (f = f.child; f !== null; )
                yD(c, f.alternate, f),
                f = f.sibling
    }
    function kd(c) {
        for (c = c.child; c !== null; ) {
            var f = c;
            switch (f.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
                Qc(4, f, f.return),
                kd(f);
                break;
            case 1:
                Aa(f, f.return);
                var y = f.stateNode;
                typeof y.componentWillUnmount == "function" && fD(f, f.return, y),
                kd(f);
                break;
            case 27:
                Em(f.stateNode);
            case 26:
            case 5:
                Aa(f, f.return),
                kd(f);
                break;
            case 22:
                f.memoizedState === null && kd(f);
                break;
            case 30:
                kd(f);
                break;
            default:
                kd(f)
            }
            c = c.sibling
        }
    }
    function Cl(c, f, y) {
        for (y = y && (f.subtreeFlags & 8772) !== 0,
        f = f.child; f !== null; ) {
            var x = f.alternate
              , T = c
              , F = f
              , Z = F.flags;
            switch (F.tag) {
            case 0:
            case 11:
            case 15:
                Cl(T, F, y),
                fm(4, F);
                break;
            case 1:
                if (Cl(T, F, y),
                x = F,
                T = x.stateNode,
                typeof T.componentDidMount == "function")
                    try {
                        T.componentDidMount()
                    } catch (ve) {
                        En(x, x.return, ve)
                    }
                if (x = F,
                T = x.updateQueue,
                T !== null) {
                    var te = x.stateNode;
                    try {
                        var le = T.shared.hiddenCallbacks;
                        if (le !== null)
                            for (T.shared.hiddenCallbacks = null,
                            T = 0; T < le.length; T++)
                                eN(le[T], te)
                    } catch (ve) {
                        En(x, x.return, ve)
                    }
                }
                y && Z & 64 && dD(F),
                hm(F, F.return);
                break;
            case 27:
                mD(F);
            case 26:
            case 5:
                Cl(T, F, y),
                y && x === null && Z & 4 && hD(F),
                hm(F, F.return);
                break;
            case 12:
                Cl(T, F, y);
                break;
            case 31:
                Cl(T, F, y),
                y && Z & 4 && vD(T, F);
                break;
            case 13:
                Cl(T, F, y),
                y && Z & 4 && xD(T, F);
                break;
            case 22:
                F.memoizedState === null && Cl(T, F, y),
                hm(F, F.return);
                break;
            case 30:
                break;
            default:
                Cl(T, F, y)
            }
            f = f.sibling
        }
    }
    function NE(c, f) {
        var y = null;
        c !== null && c.memoizedState !== null && c.memoizedState.cachePool !== null && (y = c.memoizedState.cachePool.pool),
        c = null,
        f.memoizedState !== null && f.memoizedState.cachePool !== null && (c = f.memoizedState.cachePool.pool),
        c !== y && (c != null && c.refCount++,
        y != null && J0(y))
    }
    function DE(c, f) {
        c = null,
        f.alternate !== null && (c = f.alternate.memoizedState.cache),
        f = f.memoizedState.cache,
        f !== c && (f.refCount++,
        c != null && J0(c))
    }
    function qo(c, f, y, x) {
        if (f.subtreeFlags & 10256)
            for (f = f.child; f !== null; )
                AD(c, f, y, x),
                f = f.sibling
    }
    function AD(c, f, y, x) {
        var T = f.flags;
        switch (f.tag) {
        case 0:
        case 11:
        case 15:
            qo(c, f, y, x),
            T & 2048 && fm(9, f);
            break;
        case 1:
            qo(c, f, y, x);
            break;
        case 3:
            qo(c, f, y, x),
            T & 2048 && (c = null,
            f.alternate !== null && (c = f.alternate.memoizedState.cache),
            f = f.memoizedState.cache,
            f !== c && (f.refCount++,
            c != null && J0(c)));
            break;
        case 12:
            if (T & 2048) {
                qo(c, f, y, x),
                c = f.stateNode;
                try {
                    var F = f.memoizedProps
                      , Z = F.id
                      , te = F.onPostCommit;
                    typeof te == "function" && te(Z, f.alternate === null ? "mount" : "update", c.passiveEffectDuration, -0)
                } catch (le) {
                    En(f, f.return, le)
                }
            } else
                qo(c, f, y, x);
            break;
        case 31:
            qo(c, f, y, x);
            break;
        case 13:
            qo(c, f, y, x);
            break;
        case 23:
            break;
        case 22:
            F = f.stateNode,
            Z = f.alternate,
            f.memoizedState !== null ? F._visibility & 2 ? qo(c, f, y, x) : pm(c, f) : F._visibility & 2 ? qo(c, f, y, x) : (F._visibility |= 2,
            Dh(c, f, y, x, (f.subtreeFlags & 10256) !== 0 || !1)),
            T & 2048 && NE(Z, f);
            break;
        case 24:
            qo(c, f, y, x),
            T & 2048 && DE(f.alternate, f);
            break;
        default:
            qo(c, f, y, x)
        }
    }
    function Dh(c, f, y, x, T) {
        for (T = T && ((f.subtreeFlags & 10256) !== 0 || !1),
        f = f.child; f !== null; ) {
            var F = c
              , Z = f
              , te = y
              , le = x
              , ve = Z.flags;
            switch (Z.tag) {
            case 0:
            case 11:
            case 15:
                Dh(F, Z, te, le, T),
                fm(8, Z);
                break;
            case 23:
                break;
            case 22:
                var ke = Z.stateNode;
                Z.memoizedState !== null ? ke._visibility & 2 ? Dh(F, Z, te, le, T) : pm(F, Z) : (ke._visibility |= 2,
                Dh(F, Z, te, le, T)),
                T && ve & 2048 && NE(Z.alternate, Z);
                break;
            case 24:
                Dh(F, Z, te, le, T),
                T && ve & 2048 && DE(Z.alternate, Z);
                break;
            default:
                Dh(F, Z, te, le, T)
            }
            f = f.sibling
        }
    }
    function pm(c, f) {
        if (f.subtreeFlags & 10256)
            for (f = f.child; f !== null; ) {
                var y = c
                  , x = f
                  , T = x.flags;
                switch (x.tag) {
                case 22:
                    pm(y, x),
                    T & 2048 && NE(x.alternate, x);
                    break;
                case 24:
                    pm(y, x),
                    T & 2048 && DE(x.alternate, x);
                    break;
                default:
                    pm(y, x)
                }
                f = f.sibling
            }
    }
    var mm = 8192;
    function Th(c, f, y) {
        if (c.subtreeFlags & mm)
            for (c = c.child; c !== null; )
                CD(c, f, y),
                c = c.sibling
    }
    function CD(c, f, y) {
        switch (c.tag) {
        case 26:
            Th(c, f, y),
            c.flags & mm && c.memoizedState !== null && QK(y, Vo, c.memoizedState, c.memoizedProps);
            break;
        case 5:
            Th(c, f, y);
            break;
        case 3:
        case 4:
            var x = Vo;
            Vo = i1(c.stateNode.containerInfo),
            Th(c, f, y),
            Vo = x;
            break;
        case 22:
            c.memoizedState === null && (x = c.alternate,
            x !== null && x.memoizedState !== null ? (x = mm,
            mm = 16777216,
            Th(c, f, y),
            mm = x) : Th(c, f, y));
            break;
        default:
            Th(c, f, y)
        }
    }
    function _D(c) {
        var f = c.alternate;
        if (f !== null && (c = f.child,
        c !== null)) {
            f.child = null;
            do
                f = c.sibling,
                c.sibling = null,
                c = f;
            while (c !== null)
        }
    }
    function gm(c) {
        var f = c.deletions;
        if ((c.flags & 16) !== 0) {
            if (f !== null)
                for (var y = 0; y < f.length; y++) {
                    var x = f[y];
                    Yr = x,
                    ND(x, c)
                }
            _D(c)
        }
        if (c.subtreeFlags & 10256)
            for (c = c.child; c !== null; )
                kD(c),
                c = c.sibling
    }
    function kD(c) {
        switch (c.tag) {
        case 0:
        case 11:
        case 15:
            gm(c),
            c.flags & 2048 && Qc(9, c, c.return);
            break;
        case 3:
            gm(c);
            break;
        case 12:
            gm(c);
            break;
        case 22:
            var f = c.stateNode;
            c.memoizedState !== null && f._visibility & 2 && (c.return === null || c.return.tag !== 13) ? (f._visibility &= -3,
            Gb(c)) : gm(c);
            break;
        default:
            gm(c)
        }
    }
    function Gb(c) {
        var f = c.deletions;
        if ((c.flags & 16) !== 0) {
            if (f !== null)
                for (var y = 0; y < f.length; y++) {
                    var x = f[y];
                    Yr = x,
                    ND(x, c)
                }
            _D(c)
        }
        for (c = c.child; c !== null; ) {
            switch (f = c,
            f.tag) {
            case 0:
            case 11:
            case 15:
                Qc(8, f, f.return),
                Gb(f);
                break;
            case 22:
                y = f.stateNode,
                y._visibility & 2 && (y._visibility &= -3,
                Gb(f));
                break;
            default:
                Gb(f)
            }
            c = c.sibling
        }
    }
    function ND(c, f) {
        for (; Yr !== null; ) {
            var y = Yr;
            switch (y.tag) {
            case 0:
            case 11:
            case 15:
                Qc(8, y, f);
                break;
            case 23:
            case 22:
                if (y.memoizedState !== null && y.memoizedState.cachePool !== null) {
                    var x = y.memoizedState.cachePool.pool;
                    x != null && x.refCount++
                }
                break;
            case 24:
                J0(y.memoizedState.cache)
            }
            if (x = y.child,
            x !== null)
                x.return = y,
                Yr = x;
            else
                e: for (y = c; Yr !== null; ) {
                    x = Yr;
                    var T = x.sibling
                      , F = x.return;
                    if (bD(x),
                    x === y) {
                        Yr = null;
                        break e
                    }
                    if (T !== null) {
                        T.return = F,
                        Yr = T;
                        break e
                    }
                    Yr = F
                }
        }
    }
    var fK = {
        getCacheForType: function(c) {
            var f = os(Nr)
              , y = f.data.get(c);
            return y === void 0 && (y = c(),
            f.data.set(c, y)),
            y
        },
        cacheSignal: function() {
            return os(Nr).controller.signal
        }
    }
      , hK = typeof WeakMap == "function" ? WeakMap : Map
      , mn = 0
      , On = null
      , Vt = null
      , Wt = 0
      , xn = 0
      , Pi = null
      , Zc = !1
      , Ih = !1
      , TE = !1
      , _l = 0
      , ur = 0
      , Jc = 0
      , Nd = 0
      , IE = 0
      , ji = 0
      , Mh = 0
      , ym = null
      , di = null
      , ME = !1
      , Wb = 0
      , DD = 0
      , Yb = 1 / 0
      , Kb = null
      , eu = null
      , zr = 0
      , tu = null
      , Bh = null
      , kl = 0
      , BE = 0
      , RE = null
      , TD = null
      , bm = 0
      , OE = null;
    function Li() {
        return (mn & 2) !== 0 && Wt !== 0 ? Wt & -Wt : C.T !== null ? zE() : Zt()
    }
    function ID() {
        if (ji === 0)
            if ((Wt & 536870912) === 0 || en) {
                var c = ln;
                ln <<= 1,
                (ln & 3932160) === 0 && (ln = 262144),
                ji = c
            } else
                ji = 536870912;
        return c = Ri.current,
        c !== null && (c.flags |= 32),
        ji
    }
    function fi(c, f, y) {
        (c === On && (xn === 2 || xn === 9) || c.cancelPendingCommit !== null) && (Rh(c, 0),
        nu(c, Wt, ji, !1)),
        Je(c, y),
        ((mn & 2) === 0 || c !== On) && (c === On && ((mn & 2) === 0 && (Nd |= y),
        ur === 4 && nu(c, Wt, ji, !1)),
        Ca(c))
    }
    function MD(c, f, y) {
        if ((mn & 6) !== 0)
            throw Error(r(327));
        var x = !y && (f & 127) === 0 && (f & c.expiredLanes) === 0 || qe(c, f)
          , T = x ? gK(c, f) : jE(c, f, !0)
          , F = x;
        do {
            if (T === 0) {
                Ih && !x && nu(c, f, 0, !1);
                break
            } else {
                if (y = c.current.alternate,
                F && !pK(y)) {
                    T = jE(c, f, !1),
                    F = !1;
                    continue
                }
                if (T === 2) {
                    if (F = f,
                    c.errorRecoveryDisabledLanes & F)
                        var Z = 0;
                    else
                        Z = c.pendingLanes & -536870913,
                        Z = Z !== 0 ? Z : Z & 536870912 ? 536870912 : 0;
                    if (Z !== 0) {
                        f = Z;
                        e: {
                            var te = c;
                            T = ym;
                            var le = te.current.memoizedState.isDehydrated;
                            if (le && (Rh(te, Z).flags |= 256),
                            Z = jE(te, Z, !1),
                            Z !== 2) {
                                if (TE && !le) {
                                    te.errorRecoveryDisabledLanes |= F,
                                    Nd |= F,
                                    T = 4;
                                    break e
                                }
                                F = di,
                                di = T,
                                F !== null && (di === null ? di = F : di.push.apply(di, F))
                            }
                            T = Z
                        }
                        if (F = !1,
                        T !== 2)
                            continue
                    }
                }
                if (T === 1) {
                    Rh(c, 0),
                    nu(c, f, 0, !0);
                    break
                }
                e: {
                    switch (x = c,
                    F = T,
                    F) {
                    case 0:
                    case 1:
                        throw Error(r(345));
                    case 4:
                        if ((f & 4194048) !== f)
                            break;
                    case 6:
                        nu(x, f, ji, !Zc);
                        break e;
                    case 2:
                        di = null;
                        break;
                    case 3:
                    case 5:
                        break;
                    default:
                        throw Error(r(329))
                    }
                    if ((f & 62914560) === f && (T = Wb + 300 - ut(),
                    10 < T)) {
                        if (nu(x, f, ji, !Zc),
                        Ue(x, 0, !0) !== 0)
                            break e;
                        kl = f,
                        x.timeoutHandle = cT(BD.bind(null, x, y, di, Kb, ME, f, ji, Nd, Mh, Zc, F, "Throttled", -0, 0), T);
                        break e
                    }
                    BD(x, y, di, Kb, ME, f, ji, Nd, Mh, Zc, F, null, -0, 0)
                }
            }
            break
        } while (!0);
        Ca(c)
    }
    function BD(c, f, y, x, T, F, Z, te, le, ve, ke, Te, Se, Ce) {
        if (c.timeoutHandle = -1,
        Te = f.subtreeFlags,
        Te & 8192 || (Te & 16785408) === 16785408) {
            Te = {
                stylesheets: null,
                count: 0,
                imgCount: 0,
                imgBytes: 0,
                suspenseyImages: [],
                waitingForImages: !0,
                waitingForViewTransition: !1,
                unsuspend: fl
            },
            CD(f, F, Te);
            var it = (F & 62914560) === F ? Wb - ut() : (F & 4194048) === F ? DD - ut() : 0;
            if (it = ZK(Te, it),
            it !== null) {
                kl = F,
                c.cancelPendingCommit = it(zD.bind(null, c, f, F, y, x, T, Z, te, le, ke, Te, null, Se, Ce)),
                nu(c, F, Z, !ve);
                return
            }
        }
        zD(c, f, F, y, x, T, Z, te, le)
    }
    function pK(c) {
        for (var f = c; ; ) {
            var y = f.tag;
            if ((y === 0 || y === 11 || y === 15) && f.flags & 16384 && (y = f.updateQueue,
            y !== null && (y = y.stores,
            y !== null)))
                for (var x = 0; x < y.length; x++) {
                    var T = y[x]
                      , F = T.getSnapshot;
                    T = T.value;
                    try {
                        if (!Mi(F(), T))
                            return !1
                    } catch {
                        return !1
                    }
                }
            if (y = f.child,
            f.subtreeFlags & 16384 && y !== null)
                y.return = f,
                f = y;
            else {
                if (f === c)
                    break;
                for (; f.sibling === null; ) {
                    if (f.return === null || f.return === c)
                        return !0;
                    f = f.return
                }
                f.sibling.return = f.return,
                f = f.sibling
            }
        }
        return !0
    }
    function nu(c, f, y, x) {
        f &= ~IE,
        f &= ~Nd,
        c.suspendedLanes |= f,
        c.pingedLanes &= ~f,
        x && (c.warmLanes |= f),
        x = c.expirationTimes;
        for (var T = f; 0 < T; ) {
            var F = 31 - Ve(T)
              , Z = 1 << F;
            x[F] = -1,
            T &= ~Z
        }
        y !== 0 && et(c, y, f)
    }
    function Xb() {
        return (mn & 6) === 0 ? (wm(0),
        !1) : !0
    }
    function PE() {
        if (Vt !== null) {
            if (xn === 0)
                var c = Vt.return;
            else
                c = Vt,
                gl = wd = null,
                Z3(c),
                Ah = null,
                tm = 0,
                c = Vt;
            for (; c !== null; )
                uD(c.alternate, c),
                c = c.return;
            Vt = null
        }
    }
    function Rh(c, f) {
        var y = c.timeoutHandle;
        y !== -1 && (c.timeoutHandle = -1,
        RK(y)),
        y = c.cancelPendingCommit,
        y !== null && (c.cancelPendingCommit = null,
        y()),
        kl = 0,
        PE(),
        On = c,
        Vt = y = pl(c.current, null),
        Wt = f,
        xn = 0,
        Pi = null,
        Zc = !1,
        Ih = qe(c, f),
        TE = !1,
        Mh = ji = IE = Nd = Jc = ur = 0,
        di = ym = null,
        ME = !1,
        (f & 8) !== 0 && (f |= f & 32);
        var x = c.entangledLanes;
        if (x !== 0)
            for (c = c.entanglements,
            x &= f; 0 < x; ) {
                var T = 31 - Ve(x)
                  , F = 1 << T;
                f |= c[T],
                x &= ~F
            }
        return _l = f,
        yb(),
        y
    }
    function RD(c, f) {
        Tt = null,
        C.H = cm,
        f === Sh || f === Cb ? (f = X6(),
        xn = 3) : f === U3 ? (f = X6(),
        xn = 4) : xn = f === pE ? 8 : f !== null && typeof f == "object" && typeof f.then == "function" ? 6 : 1,
        Pi = f,
        Vt === null && (ur = 1,
        Fb(c, ao(f, c.current)))
    }
    function OD() {
        var c = Ri.current;
        return c === null ? !0 : (Wt & 4194048) === Wt ? fo === null : (Wt & 62914560) === Wt || (Wt & 536870912) !== 0 ? c === fo : !1
    }
    function PD() {
        var c = C.H;
        return C.H = cm,
        c === null ? cm : c
    }
    function jD() {
        var c = C.A;
        return C.A = fK,
        c
    }
    function Qb() {
        ur = 4,
        Zc || (Wt & 4194048) !== Wt && Ri.current !== null || (Ih = !0),
        (Jc & 134217727) === 0 && (Nd & 134217727) === 0 || On === null || nu(On, Wt, ji, !1)
    }
    function jE(c, f, y) {
        var x = mn;
        mn |= 2;
        var T = PD()
          , F = jD();
        (On !== c || Wt !== f) && (Kb = null,
        Rh(c, f)),
        f = !1;
        var Z = ur;
        e: do
            try {
                if (xn !== 0 && Vt !== null) {
                    var te = Vt
                      , le = Pi;
                    switch (xn) {
                    case 8:
                        PE(),
                        Z = 6;
                        break e;
                    case 3:
                    case 2:
                    case 9:
                    case 6:
                        Ri.current === null && (f = !0);
                        var ve = xn;
                        if (xn = 0,
                        Pi = null,
                        Oh(c, te, le, ve),
                        y && Ih) {
                            Z = 0;
                            break e
                        }
                        break;
                    default:
                        ve = xn,
                        xn = 0,
                        Pi = null,
                        Oh(c, te, le, ve)
                    }
                }
                mK(),
                Z = ur;
                break
            } catch (ke) {
                RD(c, ke)
            }
        while (!0);
        return f && c.shellSuspendCounter++,
        gl = wd = null,
        mn = x,
        C.H = T,
        C.A = F,
        Vt === null && (On = null,
        Wt = 0,
        yb()),
        Z
    }
    function mK() {
        for (; Vt !== null; )
            LD(Vt)
    }
    function gK(c, f) {
        var y = mn;
        mn |= 2;
        var x = PD()
          , T = jD();
        On !== c || Wt !== f ? (Kb = null,
        Yb = ut() + 500,
        Rh(c, f)) : Ih = qe(c, f);
        e: do
            try {
                if (xn !== 0 && Vt !== null) {
                    f = Vt;
                    var F = Pi;
                    t: switch (xn) {
                    case 1:
                        xn = 0,
                        Pi = null,
                        Oh(c, f, F, 1);
                        break;
                    case 2:
                    case 9:
                        if (Y6(F)) {
                            xn = 0,
                            Pi = null,
                            FD(f);
                            break
                        }
                        f = function() {
                            xn !== 2 && xn !== 9 || On !== c || (xn = 7),
                            Ca(c)
                        }
                        ,
                        F.then(f, f);
                        break e;
                    case 3:
                        xn = 7;
                        break e;
                    case 4:
                        xn = 5;
                        break e;
                    case 7:
                        Y6(F) ? (xn = 0,
                        Pi = null,
                        FD(f)) : (xn = 0,
                        Pi = null,
                        Oh(c, f, F, 7));
                        break;
                    case 5:
                        var Z = null;
                        switch (Vt.tag) {
                        case 26:
                            Z = Vt.memoizedState;
                        case 5:
                        case 27:
                            var te = Vt;
                            if (Z ? AT(Z) : te.stateNode.complete) {
                                xn = 0,
                                Pi = null;
                                var le = te.sibling;
                                if (le !== null)
                                    Vt = le;
                                else {
                                    var ve = te.return;
                                    ve !== null ? (Vt = ve,
                                    Zb(ve)) : Vt = null
                                }
                                break t
                            }
                        }
                        xn = 0,
                        Pi = null,
                        Oh(c, f, F, 5);
                        break;
                    case 6:
                        xn = 0,
                        Pi = null,
                        Oh(c, f, F, 6);
                        break;
                    case 8:
                        PE(),
                        ur = 6;
                        break e;
                    default:
                        throw Error(r(462))
                    }
                }
                yK();
                break
            } catch (ke) {
                RD(c, ke)
            }
        while (!0);
        return gl = wd = null,
        C.H = x,
        C.A = T,
        mn = y,
        Vt !== null ? 0 : (On = null,
        Wt = 0,
        yb(),
        ur)
    }
    function yK() {
        for (; Vt !== null && !Et(); )
            LD(Vt)
    }
    function LD(c) {
        var f = lD(c.alternate, c, _l);
        c.memoizedProps = c.pendingProps,
        f === null ? Zb(c) : Vt = f
    }
    function FD(c) {
        var f = c
          , y = f.alternate;
        switch (f.tag) {
        case 15:
        case 0:
            f = nD(y, f, f.pendingProps, f.type, void 0, Wt);
            break;
        case 11:
            f = nD(y, f, f.pendingProps, f.type.render, f.ref, Wt);
            break;
        case 5:
            Z3(f);
        default:
            uD(y, f),
            f = Vt = j6(f, _l),
            f = lD(y, f, _l)
        }
        c.memoizedProps = c.pendingProps,
        f === null ? Zb(c) : Vt = f
    }
    function Oh(c, f, y, x) {
        gl = wd = null,
        Z3(f),
        Ah = null,
        tm = 0;
        var T = f.return;
        try {
            if (iK(c, T, f, y, Wt)) {
                ur = 1,
                Fb(c, ao(y, c.current)),
                Vt = null;
                return
            }
        } catch (F) {
            if (T !== null)
                throw Vt = T,
                F;
            ur = 1,
            Fb(c, ao(y, c.current)),
            Vt = null;
            return
        }
        f.flags & 32768 ? (en || x === 1 ? c = !0 : Ih || (Wt & 536870912) !== 0 ? c = !1 : (Zc = c = !0,
        (x === 2 || x === 9 || x === 3 || x === 6) && (x = Ri.current,
        x !== null && x.tag === 13 && (x.flags |= 16384))),
        UD(f, c)) : Zb(f)
    }
    function Zb(c) {
        var f = c;
        do {
            if ((f.flags & 32768) !== 0) {
                UD(f, Zc);
                return
            }
            c = f.return;
            var y = lK(f.alternate, f, _l);
            if (y !== null) {
                Vt = y;
                return
            }
            if (f = f.sibling,
            f !== null) {
                Vt = f;
                return
            }
            Vt = f = c
        } while (f !== null);
        ur === 0 && (ur = 5)
    }
    function UD(c, f) {
        do {
            var y = cK(c.alternate, c);
            if (y !== null) {
                y.flags &= 32767,
                Vt = y;
                return
            }
            if (y = c.return,
            y !== null && (y.flags |= 32768,
            y.subtreeFlags = 0,
            y.deletions = null),
            !f && (c = c.sibling,
            c !== null)) {
                Vt = c;
                return
            }
            Vt = c = y
        } while (c !== null);
        ur = 6,
        Vt = null
    }
    function zD(c, f, y, x, T, F, Z, te, le) {
        c.cancelPendingCommit = null;
        do
            Jb();
        while (zr !== 0);
        if ((mn & 6) !== 0)
            throw Error(r(327));
        if (f !== null) {
            if (f === c.current)
                throw Error(r(177));
            if (F = f.lanes | f.childLanes,
            F |= C3,
            Pe(c, y, F, Z, te, le),
            c === On && (Vt = On = null,
            Wt = 0),
            Bh = f,
            tu = c,
            kl = y,
            BE = F,
            RE = T,
            TD = x,
            (f.subtreeFlags & 10256) !== 0 || (f.flags & 10256) !== 0 ? (c.callbackNode = null,
            c.callbackPriority = 0,
            xK(K, function() {
                return GD(),
                null
            })) : (c.callbackNode = null,
            c.callbackPriority = 0),
            x = (f.flags & 13878) !== 0,
            (f.subtreeFlags & 13878) !== 0 || x) {
                x = C.T,
                C.T = null,
                T = O.p,
                O.p = 2,
                Z = mn,
                mn |= 4;
                try {
                    uK(c, f, y)
                } finally {
                    mn = Z,
                    O.p = T,
                    C.T = x
                }
            }
            zr = 1,
            $D(),
            HD(),
            VD()
        }
    }
    function $D() {
        if (zr === 1) {
            zr = 0;
            var c = tu
              , f = Bh
              , y = (f.flags & 13878) !== 0;
            if ((f.subtreeFlags & 13878) !== 0 || y) {
                y = C.T,
                C.T = null;
                var x = O.p;
                O.p = 2;
                var T = mn;
                mn |= 4;
                try {
                    ED(f, c);
                    var F = KE
                      , Z = N6(c.containerInfo)
                      , te = F.focusedElem
                      , le = F.selectionRange;
                    if (Z !== te && te && te.ownerDocument && k6(te.ownerDocument.documentElement, te)) {
                        if (le !== null && v3(te)) {
                            var ve = le.start
                              , ke = le.end;
                            if (ke === void 0 && (ke = ve),
                            "selectionStart"in te)
                                te.selectionStart = ve,
                                te.selectionEnd = Math.min(ke, te.value.length);
                            else {
                                var Te = te.ownerDocument || document
                                  , Se = Te && Te.defaultView || window;
                                if (Se.getSelection) {
                                    var Ce = Se.getSelection()
                                      , it = te.textContent.length
                                      , vt = Math.min(le.start, it)
                                      , In = le.end === void 0 ? vt : Math.min(le.end, it);
                                    !Ce.extend && vt > In && (Z = In,
                                    In = vt,
                                    vt = Z);
                                    var pe = _6(te, vt)
                                      , de = _6(te, In);
                                    if (pe && de && (Ce.rangeCount !== 1 || Ce.anchorNode !== pe.node || Ce.anchorOffset !== pe.offset || Ce.focusNode !== de.node || Ce.focusOffset !== de.offset)) {
                                        var we = Te.createRange();
                                        we.setStart(pe.node, pe.offset),
                                        Ce.removeAllRanges(),
                                        vt > In ? (Ce.addRange(we),
                                        Ce.extend(de.node, de.offset)) : (we.setEnd(de.node, de.offset),
                                        Ce.addRange(we))
                                    }
                                }
                            }
                        }
                        for (Te = [],
                        Ce = te; Ce = Ce.parentNode; )
                            Ce.nodeType === 1 && Te.push({
                                element: Ce,
                                left: Ce.scrollLeft,
                                top: Ce.scrollTop
                            });
                        for (typeof te.focus == "function" && te.focus(),
                        te = 0; te < Te.length; te++) {
                            var Ne = Te[te];
                            Ne.element.scrollLeft = Ne.left,
                            Ne.element.scrollTop = Ne.top
                        }
                    }
                    d1 = !!YE,
                    KE = YE = null
                } finally {
                    mn = T,
                    O.p = x,
                    C.T = y
                }
            }
            c.current = f,
            zr = 2
        }
    }
    function HD() {
        if (zr === 2) {
            zr = 0;
            var c = tu
              , f = Bh
              , y = (f.flags & 8772) !== 0;
            if ((f.subtreeFlags & 8772) !== 0 || y) {
                y = C.T,
                C.T = null;
                var x = O.p;
                O.p = 2;
                var T = mn;
                mn |= 4;
                try {
                    yD(c, f.alternate, f)
                } finally {
                    mn = T,
                    O.p = x,
                    C.T = y
                }
            }
            zr = 3
        }
    }
    function VD() {
        if (zr === 4 || zr === 3) {
            zr = 0,
            St();
            var c = tu
              , f = Bh
              , y = kl
              , x = TD;
            (f.subtreeFlags & 10256) !== 0 || (f.flags & 10256) !== 0 ? zr = 5 : (zr = 0,
            Bh = tu = null,
            qD(c, c.pendingLanes));
            var T = c.pendingLanes;
            if (T === 0 && (eu = null),
            Rn(y),
            f = f.stateNode,
            _e && typeof _e.onCommitFiberRoot == "function")
                try {
                    _e.onCommitFiberRoot(ge, f, void 0, (f.current.flags & 128) === 128)
                } catch {}
            if (x !== null) {
                f = C.T,
                T = O.p,
                O.p = 2,
                C.T = null;
                try {
                    for (var F = c.onRecoverableError, Z = 0; Z < x.length; Z++) {
                        var te = x[Z];
                        F(te.value, {
                            componentStack: te.stack
                        })
                    }
                } finally {
                    C.T = f,
                    O.p = T
                }
            }
            (kl & 3) !== 0 && Jb(),
            Ca(c),
            T = c.pendingLanes,
            (y & 261930) !== 0 && (T & 42) !== 0 ? c === OE ? bm++ : (bm = 0,
            OE = c) : bm = 0,
            wm(0)
        }
    }
    function qD(c, f) {
        (c.pooledCacheLanes &= f) === 0 && (f = c.pooledCache,
        f != null && (c.pooledCache = null,
        J0(f)))
    }
    function Jb() {
        return $D(),
        HD(),
        VD(),
        GD()
    }
    function GD() {
        if (zr !== 5)
            return !1;
        var c = tu
          , f = BE;
        BE = 0;
        var y = Rn(kl)
          , x = C.T
          , T = O.p;
        try {
            O.p = 32 > y ? 32 : y,
            C.T = null,
            y = RE,
            RE = null;
            var F = tu
              , Z = kl;
            if (zr = 0,
            Bh = tu = null,
            kl = 0,
            (mn & 6) !== 0)
                throw Error(r(331));
            var te = mn;
            if (mn |= 4,
            kD(F.current),
            AD(F, F.current, Z, y),
            mn = te,
            wm(0, !1),
            _e && typeof _e.onPostCommitFiberRoot == "function")
                try {
                    _e.onPostCommitFiberRoot(ge, F)
                } catch {}
            return !0
        } finally {
            O.p = T,
            C.T = x,
            qD(c, f)
        }
    }
    function WD(c, f, y) {
        f = ao(y, f),
        f = hE(c.stateNode, f, 2),
        c = Yc(c, f, 2),
        c !== null && (Je(c, 2),
        Ca(c))
    }
    function En(c, f, y) {
        if (c.tag === 3)
            WD(c, c, y);
        else
            for (; f !== null; ) {
                if (f.tag === 3) {
                    WD(f, c, y);
                    break
                } else if (f.tag === 1) {
                    var x = f.stateNode;
                    if (typeof f.type.getDerivedStateFromError == "function" || typeof x.componentDidCatch == "function" && (eu === null || !eu.has(x))) {
                        c = ao(y, c),
                        y = YN(2),
                        x = Yc(f, y, 2),
                        x !== null && (KN(y, x, f, c),
                        Je(x, 2),
                        Ca(x));
                        break
                    }
                }
                f = f.return
            }
    }
    function LE(c, f, y) {
        var x = c.pingCache;
        if (x === null) {
            x = c.pingCache = new hK;
            var T = new Set;
            x.set(f, T)
        } else
            T = x.get(f),
            T === void 0 && (T = new Set,
            x.set(f, T));
        T.has(y) || (TE = !0,
        T.add(y),
        c = bK.bind(null, c, f, y),
        f.then(c, c))
    }
    function bK(c, f, y) {
        var x = c.pingCache;
        x !== null && x.delete(f),
        c.pingedLanes |= c.suspendedLanes & y,
        c.warmLanes &= ~y,
        On === c && (Wt & y) === y && (ur === 4 || ur === 3 && (Wt & 62914560) === Wt && 300 > ut() - Wb ? (mn & 2) === 0 && Rh(c, 0) : IE |= y,
        Mh === Wt && (Mh = 0)),
        Ca(c)
    }
    function YD(c, f) {
        f === 0 && (f = De()),
        c = gd(c, f),
        c !== null && (Je(c, f),
        Ca(c))
    }
    function wK(c) {
        var f = c.memoizedState
          , y = 0;
        f !== null && (y = f.retryLane),
        YD(c, y)
    }
    function vK(c, f) {
        var y = 0;
        switch (c.tag) {
        case 31:
        case 13:
            var x = c.stateNode
              , T = c.memoizedState;
            T !== null && (y = T.retryLane);
            break;
        case 19:
            x = c.stateNode;
            break;
        case 22:
            x = c.stateNode._retryCache;
            break;
        default:
            throw Error(r(314))
        }
        x !== null && x.delete(f),
        YD(c, y)
    }
    function xK(c, f) {
        return ct(c, f)
    }
    var e1 = null
      , Ph = null
      , FE = !1
      , t1 = !1
      , UE = !1
      , ru = 0;
    function Ca(c) {
        c !== Ph && c.next === null && (Ph === null ? e1 = Ph = c : Ph = Ph.next = c),
        t1 = !0,
        FE || (FE = !0,
        SK())
    }
    function wm(c, f) {
        if (!UE && t1) {
            UE = !0;
            do
                for (var y = !1, x = e1; x !== null; ) {
                    if (c !== 0) {
                        var T = x.pendingLanes;
                        if (T === 0)
                            var F = 0;
                        else {
                            var Z = x.suspendedLanes
                              , te = x.pingedLanes;
                            F = (1 << 31 - Ve(42 | c) + 1) - 1,
                            F &= T & ~(Z & ~te),
                            F = F & 201326741 ? F & 201326741 | 1 : F ? F | 2 : 0
                        }
                        F !== 0 && (y = !0,
                        ZD(x, F))
                    } else
                        F = Wt,
                        F = Ue(x, x === On ? F : 0, x.cancelPendingCommit !== null || x.timeoutHandle !== -1),
                        (F & 3) === 0 || qe(x, F) || (y = !0,
                        ZD(x, F));
                    x = x.next
                }
            while (y);
            UE = !1
        }
    }
    function EK() {
        KD()
    }
    function KD() {
        t1 = FE = !1;
        var c = 0;
        ru !== 0 && BK() && (c = ru);
        for (var f = ut(), y = null, x = e1; x !== null; ) {
            var T = x.next
              , F = XD(x, f);
            F === 0 ? (x.next = null,
            y === null ? e1 = T : y.next = T,
            T === null && (Ph = y)) : (y = x,
            (c !== 0 || (F & 3) !== 0) && (t1 = !0)),
            x = T
        }
        zr !== 0 && zr !== 5 || wm(c),
        ru !== 0 && (ru = 0)
    }
    function XD(c, f) {
        for (var y = c.suspendedLanes, x = c.pingedLanes, T = c.expirationTimes, F = c.pendingLanes & -62914561; 0 < F; ) {
            var Z = 31 - Ve(F)
              , te = 1 << Z
              , le = T[Z];
            le === -1 ? ((te & y) === 0 || (te & x) !== 0) && (T[Z] = At(te, f)) : le <= f && (c.expiredLanes |= te),
            F &= ~te
        }
        if (f = On,
        y = Wt,
        y = Ue(c, c === f ? y : 0, c.cancelPendingCommit !== null || c.timeoutHandle !== -1),
        x = c.callbackNode,
        y === 0 || c === f && (xn === 2 || xn === 9) || c.cancelPendingCommit !== null)
            return x !== null && x !== null && Xe(x),
            c.callbackNode = null,
            c.callbackPriority = 0;
        if ((y & 3) === 0 || qe(c, y)) {
            if (f = y & -y,
            f === c.callbackPriority)
                return f;
            switch (x !== null && Xe(x),
            Rn(y)) {
            case 2:
            case 8:
                y = ee;
                break;
            case 32:
                y = K;
                break;
            case 268435456:
                y = re;
                break;
            default:
                y = K
            }
            return x = QD.bind(null, c),
            y = ct(y, x),
            c.callbackPriority = f,
            c.callbackNode = y,
            f
        }
        return x !== null && x !== null && Xe(x),
        c.callbackPriority = 2,
        c.callbackNode = null,
        2
    }
    function QD(c, f) {
        if (zr !== 0 && zr !== 5)
            return c.callbackNode = null,
            c.callbackPriority = 0,
            null;
        var y = c.callbackNode;
        if (Jb() && c.callbackNode !== y)
            return null;
        var x = Wt;
        return x = Ue(c, c === On ? x : 0, c.cancelPendingCommit !== null || c.timeoutHandle !== -1),
        x === 0 ? null : (MD(c, x, f),
        XD(c, ut()),
        c.callbackNode != null && c.callbackNode === y ? QD.bind(null, c) : null)
    }
    function ZD(c, f) {
        if (Jb())
            return null;
        MD(c, f, !0)
    }
    function SK() {
        OK(function() {
            (mn & 6) !== 0 ? ct(_t, EK) : KD()
        })
    }
    function zE() {
        if (ru === 0) {
            var c = xh;
            c === 0 && (c = Nn,
            Nn <<= 1,
            (Nn & 261888) === 0 && (Nn = 256)),
            ru = c
        }
        return ru
    }
    function JD(c) {
        return c == null || typeof c == "symbol" || typeof c == "boolean" ? null : typeof c == "function" ? c : cb("" + c)
    }
    function eT(c, f) {
        var y = f.ownerDocument.createElement("input");
        return y.name = f.name,
        y.value = f.value,
        c.id && y.setAttribute("form", c.id),
        f.parentNode.insertBefore(y, f),
        c = new FormData(c),
        y.parentNode.removeChild(y),
        c
    }
    function AK(c, f, y, x, T) {
        if (f === "submit" && y && y.stateNode === T) {
            var F = JD((T[Ht] || null).action)
              , Z = x.submitter;
            Z && (f = (f = Z[Ht] || null) ? JD(f.formAction) : Z.getAttribute("formAction"),
            f !== null && (F = f,
            Z = null));
            var te = new hb("action","action",null,x,T);
            c.push({
                event: te,
                listeners: [{
                    instance: null,
                    listener: function() {
                        if (x.defaultPrevented) {
                            if (ru !== 0) {
                                var le = Z ? eT(T, Z) : new FormData(T);
                                aE(y, {
                                    pending: !0,
                                    data: le,
                                    method: T.method,
                                    action: F
                                }, null, le)
                            }
                        } else
                            typeof F == "function" && (te.preventDefault(),
                            le = Z ? eT(T, Z) : new FormData(T),
                            aE(y, {
                                pending: !0,
                                data: le,
                                method: T.method,
                                action: F
                            }, F, le))
                    },
                    currentTarget: T
                }]
            })
        }
    }
    for (var $E = 0; $E < A3.length; $E++) {
        var HE = A3[$E]
          , CK = HE.toLowerCase()
          , _K = HE[0].toUpperCase() + HE.slice(1);
        Ho(CK, "on" + _K)
    }
    Ho(I6, "onAnimationEnd"),
    Ho(M6, "onAnimationIteration"),
    Ho(B6, "onAnimationStart"),
    Ho("dblclick", "onDoubleClick"),
    Ho("focusin", "onFocus"),
    Ho("focusout", "onBlur"),
    Ho($Y, "onTransitionRun"),
    Ho(HY, "onTransitionStart"),
    Ho(VY, "onTransitionCancel"),
    Ho(R6, "onTransitionEnd"),
    xa("onMouseEnter", ["mouseout", "mouseover"]),
    xa("onMouseLeave", ["mouseout", "mouseover"]),
    xa("onPointerEnter", ["pointerout", "pointerover"]),
    xa("onPointerLeave", ["pointerout", "pointerover"]),
    $o("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")),
    $o("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),
    $o("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]),
    $o("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")),
    $o("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")),
    $o("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
    var vm = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ")
      , kK = new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(vm));
    function tT(c, f) {
        f = (f & 4) !== 0;
        for (var y = 0; y < c.length; y++) {
            var x = c[y]
              , T = x.event;
            x = x.listeners;
            e: {
                var F = void 0;
                if (f)
                    for (var Z = x.length - 1; 0 <= Z; Z--) {
                        var te = x[Z]
                          , le = te.instance
                          , ve = te.currentTarget;
                        if (te = te.listener,
                        le !== F && T.isPropagationStopped())
                            break e;
                        F = te,
                        T.currentTarget = ve;
                        try {
                            F(T)
                        } catch (ke) {
                            gb(ke)
                        }
                        T.currentTarget = null,
                        F = le
                    }
                else
                    for (Z = 0; Z < x.length; Z++) {
                        if (te = x[Z],
                        le = te.instance,
                        ve = te.currentTarget,
                        te = te.listener,
                        le !== F && T.isPropagationStopped())
                            break e;
                        F = te,
                        T.currentTarget = ve;
                        try {
                            F(T)
                        } catch (ke) {
                            gb(ke)
                        }
                        T.currentTarget = null,
                        F = le
                    }
            }
        }
    }
    function qt(c, f) {
        var y = f[Xn];
        y === void 0 && (y = f[Xn] = new Set);
        var x = c + "__bubble";
        y.has(x) || (nT(f, c, 2, !1),
        y.add(x))
    }
    function VE(c, f, y) {
        var x = 0;
        f && (x |= 4),
        nT(y, c, x, f)
    }
    var n1 = "_reactListening" + Math.random().toString(36).slice(2);
    function qE(c) {
        if (!c[n1]) {
            c[n1] = !0,
            sh.forEach(function(y) {
                y !== "selectionchange" && (kK.has(y) || VE(y, !1, c),
                VE(y, !0, c))
            });
            var f = c.nodeType === 9 ? c : c.ownerDocument;
            f === null || f[n1] || (f[n1] = !0,
            VE("selectionchange", !1, f))
        }
    }
    function nT(c, f, y, x) {
        switch (IT(f)) {
        case 2:
            var T = tX;
            break;
        case 8:
            T = nX;
            break;
        default:
            T = oS
        }
        y = T.bind(null, f, y, c),
        T = void 0,
        !d3 || f !== "touchstart" && f !== "touchmove" && f !== "wheel" || (T = !0),
        x ? T !== void 0 ? c.addEventListener(f, y, {
            capture: !0,
            passive: T
        }) : c.addEventListener(f, y, !0) : T !== void 0 ? c.addEventListener(f, y, {
            passive: T
        }) : c.addEventListener(f, y, !1)
    }
    function GE(c, f, y, x, T) {
        var F = x;
        if ((f & 1) === 0 && (f & 2) === 0 && x !== null)
            e: for (; ; ) {
                if (x === null)
                    return;
                var Z = x.tag;
                if (Z === 3 || Z === 4) {
                    var te = x.stateNode.containerInfo;
                    if (te === T)
                        break;
                    if (Z === 4)
                        for (Z = x.return; Z !== null; ) {
                            var le = Z.tag;
                            if ((le === 3 || le === 4) && Z.stateNode.containerInfo === T)
                                return;
                            Z = Z.return
                        }
                    for (; te !== null; ) {
                        if (Z = ba(te),
                        Z === null)
                            return;
                        if (le = Z.tag,
                        le === 5 || le === 6 || le === 26 || le === 27) {
                            x = F = Z;
                            continue e
                        }
                        te = te.parentNode
                    }
                }
                x = x.return
            }
        a6(function() {
            var ve = F
              , ke = c3(y)
              , Te = [];
            e: {
                var Se = O6.get(c);
                if (Se !== void 0) {
                    var Ce = hb
                      , it = c;
                    switch (c) {
                    case "keypress":
                        if (db(y) === 0)
                            break e;
                    case "keydown":
                    case "keyup":
                        Ce = vY;
                        break;
                    case "focusin":
                        it = "focus",
                        Ce = m3;
                        break;
                    case "focusout":
                        it = "blur",
                        Ce = m3;
                        break;
                    case "beforeblur":
                    case "afterblur":
                        Ce = m3;
                        break;
                    case "click":
                        if (y.button === 2)
                            break e;
                    case "auxclick":
                    case "dblclick":
                    case "mousedown":
                    case "mousemove":
                    case "mouseup":
                    case "mouseout":
                    case "mouseover":
                    case "contextmenu":
                        Ce = u6;
                        break;
                    case "drag":
                    case "dragend":
                    case "dragenter":
                    case "dragexit":
                    case "dragleave":
                    case "dragover":
                    case "dragstart":
                    case "drop":
                        Ce = lY;
                        break;
                    case "touchcancel":
                    case "touchend":
                    case "touchmove":
                    case "touchstart":
                        Ce = SY;
                        break;
                    case I6:
                    case M6:
                    case B6:
                        Ce = dY;
                        break;
                    case R6:
                        Ce = CY;
                        break;
                    case "scroll":
                    case "scrollend":
                        Ce = oY;
                        break;
                    case "wheel":
                        Ce = kY;
                        break;
                    case "copy":
                    case "cut":
                    case "paste":
                        Ce = hY;
                        break;
                    case "gotpointercapture":
                    case "lostpointercapture":
                    case "pointercancel":
                    case "pointerdown":
                    case "pointermove":
                    case "pointerout":
                    case "pointerover":
                    case "pointerup":
                        Ce = f6;
                        break;
                    case "toggle":
                    case "beforetoggle":
                        Ce = DY
                    }
                    var vt = (f & 4) !== 0
                      , In = !vt && (c === "scroll" || c === "scrollend")
                      , pe = vt ? Se !== null ? Se + "Capture" : null : Se;
                    vt = [];
                    for (var de = ve, we; de !== null; ) {
                        var Ne = de;
                        if (we = Ne.stateNode,
                        Ne = Ne.tag,
                        Ne !== 5 && Ne !== 26 && Ne !== 27 || we === null || pe === null || (Ne = $0(de, pe),
                        Ne != null && vt.push(xm(de, Ne, we))),
                        In)
                            break;
                        de = de.return
                    }
                    0 < vt.length && (Se = new Ce(Se,it,null,y,ke),
                    Te.push({
                        event: Se,
                        listeners: vt
                    }))
                }
            }
            if ((f & 7) === 0) {
                e: {
                    if (Se = c === "mouseover" || c === "pointerover",
                    Ce = c === "mouseout" || c === "pointerout",
                    Se && y !== l3 && (it = y.relatedTarget || y.fromElement) && (ba(it) || it[ll]))
                        break e;
                    if ((Ce || Se) && (Se = ke.window === ke ? ke : (Se = ke.ownerDocument) ? Se.defaultView || Se.parentWindow : window,
                    Ce ? (it = y.relatedTarget || y.toElement,
                    Ce = ve,
                    it = it ? ba(it) : null,
                    it !== null && (In = i(it),
                    vt = it.tag,
                    it !== In || vt !== 5 && vt !== 27 && vt !== 6) && (it = null)) : (Ce = null,
                    it = ve),
                    Ce !== it)) {
                        if (vt = u6,
                        Ne = "onMouseLeave",
                        pe = "onMouseEnter",
                        de = "mouse",
                        (c === "pointerout" || c === "pointerover") && (vt = f6,
                        Ne = "onPointerLeave",
                        pe = "onPointerEnter",
                        de = "pointer"),
                        In = Ce == null ? Se : ul(Ce),
                        we = it == null ? Se : ul(it),
                        Se = new vt(Ne,de + "leave",Ce,y,ke),
                        Se.target = In,
                        Se.relatedTarget = we,
                        Ne = null,
                        ba(ke) === ve && (vt = new vt(pe,de + "enter",it,y,ke),
                        vt.target = we,
                        vt.relatedTarget = In,
                        Ne = vt),
                        In = Ne,
                        Ce && it)
                            t: {
                                for (vt = NK,
                                pe = Ce,
                                de = it,
                                we = 0,
                                Ne = pe; Ne; Ne = vt(Ne))
                                    we++;
                                Ne = 0;
                                for (var yt = de; yt; yt = vt(yt))
                                    Ne++;
                                for (; 0 < we - Ne; )
                                    pe = vt(pe),
                                    we--;
                                for (; 0 < Ne - we; )
                                    de = vt(de),
                                    Ne--;
                                for (; we--; ) {
                                    if (pe === de || de !== null && pe === de.alternate) {
                                        vt = pe;
                                        break t
                                    }
                                    pe = vt(pe),
                                    de = vt(de)
                                }
                                vt = null
                            }
                        else
                            vt = null;
                        Ce !== null && rT(Te, Se, Ce, vt, !1),
                        it !== null && In !== null && rT(Te, In, it, vt, !0)
                    }
                }
                e: {
                    if (Se = ve ? ul(ve) : window,
                    Ce = Se.nodeName && Se.nodeName.toLowerCase(),
                    Ce === "select" || Ce === "input" && Se.type === "file")
                        var un = v6;
                    else if (b6(Se))
                        if (x6)
                            un = FY;
                        else {
                            un = jY;
                            var ft = PY
                        }
                    else
                        Ce = Se.nodeName,
                        !Ce || Ce.toLowerCase() !== "input" || Se.type !== "checkbox" && Se.type !== "radio" ? ve && a3(ve.elementType) && (un = v6) : un = LY;
                    if (un && (un = un(c, ve))) {
                        w6(Te, un, y, ke);
                        break e
                    }
                    ft && ft(c, Se, ve),
                    c === "focusout" && ve && Se.type === "number" && ve.memoizedProps.value != null && o3(Se, "number", Se.value)
                }
                switch (ft = ve ? ul(ve) : window,
                c) {
                case "focusin":
                    (b6(ft) || ft.contentEditable === "true") && (hh = ft,
                    x3 = ve,
                    X0 = null);
                    break;
                case "focusout":
                    X0 = x3 = hh = null;
                    break;
                case "mousedown":
                    E3 = !0;
                    break;
                case "contextmenu":
                case "mouseup":
                case "dragend":
                    E3 = !1,
                    D6(Te, y, ke);
                    break;
                case "selectionchange":
                    if (zY)
                        break;
                case "keydown":
                case "keyup":
                    D6(Te, y, ke)
                }
                var It;
                if (y3)
                    e: {
                        switch (c) {
                        case "compositionstart":
                            var Yt = "onCompositionStart";
                            break e;
                        case "compositionend":
                            Yt = "onCompositionEnd";
                            break e;
                        case "compositionupdate":
                            Yt = "onCompositionUpdate";
                            break e
                        }
                        Yt = void 0
                    }
                else
                    fh ? g6(c, y) && (Yt = "onCompositionEnd") : c === "keydown" && y.keyCode === 229 && (Yt = "onCompositionStart");
                Yt && (h6 && y.locale !== "ko" && (fh || Yt !== "onCompositionStart" ? Yt === "onCompositionEnd" && fh && (It = l6()) : (zc = ke,
                f3 = "value"in zc ? zc.value : zc.textContent,
                fh = !0)),
                ft = r1(ve, Yt),
                0 < ft.length && (Yt = new d6(Yt,c,null,y,ke),
                Te.push({
                    event: Yt,
                    listeners: ft
                }),
                It ? Yt.data = It : (It = y6(y),
                It !== null && (Yt.data = It)))),
                (It = IY ? MY(c, y) : BY(c, y)) && (Yt = r1(ve, "onBeforeInput"),
                0 < Yt.length && (ft = new d6("onBeforeInput","beforeinput",null,y,ke),
                Te.push({
                    event: ft,
                    listeners: Yt
                }),
                ft.data = It)),
                AK(Te, c, ve, y, ke)
            }
            tT(Te, f)
        })
    }
    function xm(c, f, y) {
        return {
            instance: c,
            listener: f,
            currentTarget: y
        }
    }
    function r1(c, f) {
        for (var y = f + "Capture", x = []; c !== null; ) {
            var T = c
              , F = T.stateNode;
            if (T = T.tag,
            T !== 5 && T !== 26 && T !== 27 || F === null || (T = $0(c, y),
            T != null && x.unshift(xm(c, T, F)),
            T = $0(c, f),
            T != null && x.push(xm(c, T, F))),
            c.tag === 3)
                return x;
            c = c.return
        }
        return []
    }
    function NK(c) {
        if (c === null)
            return null;
        do
            c = c.return;
        while (c && c.tag !== 5 && c.tag !== 27);
        return c || null
    }
    function rT(c, f, y, x, T) {
        for (var F = f._reactName, Z = []; y !== null && y !== x; ) {
            var te = y
              , le = te.alternate
              , ve = te.stateNode;
            if (te = te.tag,
            le !== null && le === x)
                break;
            te !== 5 && te !== 26 && te !== 27 || ve === null || (le = ve,
            T ? (ve = $0(y, F),
            ve != null && Z.unshift(xm(y, ve, le))) : T || (ve = $0(y, F),
            ve != null && Z.push(xm(y, ve, le)))),
            y = y.return
        }
        Z.length !== 0 && c.push({
            event: f,
            listeners: Z
        })
    }
    var DK = /\r\n?/g
      , TK = /\u0000|\uFFFD/g;
    function sT(c) {
        return (typeof c == "string" ? c : "" + c).replace(DK, `
`).replace(TK, "")
    }
    function iT(c, f) {
        return f = sT(f),
        sT(c) === f
    }
    function Tn(c, f, y, x, T, F) {
        switch (y) {
        case "children":
            typeof x == "string" ? f === "body" || f === "textarea" && x === "" || ch(c, x) : (typeof x == "number" || typeof x == "bigint") && f !== "body" && ch(c, "" + x);
            break;
        case "className":
            Uc(c, "class", x);
            break;
        case "tabIndex":
            Uc(c, "tabindex", x);
            break;
        case "dir":
        case "role":
        case "viewBox":
        case "width":
        case "height":
            Uc(c, y, x);
            break;
        case "style":
            i6(c, x, F);
            break;
        case "data":
            if (f !== "object") {
                Uc(c, "data", x);
                break
            }
        case "src":
        case "href":
            if (x === "" && (f !== "a" || y !== "href")) {
                c.removeAttribute(y);
                break
            }
            if (x == null || typeof x == "function" || typeof x == "symbol" || typeof x == "boolean") {
                c.removeAttribute(y);
                break
            }
            x = cb("" + x),
            c.setAttribute(y, x);
            break;
        case "action":
        case "formAction":
            if (typeof x == "function") {
                c.setAttribute(y, "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");
                break
            } else
                typeof F == "function" && (y === "formAction" ? (f !== "input" && Tn(c, f, "name", T.name, T, null),
                Tn(c, f, "formEncType", T.formEncType, T, null),
                Tn(c, f, "formMethod", T.formMethod, T, null),
                Tn(c, f, "formTarget", T.formTarget, T, null)) : (Tn(c, f, "encType", T.encType, T, null),
                Tn(c, f, "method", T.method, T, null),
                Tn(c, f, "target", T.target, T, null)));
            if (x == null || typeof x == "symbol" || typeof x == "boolean") {
                c.removeAttribute(y);
                break
            }
            x = cb("" + x),
            c.setAttribute(y, x);
            break;
        case "onClick":
            x != null && (c.onclick = fl);
            break;
        case "onScroll":
            x != null && qt("scroll", c);
            break;
        case "onScrollEnd":
            x != null && qt("scrollend", c);
            break;
        case "dangerouslySetInnerHTML":
            if (x != null) {
                if (typeof x != "object" || !("__html"in x))
                    throw Error(r(61));
                if (y = x.__html,
                y != null) {
                    if (T.children != null)
                        throw Error(r(60));
                    c.innerHTML = y
                }
            }
            break;
        case "multiple":
            c.multiple = x && typeof x != "function" && typeof x != "symbol";
            break;
        case "muted":
            c.muted = x && typeof x != "function" && typeof x != "symbol";
            break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "ref":
            break;
        case "autoFocus":
            break;
        case "xlinkHref":
            if (x == null || typeof x == "function" || typeof x == "boolean" || typeof x == "symbol") {
                c.removeAttribute("xlink:href");
                break
            }
            y = cb("" + x),
            c.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", y);
            break;
        case "contentEditable":
        case "spellCheck":
        case "draggable":
        case "value":
        case "autoReverse":
        case "externalResourcesRequired":
        case "focusable":
        case "preserveAlpha":
            x != null && typeof x != "function" && typeof x != "symbol" ? c.setAttribute(y, "" + x) : c.removeAttribute(y);
            break;
        case "inert":
        case "allowFullScreen":
        case "async":
        case "autoPlay":
        case "controls":
        case "default":
        case "defer":
        case "disabled":
        case "disablePictureInPicture":
        case "disableRemotePlayback":
        case "formNoValidate":
        case "hidden":
        case "loop":
        case "noModule":
        case "noValidate":
        case "open":
        case "playsInline":
        case "readOnly":
        case "required":
        case "reversed":
        case "scoped":
        case "seamless":
        case "itemScope":
            x && typeof x != "function" && typeof x != "symbol" ? c.setAttribute(y, "") : c.removeAttribute(y);
            break;
        case "capture":
        case "download":
            x === !0 ? c.setAttribute(y, "") : x !== !1 && x != null && typeof x != "function" && typeof x != "symbol" ? c.setAttribute(y, x) : c.removeAttribute(y);
            break;
        case "cols":
        case "rows":
        case "size":
        case "span":
            x != null && typeof x != "function" && typeof x != "symbol" && !isNaN(x) && 1 <= x ? c.setAttribute(y, x) : c.removeAttribute(y);
            break;
        case "rowSpan":
        case "start":
            x == null || typeof x == "function" || typeof x == "symbol" || isNaN(x) ? c.removeAttribute(y) : c.setAttribute(y, x);
            break;
        case "popover":
            qt("beforetoggle", c),
            qt("toggle", c),
            Fc(c, "popover", x);
            break;
        case "xlinkActuate":
            dl(c, "http://www.w3.org/1999/xlink", "xlink:actuate", x);
            break;
        case "xlinkArcrole":
            dl(c, "http://www.w3.org/1999/xlink", "xlink:arcrole", x);
            break;
        case "xlinkRole":
            dl(c, "http://www.w3.org/1999/xlink", "xlink:role", x);
            break;
        case "xlinkShow":
            dl(c, "http://www.w3.org/1999/xlink", "xlink:show", x);
            break;
        case "xlinkTitle":
            dl(c, "http://www.w3.org/1999/xlink", "xlink:title", x);
            break;
        case "xlinkType":
            dl(c, "http://www.w3.org/1999/xlink", "xlink:type", x);
            break;
        case "xmlBase":
            dl(c, "http://www.w3.org/XML/1998/namespace", "xml:base", x);
            break;
        case "xmlLang":
            dl(c, "http://www.w3.org/XML/1998/namespace", "xml:lang", x);
            break;
        case "xmlSpace":
            dl(c, "http://www.w3.org/XML/1998/namespace", "xml:space", x);
            break;
        case "is":
            Fc(c, "is", x);
            break;
        case "innerText":
        case "textContent":
            break;
        default:
            (!(2 < y.length) || y[0] !== "o" && y[0] !== "O" || y[1] !== "n" && y[1] !== "N") && (y = sY.get(y) || y,
            Fc(c, y, x))
        }
    }
    function WE(c, f, y, x, T, F) {
        switch (y) {
        case "style":
            i6(c, x, F);
            break;
        case "dangerouslySetInnerHTML":
            if (x != null) {
                if (typeof x != "object" || !("__html"in x))
                    throw Error(r(61));
                if (y = x.__html,
                y != null) {
                    if (T.children != null)
                        throw Error(r(60));
                    c.innerHTML = y
                }
            }
            break;
        case "children":
            typeof x == "string" ? ch(c, x) : (typeof x == "number" || typeof x == "bigint") && ch(c, "" + x);
            break;
        case "onScroll":
            x != null && qt("scroll", c);
            break;
        case "onScrollEnd":
            x != null && qt("scrollend", c);
            break;
        case "onClick":
            x != null && (c.onclick = fl);
            break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "innerHTML":
        case "ref":
            break;
        case "innerText":
        case "textContent":
            break;
        default:
            if (!ih.hasOwnProperty(y))
                e: {
                    if (y[0] === "o" && y[1] === "n" && (T = y.endsWith("Capture"),
                    f = y.slice(2, T ? y.length - 7 : void 0),
                    F = c[Ht] || null,
                    F = F != null ? F[y] : null,
                    typeof F == "function" && c.removeEventListener(f, F, T),
                    typeof x == "function")) {
                        typeof F != "function" && F !== null && (y in c ? c[y] = null : c.hasAttribute(y) && c.removeAttribute(y)),
                        c.addEventListener(f, x, T);
                        break e
                    }
                    y in c ? c[y] = x : x === !0 ? c.setAttribute(y, "") : Fc(c, y, x)
                }
        }
    }
    function ls(c, f, y) {
        switch (f) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
            break;
        case "img":
            qt("error", c),
            qt("load", c);
            var x = !1, T = !1, F;
            for (F in y)
                if (y.hasOwnProperty(F)) {
                    var Z = y[F];
                    if (Z != null)
                        switch (F) {
                        case "src":
                            x = !0;
                            break;
                        case "srcSet":
                            T = !0;
                            break;
                        case "children":
                        case "dangerouslySetInnerHTML":
                            throw Error(r(137, f));
                        default:
                            Tn(c, f, F, Z, y, null)
                        }
                }
            T && Tn(c, f, "srcSet", y.srcSet, y, null),
            x && Tn(c, f, "src", y.src, y, null);
            return;
        case "input":
            qt("invalid", c);
            var te = F = Z = T = null
              , le = null
              , ve = null;
            for (x in y)
                if (y.hasOwnProperty(x)) {
                    var ke = y[x];
                    if (ke != null)
                        switch (x) {
                        case "name":
                            T = ke;
                            break;
                        case "type":
                            Z = ke;
                            break;
                        case "checked":
                            le = ke;
                            break;
                        case "defaultChecked":
                            ve = ke;
                            break;
                        case "value":
                            F = ke;
                            break;
                        case "defaultValue":
                            te = ke;
                            break;
                        case "children":
                        case "dangerouslySetInnerHTML":
                            if (ke != null)
                                throw Error(r(137, f));
                            break;
                        default:
                            Tn(c, f, x, ke, y, null)
                        }
                }
            t6(c, F, te, le, ve, Z, T, !1);
            return;
        case "select":
            qt("invalid", c),
            x = Z = F = null;
            for (T in y)
                if (y.hasOwnProperty(T) && (te = y[T],
                te != null))
                    switch (T) {
                    case "value":
                        F = te;
                        break;
                    case "defaultValue":
                        Z = te;
                        break;
                    case "multiple":
                        x = te;
                    default:
                        Tn(c, f, T, te, y, null)
                    }
            f = F,
            y = Z,
            c.multiple = !!x,
            f != null ? lh(c, !!x, f, !1) : y != null && lh(c, !!x, y, !0);
            return;
        case "textarea":
            qt("invalid", c),
            F = T = x = null;
            for (Z in y)
                if (y.hasOwnProperty(Z) && (te = y[Z],
                te != null))
                    switch (Z) {
                    case "value":
                        x = te;
                        break;
                    case "defaultValue":
                        T = te;
                        break;
                    case "children":
                        F = te;
                        break;
                    case "dangerouslySetInnerHTML":
                        if (te != null)
                            throw Error(r(91));
                        break;
                    default:
                        Tn(c, f, Z, te, y, null)
                    }
            r6(c, x, T, F);
            return;
        case "option":
            for (le in y)
                if (y.hasOwnProperty(le) && (x = y[le],
                x != null))
                    switch (le) {
                    case "selected":
                        c.selected = x && typeof x != "function" && typeof x != "symbol";
                        break;
                    default:
                        Tn(c, f, le, x, y, null)
                    }
            return;
        case "dialog":
            qt("beforetoggle", c),
            qt("toggle", c),
            qt("cancel", c),
            qt("close", c);
            break;
        case "iframe":
        case "object":
            qt("load", c);
            break;
        case "video":
        case "audio":
            for (x = 0; x < vm.length; x++)
                qt(vm[x], c);
            break;
        case "image":
            qt("error", c),
            qt("load", c);
            break;
        case "details":
            qt("toggle", c);
            break;
        case "embed":
        case "source":
        case "link":
            qt("error", c),
            qt("load", c);
        case "area":
        case "base":
        case "br":
        case "col":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "track":
        case "wbr":
        case "menuitem":
            for (ve in y)
                if (y.hasOwnProperty(ve) && (x = y[ve],
                x != null))
                    switch (ve) {
                    case "children":
                    case "dangerouslySetInnerHTML":
                        throw Error(r(137, f));
                    default:
                        Tn(c, f, ve, x, y, null)
                    }
            return;
        default:
            if (a3(f)) {
                for (ke in y)
                    y.hasOwnProperty(ke) && (x = y[ke],
                    x !== void 0 && WE(c, f, ke, x, y, void 0));
                return
            }
        }
        for (te in y)
            y.hasOwnProperty(te) && (x = y[te],
            x != null && Tn(c, f, te, x, y, null))
    }
    function IK(c, f, y, x) {
        switch (f) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
            break;
        case "input":
            var T = null
              , F = null
              , Z = null
              , te = null
              , le = null
              , ve = null
              , ke = null;
            for (Ce in y) {
                var Te = y[Ce];
                if (y.hasOwnProperty(Ce) && Te != null)
                    switch (Ce) {
                    case "checked":
                        break;
                    case "value":
                        break;
                    case "defaultValue":
                        le = Te;
                    default:
                        x.hasOwnProperty(Ce) || Tn(c, f, Ce, null, x, Te)
                    }
            }
            for (var Se in x) {
                var Ce = x[Se];
                if (Te = y[Se],
                x.hasOwnProperty(Se) && (Ce != null || Te != null))
                    switch (Se) {
                    case "type":
                        F = Ce;
                        break;
                    case "name":
                        T = Ce;
                        break;
                    case "checked":
                        ve = Ce;
                        break;
                    case "defaultChecked":
                        ke = Ce;
                        break;
                    case "value":
                        Z = Ce;
                        break;
                    case "defaultValue":
                        te = Ce;
                        break;
                    case "children":
                    case "dangerouslySetInnerHTML":
                        if (Ce != null)
                            throw Error(r(137, f));
                        break;
                    default:
                        Ce !== Te && Tn(c, f, Se, Ce, x, Te)
                    }
            }
            i3(c, Z, te, le, ve, ke, F, T);
            return;
        case "select":
            Ce = Z = te = Se = null;
            for (F in y)
                if (le = y[F],
                y.hasOwnProperty(F) && le != null)
                    switch (F) {
                    case "value":
                        break;
                    case "multiple":
                        Ce = le;
                    default:
                        x.hasOwnProperty(F) || Tn(c, f, F, null, x, le)
                    }
            for (T in x)
                if (F = x[T],
                le = y[T],
                x.hasOwnProperty(T) && (F != null || le != null))
                    switch (T) {
                    case "value":
                        Se = F;
                        break;
                    case "defaultValue":
                        te = F;
                        break;
                    case "multiple":
                        Z = F;
                    default:
                        F !== le && Tn(c, f, T, F, x, le)
                    }
            f = te,
            y = Z,
            x = Ce,
            Se != null ? lh(c, !!y, Se, !1) : !!x != !!y && (f != null ? lh(c, !!y, f, !0) : lh(c, !!y, y ? [] : "", !1));
            return;
        case "textarea":
            Ce = Se = null;
            for (te in y)
                if (T = y[te],
                y.hasOwnProperty(te) && T != null && !x.hasOwnProperty(te))
                    switch (te) {
                    case "value":
                        break;
                    case "children":
                        break;
                    default:
                        Tn(c, f, te, null, x, T)
                    }
            for (Z in x)
                if (T = x[Z],
                F = y[Z],
                x.hasOwnProperty(Z) && (T != null || F != null))
                    switch (Z) {
                    case "value":
                        Se = T;
                        break;
                    case "defaultValue":
                        Ce = T;
                        break;
                    case "children":
                        break;
                    case "dangerouslySetInnerHTML":
                        if (T != null)
                            throw Error(r(91));
                        break;
                    default:
                        T !== F && Tn(c, f, Z, T, x, F)
                    }
            n6(c, Se, Ce);
            return;
        case "option":
            for (var it in y)
                if (Se = y[it],
                y.hasOwnProperty(it) && Se != null && !x.hasOwnProperty(it))
                    switch (it) {
                    case "selected":
                        c.selected = !1;
                        break;
                    default:
                        Tn(c, f, it, null, x, Se)
                    }
            for (le in x)
                if (Se = x[le],
                Ce = y[le],
                x.hasOwnProperty(le) && Se !== Ce && (Se != null || Ce != null))
                    switch (le) {
                    case "selected":
                        c.selected = Se && typeof Se != "function" && typeof Se != "symbol";
                        break;
                    default:
                        Tn(c, f, le, Se, x, Ce)
                    }
            return;
        case "img":
        case "link":
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
        case "menuitem":
            for (var vt in y)
                Se = y[vt],
                y.hasOwnProperty(vt) && Se != null && !x.hasOwnProperty(vt) && Tn(c, f, vt, null, x, Se);
            for (ve in x)
                if (Se = x[ve],
                Ce = y[ve],
                x.hasOwnProperty(ve) && Se !== Ce && (Se != null || Ce != null))
                    switch (ve) {
                    case "children":
                    case "dangerouslySetInnerHTML":
                        if (Se != null)
                            throw Error(r(137, f));
                        break;
                    default:
                        Tn(c, f, ve, Se, x, Ce)
                    }
            return;
        default:
            if (a3(f)) {
                for (var In in y)
                    Se = y[In],
                    y.hasOwnProperty(In) && Se !== void 0 && !x.hasOwnProperty(In) && WE(c, f, In, void 0, x, Se);
                for (ke in x)
                    Se = x[ke],
                    Ce = y[ke],
                    !x.hasOwnProperty(ke) || Se === Ce || Se === void 0 && Ce === void 0 || WE(c, f, ke, Se, x, Ce);
                return
            }
        }
        for (var pe in y)
            Se = y[pe],
            y.hasOwnProperty(pe) && Se != null && !x.hasOwnProperty(pe) && Tn(c, f, pe, null, x, Se);
        for (Te in x)
            Se = x[Te],
            Ce = y[Te],
            !x.hasOwnProperty(Te) || Se === Ce || Se == null && Ce == null || Tn(c, f, Te, Se, x, Ce)
    }
    function oT(c) {
        switch (c) {
        case "css":
        case "script":
        case "font":
        case "img":
        case "image":
        case "input":
        case "link":
            return !0;
        default:
            return !1
        }
    }
    function MK() {
        if (typeof performance.getEntriesByType == "function") {
            for (var c = 0, f = 0, y = performance.getEntriesByType("resource"), x = 0; x < y.length; x++) {
                var T = y[x]
                  , F = T.transferSize
                  , Z = T.initiatorType
                  , te = T.duration;
                if (F && te && oT(Z)) {
                    for (Z = 0,
                    te = T.responseEnd,
                    x += 1; x < y.length; x++) {
                        var le = y[x]
                          , ve = le.startTime;
                        if (ve > te)
                            break;
                        var ke = le.transferSize
                          , Te = le.initiatorType;
                        ke && oT(Te) && (le = le.responseEnd,
                        Z += ke * (le < te ? 1 : (te - ve) / (le - ve)))
                    }
                    if (--x,
                    f += 8 * (F + Z) / (T.duration / 1e3),
                    c++,
                    10 < c)
                        break
                }
            }
            if (0 < c)
                return f / c / 1e6
        }
        return navigator.connection && (c = navigator.connection.downlink,
        typeof c == "number") ? c : 5
    }
    var YE = null
      , KE = null;
    function s1(c) {
        return c.nodeType === 9 ? c : c.ownerDocument
    }
    function aT(c) {
        switch (c) {
        case "http://www.w3.org/2000/svg":
            return 1;
        case "http://www.w3.org/1998/Math/MathML":
            return 2;
        default:
            return 0
        }
    }
    function lT(c, f) {
        if (c === 0)
            switch (f) {
            case "svg":
                return 1;
            case "math":
                return 2;
            default:
                return 0
            }
        return c === 1 && f === "foreignObject" ? 0 : c
    }
    function XE(c, f) {
        return c === "textarea" || c === "noscript" || typeof f.children == "string" || typeof f.children == "number" || typeof f.children == "bigint" || typeof f.dangerouslySetInnerHTML == "object" && f.dangerouslySetInnerHTML !== null && f.dangerouslySetInnerHTML.__html != null
    }
    var QE = null;
    function BK() {
        var c = window.event;
        return c && c.type === "popstate" ? c === QE ? !1 : (QE = c,
        !0) : (QE = null,
        !1)
    }
    var cT = typeof setTimeout == "function" ? setTimeout : void 0
      , RK = typeof clearTimeout == "function" ? clearTimeout : void 0
      , uT = typeof Promise == "function" ? Promise : void 0
      , OK = typeof queueMicrotask == "function" ? queueMicrotask : typeof uT < "u" ? function(c) {
        return uT.resolve(null).then(c).catch(PK)
    }
    : cT;
    function PK(c) {
        setTimeout(function() {
            throw c
        })
    }
    function su(c) {
        return c === "head"
    }
    function dT(c, f) {
        var y = f
          , x = 0;
        do {
            var T = y.nextSibling;
            if (c.removeChild(y),
            T && T.nodeType === 8)
                if (y = T.data,
                y === "/$" || y === "/&") {
                    if (x === 0) {
                        c.removeChild(T),
                        Uh(f);
                        return
                    }
                    x--
                } else if (y === "$" || y === "$?" || y === "$~" || y === "$!" || y === "&")
                    x++;
                else if (y === "html")
                    Em(c.ownerDocument.documentElement);
                else if (y === "head") {
                    y = c.ownerDocument.head,
                    Em(y);
                    for (var F = y.firstChild; F; ) {
                        var Z = F.nextSibling
                          , te = F.nodeName;
                        F[cl] || te === "SCRIPT" || te === "STYLE" || te === "LINK" && F.rel.toLowerCase() === "stylesheet" || y.removeChild(F),
                        F = Z
                    }
                } else
                    y === "body" && Em(c.ownerDocument.body);
            y = T
        } while (y);
        Uh(f)
    }
    function fT(c, f) {
        var y = c;
        c = 0;
        do {
            var x = y.nextSibling;
            if (y.nodeType === 1 ? f ? (y._stashedDisplay = y.style.display,
            y.style.display = "none") : (y.style.display = y._stashedDisplay || "",
            y.getAttribute("style") === "" && y.removeAttribute("style")) : y.nodeType === 3 && (f ? (y._stashedText = y.nodeValue,
            y.nodeValue = "") : y.nodeValue = y._stashedText || ""),
            x && x.nodeType === 8)
                if (y = x.data,
                y === "/$") {
                    if (c === 0)
                        break;
                    c--
                } else
                    y !== "$" && y !== "$?" && y !== "$~" && y !== "$!" || c++;
            y = x
        } while (y)
    }
    function ZE(c) {
        var f = c.firstChild;
        for (f && f.nodeType === 10 && (f = f.nextSibling); f; ) {
            var y = f;
            switch (f = f.nextSibling,
            y.nodeName) {
            case "HTML":
            case "HEAD":
            case "BODY":
                ZE(y),
                fd(y);
                continue;
            case "SCRIPT":
            case "STYLE":
                continue;
            case "LINK":
                if (y.rel.toLowerCase() === "stylesheet")
                    continue
            }
            c.removeChild(y)
        }
    }
    function jK(c, f, y, x) {
        for (; c.nodeType === 1; ) {
            var T = y;
            if (c.nodeName.toLowerCase() !== f.toLowerCase()) {
                if (!x && (c.nodeName !== "INPUT" || c.type !== "hidden"))
                    break
            } else if (x) {
                if (!c[cl])
                    switch (f) {
                    case "meta":
                        if (!c.hasAttribute("itemprop"))
                            break;
                        return c;
                    case "link":
                        if (F = c.getAttribute("rel"),
                        F === "stylesheet" && c.hasAttribute("data-precedence"))
                            break;
                        if (F !== T.rel || c.getAttribute("href") !== (T.href == null || T.href === "" ? null : T.href) || c.getAttribute("crossorigin") !== (T.crossOrigin == null ? null : T.crossOrigin) || c.getAttribute("title") !== (T.title == null ? null : T.title))
                            break;
                        return c;
                    case "style":
                        if (c.hasAttribute("data-precedence"))
                            break;
                        return c;
                    case "script":
                        if (F = c.getAttribute("src"),
                        (F !== (T.src == null ? null : T.src) || c.getAttribute("type") !== (T.type == null ? null : T.type) || c.getAttribute("crossorigin") !== (T.crossOrigin == null ? null : T.crossOrigin)) && F && c.hasAttribute("async") && !c.hasAttribute("itemprop"))
                            break;
                        return c;
                    default:
                        return c
                    }
            } else if (f === "input" && c.type === "hidden") {
                var F = T.name == null ? null : "" + T.name;
                if (T.type === "hidden" && c.getAttribute("name") === F)
                    return c
            } else
                return c;
            if (c = ho(c.nextSibling),
            c === null)
                break
        }
        return null
    }
    function LK(c, f, y) {
        if (f === "")
            return null;
        for (; c.nodeType !== 3; )
            if ((c.nodeType !== 1 || c.nodeName !== "INPUT" || c.type !== "hidden") && !y || (c = ho(c.nextSibling),
            c === null))
                return null;
        return c
    }
    function hT(c, f) {
        for (; c.nodeType !== 8; )
            if ((c.nodeType !== 1 || c.nodeName !== "INPUT" || c.type !== "hidden") && !f || (c = ho(c.nextSibling),
            c === null))
                return null;
        return c
    }
    function JE(c) {
        return c.data === "$?" || c.data === "$~"
    }
    function eS(c) {
        return c.data === "$!" || c.data === "$?" && c.ownerDocument.readyState !== "loading"
    }
    function FK(c, f) {
        var y = c.ownerDocument;
        if (c.data === "$~")
            c._reactRetry = f;
        else if (c.data !== "$?" || y.readyState !== "loading")
            f();
        else {
            var x = function() {
                f(),
                y.removeEventListener("DOMContentLoaded", x)
            };
            y.addEventListener("DOMContentLoaded", x),
            c._reactRetry = x
        }
    }
    function ho(c) {
        for (; c != null; c = c.nextSibling) {
            var f = c.nodeType;
            if (f === 1 || f === 3)
                break;
            if (f === 8) {
                if (f = c.data,
                f === "$" || f === "$!" || f === "$?" || f === "$~" || f === "&" || f === "F!" || f === "F")
                    break;
                if (f === "/$" || f === "/&")
                    return null
            }
        }
        return c
    }
    var tS = null;
    function pT(c) {
        c = c.nextSibling;
        for (var f = 0; c; ) {
            if (c.nodeType === 8) {
                var y = c.data;
                if (y === "/$" || y === "/&") {
                    if (f === 0)
                        return ho(c.nextSibling);
                    f--
                } else
                    y !== "$" && y !== "$!" && y !== "$?" && y !== "$~" && y !== "&" || f++
            }
            c = c.nextSibling
        }
        return null
    }
    function mT(c) {
        c = c.previousSibling;
        for (var f = 0; c; ) {
            if (c.nodeType === 8) {
                var y = c.data;
                if (y === "$" || y === "$!" || y === "$?" || y === "$~" || y === "&") {
                    if (f === 0)
                        return c;
                    f--
                } else
                    y !== "/$" && y !== "/&" || f++
            }
            c = c.previousSibling
        }
        return null
    }
    function gT(c, f, y) {
        switch (f = s1(y),
        c) {
        case "html":
            if (c = f.documentElement,
            !c)
                throw Error(r(452));
            return c;
        case "head":
            if (c = f.head,
            !c)
                throw Error(r(453));
            return c;
        case "body":
            if (c = f.body,
            !c)
                throw Error(r(454));
            return c;
        default:
            throw Error(r(451))
        }
    }
    function Em(c) {
        for (var f = c.attributes; f.length; )
            c.removeAttributeNode(f[0]);
        fd(c)
    }
    var po = new Map
      , yT = new Set;
    function i1(c) {
        return typeof c.getRootNode == "function" ? c.getRootNode() : c.nodeType === 9 ? c : c.ownerDocument
    }
    var Nl = O.d;
    O.d = {
        f: UK,
        r: zK,
        D: $K,
        C: HK,
        L: VK,
        m: qK,
        X: WK,
        S: GK,
        M: YK
    };
    function UK() {
        var c = Nl.f()
          , f = Xb();
        return c || f
    }
    function zK(c) {
        var f = wa(c);
        f !== null && f.tag === 5 && f.type === "form" ? RN(f) : Nl.r(c)
    }
    var jh = typeof document > "u" ? null : document;
    function bT(c, f, y) {
        var x = jh;
        if (x && typeof f == "string" && f) {
            var T = io(f);
            T = 'link[rel="' + c + '"][href="' + T + '"]',
            typeof y == "string" && (T += '[crossorigin="' + y + '"]'),
            yT.has(T) || (yT.add(T),
            c = {
                rel: c,
                crossOrigin: y,
                href: f
            },
            x.querySelector(T) === null && (f = x.createElement("link"),
            ls(f, "link", c),
            lr(f),
            x.head.appendChild(f)))
        }
    }
    function $K(c) {
        Nl.D(c),
        bT("dns-prefetch", c, null)
    }
    function HK(c, f) {
        Nl.C(c, f),
        bT("preconnect", c, f)
    }
    function VK(c, f, y) {
        Nl.L(c, f, y);
        var x = jh;
        if (x && c && f) {
            var T = 'link[rel="preload"][as="' + io(f) + '"]';
            f === "image" && y && y.imageSrcSet ? (T += '[imagesrcset="' + io(y.imageSrcSet) + '"]',
            typeof y.imageSizes == "string" && (T += '[imagesizes="' + io(y.imageSizes) + '"]')) : T += '[href="' + io(c) + '"]';
            var F = T;
            switch (f) {
            case "style":
                F = Lh(c);
                break;
            case "script":
                F = Fh(c)
            }
            po.has(F) || (c = h({
                rel: "preload",
                href: f === "image" && y && y.imageSrcSet ? void 0 : c,
                as: f
            }, y),
            po.set(F, c),
            x.querySelector(T) !== null || f === "style" && x.querySelector(Sm(F)) || f === "script" && x.querySelector(Am(F)) || (f = x.createElement("link"),
            ls(f, "link", c),
            lr(f),
            x.head.appendChild(f)))
        }
    }
    function qK(c, f) {
        Nl.m(c, f);
        var y = jh;
        if (y && c) {
            var x = f && typeof f.as == "string" ? f.as : "script"
              , T = 'link[rel="modulepreload"][as="' + io(x) + '"][href="' + io(c) + '"]'
              , F = T;
            switch (x) {
            case "audioworklet":
            case "paintworklet":
            case "serviceworker":
            case "sharedworker":
            case "worker":
            case "script":
                F = Fh(c)
            }
            if (!po.has(F) && (c = h({
                rel: "modulepreload",
                href: c
            }, f),
            po.set(F, c),
            y.querySelector(T) === null)) {
                switch (x) {
                case "audioworklet":
                case "paintworklet":
                case "serviceworker":
                case "sharedworker":
                case "worker":
                case "script":
                    if (y.querySelector(Am(F)))
                        return
                }
                x = y.createElement("link"),
                ls(x, "link", c),
                lr(x),
                y.head.appendChild(x)
            }
        }
    }
    function GK(c, f, y) {
        Nl.S(c, f, y);
        var x = jh;
        if (x && c) {
            var T = va(x).hoistableStyles
              , F = Lh(c);
            f = f || "default";
            var Z = T.get(F);
            if (!Z) {
                var te = {
                    loading: 0,
                    preload: null
                };
                if (Z = x.querySelector(Sm(F)))
                    te.loading = 5;
                else {
                    c = h({
                        rel: "stylesheet",
                        href: c,
                        "data-precedence": f
                    }, y),
                    (y = po.get(F)) && nS(c, y);
                    var le = Z = x.createElement("link");
                    lr(le),
                    ls(le, "link", c),
                    le._p = new Promise(function(ve, ke) {
                        le.onload = ve,
                        le.onerror = ke
                    }
                    ),
                    le.addEventListener("load", function() {
                        te.loading |= 1
                    }),
                    le.addEventListener("error", function() {
                        te.loading |= 2
                    }),
                    te.loading |= 4,
                    o1(Z, f, x)
                }
                Z = {
                    type: "stylesheet",
                    instance: Z,
                    count: 1,
                    state: te
                },
                T.set(F, Z)
            }
        }
    }
    function WK(c, f) {
        Nl.X(c, f);
        var y = jh;
        if (y && c) {
            var x = va(y).hoistableScripts
              , T = Fh(c)
              , F = x.get(T);
            F || (F = y.querySelector(Am(T)),
            F || (c = h({
                src: c,
                async: !0
            }, f),
            (f = po.get(T)) && rS(c, f),
            F = y.createElement("script"),
            lr(F),
            ls(F, "link", c),
            y.head.appendChild(F)),
            F = {
                type: "script",
                instance: F,
                count: 1,
                state: null
            },
            x.set(T, F))
        }
    }
    function YK(c, f) {
        Nl.M(c, f);
        var y = jh;
        if (y && c) {
            var x = va(y).hoistableScripts
              , T = Fh(c)
              , F = x.get(T);
            F || (F = y.querySelector(Am(T)),
            F || (c = h({
                src: c,
                async: !0,
                type: "module"
            }, f),
            (f = po.get(T)) && rS(c, f),
            F = y.createElement("script"),
            lr(F),
            ls(F, "link", c),
            y.head.appendChild(F)),
            F = {
                type: "script",
                instance: F,
                count: 1,
                state: null
            },
            x.set(T, F))
        }
    }
    function wT(c, f, y, x) {
        var T = (T = J.current) ? i1(T) : null;
        if (!T)
            throw Error(r(446));
        switch (c) {
        case "meta":
        case "title":
            return null;
        case "style":
            return typeof y.precedence == "string" && typeof y.href == "string" ? (f = Lh(y.href),
            y = va(T).hoistableStyles,
            x = y.get(f),
            x || (x = {
                type: "style",
                instance: null,
                count: 0,
                state: null
            },
            y.set(f, x)),
            x) : {
                type: "void",
                instance: null,
                count: 0,
                state: null
            };
        case "link":
            if (y.rel === "stylesheet" && typeof y.href == "string" && typeof y.precedence == "string") {
                c = Lh(y.href);
                var F = va(T).hoistableStyles
                  , Z = F.get(c);
                if (Z || (T = T.ownerDocument || T,
                Z = {
                    type: "stylesheet",
                    instance: null,
                    count: 0,
                    state: {
                        loading: 0,
                        preload: null
                    }
                },
                F.set(c, Z),
                (F = T.querySelector(Sm(c))) && !F._p && (Z.instance = F,
                Z.state.loading = 5),
                po.has(c) || (y = {
                    rel: "preload",
                    as: "style",
                    href: y.href,
                    crossOrigin: y.crossOrigin,
                    integrity: y.integrity,
                    media: y.media,
                    hrefLang: y.hrefLang,
                    referrerPolicy: y.referrerPolicy
                },
                po.set(c, y),
                F || KK(T, c, y, Z.state))),
                f && x === null)
                    throw Error(r(528, ""));
                return Z
            }
            if (f && x !== null)
                throw Error(r(529, ""));
            return null;
        case "script":
            return f = y.async,
            y = y.src,
            typeof y == "string" && f && typeof f != "function" && typeof f != "symbol" ? (f = Fh(y),
            y = va(T).hoistableScripts,
            x = y.get(f),
            x || (x = {
                type: "script",
                instance: null,
                count: 0,
                state: null
            },
            y.set(f, x)),
            x) : {
                type: "void",
                instance: null,
                count: 0,
                state: null
            };
        default:
            throw Error(r(444, c))
        }
    }
    function Lh(c) {
        return 'href="' + io(c) + '"'
    }
    function Sm(c) {
        return 'link[rel="stylesheet"][' + c + "]"
    }
    function vT(c) {
        return h({}, c, {
            "data-precedence": c.precedence,
            precedence: null
        })
    }
    function KK(c, f, y, x) {
        c.querySelector('link[rel="preload"][as="style"][' + f + "]") ? x.loading = 1 : (f = c.createElement("link"),
        x.preload = f,
        f.addEventListener("load", function() {
            return x.loading |= 1
        }),
        f.addEventListener("error", function() {
            return x.loading |= 2
        }),
        ls(f, "link", y),
        lr(f),
        c.head.appendChild(f))
    }
    function Fh(c) {
        return '[src="' + io(c) + '"]'
    }
    function Am(c) {
        return "script[async]" + c
    }
    function xT(c, f, y) {
        if (f.count++,
        f.instance === null)
            switch (f.type) {
            case "style":
                var x = c.querySelector('style[data-href~="' + io(y.href) + '"]');
                if (x)
                    return f.instance = x,
                    lr(x),
                    x;
                var T = h({}, y, {
                    "data-href": y.href,
                    "data-precedence": y.precedence,
                    href: null,
                    precedence: null
                });
                return x = (c.ownerDocument || c).createElement("style"),
                lr(x),
                ls(x, "style", T),
                o1(x, y.precedence, c),
                f.instance = x;
            case "stylesheet":
                T = Lh(y.href);
                var F = c.querySelector(Sm(T));
                if (F)
                    return f.state.loading |= 4,
                    f.instance = F,
                    lr(F),
                    F;
                x = vT(y),
                (T = po.get(T)) && nS(x, T),
                F = (c.ownerDocument || c).createElement("link"),
                lr(F);
                var Z = F;
                return Z._p = new Promise(function(te, le) {
                    Z.onload = te,
                    Z.onerror = le
                }
                ),
                ls(F, "link", x),
                f.state.loading |= 4,
                o1(F, y.precedence, c),
                f.instance = F;
            case "script":
                return F = Fh(y.src),
                (T = c.querySelector(Am(F))) ? (f.instance = T,
                lr(T),
                T) : (x = y,
                (T = po.get(F)) && (x = h({}, y),
                rS(x, T)),
                c = c.ownerDocument || c,
                T = c.createElement("script"),
                lr(T),
                ls(T, "link", x),
                c.head.appendChild(T),
                f.instance = T);
            case "void":
                return null;
            default:
                throw Error(r(443, f.type))
            }
        else
            f.type === "stylesheet" && (f.state.loading & 4) === 0 && (x = f.instance,
            f.state.loading |= 4,
            o1(x, y.precedence, c));
        return f.instance
    }
    function o1(c, f, y) {
        for (var x = y.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'), T = x.length ? x[x.length - 1] : null, F = T, Z = 0; Z < x.length; Z++) {
            var te = x[Z];
            if (te.dataset.precedence === f)
                F = te;
            else if (F !== T)
                break
        }
        F ? F.parentNode.insertBefore(c, F.nextSibling) : (f = y.nodeType === 9 ? y.head : y,
        f.insertBefore(c, f.firstChild))
    }
    function nS(c, f) {
        c.crossOrigin == null && (c.crossOrigin = f.crossOrigin),
        c.referrerPolicy == null && (c.referrerPolicy = f.referrerPolicy),
        c.title == null && (c.title = f.title)
    }
    function rS(c, f) {
        c.crossOrigin == null && (c.crossOrigin = f.crossOrigin),
        c.referrerPolicy == null && (c.referrerPolicy = f.referrerPolicy),
        c.integrity == null && (c.integrity = f.integrity)
    }
    var a1 = null;
    function ET(c, f, y) {
        if (a1 === null) {
            var x = new Map
              , T = a1 = new Map;
            T.set(y, x)
        } else
            T = a1,
            x = T.get(y),
            x || (x = new Map,
            T.set(y, x));
        if (x.has(c))
            return x;
        for (x.set(c, null),
        y = y.getElementsByTagName(c),
        T = 0; T < y.length; T++) {
            var F = y[T];
            if (!(F[cl] || F[Dt] || c === "link" && F.getAttribute("rel") === "stylesheet") && F.namespaceURI !== "http://www.w3.org/2000/svg") {
                var Z = F.getAttribute(f) || "";
                Z = c + Z;
                var te = x.get(Z);
                te ? te.push(F) : x.set(Z, [F])
            }
        }
        return x
    }
    function ST(c, f, y) {
        c = c.ownerDocument || c,
        c.head.insertBefore(y, f === "title" ? c.querySelector("head > title") : null)
    }
    function XK(c, f, y) {
        if (y === 1 || f.itemProp != null)
            return !1;
        switch (c) {
        case "meta":
        case "title":
            return !0;
        case "style":
            if (typeof f.precedence != "string" || typeof f.href != "string" || f.href === "")
                break;
            return !0;
        case "link":
            if (typeof f.rel != "string" || typeof f.href != "string" || f.href === "" || f.onLoad || f.onError)
                break;
            switch (f.rel) {
            case "stylesheet":
                return c = f.disabled,
                typeof f.precedence == "string" && c == null;
            default:
                return !0
            }
        case "script":
            if (f.async && typeof f.async != "function" && typeof f.async != "symbol" && !f.onLoad && !f.onError && f.src && typeof f.src == "string")
                return !0
        }
        return !1
    }
    function AT(c) {
        return !(c.type === "stylesheet" && (c.state.loading & 3) === 0)
    }
    function QK(c, f, y, x) {
        if (y.type === "stylesheet" && (typeof x.media != "string" || matchMedia(x.media).matches !== !1) && (y.state.loading & 4) === 0) {
            if (y.instance === null) {
                var T = Lh(x.href)
                  , F = f.querySelector(Sm(T));
                if (F) {
                    f = F._p,
                    f !== null && typeof f == "object" && typeof f.then == "function" && (c.count++,
                    c = l1.bind(c),
                    f.then(c, c)),
                    y.state.loading |= 4,
                    y.instance = F,
                    lr(F);
                    return
                }
                F = f.ownerDocument || f,
                x = vT(x),
                (T = po.get(T)) && nS(x, T),
                F = F.createElement("link"),
                lr(F);
                var Z = F;
                Z._p = new Promise(function(te, le) {
                    Z.onload = te,
                    Z.onerror = le
                }
                ),
                ls(F, "link", x),
                y.instance = F
            }
            c.stylesheets === null && (c.stylesheets = new Map),
            c.stylesheets.set(y, f),
            (f = y.state.preload) && (y.state.loading & 3) === 0 && (c.count++,
            y = l1.bind(c),
            f.addEventListener("load", y),
            f.addEventListener("error", y))
        }
    }
    var sS = 0;
    function ZK(c, f) {
        return c.stylesheets && c.count === 0 && u1(c, c.stylesheets),
        0 < c.count || 0 < c.imgCount ? function(y) {
            var x = setTimeout(function() {
                if (c.stylesheets && u1(c, c.stylesheets),
                c.unsuspend) {
                    var F = c.unsuspend;
                    c.unsuspend = null,
                    F()
                }
            }, 6e4 + f);
            0 < c.imgBytes && sS === 0 && (sS = 62500 * MK());
            var T = setTimeout(function() {
                if (c.waitingForImages = !1,
                c.count === 0 && (c.stylesheets && u1(c, c.stylesheets),
                c.unsuspend)) {
                    var F = c.unsuspend;
                    c.unsuspend = null,
                    F()
                }
            }, (c.imgBytes > sS ? 50 : 800) + f);
            return c.unsuspend = y,
            function() {
                c.unsuspend = null,
                clearTimeout(x),
                clearTimeout(T)
            }
        }
        : null
    }
    function l1() {
        if (this.count--,
        this.count === 0 && (this.imgCount === 0 || !this.waitingForImages)) {
            if (this.stylesheets)
                u1(this, this.stylesheets);
            else if (this.unsuspend) {
                var c = this.unsuspend;
                this.unsuspend = null,
                c()
            }
        }
    }
    var c1 = null;
    function u1(c, f) {
        c.stylesheets = null,
        c.unsuspend !== null && (c.count++,
        c1 = new Map,
        f.forEach(JK, c),
        c1 = null,
        l1.call(c))
    }
    function JK(c, f) {
        if (!(f.state.loading & 4)) {
            var y = c1.get(c);
            if (y)
                var x = y.get(null);
            else {
                y = new Map,
                c1.set(c, y);
                for (var T = c.querySelectorAll("link[data-precedence],style[data-precedence]"), F = 0; F < T.length; F++) {
                    var Z = T[F];
                    (Z.nodeName === "LINK" || Z.getAttribute("media") !== "not all") && (y.set(Z.dataset.precedence, Z),
                    x = Z)
                }
                x && y.set(null, x)
            }
            T = f.instance,
            Z = T.getAttribute("data-precedence"),
            F = y.get(Z) || x,
            F === x && y.set(null, T),
            y.set(Z, T),
            this.count++,
            x = l1.bind(this),
            T.addEventListener("load", x),
            T.addEventListener("error", x),
            F ? F.parentNode.insertBefore(T, F.nextSibling) : (c = c.nodeType === 9 ? c.head : c,
            c.insertBefore(T, c.firstChild)),
            f.state.loading |= 4
        }
    }
    var Cm = {
        $$typeof: _,
        Provider: null,
        Consumer: null,
        _currentValue: z,
        _currentValue2: z,
        _threadCount: 0
    };
    function eX(c, f, y, x, T, F, Z, te, le) {
        this.tag = 1,
        this.containerInfo = c,
        this.pingCache = this.current = this.pendingChildren = null,
        this.timeoutHandle = -1,
        this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null,
        this.callbackPriority = 0,
        this.expirationTimes = Me(-1),
        this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
        this.entanglements = Me(0),
        this.hiddenUpdates = Me(null),
        this.identifierPrefix = x,
        this.onUncaughtError = T,
        this.onCaughtError = F,
        this.onRecoverableError = Z,
        this.pooledCache = null,
        this.pooledCacheLanes = 0,
        this.formState = le,
        this.incompleteTransitions = new Map
    }
    function CT(c, f, y, x, T, F, Z, te, le, ve, ke, Te) {
        return c = new eX(c,f,y,Z,le,ve,ke,Te,te),
        f = 1,
        F === !0 && (f |= 24),
        F = Bi(3, null, null, f),
        c.current = F,
        F.stateNode = c,
        f = j3(),
        f.refCount++,
        c.pooledCache = f,
        f.refCount++,
        F.memoizedState = {
            element: x,
            isDehydrated: y,
            cache: f
        },
        z3(F),
        c
    }
    function _T(c) {
        return c ? (c = gh,
        c) : gh
    }
    function kT(c, f, y, x, T, F) {
        T = _T(T),
        x.context === null ? x.context = T : x.pendingContext = T,
        x = Wc(f),
        x.payload = {
            element: y
        },
        F = F === void 0 ? null : F,
        F !== null && (x.callback = F),
        y = Yc(c, x, f),
        y !== null && (fi(y, c, f),
        rm(y, c, f))
    }
    function NT(c, f) {
        if (c = c.memoizedState,
        c !== null && c.dehydrated !== null) {
            var y = c.retryLane;
            c.retryLane = y !== 0 && y < f ? y : f
        }
    }
    function iS(c, f) {
        NT(c, f),
        (c = c.alternate) && NT(c, f)
    }
    function DT(c) {
        if (c.tag === 13 || c.tag === 31) {
            var f = gd(c, 67108864);
            f !== null && fi(f, c, 67108864),
            iS(c, 67108864)
        }
    }
    function TT(c) {
        if (c.tag === 13 || c.tag === 31) {
            var f = Li();
            f = wt(f);
            var y = gd(c, f);
            y !== null && fi(y, c, f),
            iS(c, f)
        }
    }
    var d1 = !0;
    function tX(c, f, y, x) {
        var T = C.T;
        C.T = null;
        var F = O.p;
        try {
            O.p = 2,
            oS(c, f, y, x)
        } finally {
            O.p = F,
            C.T = T
        }
    }
    function nX(c, f, y, x) {
        var T = C.T;
        C.T = null;
        var F = O.p;
        try {
            O.p = 8,
            oS(c, f, y, x)
        } finally {
            O.p = F,
            C.T = T
        }
    }
    function oS(c, f, y, x) {
        if (d1) {
            var T = aS(x);
            if (T === null)
                GE(c, f, x, f1, y),
                MT(c, x);
            else if (sX(T, c, f, y, x))
                x.stopPropagation();
            else if (MT(c, x),
            f & 4 && -1 < rX.indexOf(c)) {
                for (; T !== null; ) {
                    var F = wa(T);
                    if (F !== null)
                        switch (F.tag) {
                        case 3:
                            if (F = F.stateNode,
                            F.current.memoizedState.isDehydrated) {
                                var Z = $e(F.pendingLanes);
                                if (Z !== 0) {
                                    var te = F;
                                    for (te.pendingLanes |= 2,
                                    te.entangledLanes |= 2; Z; ) {
                                        var le = 1 << 31 - Ve(Z);
                                        te.entanglements[1] |= le,
                                        Z &= ~le
                                    }
                                    Ca(F),
                                    (mn & 6) === 0 && (Yb = ut() + 500,
                                    wm(0))
                                }
                            }
                            break;
                        case 31:
                        case 13:
                            te = gd(F, 2),
                            te !== null && fi(te, F, 2),
                            Xb(),
                            iS(F, 2)
                        }
                    if (F = aS(x),
                    F === null && GE(c, f, x, f1, y),
                    F === T)
                        break;
                    T = F
                }
                T !== null && x.stopPropagation()
            } else
                GE(c, f, x, null, y)
        }
    }
    function aS(c) {
        return c = c3(c),
        lS(c)
    }
    var f1 = null;
    function lS(c) {
        if (f1 = null,
        c = ba(c),
        c !== null) {
            var f = i(c);
            if (f === null)
                c = null;
            else {
                var y = f.tag;
                if (y === 13) {
                    if (c = o(f),
                    c !== null)
                        return c;
                    c = null
                } else if (y === 31) {
                    if (c = a(f),
                    c !== null)
                        return c;
                    c = null
                } else if (y === 3) {
                    if (f.stateNode.current.memoizedState.isDehydrated)
                        return f.tag === 3 ? f.stateNode.containerInfo : null;
                    c = null
                } else
                    f !== c && (c = null)
            }
        }
        return f1 = c,
        null
    }
    function IT(c) {
        switch (c) {
        case "beforetoggle":
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "toggle":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
            return 2;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
            return 8;
        case "message":
            switch (cn()) {
            case _t:
                return 2;
            case ee:
                return 8;
            case K:
            case X:
                return 32;
            case re:
                return 268435456;
            default:
                return 32
            }
        default:
            return 32
        }
    }
    var cS = !1
      , iu = null
      , ou = null
      , au = null
      , _m = new Map
      , km = new Map
      , lu = []
      , rX = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");
    function MT(c, f) {
        switch (c) {
        case "focusin":
        case "focusout":
            iu = null;
            break;
        case "dragenter":
        case "dragleave":
            ou = null;
            break;
        case "mouseover":
        case "mouseout":
            au = null;
            break;
        case "pointerover":
        case "pointerout":
            _m.delete(f.pointerId);
            break;
        case "gotpointercapture":
        case "lostpointercapture":
            km.delete(f.pointerId)
        }
    }
    function Nm(c, f, y, x, T, F) {
        return c === null || c.nativeEvent !== F ? (c = {
            blockedOn: f,
            domEventName: y,
            eventSystemFlags: x,
            nativeEvent: F,
            targetContainers: [T]
        },
        f !== null && (f = wa(f),
        f !== null && DT(f)),
        c) : (c.eventSystemFlags |= x,
        f = c.targetContainers,
        T !== null && f.indexOf(T) === -1 && f.push(T),
        c)
    }
    function sX(c, f, y, x, T) {
        switch (f) {
        case "focusin":
            return iu = Nm(iu, c, f, y, x, T),
            !0;
        case "dragenter":
            return ou = Nm(ou, c, f, y, x, T),
            !0;
        case "mouseover":
            return au = Nm(au, c, f, y, x, T),
            !0;
        case "pointerover":
            var F = T.pointerId;
            return _m.set(F, Nm(_m.get(F) || null, c, f, y, x, T)),
            !0;
        case "gotpointercapture":
            return F = T.pointerId,
            km.set(F, Nm(km.get(F) || null, c, f, y, x, T)),
            !0
        }
        return !1
    }
    function BT(c) {
        var f = ba(c.target);
        if (f !== null) {
            var y = i(f);
            if (y !== null) {
                if (f = y.tag,
                f === 13) {
                    if (f = o(y),
                    f !== null) {
                        c.blockedOn = f,
                        Jt(c.priority, function() {
                            TT(y)
                        });
                        return
                    }
                } else if (f === 31) {
                    if (f = a(y),
                    f !== null) {
                        c.blockedOn = f,
                        Jt(c.priority, function() {
                            TT(y)
                        });
                        return
                    }
                } else if (f === 3 && y.stateNode.current.memoizedState.isDehydrated) {
                    c.blockedOn = y.tag === 3 ? y.stateNode.containerInfo : null;
                    return
                }
            }
        }
        c.blockedOn = null
    }
    function h1(c) {
        if (c.blockedOn !== null)
            return !1;
        for (var f = c.targetContainers; 0 < f.length; ) {
            var y = aS(c.nativeEvent);
            if (y === null) {
                y = c.nativeEvent;
                var x = new y.constructor(y.type,y);
                l3 = x,
                y.target.dispatchEvent(x),
                l3 = null
            } else
                return f = wa(y),
                f !== null && DT(f),
                c.blockedOn = y,
                !1;
            f.shift()
        }
        return !0
    }
    function RT(c, f, y) {
        h1(c) && y.delete(f)
    }
    function iX() {
        cS = !1,
        iu !== null && h1(iu) && (iu = null),
        ou !== null && h1(ou) && (ou = null),
        au !== null && h1(au) && (au = null),
        _m.forEach(RT),
        km.forEach(RT)
    }
    function p1(c, f) {
        c.blockedOn === f && (c.blockedOn = null,
        cS || (cS = !0,
        n.unstable_scheduleCallback(n.unstable_NormalPriority, iX)))
    }
    var m1 = null;
    function OT(c) {
        m1 !== c && (m1 = c,
        n.unstable_scheduleCallback(n.unstable_NormalPriority, function() {
            m1 === c && (m1 = null);
            for (var f = 0; f < c.length; f += 3) {
                var y = c[f]
                  , x = c[f + 1]
                  , T = c[f + 2];
                if (typeof x != "function") {
                    if (lS(x || y) === null)
                        continue;
                    break
                }
                var F = wa(y);
                F !== null && (c.splice(f, 3),
                f -= 3,
                aE(F, {
                    pending: !0,
                    data: T,
                    method: y.method,
                    action: x
                }, x, T))
            }
        }))
    }
    function Uh(c) {
        function f(le) {
            return p1(le, c)
        }
        iu !== null && p1(iu, c),
        ou !== null && p1(ou, c),
        au !== null && p1(au, c),
        _m.forEach(f),
        km.forEach(f);
        for (var y = 0; y < lu.length; y++) {
            var x = lu[y];
            x.blockedOn === c && (x.blockedOn = null)
        }
        for (; 0 < lu.length && (y = lu[0],
        y.blockedOn === null); )
            BT(y),
            y.blockedOn === null && lu.shift();
        if (y = (c.ownerDocument || c).$$reactFormReplay,
        y != null)
            for (x = 0; x < y.length; x += 3) {
                var T = y[x]
                  , F = y[x + 1]
                  , Z = T[Ht] || null;
                if (typeof F == "function")
                    Z || OT(y);
                else if (Z) {
                    var te = null;
                    if (F && F.hasAttribute("formAction")) {
                        if (T = F,
                        Z = F[Ht] || null)
                            te = Z.formAction;
                        else if (lS(T) !== null)
                            continue
                    } else
                        te = Z.action;
                    typeof te == "function" ? y[x + 1] = te : (y.splice(x, 3),
                    x -= 3),
                    OT(y)
                }
            }
    }
    function PT() {
        function c(F) {
            F.canIntercept && F.info === "react-transition" && F.intercept({
                handler: function() {
                    return new Promise(function(Z) {
                        return T = Z
                    }
                    )
                },
                focusReset: "manual",
                scroll: "manual"
            })
        }
        function f() {
            T !== null && (T(),
            T = null),
            x || setTimeout(y, 20)
        }
        function y() {
            if (!x && !navigation.transition) {
                var F = navigation.currentEntry;
                F && F.url != null && navigation.navigate(F.url, {
                    state: F.getState(),
                    info: "react-transition",
                    history: "replace"
                })
            }
        }
        if (typeof navigation == "object") {
            var x = !1
              , T = null;
            return navigation.addEventListener("navigate", c),
            navigation.addEventListener("navigatesuccess", f),
            navigation.addEventListener("navigateerror", f),
            setTimeout(y, 100),
            function() {
                x = !0,
                navigation.removeEventListener("navigate", c),
                navigation.removeEventListener("navigatesuccess", f),
                navigation.removeEventListener("navigateerror", f),
                T !== null && (T(),
                T = null)
            }
        }
    }
    function uS(c) {
        this._internalRoot = c
    }
    g1.prototype.render = uS.prototype.render = function(c) {
        var f = this._internalRoot;
        if (f === null)
            throw Error(r(409));
        var y = f.current
          , x = Li();
        kT(y, x, c, f, null, null)
    }
    ,
    g1.prototype.unmount = uS.prototype.unmount = function() {
        var c = this._internalRoot;
        if (c !== null) {
            this._internalRoot = null;
            var f = c.containerInfo;
            kT(c.current, 2, null, c, null, null),
            Xb(),
            f[ll] = null
        }
    }
    ;
    function g1(c) {
        this._internalRoot = c
    }
    g1.prototype.unstable_scheduleHydration = function(c) {
        if (c) {
            var f = Zt();
            c = {
                blockedOn: null,
                target: c,
                priority: f
            };
            for (var y = 0; y < lu.length && f !== 0 && f < lu[y].priority; y++)
                ;
            lu.splice(y, 0, c),
            y === 0 && BT(c)
        }
    }
    ;
    var jT = e.version;
    if (jT !== "19.2.0")
        throw Error(r(527, jT, "19.2.0"));
    O.findDOMNode = function(c) {
        var f = c._reactInternals;
        if (f === void 0)
            throw typeof c.render == "function" ? Error(r(188)) : (c = Object.keys(c).join(","),
            Error(r(268, c)));
        return c = u(f),
        c = c !== null ? d(c) : null,
        c = c === null ? null : c.stateNode,
        c
    }
    ;
    var oX = {
        bundleType: 0,
        version: "19.2.0",
        rendererPackageName: "react-dom",
        currentDispatcherRef: C,
        reconcilerVersion: "19.2.0"
    };
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
        var y1 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (!y1.isDisabled && y1.supportsFiber)
            try {
                ge = y1.inject(oX),
                _e = y1
            } catch {}
    }
    return Tm.createRoot = function(c, f) {
        if (!s(c))
            throw Error(r(299));
        var y = !1
          , x = ""
          , T = VN
          , F = qN
          , Z = GN;
        return f != null && (f.unstable_strictMode === !0 && (y = !0),
        f.identifierPrefix !== void 0 && (x = f.identifierPrefix),
        f.onUncaughtError !== void 0 && (T = f.onUncaughtError),
        f.onCaughtError !== void 0 && (F = f.onCaughtError),
        f.onRecoverableError !== void 0 && (Z = f.onRecoverableError)),
        f = CT(c, 1, !1, null, null, y, x, null, T, F, Z, PT),
        c[ll] = f.current,
        qE(c),
        new uS(f)
    }
    ,
    Tm.hydrateRoot = function(c, f, y) {
        if (!s(c))
            throw Error(r(299));
        var x = !1
          , T = ""
          , F = VN
          , Z = qN
          , te = GN
          , le = null;
        return y != null && (y.unstable_strictMode === !0 && (x = !0),
        y.identifierPrefix !== void 0 && (T = y.identifierPrefix),
        y.onUncaughtError !== void 0 && (F = y.onUncaughtError),
        y.onCaughtError !== void 0 && (Z = y.onCaughtError),
        y.onRecoverableError !== void 0 && (te = y.onRecoverableError),
        y.formState !== void 0 && (le = y.formState)),
        f = CT(c, 1, !0, f, y ?? null, x, T, le, F, Z, te, PT),
        f.context = _T(null),
        y = f.current,
        x = Li(),
        x = wt(x),
        T = Wc(x),
        T.callback = null,
        Yc(y, T, x),
        y = x,
        f.current.lanes = y,
        Je(f, y),
        Ca(f),
        c[ll] = f.current,
        qE(c),
        new g1(f)
    }
    ,
    Tm.version = "19.2.0",
    Tm
}
var WT;
function gX() {
    if (WT)
        return hS.exports;
    WT = 1;
    function n() {
        if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
            try {
                __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)
            } catch (e) {
                console.error(e)
            }
    }
    return n(),
    hS.exports = mX(),
    hS.exports
}
var yX = gX();
var YT = "popstate";
function bX(n={}) {
    function e(r, s) {
        let {pathname: i, search: o, hash: a} = r.location;
        return d4("", {
            pathname: i,
            search: o,
            hash: a
        }, s.state && s.state.usr || null, s.state && s.state.key || "default")
    }
    function t(r, s) {
        return typeof s == "string" ? s : $g(s)
    }
    return vX(e, t, null, n)
}
function ir(n, e) {
    if (n === !1 || n === null || typeof n > "u")
        throw new Error(e)
}
function el(n, e) {
    if (!n) {
        typeof console < "u" && console.warn(e);
        try {
            throw new Error(e)
        } catch {}
    }
}
function wX() {
    return Math.random().toString(36).substring(2, 10)
}
function KT(n, e) {
    return {
        usr: n.state,
        key: n.key,
        idx: e
    }
}
function d4(n, e, t=null, r) {
    return {
        pathname: typeof n == "string" ? n : n.pathname,
        search: "",
        hash: "",
        ...typeof e == "string" ? v0(e) : e,
        state: t,
        key: e && e.key || r || wX()
    }
}
function $g({pathname: n="/", search: e="", hash: t=""}) {
    return e && e !== "?" && (n += e.charAt(0) === "?" ? e : "?" + e),
    t && t !== "#" && (n += t.charAt(0) === "#" ? t : "#" + t),
    n
}
function v0(n) {
    let e = {};
    if (n) {
        let t = n.indexOf("#");
        t >= 0 && (e.hash = n.substring(t),
        n = n.substring(0, t));
        let r = n.indexOf("?");
        r >= 0 && (e.search = n.substring(r),
        n = n.substring(0, r)),
        n && (e.pathname = n)
    }
    return e
}
function vX(n, e, t, r={}) {
    let {window: s=document.defaultView, v5Compat: i=!1} = r
      , o = s.history
      , a = "POP"
      , l = null
      , u = d();
    u == null && (u = 0,
    o.replaceState({
        ...o.state,
        idx: u
    }, ""));
    function d() {
        return (o.state || {
            idx: null
        }).idx
    }
    function h() {
        a = "POP";
        let v = d()
          , S = v == null ? null : v - u;
        u = v,
        l && l({
            action: a,
            location: b.location,
            delta: S
        })
    }
    function p(v, S) {
        a = "PUSH";
        let N = d4(b.location, v, S);
        u = d() + 1;
        let _ = KT(N, u)
          , I = b.createHref(N);
        try {
            o.pushState(_, "", I)
        } catch (k) {
            if (k instanceof DOMException && k.name === "DataCloneError")
                throw k;
            s.location.assign(I)
        }
        i && l && l({
            action: a,
            location: b.location,
            delta: 1
        })
    }
    function g(v, S) {
        a = "REPLACE";
        let N = d4(b.location, v, S);
        u = d();
        let _ = KT(N, u)
          , I = b.createHref(N);
        o.replaceState(_, "", I),
        i && l && l({
            action: a,
            location: b.location,
            delta: 0
        })
    }
    function w(v) {
        return xX(v)
    }
    let b = {
        get action() {
            return a
        },
        get location() {
            return n(s, o)
        },
        listen(v) {
            if (l)
                throw new Error("A history only accepts one active listener");
            return s.addEventListener(YT, h),
            l = v,
            () => {
                s.removeEventListener(YT, h),
                l = null
            }
        },
        createHref(v) {
            return e(s, v)
        },
        createURL: w,
        encodeLocation(v) {
            let S = w(v);
            return {
                pathname: S.pathname,
                search: S.search,
                hash: S.hash
            }
        },
        push: p,
        replace: g,
        go(v) {
            return o.go(v)
        }
    };
    return b
}
function xX(n, e=!1) {
    let t = "http://localhost";
    typeof window < "u" && (t = window.location.origin !== "null" ? window.location.origin : window.location.href),
    ir(t, "No window.location.(origin|href) available to create URL");
    let r = typeof n == "string" ? n : $g(n);
    return r = r.replace(/ $/, "%20"),
    !e && r.startsWith("//") && (r = t + r),
    new URL(r,t)
}
function Z9(n, e, t="/") {
    return EX(n, e, t, !1)
}
function EX(n, e, t, r) {
    let s = typeof e == "string" ? v0(e) : e
      , i = Ac(s.pathname || "/", t);
    if (i == null)
        return null;
    let o = J9(n);
    SX(o);
    let a = null;
    for (let l = 0; a == null && l < o.length; ++l) {
        let u = RX(i);
        a = MX(o[l], u, r)
    }
    return a
}
function J9(n, e=[], t=[], r="", s=!1) {
    let i = (o, a, l=s, u) => {
        let d = {
            relativePath: u === void 0 ? o.path || "" : u,
            caseSensitive: o.caseSensitive === !0,
            childrenIndex: a,
            route: o
        };
        if (d.relativePath.startsWith("/")) {
            if (!d.relativePath.startsWith(r) && l)
                return;
            ir(d.relativePath.startsWith(r), `Absolute route path "${d.relativePath}" nested under path "${r}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`),
            d.relativePath = d.relativePath.slice(r.length)
        }
        let h = hc([r, d.relativePath])
          , p = t.concat(d);
        o.children && o.children.length > 0 && (ir(o.index !== !0, `Index routes must not have child routes. Please remove all child routes from route path "${h}".`),
        J9(o.children, e, p, h, l)),
        !(o.path == null && !o.index) && e.push({
            path: h,
            score: TX(h, o.index),
            routesMeta: p
        })
    }
    ;
    return n.forEach( (o, a) => {
        if (o.path === "" || !o.path?.includes("?"))
            i(o, a);
        else
            for (let l of eL(o.path))
                i(o, a, !0, l)
    }
    ),
    e
}
function eL(n) {
    let e = n.split("/");
    if (e.length === 0)
        return [];
    let[t,...r] = e
      , s = t.endsWith("?")
      , i = t.replace(/\?$/, "");
    if (r.length === 0)
        return s ? [i, ""] : [i];
    let o = eL(r.join("/"))
      , a = [];
    return a.push(...o.map(l => l === "" ? i : [i, l].join("/"))),
    s && a.push(...o),
    a.map(l => n.startsWith("/") && l === "" ? "/" : l)
}
function SX(n) {
    n.sort( (e, t) => e.score !== t.score ? t.score - e.score : IX(e.routesMeta.map(r => r.childrenIndex), t.routesMeta.map(r => r.childrenIndex)))
}
var AX = /^:[\w-]+$/
  , CX = 3
  , _X = 2
  , kX = 1
  , NX = 10
  , DX = -2
  , XT = n => n === "*";
function TX(n, e) {
    let t = n.split("/")
      , r = t.length;
    return t.some(XT) && (r += DX),
    e && (r += _X),
    t.filter(s => !XT(s)).reduce( (s, i) => s + (AX.test(i) ? CX : i === "" ? kX : NX), r)
}
function IX(n, e) {
    return n.length === e.length && n.slice(0, -1).every( (r, s) => r === e[s]) ? n[n.length - 1] - e[e.length - 1] : 0
}
function MX(n, e, t=!1) {
    let {routesMeta: r} = n
      , s = {}
      , i = "/"
      , o = [];
    for (let a = 0; a < r.length; ++a) {
        let l = r[a]
          , u = a === r.length - 1
          , d = i === "/" ? e : e.slice(i.length) || "/"
          , h = l2({
            path: l.relativePath,
            caseSensitive: l.caseSensitive,
            end: u
        }, d)
          , p = l.route;
        if (!h && u && t && !r[r.length - 1].route.index && (h = l2({
            path: l.relativePath,
            caseSensitive: l.caseSensitive,
            end: !1
        }, d)),
        !h)
            return null;
        Object.assign(s, h.params),
        o.push({
            params: s,
            pathname: hc([i, h.pathname]),
            pathnameBase: LX(hc([i, h.pathnameBase])),
            route: p
        }),
        h.pathnameBase !== "/" && (i = hc([i, h.pathnameBase]))
    }
    return o
}
function l2(n, e) {
    typeof n == "string" && (n = {
        path: n,
        caseSensitive: !1,
        end: !0
    });
    let[t,r] = BX(n.path, n.caseSensitive, n.end)
      , s = e.match(t);
    if (!s)
        return null;
    let i = s[0]
      , o = i.replace(/(.)\/+$/, "$1")
      , a = s.slice(1);
    return {
        params: r.reduce( (u, {paramName: d, isOptional: h}, p) => {
            if (d === "*") {
                let w = a[p] || "";
                o = i.slice(0, i.length - w.length).replace(/(.)\/+$/, "$1")
            }
            const g = a[p];
            return h && !g ? u[d] = void 0 : u[d] = (g || "").replace(/%2F/g, "/"),
            u
        }
        , {}),
        pathname: i,
        pathnameBase: o,
        pattern: n
    }
}
function BX(n, e=!1, t=!0) {
    el(n === "*" || !n.endsWith("*") || n.endsWith("/*"), `Route path "${n}" will be treated as if it were "${n.replace(/\*$/, "/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${n.replace(/\*$/, "/*")}".`);
    let r = []
      , s = "^" + n.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (o, a, l) => (r.push({
        paramName: a,
        isOptional: l != null
    }),
    l ? "/?([^\\/]+)?" : "/([^\\/]+)")).replace(/\/([\w-]+)\?(\/|$)/g, "(/$1)?$2");
    return n.endsWith("*") ? (r.push({
        paramName: "*"
    }),
    s += n === "*" || n === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : t ? s += "\\/*$" : n !== "" && n !== "/" && (s += "(?:(?=\\/|$))"),
    [new RegExp(s,e ? void 0 : "i"), r]
}
function RX(n) {
    try {
        return n.split("/").map(e => decodeURIComponent(e).replace(/\//g, "%2F")).join("/")
    } catch (e) {
        return el(!1, `The URL path "${n}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${e}).`),
        n
    }
}
function Ac(n, e) {
    if (e === "/")
        return n;
    if (!n.toLowerCase().startsWith(e.toLowerCase()))
        return null;
    let t = e.endsWith("/") ? e.length - 1 : e.length
      , r = n.charAt(t);
    return r && r !== "/" ? null : n.slice(t) || "/"
}
function OX(n, e="/") {
    let {pathname: t, search: r="", hash: s=""} = typeof n == "string" ? v0(n) : n;
    return {
        pathname: t ? t.startsWith("/") ? t : PX(t, e) : e,
        search: FX(r),
        hash: UX(s)
    }
}
function PX(n, e) {
    let t = e.replace(/\/+$/, "").split("/");
    return n.split("/").forEach(s => {
        s === ".." ? t.length > 1 && t.pop() : s !== "." && t.push(s)
    }
    ),
    t.length > 1 ? t.join("/") : "/"
}
function yS(n, e, t, r) {
    return `Cannot include a '${n}' character in a manually specified \`to.${e}\` field [${JSON.stringify(r)}].  Please separate it out to the \`to.${t}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`
}
function jX(n) {
    return n.filter( (e, t) => t === 0 || e.route.path && e.route.path.length > 0)
}
function tL(n) {
    let e = jX(n);
    return e.map( (t, r) => r === e.length - 1 ? t.pathname : t.pathnameBase)
}
function nL(n, e, t, r=!1) {
    let s;
    typeof n == "string" ? s = v0(n) : (s = {
        ...n
    },
    ir(!s.pathname || !s.pathname.includes("?"), yS("?", "pathname", "search", s)),
    ir(!s.pathname || !s.pathname.includes("#"), yS("#", "pathname", "hash", s)),
    ir(!s.search || !s.search.includes("#"), yS("#", "search", "hash", s)));
    let i = n === "" || s.pathname === "", o = i ? "/" : s.pathname, a;
    if (o == null)
        a = t;
    else {
        let h = e.length - 1;
        if (!r && o.startsWith("..")) {
            let p = o.split("/");
            for (; p[0] === ".."; )
                p.shift(),
                h -= 1;
            s.pathname = p.join("/")
        }
        a = h >= 0 ? e[h] : "/"
    }
    let l = OX(s, a)
      , u = o && o !== "/" && o.endsWith("/")
      , d = (i || o === ".") && t.endsWith("/");
    return !l.pathname.endsWith("/") && (u || d) && (l.pathname += "/"),
    l
}
var hc = n => n.join("/").replace(/\/\/+/g, "/")
  , LX = n => n.replace(/\/+$/, "").replace(/^\/*/, "/")
  , FX = n => !n || n === "?" ? "" : n.startsWith("?") ? n : "?" + n
  , UX = n => !n || n === "#" ? "" : n.startsWith("#") ? n : "#" + n;
function zX(n) {
    return n != null && typeof n.status == "number" && typeof n.statusText == "string" && typeof n.internal == "boolean" && "data"in n
}
Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
var rL = ["POST", "PUT", "PATCH", "DELETE"];
new Set(rL);
var $X = ["GET", ...rL];
new Set($X);
var x0 = V.createContext(null);
x0.displayName = "DataRouter";
var Tv = V.createContext(null);
Tv.displayName = "DataRouterState";
V.createContext(!1);
var sL = V.createContext({
    isTransitioning: !1
});
sL.displayName = "ViewTransition";
var HX = V.createContext(new Map);
HX.displayName = "Fetchers";
var VX = V.createContext(null);
VX.displayName = "Await";
var il = V.createContext(null);
il.displayName = "Navigation";
var wy = V.createContext(null);
wy.displayName = "Location";
var ga = V.createContext({
    outlet: null,
    matches: [],
    isDataRoute: !1
});
ga.displayName = "Route";
var C8 = V.createContext(null);
C8.displayName = "RouteError";
function qX(n, {relative: e}={}) {
    ir(vy(), "useHref() may be used only in the context of a <Router> component.");
    let {basename: t, navigator: r} = V.useContext(il)
      , {hash: s, pathname: i, search: o} = xy(n, {
        relative: e
    })
      , a = i;
    return t !== "/" && (a = i === "/" ? t : hc([t, i])),
    r.createHref({
        pathname: a,
        search: o,
        hash: s
    })
}
function vy() {
    return V.useContext(wy) != null
}
function Ti() {
    return ir(vy(), "useLocation() may be used only in the context of a <Router> component."),
    V.useContext(wy).location
}
var iL = "You should call navigate() in a React.useEffect(), not when your component is first rendered.";
function oL(n) {
    V.useContext(il).static || V.useLayoutEffect(n)
}
function kr() {
    let {isDataRoute: n} = V.useContext(ga);
    return n ? oQ() : GX()
}
function GX() {
    ir(vy(), "useNavigate() may be used only in the context of a <Router> component.");
    let n = V.useContext(x0)
      , {basename: e, navigator: t} = V.useContext(il)
      , {matches: r} = V.useContext(ga)
      , {pathname: s} = Ti()
      , i = JSON.stringify(tL(r))
      , o = V.useRef(!1);
    return oL( () => {
        o.current = !0
    }
    ),
    V.useCallback( (l, u={}) => {
        if (el(o.current, iL),
        !o.current)
            return;
        if (typeof l == "number") {
            t.go(l);
            return
        }
        let d = nL(l, JSON.parse(i), s, u.relative === "path");
        n == null && e !== "/" && (d.pathname = d.pathname === "/" ? e : hc([e, d.pathname])),
        (u.replace ? t.replace : t.push)(d, u.state, u)
    }
    , [e, t, i, s, n])
}
var WX = V.createContext(null);
function YX(n) {
    let e = V.useContext(ga).outlet;
    return V.useMemo( () => e && V.createElement(WX.Provider, {
        value: n
    }, e), [e, n])
}
function E0() {
    let {matches: n} = V.useContext(ga)
      , e = n[n.length - 1];
    return e ? e.params : {}
}
function xy(n, {relative: e}={}) {
    let {matches: t} = V.useContext(ga)
      , {pathname: r} = Ti()
      , s = JSON.stringify(tL(t));
    return V.useMemo( () => nL(n, JSON.parse(s), r, e === "path"), [n, s, r, e])
}
function KX(n, e) {
    return aL(n, e)
}
function aL(n, e, t, r, s) {
    ir(vy(), "useRoutes() may be used only in the context of a <Router> component.");
    let {navigator: i} = V.useContext(il)
      , {matches: o} = V.useContext(ga)
      , a = o[o.length - 1]
      , l = a ? a.params : {}
      , u = a ? a.pathname : "/"
      , d = a ? a.pathnameBase : "/"
      , h = a && a.route;
    {
        let N = h && h.path || "";
        lL(u, !h || N.endsWith("*") || N.endsWith("*?"), `You rendered descendant <Routes> (or called \`useRoutes()\`) at "${u}" (under <Route path="${N}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${N}"> to <Route path="${N === "/" ? "*" : `${N}/*`}">.`)
    }
    let p = Ti(), g;
    if (e) {
        let N = typeof e == "string" ? v0(e) : e;
        ir(d === "/" || N.pathname?.startsWith(d), `When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${d}" but pathname "${N.pathname}" was given in the \`location\` prop.`),
        g = N
    } else
        g = p;
    let w = g.pathname || "/"
      , b = w;
    if (d !== "/") {
        let N = d.replace(/^\//, "").split("/");
        b = "/" + w.replace(/^\//, "").split("/").slice(N.length).join("/")
    }
    let v = Z9(n, {
        pathname: b
    });
    el(h || v != null, `No routes matched location "${g.pathname}${g.search}${g.hash}" `),
    el(v == null || v[v.length - 1].route.element !== void 0 || v[v.length - 1].route.Component !== void 0 || v[v.length - 1].route.lazy !== void 0, `Matched leaf route at location "${g.pathname}${g.search}${g.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`);
    let S = eQ(v && v.map(N => Object.assign({}, N, {
        params: Object.assign({}, l, N.params),
        pathname: hc([d, i.encodeLocation ? i.encodeLocation(N.pathname.replace(/\?/g, "%3F").replace(/#/g, "%23")).pathname : N.pathname]),
        pathnameBase: N.pathnameBase === "/" ? d : hc([d, i.encodeLocation ? i.encodeLocation(N.pathnameBase.replace(/\?/g, "%3F").replace(/#/g, "%23")).pathname : N.pathnameBase])
    })), o, t, r, s);
    return e && S ? V.createElement(wy.Provider, {
        value: {
            location: {
                pathname: "/",
                search: "",
                hash: "",
                state: null,
                key: "default",
                ...g
            },
            navigationType: "POP"
        }
    }, S) : S
}
function XX() {
    let n = iQ()
      , e = zX(n) ? `${n.status} ${n.statusText}` : n instanceof Error ? n.message : JSON.stringify(n)
      , t = n instanceof Error ? n.stack : null
      , r = "rgba(200,200,200, 0.5)"
      , s = {
        padding: "0.5rem",
        backgroundColor: r
    }
      , i = {
        padding: "2px 4px",
        backgroundColor: r
    }
      , o = null;
    return console.error("Error handled by React Router default ErrorBoundary:", n),
    o = V.createElement(V.Fragment, null, V.createElement("p", null, " Hey developer "), V.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", V.createElement("code", {
        style: i
    }, "ErrorBoundary"), " or", " ", V.createElement("code", {
        style: i
    }, "errorElement"), " prop on your route.")),
    V.createElement(V.Fragment, null, V.createElement("h2", null, "Unexpected Application Error!"), V.createElement("h3", {
        style: {
            fontStyle: "italic"
        }
    }, e), t ? V.createElement("pre", {
        style: s
    }, t) : null, o)
}
var QX = V.createElement(XX, null)
  , ZX = class extends V.Component {
    constructor(n) {
        super(n),
        this.state = {
            location: n.location,
            revalidation: n.revalidation,
            error: n.error
        }
    }
    static getDerivedStateFromError(n) {
        return {
            error: n
        }
    }
    static getDerivedStateFromProps(n, e) {
        return e.location !== n.location || e.revalidation !== "idle" && n.revalidation === "idle" ? {
            error: n.error,
            location: n.location,
            revalidation: n.revalidation
        } : {
            error: n.error !== void 0 ? n.error : e.error,
            location: e.location,
            revalidation: n.revalidation || e.revalidation
        }
    }
    componentDidCatch(n, e) {
        this.props.unstable_onError ? this.props.unstable_onError(n, e) : console.error("React Router caught the following error during render", n)
    }
    render() {
        return this.state.error !== void 0 ? V.createElement(ga.Provider, {
            value: this.props.routeContext
        }, V.createElement(C8.Provider, {
            value: this.state.error,
            children: this.props.component
        })) : this.props.children
    }
}
;
function JX({routeContext: n, match: e, children: t}) {
    let r = V.useContext(x0);
    return r && r.static && r.staticContext && (e.route.errorElement || e.route.ErrorBoundary) && (r.staticContext._deepestRenderedBoundaryId = e.route.id),
    V.createElement(ga.Provider, {
        value: n
    }, t)
}
function eQ(n, e=[], t=null, r=null, s=null) {
    if (n == null) {
        if (!t)
            return null;
        if (t.errors)
            n = t.matches;
        else if (e.length === 0 && !t.initialized && t.matches.length > 0)
            n = t.matches;
        else
            return null
    }
    let i = n
      , o = t?.errors;
    if (o != null) {
        let u = i.findIndex(d => d.route.id && o?.[d.route.id] !== void 0);
        ir(u >= 0, `Could not find a matching route for errors on route IDs: ${Object.keys(o).join(",")}`),
        i = i.slice(0, Math.min(i.length, u + 1))
    }
    let a = !1
      , l = -1;
    if (t)
        for (let u = 0; u < i.length; u++) {
            let d = i[u];
            if ((d.route.HydrateFallback || d.route.hydrateFallbackElement) && (l = u),
            d.route.id) {
                let {loaderData: h, errors: p} = t
                  , g = d.route.loader && !h.hasOwnProperty(d.route.id) && (!p || p[d.route.id] === void 0);
                if (d.route.lazy || g) {
                    a = !0,
                    l >= 0 ? i = i.slice(0, l + 1) : i = [i[0]];
                    break
                }
            }
        }
    return i.reduceRight( (u, d, h) => {
        let p, g = !1, w = null, b = null;
        t && (p = o && d.route.id ? o[d.route.id] : void 0,
        w = d.route.errorElement || QX,
        a && (l < 0 && h === 0 ? (lL("route-fallback", !1, "No `HydrateFallback` element provided to render during initial hydration"),
        g = !0,
        b = null) : l === h && (g = !0,
        b = d.route.hydrateFallbackElement || null)));
        let v = e.concat(i.slice(0, h + 1))
          , S = () => {
            let N;
            return p ? N = w : g ? N = b : d.route.Component ? N = V.createElement(d.route.Component, null) : d.route.element ? N = d.route.element : N = u,
            V.createElement(JX, {
                match: d,
                routeContext: {
                    outlet: u,
                    matches: v,
                    isDataRoute: t != null
                },
                children: N
            })
        }
        ;
        return t && (d.route.ErrorBoundary || d.route.errorElement || h === 0) ? V.createElement(ZX, {
            location: t.location,
            revalidation: t.revalidation,
            component: w,
            error: p,
            children: S(),
            routeContext: {
                outlet: null,
                matches: v,
                isDataRoute: !0
            },
            unstable_onError: r
        }) : S()
    }
    , null)
}
function _8(n) {
    return `${n} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`
}
function tQ(n) {
    let e = V.useContext(x0);
    return ir(e, _8(n)),
    e
}
function nQ(n) {
    let e = V.useContext(Tv);
    return ir(e, _8(n)),
    e
}
function rQ(n) {
    let e = V.useContext(ga);
    return ir(e, _8(n)),
    e
}
function k8(n) {
    let e = rQ(n)
      , t = e.matches[e.matches.length - 1];
    return ir(t.route.id, `${n} can only be used on routes that contain a unique "id"`),
    t.route.id
}
function sQ() {
    return k8("useRouteId")
}
function iQ() {
    let n = V.useContext(C8)
      , e = nQ("useRouteError")
      , t = k8("useRouteError");
    return n !== void 0 ? n : e.errors?.[t]
}
function oQ() {
    let {router: n} = tQ("useNavigate")
      , e = k8("useNavigate")
      , t = V.useRef(!1);
    return oL( () => {
        t.current = !0
    }
    ),
    V.useCallback(async (s, i={}) => {
        el(t.current, iL),
        t.current && (typeof s == "number" ? n.navigate(s) : await n.navigate(s, {
            fromRouteId: e,
            ...i
        }))
    }
    , [n, e])
}
var QT = {};
function lL(n, e, t) {
    !e && !QT[n] && (QT[n] = !0,
    el(!1, t))
}
V.memo(aQ);
function aQ({routes: n, future: e, state: t, unstable_onError: r}) {
    return aL(n, void 0, t, r, e)
}
function lQ(n) {
    return YX(n.context)
}
function Vn(n) {
    ir(!1, "A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.")
}
function cQ({basename: n="/", children: e=null, location: t, navigationType: r="POP", navigator: s, static: i=!1}) {
    ir(!vy(), "You cannot render a <Router> inside another <Router>. You should never have more than one in your app.");
    let o = n.replace(/^\/*/, "/")
      , a = V.useMemo( () => ({
        basename: o,
        navigator: s,
        static: i,
        future: {}
    }), [o, s, i]);
    typeof t == "string" && (t = v0(t));
    let {pathname: l="/", search: u="", hash: d="", state: h=null, key: p="default"} = t
      , g = V.useMemo( () => {
        let w = Ac(l, o);
        return w == null ? null : {
            location: {
                pathname: w,
                search: u,
                hash: d,
                state: h,
                key: p
            },
            navigationType: r
        }
    }
    , [o, l, u, d, h, p, r]);
    return el(g != null, `<Router basename="${o}"> is not able to match the URL "${l}${u}${d}" because it does not start with the basename, so the <Router> won't render anything.`),
    g == null ? null : V.createElement(il.Provider, {
        value: a
    }, V.createElement(wy.Provider, {
        children: e,
        value: g
    }))
}
function cL({children: n, location: e}) {
    return KX(f4(n), e)
}
function f4(n, e=[]) {
    let t = [];
    return V.Children.forEach(n, (r, s) => {
        if (!V.isValidElement(r))
            return;
        let i = [...e, s];
        if (r.type === V.Fragment) {
            t.push.apply(t, f4(r.props.children, i));
            return
        }
        ir(r.type === Vn, `[${typeof r.type == "string" ? r.type : r.type.name}] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`),
        ir(!r.props.index || !r.props.children, "An index route cannot have child routes.");
        let o = {
            id: r.props.id || i.join("-"),
            caseSensitive: r.props.caseSensitive,
            element: r.props.element,
            Component: r.props.Component,
            index: r.props.index,
            path: r.props.path,
            middleware: r.props.middleware,
            loader: r.props.loader,
            action: r.props.action,
            hydrateFallbackElement: r.props.hydrateFallbackElement,
            HydrateFallback: r.props.HydrateFallback,
            errorElement: r.props.errorElement,
            ErrorBoundary: r.props.ErrorBoundary,
            hasErrorBoundary: r.props.hasErrorBoundary === !0 || r.props.ErrorBoundary != null || r.props.errorElement != null,
            shouldRevalidate: r.props.shouldRevalidate,
            handle: r.props.handle,
            lazy: r.props.lazy
        };
        r.props.children && (o.children = f4(r.props.children, i)),
        t.push(o)
    }
    ),
    t
}
var Pw = "get"
  , jw = "application/x-www-form-urlencoded";
function Iv(n) {
    return n != null && typeof n.tagName == "string"
}
function uQ(n) {
    return Iv(n) && n.tagName.toLowerCase() === "button"
}
function dQ(n) {
    return Iv(n) && n.tagName.toLowerCase() === "form"
}
function fQ(n) {
    return Iv(n) && n.tagName.toLowerCase() === "input"
}
function hQ(n) {
    return !!(n.metaKey || n.altKey || n.ctrlKey || n.shiftKey)
}
function pQ(n, e) {
    return n.button === 0 && (!e || e === "_self") && !hQ(n)
}
var b1 = null;
function mQ() {
    if (b1 === null)
        try {
            new FormData(document.createElement("form"),0),
            b1 = !1
        } catch {
            b1 = !0
        }
    return b1
}
var gQ = new Set(["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]);
function bS(n) {
    return n != null && !gQ.has(n) ? (el(!1, `"${n}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${jw}"`),
    null) : n
}
function yQ(n, e) {
    let t, r, s, i, o;
    if (dQ(n)) {
        let a = n.getAttribute("action");
        r = a ? Ac(a, e) : null,
        t = n.getAttribute("method") || Pw,
        s = bS(n.getAttribute("enctype")) || jw,
        i = new FormData(n)
    } else if (uQ(n) || fQ(n) && (n.type === "submit" || n.type === "image")) {
        let a = n.form;
        if (a == null)
            throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');
        let l = n.getAttribute("formaction") || a.getAttribute("action");
        if (r = l ? Ac(l, e) : null,
        t = n.getAttribute("formmethod") || a.getAttribute("method") || Pw,
        s = bS(n.getAttribute("formenctype")) || bS(a.getAttribute("enctype")) || jw,
        i = new FormData(a,n),
        !mQ()) {
            let {name: u, type: d, value: h} = n;
            if (d === "image") {
                let p = u ? `${u}.` : "";
                i.append(`${p}x`, "0"),
                i.append(`${p}y`, "0")
            } else
                u && i.append(u, h)
        }
    } else {
        if (Iv(n))
            throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');
        t = Pw,
        r = null,
        s = jw,
        o = n
    }
    return i && s === "text/plain" && (o = i,
    i = void 0),
    {
        action: r,
        method: t.toLowerCase(),
        encType: s,
        formData: i,
        body: o
    }
}
Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
function N8(n, e) {
    if (n === !1 || n === null || typeof n > "u")
        throw new Error(e)
}
function bQ(n, e, t) {
    let r = typeof n == "string" ? new URL(n,typeof window > "u" ? "server://singlefetch/" : window.location.origin) : n;
    return r.pathname === "/" ? r.pathname = `_root.${t}` : e && Ac(r.pathname, e) === "/" ? r.pathname = `${e.replace(/\/$/, "")}/_root.${t}` : r.pathname = `${r.pathname.replace(/\/$/, "")}.${t}`,
    r
}
async function wQ(n, e) {
    if (n.id in e)
        return e[n.id];
    try {
        let t = await import(n.module);
        return e[n.id] = t,
        t
    } catch (t) {
        return console.error(`Error loading route module \`${n.module}\`, reloading page...`),
        console.error(t),
        window.__reactRouterContext && window.__reactRouterContext.isSpaMode,
        window.location.reload(),
        new Promise( () => {}
        )
    }
}
function vQ(n) {
    return n == null ? !1 : n.href == null ? n.rel === "preload" && typeof n.imageSrcSet == "string" && typeof n.imageSizes == "string" : typeof n.rel == "string" && typeof n.href == "string"
}
async function xQ(n, e, t) {
    let r = await Promise.all(n.map(async s => {
        let i = e.routes[s.route.id];
        if (i) {
            let o = await wQ(i, t);
            return o.links ? o.links() : []
        }
        return []
    }
    ));
    return CQ(r.flat(1).filter(vQ).filter(s => s.rel === "stylesheet" || s.rel === "preload").map(s => s.rel === "stylesheet" ? {
        ...s,
        rel: "prefetch",
        as: "style"
    } : {
        ...s,
        rel: "prefetch"
    }))
}
function ZT(n, e, t, r, s, i) {
    let o = (l, u) => t[u] ? l.route.id !== t[u].route.id : !0
      , a = (l, u) => t[u].pathname !== l.pathname || t[u].route.path?.endsWith("*") && t[u].params["*"] !== l.params["*"];
    return i === "assets" ? e.filter( (l, u) => o(l, u) || a(l, u)) : i === "data" ? e.filter( (l, u) => {
        let d = r.routes[l.route.id];
        if (!d || !d.hasLoader)
            return !1;
        if (o(l, u) || a(l, u))
            return !0;
        if (l.route.shouldRevalidate) {
            let h = l.route.shouldRevalidate({
                currentUrl: new URL(s.pathname + s.search + s.hash,window.origin),
                currentParams: t[0]?.params || {},
                nextUrl: new URL(n,window.origin),
                nextParams: l.params,
                defaultShouldRevalidate: !0
            });
            if (typeof h == "boolean")
                return h
        }
        return !0
    }
    ) : []
}
function EQ(n, e, {includeHydrateFallback: t}={}) {
    return SQ(n.map(r => {
        let s = e.routes[r.route.id];
        if (!s)
            return [];
        let i = [s.module];
        return s.clientActionModule && (i = i.concat(s.clientActionModule)),
        s.clientLoaderModule && (i = i.concat(s.clientLoaderModule)),
        t && s.hydrateFallbackModule && (i = i.concat(s.hydrateFallbackModule)),
        s.imports && (i = i.concat(s.imports)),
        i
    }
    ).flat(1))
}
function SQ(n) {
    return [...new Set(n)]
}
function AQ(n) {
    let e = {}
      , t = Object.keys(n).sort();
    for (let r of t)
        e[r] = n[r];
    return e
}
function CQ(n, e) {
    let t = new Set;
    return new Set(e),
    n.reduce( (r, s) => {
        let i = JSON.stringify(AQ(s));
        return t.has(i) || (t.add(i),
        r.push({
            key: i,
            link: s
        })),
        r
    }
    , [])
}
function uL() {
    let n = V.useContext(x0);
    return N8(n, "You must render this element inside a <DataRouterContext.Provider> element"),
    n
}
function _Q() {
    let n = V.useContext(Tv);
    return N8(n, "You must render this element inside a <DataRouterStateContext.Provider> element"),
    n
}
var D8 = V.createContext(void 0);
D8.displayName = "FrameworkContext";
function dL() {
    let n = V.useContext(D8);
    return N8(n, "You must render this element inside a <HydratedRouter> element"),
    n
}
function kQ(n, e) {
    let t = V.useContext(D8)
      , [r,s] = V.useState(!1)
      , [i,o] = V.useState(!1)
      , {onFocus: a, onBlur: l, onMouseEnter: u, onMouseLeave: d, onTouchStart: h} = e
      , p = V.useRef(null);
    V.useEffect( () => {
        if (n === "render" && o(!0),
        n === "viewport") {
            let b = S => {
                S.forEach(N => {
                    o(N.isIntersecting)
                }
                )
            }
              , v = new IntersectionObserver(b,{
                threshold: .5
            });
            return p.current && v.observe(p.current),
            () => {
                v.disconnect()
            }
        }
    }
    , [n]),
    V.useEffect( () => {
        if (r) {
            let b = setTimeout( () => {
                o(!0)
            }
            , 100);
            return () => {
                clearTimeout(b)
            }
        }
    }
    , [r]);
    let g = () => {
        s(!0)
    }
      , w = () => {
        s(!1),
        o(!1)
    }
    ;
    return t ? n !== "intent" ? [i, p, {}] : [i, p, {
        onFocus: Im(a, g),
        onBlur: Im(l, w),
        onMouseEnter: Im(u, g),
        onMouseLeave: Im(d, w),
        onTouchStart: Im(h, g)
    }] : [!1, p, {}]
}
function Im(n, e) {
    return t => {
        n && n(t),
        t.defaultPrevented || e(t)
    }
}
function NQ({page: n, ...e}) {
    let {router: t} = uL()
      , r = V.useMemo( () => Z9(t.routes, n, t.basename), [t.routes, n, t.basename]);
    return r ? V.createElement(TQ, {
        page: n,
        matches: r,
        ...e
    }) : null
}
function DQ(n) {
    let {manifest: e, routeModules: t} = dL()
      , [r,s] = V.useState([]);
    return V.useEffect( () => {
        let i = !1;
        return xQ(n, e, t).then(o => {
            i || s(o)
        }
        ),
        () => {
            i = !0
        }
    }
    , [n, e, t]),
    r
}
function TQ({page: n, matches: e, ...t}) {
    let r = Ti()
      , {manifest: s, routeModules: i} = dL()
      , {basename: o} = uL()
      , {loaderData: a, matches: l} = _Q()
      , u = V.useMemo( () => ZT(n, e, l, s, r, "data"), [n, e, l, s, r])
      , d = V.useMemo( () => ZT(n, e, l, s, r, "assets"), [n, e, l, s, r])
      , h = V.useMemo( () => {
        if (n === r.pathname + r.search + r.hash)
            return [];
        let w = new Set
          , b = !1;
        if (e.forEach(S => {
            let N = s.routes[S.route.id];
            !N || !N.hasLoader || (!u.some(_ => _.route.id === S.route.id) && S.route.id in a && i[S.route.id]?.shouldRevalidate || N.hasClientLoader ? b = !0 : w.add(S.route.id))
        }
        ),
        w.size === 0)
            return [];
        let v = bQ(n, o, "data");
        return b && w.size > 0 && v.searchParams.set("_routes", e.filter(S => w.has(S.route.id)).map(S => S.route.id).join(",")),
        [v.pathname + v.search]
    }
    , [o, a, r, s, u, e, n, i])
      , p = V.useMemo( () => EQ(d, s), [d, s])
      , g = DQ(d);
    return V.createElement(V.Fragment, null, h.map(w => V.createElement("link", {
        key: w,
        rel: "prefetch",
        as: "fetch",
        href: w,
        ...t
    })), p.map(w => V.createElement("link", {
        key: w,
        rel: "modulepreload",
        href: w,
        ...t
    })), g.map( ({key: w, link: b}) => V.createElement("link", {
        key: w,
        nonce: t.nonce,
        ...b
    })))
}
function IQ(...n) {
    return e => {
        n.forEach(t => {
            typeof t == "function" ? t(e) : t != null && (t.current = e)
        }
        )
    }
}
var fL = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
try {
    fL && (window.__reactRouterVersion = "7.9.5")
} catch {}
function MQ({basename: n, children: e, window: t}) {
    let r = V.useRef();
    r.current == null && (r.current = bX({
        window: t,
        v5Compat: !0
    }));
    let s = r.current
      , [i,o] = V.useState({
        action: s.action,
        location: s.location
    })
      , a = V.useCallback(l => {
        V.startTransition( () => o(l))
    }
    , [o]);
    return V.useLayoutEffect( () => s.listen(a), [s, a]),
    V.createElement(cQ, {
        basename: n,
        children: e,
        location: i.location,
        navigationType: i.action,
        navigator: s
    })
}
var hL = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i
  , Us = V.forwardRef(function({onClick: e, discover: t="render", prefetch: r="none", relative: s, reloadDocument: i, replace: o, state: a, target: l, to: u, preventScrollReset: d, viewTransition: h, ...p}, g) {
    let {basename: w} = V.useContext(il), b = typeof u == "string" && hL.test(u), v, S = !1;
    if (typeof u == "string" && b && (v = u,
    fL))
        try {
            let R = new URL(window.location.href)
              , L = u.startsWith("//") ? new URL(R.protocol + u) : new URL(u)
              , q = Ac(L.pathname, w);
            L.origin === R.origin && q != null ? u = q + L.search + L.hash : S = !0
        } catch {
            el(!1, `<Link to="${u}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`)
        }
    let N = qX(u, {
        relative: s
    })
      , [_,I,k] = kQ(r, p)
      , B = PQ(u, {
        replace: o,
        state: a,
        target: l,
        preventScrollReset: d,
        relative: s,
        viewTransition: h
    });
    function P(R) {
        e && e(R),
        R.defaultPrevented || B(R)
    }
    let M = V.createElement("a", {
        ...p,
        ...k,
        href: v || N,
        onClick: S || i ? e : P,
        ref: IQ(g, I),
        target: l,
        "data-discover": !b && t === "render" ? "true" : void 0
    });
    return _ && !b ? V.createElement(V.Fragment, null, M, V.createElement(NQ, {
        page: N
    })) : M
});
Us.displayName = "Link";
var BQ = V.forwardRef(function({"aria-current": e="page", caseSensitive: t=!1, className: r="", end: s=!1, style: i, to: o, viewTransition: a, children: l, ...u}, d) {
    let h = xy(o, {
        relative: u.relative
    })
      , p = Ti()
      , g = V.useContext(Tv)
      , {navigator: w, basename: b} = V.useContext(il)
      , v = g != null && zQ(h) && a === !0
      , S = w.encodeLocation ? w.encodeLocation(h).pathname : h.pathname
      , N = p.pathname
      , _ = g && g.navigation && g.navigation.location ? g.navigation.location.pathname : null;
    t || (N = N.toLowerCase(),
    _ = _ ? _.toLowerCase() : null,
    S = S.toLowerCase()),
    _ && b && (_ = Ac(_, b) || _);
    const I = S !== "/" && S.endsWith("/") ? S.length - 1 : S.length;
    let k = N === S || !s && N.startsWith(S) && N.charAt(I) === "/", B = _ != null && (_ === S || !s && _.startsWith(S) && _.charAt(S.length) === "/"), P = {
        isActive: k,
        isPending: B,
        isTransitioning: v
    }, M = k ? e : void 0, R;
    typeof r == "function" ? R = r(P) : R = [r, k ? "active" : null, B ? "pending" : null, v ? "transitioning" : null].filter(Boolean).join(" ");
    let L = typeof i == "function" ? i(P) : i;
    return V.createElement(Us, {
        ...u,
        "aria-current": M,
        className: R,
        ref: d,
        style: L,
        to: o,
        viewTransition: a
    }, typeof l == "function" ? l(P) : l)
});
BQ.displayName = "NavLink";
var RQ = V.forwardRef( ({discover: n="render", fetcherKey: e, navigate: t, reloadDocument: r, replace: s, state: i, method: o=Pw, action: a, onSubmit: l, relative: u, preventScrollReset: d, viewTransition: h, ...p}, g) => {
    let w = FQ()
      , b = UQ(a, {
        relative: u
    })
      , v = o.toLowerCase() === "get" ? "get" : "post"
      , S = typeof a == "string" && hL.test(a)
      , N = _ => {
        if (l && l(_),
        _.defaultPrevented)
            return;
        _.preventDefault();
        let I = _.nativeEvent.submitter
          , k = I?.getAttribute("formmethod") || o;
        w(I || _.currentTarget, {
            fetcherKey: e,
            method: k,
            navigate: t,
            replace: s,
            state: i,
            relative: u,
            preventScrollReset: d,
            viewTransition: h
        })
    }
    ;
    return V.createElement("form", {
        ref: g,
        method: v,
        action: b,
        onSubmit: r ? l : N,
        ...p,
        "data-discover": !S && n === "render" ? "true" : void 0
    })
}
);
RQ.displayName = "Form";
function OQ(n) {
    return `${n} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`
}
function pL(n) {
    let e = V.useContext(x0);
    return ir(e, OQ(n)),
    e
}
function PQ(n, {target: e, replace: t, state: r, preventScrollReset: s, relative: i, viewTransition: o}={}) {
    let a = kr()
      , l = Ti()
      , u = xy(n, {
        relative: i
    });
    return V.useCallback(d => {
        if (pQ(d, e)) {
            d.preventDefault();
            let h = t !== void 0 ? t : $g(l) === $g(u);
            a(n, {
                replace: h,
                state: r,
                preventScrollReset: s,
                relative: i,
                viewTransition: o
            })
        }
    }
    , [l, a, u, t, r, e, n, s, i, o])
}
var jQ = 0
  , LQ = () => `__${String(++jQ)}__`;
function FQ() {
    let {router: n} = pL("useSubmit")
      , {basename: e} = V.useContext(il)
      , t = sQ();
    return V.useCallback(async (r, s={}) => {
        let {action: i, method: o, encType: a, formData: l, body: u} = yQ(r, e);
        if (s.navigate === !1) {
            let d = s.fetcherKey || LQ();
            await n.fetch(d, t, s.action || i, {
                preventScrollReset: s.preventScrollReset,
                formData: l,
                body: u,
                formMethod: s.method || o,
                formEncType: s.encType || a,
                flushSync: s.flushSync
            })
        } else
            await n.navigate(s.action || i, {
                preventScrollReset: s.preventScrollReset,
                formData: l,
                body: u,
                formMethod: s.method || o,
                formEncType: s.encType || a,
                replace: s.replace,
                state: s.state,
                fromRouteId: t,
                flushSync: s.flushSync,
                viewTransition: s.viewTransition
            })
    }
    , [n, e, t])
}
function UQ(n, {relative: e}={}) {
    let {basename: t} = V.useContext(il)
      , r = V.useContext(ga);
    ir(r, "useFormAction must be used inside a RouteContext");
    let[s] = r.matches.slice(-1)
      , i = {
        ...xy(n || ".", {
            relative: e
        })
    }
      , o = Ti();
    if (n == null) {
        i.search = o.search;
        let a = new URLSearchParams(i.search)
          , l = a.getAll("index");
        if (l.some(d => d === "")) {
            a.delete("index"),
            l.filter(h => h).forEach(h => a.append("index", h));
            let d = a.toString();
            i.search = d ? `?${d}` : ""
        }
    }
    return (!n || n === ".") && s.route.index && (i.search = i.search ? i.search.replace(/^\?/, "?index&") : "?index"),
    t !== "/" && (i.pathname = i.pathname === "/" ? t : hc([t, i.pathname])),
    $g(i)
}
function zQ(n, {relative: e}={}) {
    let t = V.useContext(sL);
    ir(t != null, "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?");
    let {basename: r} = pL("useViewTransitionState")
      , s = xy(n, {
        relative: e
    });
    if (!t.isTransitioning)
        return !1;
    let i = Ac(t.currentLocation.pathname, r) || t.currentLocation.pathname
      , o = Ac(t.nextLocation.pathname, r) || t.nextLocation.pathname;
    return l2(s.pathname, o) != null || l2(s.pathname, i) != null
}
var mL = Q9();
const $Q = Fo(mL)
  , HQ = "/assets/ultimate-arcade-of-gaming-DUtlgyiu.svg"
  , VQ = "/assets/view-3d-video-game-controller-DE5HuuxJ.png"
  , JT = () => !!document.querySelector('script[src*="/recaptcha/"]:not([src*="gstatic"])')
  , qQ = () => ".grecaptcha-badge{display: none !important;}"
  , GQ = ({host: n="google.com", isEnterprise: e=!1, render: t, hl: r, badge: s}) => {
    const i = new URLSearchParams({
        ...r && {
            hl: r
        },
        ...s && {
            badge: s
        },
        render: t
    });
    return `https://www.${n}/recaptcha/${e ? "enterprise.js" : "api.js"}?${i}`
}
  , WQ = () => {
    const n = document.createElement("style");
    n.innerHTML = qQ(),
    document.body.appendChild(n)
}
  , YQ = ({onload: n, appendTo: e="head", isEnterprise: t=!1, host: r, render: s, badge: i, hl: o, ...a}) => {
    const l = GQ({
        host: r,
        isEnterprise: t,
        render: s,
        hl: o,
        badge: i
    })
      , u = document.createElement("script");
    Object.entries(a).forEach( ([d,h]) => {
        u.setAttribute(d, h?.toString() ?? "")
    }
    ),
    u.src = l,
    u.onload = n,
    document[e].appendChild(u)
}
  , KQ = () => {
    const n = document.querySelector(".grecaptcha-badge");
    n && n.parentNode && document.body.removeChild(n.parentNode)
}
  , XQ = n => {
    const e = document.getElementById(n);
    if (e)
        for (; e.lastChild; )
            e.lastChild.remove()
}
  , QQ = "https://www.gstatic.com/recaptcha/releases"
  , ZQ = () => {
    window.___grecaptcha_cfg = void 0;
    const n = document.querySelector('script[src*="/recaptcha/"]:not([src*="gstatic"])');
    n && n.remove();
    const e = document.querySelector(`script[src^="${QQ}"]`);
    e && e.remove()
}
  , Mm = "GoogleReCaptcha Context has not yet been implemented, if you are using useGoogleReCaptcha hook, make sure the hook is called inside component wrapped by GoogleRecaptchaProvider"
  , gL = V.createContext({
    instance: void 0,
    siteKey: "",
    language: "",
    isLoading: !0,
    executeV3: () => {
        throw new Error(Mm)
    }
    ,
    executeV2Invisible: () => {
        throw new Error(Mm)
    }
    ,
    reset: () => {
        throw new Error(Mm)
    }
    ,
    getResponse: () => {
        throw new Error(Mm)
    }
    ,
    render: () => {
        throw new Error(Mm)
    }
})
  , Uo = () => V.useContext(gL)
  , JQ = "onGoogleReCaptchaLoad"
  , eZ = "google-recaptcha-container"
  , tZ = ({type: n, siteKey: e, language: t, scriptProps: r, isEnterprise: s=!1, host: i, theme: o="light", children: a, explicit: l, onLoad: u, onError: d}) => {
    const [h,p] = V.useState(!0)
      , [g,w] = V.useState();
    V.useEffect( () => {
        const N = r?.id ?? `google-recaptcha-${n}-script`
          , _ = JT()
          , I = () => {
            var k;
            p(!0);
            const B = s ? (k = window.grecaptcha) == null ? void 0 : k.enterprise : window.grecaptcha;
            if (!B) {
                d && d();
                return
            }
            if (l || B.ready(async () => {
                w(B),
                u && await u(B),
                p(!1)
            }
            ),
            l) {
                const P = {
                    size: n === "v3" || n === "v2-invisible" ? "invisible" : "normal",
                    ...(n === "v3" || n === "v2-invisible") && {
                        badge: "bottomright"
                    },
                    sitekey: e,
                    theme: o,
                    ...typeof l == "object" && {
                        ...l,
                        "expired-callback": l.expiredCallback,
                        "error-callback": l.errorCallback
                    }
                };
                _ || typeof l == "object" && (n === "v3" || n === "v2-invisible") && l?.badge === "hidden" && WQ(),
                B.ready(async () => {
                    typeof l == "object" && l.container && B.render(l.container, P, !!l.inherit),
                    w(B),
                    u && await u(B),
                    p(!1)
                }
                )
            }
        }
        ;
        return window[JQ] = I,
        _ ? I() : YQ({
            isEnterprise: s,
            host: i,
            ...(n === "v3" || n === "v2-invisible") && typeof l == "object" && l?.badge && {
                badge: l?.badge === "hidden" ? "bottomright" : l?.badge
            },
            ...t && {
                hl: t
            },
            render: l || n === "v2-checkbox" ? "explicit" : e,
            ...r,
            onload: I,
            id: N
        }),
        () => {
            JT() && ZQ(),
            typeof l == "object" && (n === "v3" || n === "v2-invisible") && !(l != null && l.container) && l != null && l.badge ? XQ(eZ) : KQ()
        }
    }
    , [s, t, i, e, n]);
    const b = N => {
        if (!(g != null && g.execute))
            throw new Error("Google ReCaptcha has not been loaded");
        return g.execute(e, {
            action: N
        })
    }
      , v = N => {
        if (!(g != null && g.execute))
            throw new Error("Google ReCaptcha has not been loaded");
        return g.execute(N)
    }
      , S = V.useMemo( () => ({
        instance: g,
        siteKey: e,
        isLoading: h,
        theme: o,
        executeV2Invisible: v,
        executeV3: b,
        reset: g?.reset,
        getResponse: g?.getResponse,
        render: g?.render,
        ...t && {
            language: t
        }
    }), [g, e, h, t]);
    return m.jsx(gL.Provider, {
        value: S,
        children: a
    })
}
;
function Hg(n, e) {
    try {
        return typeof e == "object" && (e = JSON.stringify(e)),
        window.localStorage.setItem(n, e),
        !0
    } catch {
        return console.error("Error Occured while storing data"),
        !1
    }
}
function S0(n) {
    try {
        let e = window.localStorage.getItem(n);
        return e == null ? !1 : JSON.parse(e)
    } catch {
        return console.error("Error Occured while getting data"),
        !1
    }
}
function T8(n) {
    try {
        window.localStorage.removeItem(n)
    } catch {
        return !1
    }
}
let nc = {
    Accept: "application/json",
    "Content-Type": "application/json;charset=UTF-8"
};
function yL() {
    return S0("userInfo")?.authToken || null
}
function Gr(n) {
    const e = yL();
    return nc = {
        "Content-Type": "application/json"
    },
    e && (nc = {
        ...nc,
        Authorization: `Bearer ${e}`
    }),
    fetch(n, {
        method: "GET",
        mode: "cors",
        cache: "no-cache",
        credentials: "same-origin",
        headers: nc
    }).then(t => t.json()).then(async t => t).catch(t => t)
}
async function Wr(n, e, t) {
    try {
        const r = yL();
        return r && (nc = {
            ...nc,
            Authorization: "Bearer " + r
        }),
        t && (nc = {
            ...nc,
            "x-recaptcha-token": t
        }),
        fetch(`${n}`, {
            method: "POST",
            headers: nc,
            body: JSON.stringify(e)
        }).then(s => s.json()).then(s => s).catch(s => s)
    } catch (r) {
        console.log(" ~ postData ~ error:", r)
    }
}
const nZ = "production"
  , rZ = {
    local: {
        app: "http://localhost:3000",
        play: "http://localhost:4000",
        alpha: "https://alpha-api.l1xapp.com"
    },
    staging: {
        app: "https://dev-api.l1xapp.com",
        play: "https://l1x-play-staging-api.l1xapp.com",
        alpha: "https://alpha-api.l1xapp.com"
    },
    production: {
        app: "https://v2-api.l1xapp.com",
        play: " https://l1x-play-api.l1xapp.com",
        alpha: "https://alpha-api.l1xapp.com"
    }
}
  , Pc = {
    BASE_URL: rZ[nZ]
}
  , Ey = Pc.BASE_URL.play;
async function sZ(n, e) {
    return await Gr(`${Ey}/api/v1/game/l1x_games?page=${n}&limit=${e}`)
}
async function iZ() {
    return await Gr(`${Ey}/api/v1/jackpot/l1x_isEligibleForJackpot`)
}
async function oZ() {
    return await Gr(`${Ey}/api/v1/jackpot/l1x_isUserWonTheTodayJackpot`)
}
async function aZ() {
    return await Wr(`${Ey}/api/v1/jackpot/l1x_initiateTwitterOAuth`)
}
async function lZ(n) {
    return await Wr(`${Ey}/api/v1/jackpot/l1x_shareJackpotRewardToSocialMedia`, n)
}
const cZ = "6.15.0";
function uZ(n, e, t) {
    const r = e.split("|").map(i => i.trim());
    for (let i = 0; i < r.length; i++)
        switch (e) {
        case "any":
            return;
        case "bigint":
        case "boolean":
        case "number":
        case "string":
            if (typeof n === e)
                return
        }
    const s = new Error(`invalid value for type ${e}`);
    throw s.code = "INVALID_ARGUMENT",
    s.argument = `value.${t}`,
    s.value = n,
    s
}
async function qs(n) {
    const e = Object.keys(n);
    return (await Promise.all(e.map(r => Promise.resolve(n[r])))).reduce( (r, s, i) => (r[e[i]] = s,
    r), {})
}
function xt(n, e, t) {
    for (let r in e) {
        let s = e[r];
        const i = t ? t[r] : null;
        i && uZ(s, i, r),
        Object.defineProperty(n, r, {
            enumerable: !0,
            value: s,
            writable: !1
        })
    }
}
function hp(n, e) {
    if (n == null)
        return "null";
    if (e == null && (e = new Set),
    typeof n == "object") {
        if (e.has(n))
            return "[Circular]";
        e.add(n)
    }
    if (Array.isArray(n))
        return "[ " + n.map(t => hp(t, e)).join(", ") + " ]";
    if (n instanceof Uint8Array) {
        const t = "0123456789abcdef";
        let r = "0x";
        for (let s = 0; s < n.length; s++)
            r += t[n[s] >> 4],
            r += t[n[s] & 15];
        return r
    }
    if (typeof n == "object" && typeof n.toJSON == "function")
        return hp(n.toJSON(), e);
    switch (typeof n) {
    case "boolean":
    case "number":
    case "symbol":
        return n.toString();
    case "bigint":
        return BigInt(n).toString();
    case "string":
        return JSON.stringify(n);
    case "object":
        {
            const t = Object.keys(n);
            return t.sort(),
            "{ " + t.map(r => `${hp(r, e)}: ${hp(n[r], e)}`).join(", ") + " }"
        }
    }
    return "[ COULD NOT SERIALIZE ]"
}
function xs(n, e) {
    return n && n.code === e
}
function I8(n) {
    return xs(n, "CALL_EXCEPTION")
}
function Zn(n, e, t) {
    let r = n;
    {
        const i = [];
        if (t) {
            if ("message"in t || "code"in t || "name"in t)
                throw new Error(`value will overwrite populated values: ${hp(t)}`);
            for (const o in t) {
                if (o === "shortMessage")
                    continue;
                const a = t[o];
                i.push(o + "=" + hp(a))
            }
        }
        i.push(`code=${e}`),
        i.push(`version=${cZ}`),
        i.length && (n += " (" + i.join(", ") + ")")
    }
    let s;
    switch (e) {
    case "INVALID_ARGUMENT":
        s = new TypeError(n);
        break;
    case "NUMERIC_FAULT":
    case "BUFFER_OVERRUN":
        s = new RangeError(n);
        break;
    default:
        s = new Error(n)
    }
    return xt(s, {
        code: e
    }),
    t && Object.assign(s, t),
    s.shortMessage == null && xt(s, {
        shortMessage: r
    }),
    s
}
function Ie(n, e, t, r) {
    if (!n)
        throw Zn(e, t, r)
}
function he(n, e, t, r) {
    Ie(n, e, "INVALID_ARGUMENT", {
        argument: t,
        value: r
    })
}
function bL(n, e, t) {
    t == null && (t = ""),
    t && (t = ": " + t),
    Ie(n >= e, "missing argument" + t, "MISSING_ARGUMENT", {
        count: n,
        expectedCount: e
    }),
    Ie(n <= e, "too many arguments" + t, "UNEXPECTED_ARGUMENT", {
        count: n,
        expectedCount: e
    })
}
["NFD", "NFC", "NFKD", "NFKC"].reduce( (n, e) => {
    try {
        if ("test".normalize(e) !== "test")
            throw new Error("bad");
        if (e === "NFD" && "".normalize("NFD") !== "e")
            throw new Error("broken");
        n.push(e)
    } catch {}
    return n
}
, []);
function Sy(n, e, t) {
    if (t == null && (t = ""),
    n !== e) {
        let r = t
          , s = "new";
        t && (r += ".",
        s += " " + t),
        Ie(!1, `private constructor; use ${r}from* methods`, "UNSUPPORTED_OPERATION", {
            operation: s
        })
    }
}
function wL(n, e, t) {
    if (n instanceof Uint8Array)
        return t ? new Uint8Array(n) : n;
    if (typeof n == "string" && n.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {
        const r = new Uint8Array((n.length - 2) / 2);
        let s = 2;
        for (let i = 0; i < r.length; i++)
            r[i] = parseInt(n.substring(s, s + 2), 16),
            s += 2;
        return r
    }
    he(!1, "invalid BytesLike value", e || "value", n)
}
function zt(n, e) {
    return wL(n, e, !1)
}
function Ws(n, e) {
    return wL(n, e, !0)
}
function zn(n, e) {
    return !(typeof n != "string" || !n.match(/^0x[0-9A-Fa-f]*$/) || typeof e == "number" && n.length !== 2 + 2 * e || e === !0 && n.length % 2 !== 0)
}
function M8(n) {
    return zn(n, !0) || n instanceof Uint8Array
}
const eI = "0123456789abcdef";
function Ke(n) {
    const e = zt(n);
    let t = "0x";
    for (let r = 0; r < e.length; r++) {
        const s = e[r];
        t += eI[(s & 240) >> 4] + eI[s & 15]
    }
    return t
}
function gr(n) {
    return "0x" + n.map(e => Ke(e).substring(2)).join("")
}
function Sp(n) {
    return zn(n, !0) ? (n.length - 2) / 2 : zt(n).length
}
function fr(n, e, t) {
    const r = zt(n);
    return t != null && t > r.length && Ie(!1, "cannot slice beyond data bounds", "BUFFER_OVERRUN", {
        buffer: r,
        length: r.length,
        offset: t
    }),
    Ke(r.slice(e ?? 0, t ?? r.length))
}
function vL(n, e, t) {
    const r = zt(n);
    Ie(e >= r.length, "padding exceeds data length", "BUFFER_OVERRUN", {
        buffer: new Uint8Array(r),
        length: e,
        offset: e + 1
    });
    const s = new Uint8Array(e);
    return s.fill(0),
    t ? s.set(r, e - r.length) : s.set(r, 0),
    Ke(s)
}
function Cc(n, e) {
    return vL(n, e, !0)
}
function dZ(n, e) {
    return vL(n, e, !1)
}
const Mv = BigInt(0)
  , na = BigInt(1)
  , pp = 9007199254740991;
function c2(n, e) {
    const t = Bv(n, "value")
      , r = BigInt(Bt(e, "width"));
    if (Ie(t >> r === Mv, "overflow", "NUMERIC_FAULT", {
        operation: "fromTwos",
        fault: "overflow",
        value: n
    }),
    t >> r - na) {
        const s = (na << r) - na;
        return -((~t & s) + na)
    }
    return t
}
function xL(n, e) {
    let t = nt(n, "value");
    const r = BigInt(Bt(e, "width"))
      , s = na << r - na;
    if (t < Mv) {
        t = -t,
        Ie(t <= s, "too low", "NUMERIC_FAULT", {
            operation: "toTwos",
            fault: "overflow",
            value: n
        });
        const i = (na << r) - na;
        return (~t & i) + na
    } else
        Ie(t < s, "too high", "NUMERIC_FAULT", {
            operation: "toTwos",
            fault: "overflow",
            value: n
        });
    return t
}
function tf(n, e) {
    const t = Bv(n, "value")
      , r = BigInt(Bt(e, "bits"));
    return t & (na << r) - na
}
function nt(n, e) {
    switch (typeof n) {
    case "bigint":
        return n;
    case "number":
        return he(Number.isInteger(n), "underflow", e || "value", n),
        he(n >= -pp && n <= pp, "overflow", e || "value", n),
        BigInt(n);
    case "string":
        try {
            if (n === "")
                throw new Error("empty string");
            return n[0] === "-" && n[1] !== "-" ? -BigInt(n.substring(1)) : BigInt(n)
        } catch (t) {
            he(!1, `invalid BigNumberish string: ${t.message}`, e || "value", n)
        }
    }
    he(!1, "invalid BigNumberish value", e || "value", n)
}
function Bv(n, e) {
    const t = nt(n, e);
    return Ie(t >= Mv, "unsigned value cannot be negative", "NUMERIC_FAULT", {
        fault: "overflow",
        operation: "getUint",
        value: n
    }),
    t
}
const tI = "0123456789abcdef";
function Rv(n) {
    if (n instanceof Uint8Array) {
        let e = "0x0";
        for (const t of n)
            e += tI[t >> 4],
            e += tI[t & 15];
        return BigInt(e)
    }
    return nt(n)
}
function Bt(n, e) {
    switch (typeof n) {
    case "bigint":
        return he(n >= -pp && n <= pp, "overflow", e || "value", n),
        Number(n);
    case "number":
        return he(Number.isInteger(n), "underflow", e || "value", n),
        he(n >= -pp && n <= pp, "overflow", e || "value", n),
        n;
    case "string":
        try {
            if (n === "")
                throw new Error("empty string");
            return Bt(BigInt(n), e)
        } catch (t) {
            he(!1, `invalid numeric string: ${t.message}`, e || "value", n)
        }
    }
    he(!1, "invalid numeric value", e || "value", n)
}
function fZ(n) {
    return Bt(Rv(n))
}
function Ku(n, e) {
    let r = Bv(n, "value").toString(16);
    if (e == null)
        r.length % 2 && (r = "0" + r);
    else {
        const s = Bt(e, "width");
        for (Ie(s * 2 >= r.length, `value exceeds width (${s} bytes)`, "NUMERIC_FAULT", {
            operation: "toBeHex",
            fault: "overflow",
            value: n
        }); r.length < s * 2; )
            r = "0" + r
    }
    return "0x" + r
}
function qr(n) {
    const e = Bv(n, "value");
    if (e === Mv)
        return new Uint8Array([]);
    let t = e.toString(16);
    t.length % 2 && (t = "0" + t);
    const r = new Uint8Array(t.length / 2);
    for (let s = 0; s < r.length; s++) {
        const i = s * 2;
        r[s] = parseInt(t.substring(i, i + 2), 16)
    }
    return r
}
function ea(n) {
    let e = Ke(M8(n) ? n : qr(n)).substring(2);
    for (; e.startsWith("0"); )
        e = e.substring(1);
    return e === "" && (e = "0"),
    "0x" + e
}
const nI = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
BigInt(0);
const rI = BigInt(58);
function hZ(n) {
    const e = zt(n);
    let t = Rv(e)
      , r = "";
    for (; t; )
        r = nI[Number(t % rI)] + r,
        t /= rI;
    for (let s = 0; s < e.length && !e[s]; s++)
        r = nI[0] + r;
    return r
}
function pZ(n) {
    n = atob(n);
    const e = new Uint8Array(n.length);
    for (let t = 0; t < n.length; t++)
        e[t] = n.charCodeAt(t);
    return zt(e)
}
function mZ(n) {
    const e = zt(n);
    let t = "";
    for (let r = 0; r < e.length; r++)
        t += String.fromCharCode(e[r]);
    return btoa(t)
}
class EL {
    filter;
    emitter;
    #e;
    constructor(e, t, r) {
        this.#e = t,
        xt(this, {
            emitter: e,
            filter: r
        })
    }
    async removeListener() {
        this.#e != null && await this.emitter.off(this.filter, this.#e)
    }
}
function gZ(n, e, t, r, s) {
    he(!1, `invalid codepoint at offset ${e}; ${n}`, "bytes", t)
}
function SL(n, e, t, r, s) {
    if (n === "BAD_PREFIX" || n === "UNEXPECTED_CONTINUE") {
        let i = 0;
        for (let o = e + 1; o < t.length && t[o] >> 6 === 2; o++)
            i++;
        return i
    }
    return n === "OVERRUN" ? t.length - e - 1 : 0
}
function yZ(n, e, t, r, s) {
    return n === "OVERLONG" ? (he(typeof s == "number", "invalid bad code point for replacement", "badCodepoint", s),
    r.push(s),
    0) : (r.push(65533),
    SL(n, e, t))
}
const bZ = Object.freeze({
    error: gZ,
    ignore: SL,
    replace: yZ
});
function wZ(n, e) {
    e == null && (e = bZ.error);
    const t = zt(n, "bytes")
      , r = [];
    let s = 0;
    for (; s < t.length; ) {
        const i = t[s++];
        if (i >> 7 === 0) {
            r.push(i);
            continue
        }
        let o = null
          , a = null;
        if ((i & 224) === 192)
            o = 1,
            a = 127;
        else if ((i & 240) === 224)
            o = 2,
            a = 2047;
        else if ((i & 248) === 240)
            o = 3,
            a = 65535;
        else {
            (i & 192) === 128 ? s += e("UNEXPECTED_CONTINUE", s - 1, t, r) : s += e("BAD_PREFIX", s - 1, t, r);
            continue
        }
        if (s - 1 + o >= t.length) {
            s += e("OVERRUN", s - 1, t, r);
            continue
        }
        let l = i & (1 << 8 - o - 1) - 1;
        for (let u = 0; u < o; u++) {
            let d = t[s];
            if ((d & 192) != 128) {
                s += e("MISSING_CONTINUE", s, t, r),
                l = null;
                break
            }
            l = l << 6 | d & 63,
            s++
        }
        if (l !== null) {
            if (l > 1114111) {
                s += e("OUT_OF_RANGE", s - 1 - o, t, r, l);
                continue
            }
            if (l >= 55296 && l <= 57343) {
                s += e("UTF16_SURROGATE", s - 1 - o, t, r, l);
                continue
            }
            if (l <= a) {
                s += e("OVERLONG", s - 1 - o, t, r, l);
                continue
            }
            r.push(l)
        }
    }
    return r
}
function pc(n, e) {
    he(typeof n == "string", "invalid string value", "str", n);
    let t = [];
    for (let r = 0; r < n.length; r++) {
        const s = n.charCodeAt(r);
        if (s < 128)
            t.push(s);
        else if (s < 2048)
            t.push(s >> 6 | 192),
            t.push(s & 63 | 128);
        else if ((s & 64512) == 55296) {
            r++;
            const i = n.charCodeAt(r);
            he(r < n.length && (i & 64512) === 56320, "invalid surrogate pair", "str", n);
            const o = 65536 + ((s & 1023) << 10) + (i & 1023);
            t.push(o >> 18 | 240),
            t.push(o >> 12 & 63 | 128),
            t.push(o >> 6 & 63 | 128),
            t.push(o & 63 | 128)
        } else
            t.push(s >> 12 | 224),
            t.push(s >> 6 & 63 | 128),
            t.push(s & 63 | 128)
    }
    return new Uint8Array(t)
}
function vZ(n) {
    return n.map(e => e <= 65535 ? String.fromCharCode(e) : (e -= 65536,
    String.fromCharCode((e >> 10 & 1023) + 55296, (e & 1023) + 56320))).join("")
}
function u2(n, e) {
    return vZ(wZ(n, e))
}
function AL(n) {
    async function e(t, r) {
        Ie(r == null || !r.cancelled, "request cancelled before sending", "CANCELLED");
        const s = t.url.split(":")[0].toLowerCase();
        Ie(s === "http" || s === "https", `unsupported protocol ${s}`, "UNSUPPORTED_OPERATION", {
            info: {
                protocol: s
            },
            operation: "request"
        }),
        Ie(s === "https" || !t.credentials || t.allowInsecureAuthentication, "insecure authorized connections unsupported", "UNSUPPORTED_OPERATION", {
            operation: "request"
        });
        let i = null;
        const o = new AbortController
          , a = setTimeout( () => {
            i = Zn("request timeout", "TIMEOUT"),
            o.abort()
        }
        , t.timeout);
        r && r.addListener( () => {
            i = Zn("request cancelled", "CANCELLED"),
            o.abort()
        }
        );
        const l = Object.assign({}, n, {
            method: t.method,
            headers: new Headers(Array.from(t)),
            body: t.body || void 0,
            signal: o.signal
        });
        let u;
        try {
            u = await fetch(t.url, l)
        } catch (g) {
            throw clearTimeout(a),
            i || g
        }
        clearTimeout(a);
        const d = {};
        u.headers.forEach( (g, w) => {
            d[w.toLowerCase()] = g
        }
        );
        const h = await u.arrayBuffer()
          , p = h == null ? null : new Uint8Array(h);
        return {
            statusCode: u.status,
            statusMessage: u.statusText,
            headers: d,
            body: p
        }
    }
    return e
}
const xZ = 12
  , EZ = 250;
let sI = AL();
const SZ = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$","i")
  , AZ = new RegExp("^ipfs://(ipfs/)?(.*)$","i");
let wS = !1;
async function CL(n, e) {
    try {
        const t = n.match(SZ);
        if (!t)
            throw new Error("invalid data");
        return new Hu(200,"OK",{
            "content-type": t[1] || "text/plain"
        },t[2] ? pZ(t[3]) : _Z(t[3]))
    } catch {
        return new Hu(599,"BAD REQUEST (invalid data: URI)",{},null,new tl(n))
    }
}
function _L(n) {
    async function e(t, r) {
        try {
            const s = t.match(AZ);
            if (!s)
                throw new Error("invalid link");
            return new tl(`${n}${s[2]}`)
        } catch {
            return new Hu(599,"BAD REQUEST (invalid IPFS URI)",{},null,new tl(t))
        }
    }
    return e
}
const w1 = {
    data: CL,
    ipfs: _L("https://gateway.ipfs.io/ipfs/")
}
  , kL = new WeakMap;
class CZ {
    #e;
    #t;
    constructor(e) {
        this.#e = [],
        this.#t = !1,
        kL.set(e, () => {
            if (!this.#t) {
                this.#t = !0;
                for (const t of this.#e)
                    setTimeout( () => {
                        t()
                    }
                    , 0);
                this.#e = []
            }
        }
        )
    }
    addListener(e) {
        Ie(!this.#t, "singal already cancelled", "UNSUPPORTED_OPERATION", {
            operation: "fetchCancelSignal.addCancelListener"
        }),
        this.#e.push(e)
    }
    get cancelled() {
        return this.#t
    }
    checkSignal() {
        Ie(!this.cancelled, "cancelled", "CANCELLED", {})
    }
}
function v1(n) {
    if (n == null)
        throw new Error("missing signal; should not happen");
    return n.checkSignal(),
    n
}
class tl {
    #e;
    #t;
    #n;
    #r;
    #s;
    #o;
    #i;
    #a;
    #d;
    #c;
    #p;
    #m;
    #l;
    #u;
    #f;
    get url() {
        return this.#o
    }
    set url(e) {
        this.#o = String(e)
    }
    get body() {
        return this.#i == null ? null : new Uint8Array(this.#i)
    }
    set body(e) {
        if (e == null)
            this.#i = void 0,
            this.#a = void 0;
        else if (typeof e == "string")
            this.#i = pc(e),
            this.#a = "text/plain";
        else if (e instanceof Uint8Array)
            this.#i = e,
            this.#a = "application/octet-stream";
        else if (typeof e == "object")
            this.#i = pc(JSON.stringify(e)),
            this.#a = "application/json";
        else
            throw new Error("invalid body")
    }
    hasBody() {
        return this.#i != null
    }
    get method() {
        return this.#r ? this.#r : this.hasBody() ? "POST" : "GET"
    }
    set method(e) {
        e == null && (e = ""),
        this.#r = String(e).toUpperCase()
    }
    get headers() {
        const e = Object.assign({}, this.#n);
        return this.#d && (e.authorization = `Basic ${mZ(pc(this.#d))}`),
        this.allowGzip && (e["accept-encoding"] = "gzip"),
        e["content-type"] == null && this.#a && (e["content-type"] = this.#a),
        this.body && (e["content-length"] = String(this.body.length)),
        e
    }
    getHeader(e) {
        return this.headers[e.toLowerCase()]
    }
    setHeader(e, t) {
        this.#n[String(e).toLowerCase()] = String(t)
    }
    clearHeaders() {
        this.#n = {}
    }
    [Symbol.iterator]() {
        const e = this.headers
          , t = Object.keys(e);
        let r = 0;
        return {
            next: () => {
                if (r < t.length) {
                    const s = t[r++];
                    return {
                        value: [s, e[s]],
                        done: !1
                    }
                }
                return {
                    value: void 0,
                    done: !0
                }
            }
        }
    }
    get credentials() {
        return this.#d || null
    }
    setCredentials(e, t) {
        he(!e.match(/:/), "invalid basic authentication username", "username", "[REDACTED]"),
        this.#d = `${e}:${t}`
    }
    get allowGzip() {
        return this.#t
    }
    set allowGzip(e) {
        this.#t = !!e
    }
    get allowInsecureAuthentication() {
        return !!this.#e
    }
    set allowInsecureAuthentication(e) {
        this.#e = !!e
    }
    get timeout() {
        return this.#s
    }
    set timeout(e) {
        he(e >= 0, "timeout must be non-zero", "timeout", e),
        this.#s = e
    }
    get preflightFunc() {
        return this.#c || null
    }
    set preflightFunc(e) {
        this.#c = e
    }
    get processFunc() {
        return this.#p || null
    }
    set processFunc(e) {
        this.#p = e
    }
    get retryFunc() {
        return this.#m || null
    }
    set retryFunc(e) {
        this.#m = e
    }
    get getUrlFunc() {
        return this.#f || sI
    }
    set getUrlFunc(e) {
        this.#f = e
    }
    constructor(e) {
        this.#o = String(e),
        this.#e = !1,
        this.#t = !0,
        this.#n = {},
        this.#r = "",
        this.#s = 3e5,
        this.#u = {
            slotInterval: EZ,
            maxAttempts: xZ
        },
        this.#f = null
    }
    toString() {
        return `<FetchRequest method=${JSON.stringify(this.method)} url=${JSON.stringify(this.url)} headers=${JSON.stringify(this.headers)} body=${this.#i ? Ke(this.#i) : "null"}>`
    }
    setThrottleParams(e) {
        e.slotInterval != null && (this.#u.slotInterval = e.slotInterval),
        e.maxAttempts != null && (this.#u.maxAttempts = e.maxAttempts)
    }
    async #h(e, t, r, s, i) {
        if (e >= this.#u.maxAttempts)
            return i.makeServerError("exceeded maximum retry limit");
        Ie(iI() <= t, "timeout", "TIMEOUT", {
            operation: "request.send",
            reason: "timeout",
            request: s
        }),
        r > 0 && await kZ(r);
        let o = this.clone();
        const a = (o.url.split(":")[0] || "").toLowerCase();
        if (a in w1) {
            const d = await w1[a](o.url, v1(s.#l));
            if (d instanceof Hu) {
                let h = d;
                if (this.processFunc) {
                    v1(s.#l);
                    try {
                        h = await this.processFunc(o, h)
                    } catch (p) {
                        (p.throttle == null || typeof p.stall != "number") && h.makeServerError("error in post-processing function", p).assertOk()
                    }
                }
                return h
            }
            o = d
        }
        this.preflightFunc && (o = await this.preflightFunc(o));
        const l = await this.getUrlFunc(o, v1(s.#l));
        let u = new Hu(l.statusCode,l.statusMessage,l.headers,l.body,s);
        if (u.statusCode === 301 || u.statusCode === 302) {
            try {
                const d = u.headers.location || "";
                return o.redirect(d).#h(e + 1, t, 0, s, u)
            } catch {}
            return u
        } else if (u.statusCode === 429 && (this.retryFunc == null || await this.retryFunc(o, u, e))) {
            const d = u.headers["retry-after"];
            let h = this.#u.slotInterval * Math.trunc(Math.random() * Math.pow(2, e));
            return typeof d == "string" && d.match(/^[1-9][0-9]*$/) && (h = parseInt(d)),
            o.clone().#h(e + 1, t, h, s, u)
        }
        if (this.processFunc) {
            v1(s.#l);
            try {
                u = await this.processFunc(o, u)
            } catch (d) {
                (d.throttle == null || typeof d.stall != "number") && u.makeServerError("error in post-processing function", d).assertOk();
                let h = this.#u.slotInterval * Math.trunc(Math.random() * Math.pow(2, e));
                return d.stall >= 0 && (h = d.stall),
                o.clone().#h(e + 1, t, h, s, u)
            }
        }
        return u
    }
    send() {
        return Ie(this.#l == null, "request already sent", "UNSUPPORTED_OPERATION", {
            operation: "fetchRequest.send"
        }),
        this.#l = new CZ(this),
        this.#h(0, iI() + this.timeout, 0, this, new Hu(0,"",{},null,this))
    }
    cancel() {
        Ie(this.#l != null, "request has not been sent", "UNSUPPORTED_OPERATION", {
            operation: "fetchRequest.cancel"
        });
        const e = kL.get(this);
        if (!e)
            throw new Error("missing signal; should not happen");
        e()
    }
    redirect(e) {
        const t = this.url.split(":")[0].toLowerCase()
          , r = e.split(":")[0].toLowerCase();
        Ie(this.method === "GET" && (t !== "https" || r !== "http") && e.match(/^https?:/), "unsupported redirect", "UNSUPPORTED_OPERATION", {
            operation: `redirect(${this.method} ${JSON.stringify(this.url)} => ${JSON.stringify(e)})`
        });
        const s = new tl(e);
        return s.method = "GET",
        s.allowGzip = this.allowGzip,
        s.timeout = this.timeout,
        s.#n = Object.assign({}, this.#n),
        this.#i && (s.#i = new Uint8Array(this.#i)),
        s.#a = this.#a,
        s
    }
    clone() {
        const e = new tl(this.url);
        return e.#r = this.#r,
        this.#i && (e.#i = this.#i),
        e.#a = this.#a,
        e.#n = Object.assign({}, this.#n),
        e.#d = this.#d,
        this.allowGzip && (e.allowGzip = !0),
        e.timeout = this.timeout,
        this.allowInsecureAuthentication && (e.allowInsecureAuthentication = !0),
        e.#c = this.#c,
        e.#p = this.#p,
        e.#m = this.#m,
        e.#u = Object.assign({}, this.#u),
        e.#f = this.#f,
        e
    }
    static lockConfig() {
        wS = !0
    }
    static getGateway(e) {
        return w1[e.toLowerCase()] || null
    }
    static registerGateway(e, t) {
        if (e = e.toLowerCase(),
        e === "http" || e === "https")
            throw new Error(`cannot intercept ${e}; use registerGetUrl`);
        if (wS)
            throw new Error("gateways locked");
        w1[e] = t
    }
    static registerGetUrl(e) {
        if (wS)
            throw new Error("gateways locked");
        sI = e
    }
    static createGetUrlFunc(e) {
        return AL(e)
    }
    static createDataGateway() {
        return CL
    }
    static createIpfsGatewayFunc(e) {
        return _L(e)
    }
}
class Hu {
    #e;
    #t;
    #n;
    #r;
    #s;
    #o;
    toString() {
        return `<FetchResponse status=${this.statusCode} body=${this.#r ? Ke(this.#r) : "null"}>`
    }
    get statusCode() {
        return this.#e
    }
    get statusMessage() {
        return this.#t
    }
    get headers() {
        return Object.assign({}, this.#n)
    }
    get body() {
        return this.#r == null ? null : new Uint8Array(this.#r)
    }
    get bodyText() {
        try {
            return this.#r == null ? "" : u2(this.#r)
        } catch {
            Ie(!1, "response body is not valid UTF-8 data", "UNSUPPORTED_OPERATION", {
                operation: "bodyText",
                info: {
                    response: this
                }
            })
        }
    }
    get bodyJson() {
        try {
            return JSON.parse(this.bodyText)
        } catch {
            Ie(!1, "response body is not valid JSON", "UNSUPPORTED_OPERATION", {
                operation: "bodyJson",
                info: {
                    response: this
                }
            })
        }
    }
    [Symbol.iterator]() {
        const e = this.headers
          , t = Object.keys(e);
        let r = 0;
        return {
            next: () => {
                if (r < t.length) {
                    const s = t[r++];
                    return {
                        value: [s, e[s]],
                        done: !1
                    }
                }
                return {
                    value: void 0,
                    done: !0
                }
            }
        }
    }
    constructor(e, t, r, s, i) {
        this.#e = e,
        this.#t = t,
        this.#n = Object.keys(r).reduce( (o, a) => (o[a.toLowerCase()] = String(r[a]),
        o), {}),
        this.#r = s == null ? null : new Uint8Array(s),
        this.#s = i || null,
        this.#o = {
            message: ""
        }
    }
    makeServerError(e, t) {
        let r;
        e ? r = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${e})` : (e = `${this.statusCode} ${this.statusMessage}`,
        r = `CLIENT ESCALATED SERVER ERROR (${e})`);
        const s = new Hu(599,r,this.headers,this.body,this.#s || void 0);
        return s.#o = {
            message: e,
            error: t
        },
        s
    }
    throwThrottleError(e, t) {
        t == null ? t = -1 : he(Number.isInteger(t) && t >= 0, "invalid stall timeout", "stall", t);
        const r = new Error(e || "throttling requests");
        throw xt(r, {
            stall: t,
            throttle: !0
        }),
        r
    }
    getHeader(e) {
        return this.headers[e.toLowerCase()]
    }
    hasBody() {
        return this.#r != null
    }
    get request() {
        return this.#s
    }
    ok() {
        return this.#o.message === "" && this.statusCode >= 200 && this.statusCode < 300
    }
    assertOk() {
        if (this.ok())
            return;
        let {message: e, error: t} = this.#o;
        e === "" && (e = `server response ${this.statusCode} ${this.statusMessage}`);
        let r = null;
        this.request && (r = this.request.url);
        let s = null;
        try {
            this.#r && (s = u2(this.#r))
        } catch {}
        Ie(!1, e, "SERVER_ERROR", {
            request: this.request || "unknown request",
            response: this,
            error: t,
            info: {
                requestUrl: r,
                responseBody: s,
                responseStatus: `${this.statusCode} ${this.statusMessage}`
            }
        })
    }
}
function iI() {
    return new Date().getTime()
}
function _Z(n) {
    return pc(n.replace(/%([0-9a-f][0-9a-f])/gi, (e, t) => String.fromCharCode(parseInt(t, 16))))
}
function kZ(n) {
    return new Promise(e => setTimeout(e, n))
}
const NZ = BigInt(-1)
  , Qo = BigInt(0)
  , mp = BigInt(1)
  , DZ = BigInt(5)
  , zh = {};
let Ap = "0000";
for (; Ap.length < 80; )
    Ap += Ap;
function Dd(n) {
    let e = Ap;
    for (; e.length < n; )
        e += e;
    return BigInt("1" + e.substring(0, n))
}
function Bm(n, e, t) {
    const r = BigInt(e.width);
    if (e.signed) {
        const s = mp << r - mp;
        Ie(t == null || n >= -s && n < s, "overflow", "NUMERIC_FAULT", {
            operation: t,
            fault: "overflow",
            value: n
        }),
        n > Qo ? n = c2(tf(n, r), r) : n = -c2(tf(-n, r), r)
    } else {
        const s = mp << r;
        Ie(t == null || n >= 0 && n < s, "overflow", "NUMERIC_FAULT", {
            operation: t,
            fault: "overflow",
            value: n
        }),
        n = (n % s + s) % s & s - mp
    }
    return n
}
function vS(n) {
    typeof n == "number" && (n = `fixed128x${n}`);
    let e = !0
      , t = 128
      , r = 18;
    if (typeof n == "string") {
        if (n !== "fixed")
            if (n === "ufixed")
                e = !1;
            else {
                const i = n.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
                he(i, "invalid fixed format", "format", n),
                e = i[1] !== "u",
                t = parseInt(i[2]),
                r = parseInt(i[3])
            }
    } else if (n) {
        const i = n
          , o = (a, l, u) => i[a] == null ? u : (he(typeof i[a] === l, "invalid fixed format (" + a + " not " + l + ")", "format." + a, i[a]),
        i[a]);
        e = o("signed", "boolean", e),
        t = o("width", "number", t),
        r = o("decimals", "number", r)
    }
    he(t % 8 === 0, "invalid FixedNumber width (not byte aligned)", "format.width", t),
    he(r <= 80, "invalid FixedNumber decimals (too large)", "format.decimals", r);
    const s = (e ? "" : "u") + "fixed" + String(t) + "x" + String(r);
    return {
        signed: e,
        width: t,
        decimals: r,
        name: s
    }
}
function TZ(n, e) {
    let t = "";
    n < Qo && (t = "-",
    n *= NZ);
    let r = n.toString();
    if (e === 0)
        return t + r;
    for (; r.length <= e; )
        r = Ap + r;
    const s = r.length - e;
    for (r = r.substring(0, s) + "." + r.substring(s); r[0] === "0" && r[1] !== "."; )
        r = r.substring(1);
    for (; r[r.length - 1] === "0" && r[r.length - 2] !== "."; )
        r = r.substring(0, r.length - 1);
    return t + r
}
class Kl {
    format;
    #e;
    #t;
    #n;
    _value;
    constructor(e, t, r) {
        Sy(e, zh, "FixedNumber"),
        this.#t = t,
        this.#e = r;
        const s = TZ(t, r.decimals);
        xt(this, {
            format: r.name,
            _value: s
        }),
        this.#n = Dd(r.decimals)
    }
    get signed() {
        return this.#e.signed
    }
    get width() {
        return this.#e.width
    }
    get decimals() {
        return this.#e.decimals
    }
    get value() {
        return this.#t
    }
    #r(e) {
        he(this.format === e.format, "incompatible format; use fixedNumber.toFormat", "other", e)
    }
    #s(e, t) {
        return e = Bm(e, this.#e, t),
        new Kl(zh,e,this.#e)
    }
    #o(e, t) {
        return this.#r(e),
        this.#s(this.#t + e.#t, t)
    }
    addUnsafe(e) {
        return this.#o(e)
    }
    add(e) {
        return this.#o(e, "add")
    }
    #i(e, t) {
        return this.#r(e),
        this.#s(this.#t - e.#t, t)
    }
    subUnsafe(e) {
        return this.#i(e)
    }
    sub(e) {
        return this.#i(e, "sub")
    }
    #a(e, t) {
        return this.#r(e),
        this.#s(this.#t * e.#t / this.#n, t)
    }
    mulUnsafe(e) {
        return this.#a(e)
    }
    mul(e) {
        return this.#a(e, "mul")
    }
    mulSignal(e) {
        this.#r(e);
        const t = this.#t * e.#t;
        return Ie(t % this.#n === Qo, "precision lost during signalling mul", "NUMERIC_FAULT", {
            operation: "mulSignal",
            fault: "underflow",
            value: this
        }),
        this.#s(t / this.#n, "mulSignal")
    }
    #d(e, t) {
        return Ie(e.#t !== Qo, "division by zero", "NUMERIC_FAULT", {
            operation: "div",
            fault: "divide-by-zero",
            value: this
        }),
        this.#r(e),
        this.#s(this.#t * this.#n / e.#t, t)
    }
    divUnsafe(e) {
        return this.#d(e)
    }
    div(e) {
        return this.#d(e, "div")
    }
    divSignal(e) {
        Ie(e.#t !== Qo, "division by zero", "NUMERIC_FAULT", {
            operation: "div",
            fault: "divide-by-zero",
            value: this
        }),
        this.#r(e);
        const t = this.#t * this.#n;
        return Ie(t % e.#t === Qo, "precision lost during signalling div", "NUMERIC_FAULT", {
            operation: "divSignal",
            fault: "underflow",
            value: this
        }),
        this.#s(t / e.#t, "divSignal")
    }
    cmp(e) {
        let t = this.value
          , r = e.value;
        const s = this.decimals - e.decimals;
        return s > 0 ? r *= Dd(s) : s < 0 && (t *= Dd(-s)),
        t < r ? -1 : t > r ? 1 : 0
    }
    eq(e) {
        return this.cmp(e) === 0
    }
    lt(e) {
        return this.cmp(e) < 0
    }
    lte(e) {
        return this.cmp(e) <= 0
    }
    gt(e) {
        return this.cmp(e) > 0
    }
    gte(e) {
        return this.cmp(e) >= 0
    }
    floor() {
        let e = this.#t;
        return this.#t < Qo && (e -= this.#n - mp),
        e = this.#t / this.#n * this.#n,
        this.#s(e, "floor")
    }
    ceiling() {
        let e = this.#t;
        return this.#t > Qo && (e += this.#n - mp),
        e = this.#t / this.#n * this.#n,
        this.#s(e, "ceiling")
    }
    round(e) {
        if (e == null && (e = 0),
        e >= this.decimals)
            return this;
        const t = this.decimals - e
          , r = DZ * Dd(t - 1);
        let s = this.value + r;
        const i = Dd(t);
        return s = s / i * i,
        Bm(s, this.#e, "round"),
        new Kl(zh,s,this.#e)
    }
    isZero() {
        return this.#t === Qo
    }
    isNegative() {
        return this.#t < Qo
    }
    toString() {
        return this._value
    }
    toUnsafeFloat() {
        return parseFloat(this.toString())
    }
    toFormat(e) {
        return Kl.fromString(this.toString(), e)
    }
    static fromValue(e, t, r) {
        const s = t == null ? 0 : Bt(t)
          , i = vS(r);
        let o = nt(e, "value");
        const a = s - i.decimals;
        if (a > 0) {
            const l = Dd(a);
            Ie(o % l === Qo, "value loses precision for format", "NUMERIC_FAULT", {
                operation: "fromValue",
                fault: "underflow",
                value: e
            }),
            o /= l
        } else
            a < 0 && (o *= Dd(-a));
        return Bm(o, i, "fromValue"),
        new Kl(zh,o,i)
    }
    static fromString(e, t) {
        const r = e.match(/^(-?)([0-9]*)\.?([0-9]*)$/);
        he(r && r[2].length + r[3].length > 0, "invalid FixedNumber string value", "value", e);
        const s = vS(t);
        let i = r[2] || "0"
          , o = r[3] || "";
        for (; o.length < s.decimals; )
            o += Ap;
        Ie(o.substring(s.decimals).match(/^0*$/), "too many decimals for format", "NUMERIC_FAULT", {
            operation: "fromString",
            fault: "underflow",
            value: e
        }),
        o = o.substring(0, s.decimals);
        const a = BigInt(r[1] + i + o);
        return Bm(a, s, "fromString"),
        new Kl(zh,a,s)
    }
    static fromBytes(e, t) {
        let r = Rv(zt(e, "value"));
        const s = vS(t);
        return s.signed && (r = c2(r, s.width)),
        Bm(r, s, "fromBytes"),
        new Kl(zh,r,s)
    }
}
function IZ(n) {
    let e = n.toString(16);
    for (; e.length < 2; )
        e = "0" + e;
    return "0x" + e
}
function oI(n, e, t) {
    let r = 0;
    for (let s = 0; s < t; s++)
        r = r * 256 + n[e + s];
    return r
}
function aI(n, e, t, r) {
    const s = [];
    for (; t < e + 1 + r; ) {
        const i = NL(n, t);
        s.push(i.result),
        t += i.consumed,
        Ie(t <= e + 1 + r, "child data too short", "BUFFER_OVERRUN", {
            buffer: n,
            length: r,
            offset: e
        })
    }
    return {
        consumed: 1 + r,
        result: s
    }
}
function NL(n, e) {
    Ie(n.length !== 0, "data too short", "BUFFER_OVERRUN", {
        buffer: n,
        length: 0,
        offset: 1
    });
    const t = r => {
        Ie(r <= n.length, "data short segment too short", "BUFFER_OVERRUN", {
            buffer: n,
            length: n.length,
            offset: r
        })
    }
    ;
    if (n[e] >= 248) {
        const r = n[e] - 247;
        t(e + 1 + r);
        const s = oI(n, e + 1, r);
        return t(e + 1 + r + s),
        aI(n, e, e + 1 + r, r + s)
    } else if (n[e] >= 192) {
        const r = n[e] - 192;
        return t(e + 1 + r),
        aI(n, e, e + 1, r)
    } else if (n[e] >= 184) {
        const r = n[e] - 183;
        t(e + 1 + r);
        const s = oI(n, e + 1, r);
        t(e + 1 + r + s);
        const i = Ke(n.slice(e + 1 + r, e + 1 + r + s));
        return {
            consumed: 1 + r + s,
            result: i
        }
    } else if (n[e] >= 128) {
        const r = n[e] - 128;
        t(e + 1 + r);
        const s = Ke(n.slice(e + 1, e + 1 + r));
        return {
            consumed: 1 + r,
            result: s
        }
    }
    return {
        consumed: 1,
        result: IZ(n[e])
    }
}
function Ay(n) {
    const e = zt(n, "data")
      , t = NL(e, 0);
    return he(t.consumed === e.length, "unexpected junk after rlp payload", "data", n),
    t.result
}
function lI(n) {
    const e = [];
    for (; n; )
        e.unshift(n & 255),
        n >>= 8;
    return e
}
function DL(n) {
    if (Array.isArray(n)) {
        let r = [];
        if (n.forEach(function(i) {
            r = r.concat(DL(i))
        }),
        r.length <= 55)
            return r.unshift(192 + r.length),
            r;
        const s = lI(r.length);
        return s.unshift(247 + s.length),
        s.concat(r)
    }
    const e = Array.prototype.slice.call(zt(n, "object"));
    if (e.length === 1 && e[0] <= 127)
        return e;
    if (e.length <= 55)
        return e.unshift(128 + e.length),
        e;
    const t = lI(e.length);
    return t.unshift(183 + t.length),
    t.concat(e)
}
const cI = "0123456789abcdef";
function Xu(n) {
    let e = "0x";
    for (const t of DL(n))
        e += cI[t >> 4],
        e += cI[t & 15];
    return e
}
const TL = ["wei", "kwei", "mwei", "gwei", "szabo", "finney", "ether"];
function Ov(n, e) {
    let t = 18;
    if (typeof e == "string") {
        const r = TL.indexOf(e);
        he(r >= 0, "invalid unit", "unit", e),
        t = 3 * r
    } else
        e != null && (t = Bt(e, "unit"));
    return Kl.fromValue(n, t, {
        decimals: t,
        width: 512
    }).toString()
}
function A0(n, e) {
    he(typeof n == "string", "value must be a string", "value", n);
    let t = 18;
    if (typeof e == "string") {
        const r = TL.indexOf(e);
        he(r >= 0, "invalid unit", "unit", e),
        t = 3 * r
    } else
        e != null && (t = Bt(e, "unit"));
    return Kl.fromString(n, {
        decimals: t,
        width: 512
    }).value
}
function MZ(n) {
    return Ov(n, 18)
}
function BZ(n) {
    return A0(n, 18)
}
const Ks = 32
  , h4 = new Uint8Array(Ks)
  , RZ = ["then"]
  , x1 = {}
  , IL = new WeakMap;
function Kd(n) {
    return IL.get(n)
}
function uI(n, e) {
    IL.set(n, e)
}
function Rm(n, e) {
    const t = new Error(`deferred error during ABI decoding triggered accessing ${n}`);
    throw t.error = e,
    t
}
function p4(n, e, t) {
    return n.indexOf(null) >= 0 ? e.map( (r, s) => r instanceof lc ? p4(Kd(r), r, t) : r) : n.reduce( (r, s, i) => {
        let o = e.getValue(s);
        return s in r || (t && o instanceof lc && (o = p4(Kd(o), o, t)),
        r[s] = o),
        r
    }
    , {})
}
class lc extends Array {
    #e;
    constructor(...e) {
        const t = e[0];
        let r = e[1]
          , s = (e[2] || []).slice()
          , i = !0;
        t !== x1 && (r = e,
        s = [],
        i = !1),
        super(r.length),
        r.forEach( (l, u) => {
            this[u] = l
        }
        );
        const o = s.reduce( (l, u) => (typeof u == "string" && l.set(u, (l.get(u) || 0) + 1),
        l), new Map);
        if (uI(this, Object.freeze(r.map( (l, u) => {
            const d = s[u];
            return d != null && o.get(d) === 1 ? d : null
        }
        ))),
        this.#e = [],
        this.#e == null && this.#e,
        !i)
            return;
        Object.freeze(this);
        const a = new Proxy(this,{
            get: (l, u, d) => {
                if (typeof u == "string") {
                    if (u.match(/^[0-9]+$/)) {
                        const p = Bt(u, "%index");
                        if (p < 0 || p >= this.length)
                            throw new RangeError("out of result range");
                        const g = l[p];
                        return g instanceof Error && Rm(`index ${p}`, g),
                        g
                    }
                    if (RZ.indexOf(u) >= 0)
                        return Reflect.get(l, u, d);
                    const h = l[u];
                    if (h instanceof Function)
                        return function(...p) {
                            return h.apply(this === d ? l : this, p)
                        }
                        ;
                    if (!(u in l))
                        return l.getValue.apply(this === d ? l : this, [u])
                }
                return Reflect.get(l, u, d)
            }
        });
        return uI(a, Kd(this)),
        a
    }
    toArray(e) {
        const t = [];
        return this.forEach( (r, s) => {
            r instanceof Error && Rm(`index ${s}`, r),
            e && r instanceof lc && (r = r.toArray(e)),
            t.push(r)
        }
        ),
        t
    }
    toObject(e) {
        const t = Kd(this);
        return t.reduce( (r, s, i) => (Ie(s != null, `value at index ${i} unnamed`, "UNSUPPORTED_OPERATION", {
            operation: "toObject()"
        }),
        p4(t, this, e)), {})
    }
    slice(e, t) {
        e == null && (e = 0),
        e < 0 && (e += this.length,
        e < 0 && (e = 0)),
        t == null && (t = this.length),
        t < 0 && (t += this.length,
        t < 0 && (t = 0)),
        t > this.length && (t = this.length);
        const r = Kd(this)
          , s = []
          , i = [];
        for (let o = e; o < t; o++)
            s.push(this[o]),
            i.push(r[o]);
        return new lc(x1,s,i)
    }
    filter(e, t) {
        const r = Kd(this)
          , s = []
          , i = [];
        for (let o = 0; o < this.length; o++) {
            const a = this[o];
            a instanceof Error && Rm(`index ${o}`, a),
            e.call(t, a, o, this) && (s.push(a),
            i.push(r[o]))
        }
        return new lc(x1,s,i)
    }
    map(e, t) {
        const r = [];
        for (let s = 0; s < this.length; s++) {
            const i = this[s];
            i instanceof Error && Rm(`index ${s}`, i),
            r.push(e.call(t, i, s, this))
        }
        return r
    }
    getValue(e) {
        const t = Kd(this).indexOf(e);
        if (t === -1)
            return;
        const r = this[t];
        return r instanceof Error && Rm(`property ${JSON.stringify(e)}`, r.error),
        r
    }
    static fromItems(e, t) {
        return new lc(x1,e,t)
    }
}
function dI(n) {
    let e = qr(n);
    return Ie(e.length <= Ks, "value out-of-bounds", "BUFFER_OVERRUN", {
        buffer: e,
        length: Ks,
        offset: e.length
    }),
    e.length !== Ks && (e = Ws(gr([h4.slice(e.length % Ks), e]))),
    e
}
class jc {
    name;
    type;
    localName;
    dynamic;
    constructor(e, t, r, s) {
        xt(this, {
            name: e,
            type: t,
            localName: r,
            dynamic: s
        }, {
            name: "string",
            type: "string",
            localName: "string",
            dynamic: "boolean"
        })
    }
    _throwError(e, t) {
        he(!1, e, this.localName, t)
    }
}
class m4 {
    #e;
    #t;
    constructor() {
        this.#e = [],
        this.#t = 0
    }
    get data() {
        return gr(this.#e)
    }
    get length() {
        return this.#t
    }
    #n(e) {
        return this.#e.push(e),
        this.#t += e.length,
        e.length
    }
    appendWriter(e) {
        return this.#n(Ws(e.data))
    }
    writeBytes(e) {
        let t = Ws(e);
        const r = t.length % Ks;
        return r && (t = Ws(gr([t, h4.slice(r)]))),
        this.#n(t)
    }
    writeValue(e) {
        return this.#n(dI(e))
    }
    writeUpdatableValue() {
        const e = this.#e.length;
        return this.#e.push(h4),
        this.#t += Ks,
        t => {
            this.#e[e] = dI(t)
        }
    }
}
class B8 {
    allowLoose;
    #e;
    #t;
    #n;
    #r;
    #s;
    constructor(e, t, r) {
        xt(this, {
            allowLoose: !!t
        }),
        this.#e = Ws(e),
        this.#n = 0,
        this.#r = null,
        this.#s = r ?? 1024,
        this.#t = 0
    }
    get data() {
        return Ke(this.#e)
    }
    get dataLength() {
        return this.#e.length
    }
    get consumed() {
        return this.#t
    }
    get bytes() {
        return new Uint8Array(this.#e)
    }
    #o(e) {
        if (this.#r)
            return this.#r.#o(e);
        this.#n += e,
        Ie(this.#s < 1 || this.#n <= this.#s * this.dataLength, `compressed ABI data exceeds inflation ratio of ${this.#s} ( see: https://github.com/ethers-io/ethers.js/issues/4537 )`, "BUFFER_OVERRUN", {
            buffer: Ws(this.#e),
            offset: this.#t,
            length: e,
            info: {
                bytesRead: this.#n,
                dataLength: this.dataLength
            }
        })
    }
    #i(e, t, r) {
        let s = Math.ceil(t / Ks) * Ks;
        return this.#t + s > this.#e.length && (this.allowLoose && r && this.#t + t <= this.#e.length ? s = t : Ie(!1, "data out-of-bounds", "BUFFER_OVERRUN", {
            buffer: Ws(this.#e),
            length: this.#e.length,
            offset: this.#t + s
        })),
        this.#e.slice(this.#t, this.#t + s)
    }
    subReader(e) {
        const t = new B8(this.#e.slice(this.#t + e),this.allowLoose,this.#s);
        return t.#r = this,
        t
    }
    readBytes(e, t) {
        let r = this.#i(0, e, !!t);
        return this.#o(e),
        this.#t += r.length,
        r.slice(0, e)
    }
    readValue() {
        return Rv(this.readBytes(Ks))
    }
    readIndex() {
        return fZ(this.readBytes(Ks))
    }
}
function d2(n) {
    if (!Number.isSafeInteger(n) || n < 0)
        throw new Error(`Wrong positive integer: ${n}`)
}
function R8(n, ...e) {
    if (!(n instanceof Uint8Array))
        throw new Error("Expected Uint8Array");
    if (e.length > 0 && !e.includes(n.length))
        throw new Error(`Expected Uint8Array of length ${e}, not of length=${n.length}`)
}
function OZ(n) {
    if (typeof n != "function" || typeof n.create != "function")
        throw new Error("Hash should be wrapped by utils.wrapConstructor");
    d2(n.outputLen),
    d2(n.blockLen)
}
function qp(n, e=!0) {
    if (n.destroyed)
        throw new Error("Hash instance has been destroyed");
    if (e && n.finished)
        throw new Error("Hash#digest() has already been called")
}
function ML(n, e) {
    R8(n);
    const t = e.outputLen;
    if (n.length < t)
        throw new Error(`digestInto() expects output buffer of length at least ${t}`)
}
const xS = typeof globalThis == "object" && "crypto"in globalThis ? globalThis.crypto : void 0;
const BL = n => n instanceof Uint8Array
  , PZ = n => new Uint32Array(n.buffer,n.byteOffset,Math.floor(n.byteLength / 4))
  , ES = n => new DataView(n.buffer,n.byteOffset,n.byteLength)
  , _a = (n, e) => n << 32 - e | n >>> e
  , jZ = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!jZ)
    throw new Error("Non little-endian hardware is not supported");
function LZ(n) {
    if (typeof n != "string")
        throw new Error(`utf8ToBytes expected string, got ${typeof n}`);
    return new Uint8Array(new TextEncoder().encode(n))
}
function Pv(n) {
    if (typeof n == "string" && (n = LZ(n)),
    !BL(n))
        throw new Error(`expected Uint8Array, got ${typeof n}`);
    return n
}
function FZ(...n) {
    const e = new Uint8Array(n.reduce( (r, s) => r + s.length, 0));
    let t = 0;
    return n.forEach(r => {
        if (!BL(r))
            throw new Error("Uint8Array expected");
        e.set(r, t),
        t += r.length
    }
    ),
    e
}
let O8 = class {
    clone() {
        return this._cloneInto()
    }
}
;
function P8(n) {
    const e = r => n().update(Pv(r)).digest()
      , t = n();
    return e.outputLen = t.outputLen,
    e.blockLen = t.blockLen,
    e.create = () => n(),
    e
}
function UZ(n=32) {
    if (xS && typeof xS.getRandomValues == "function")
        return xS.getRandomValues(new Uint8Array(n));
    throw new Error("crypto.getRandomValues must be defined")
}
let RL = class extends O8 {
    constructor(e, t) {
        super(),
        this.finished = !1,
        this.destroyed = !1,
        OZ(e);
        const r = Pv(t);
        if (this.iHash = e.create(),
        typeof this.iHash.update != "function")
            throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen,
        this.outputLen = this.iHash.outputLen;
        const s = this.blockLen
          , i = new Uint8Array(s);
        i.set(r.length > s ? e.create().update(r).digest() : r);
        for (let o = 0; o < i.length; o++)
            i[o] ^= 54;
        this.iHash.update(i),
        this.oHash = e.create();
        for (let o = 0; o < i.length; o++)
            i[o] ^= 106;
        this.oHash.update(i),
        i.fill(0)
    }
    update(e) {
        return qp(this),
        this.iHash.update(e),
        this
    }
    digestInto(e) {
        qp(this),
        R8(e, this.outputLen),
        this.finished = !0,
        this.iHash.digestInto(e),
        this.oHash.update(e),
        this.oHash.digestInto(e),
        this.destroy()
    }
    digest() {
        const e = new Uint8Array(this.oHash.outputLen);
        return this.digestInto(e),
        e
    }
    _cloneInto(e) {
        e || (e = Object.create(Object.getPrototypeOf(this), {}));
        const {oHash: t, iHash: r, finished: s, destroyed: i, blockLen: o, outputLen: a} = this;
        return e = e,
        e.finished = s,
        e.destroyed = i,
        e.blockLen = o,
        e.outputLen = a,
        e.oHash = t._cloneInto(e.oHash),
        e.iHash = r._cloneInto(e.iHash),
        e
    }
    destroy() {
        this.destroyed = !0,
        this.oHash.destroy(),
        this.iHash.destroy()
    }
}
;
const OL = (n, e, t) => new RL(n,e).update(t).digest();
OL.create = (n, e) => new RL(n,e);
function zZ(n, e, t, r) {
    if (typeof n.setBigUint64 == "function")
        return n.setBigUint64(e, t, r);
    const s = BigInt(32)
      , i = BigInt(4294967295)
      , o = Number(t >> s & i)
      , a = Number(t & i)
      , l = r ? 4 : 0
      , u = r ? 0 : 4;
    n.setUint32(e + l, o, r),
    n.setUint32(e + u, a, r)
}
class PL extends O8 {
    constructor(e, t, r, s) {
        super(),
        this.blockLen = e,
        this.outputLen = t,
        this.padOffset = r,
        this.isLE = s,
        this.finished = !1,
        this.length = 0,
        this.pos = 0,
        this.destroyed = !1,
        this.buffer = new Uint8Array(e),
        this.view = ES(this.buffer)
    }
    update(e) {
        qp(this);
        const {view: t, buffer: r, blockLen: s} = this;
        e = Pv(e);
        const i = e.length;
        for (let o = 0; o < i; ) {
            const a = Math.min(s - this.pos, i - o);
            if (a === s) {
                const l = ES(e);
                for (; s <= i - o; o += s)
                    this.process(l, o);
                continue
            }
            r.set(e.subarray(o, o + a), this.pos),
            this.pos += a,
            o += a,
            this.pos === s && (this.process(t, 0),
            this.pos = 0)
        }
        return this.length += e.length,
        this.roundClean(),
        this
    }
    digestInto(e) {
        qp(this),
        ML(e, this),
        this.finished = !0;
        const {buffer: t, view: r, blockLen: s, isLE: i} = this;
        let {pos: o} = this;
        t[o++] = 128,
        this.buffer.subarray(o).fill(0),
        this.padOffset > s - o && (this.process(r, 0),
        o = 0);
        for (let h = o; h < s; h++)
            t[h] = 0;
        zZ(r, s - 8, BigInt(this.length * 8), i),
        this.process(r, 0);
        const a = ES(e)
          , l = this.outputLen;
        if (l % 4)
            throw new Error("_sha2: outputLen should be aligned to 32bit");
        const u = l / 4
          , d = this.get();
        if (u > d.length)
            throw new Error("_sha2: outputLen bigger than state");
        for (let h = 0; h < u; h++)
            a.setUint32(4 * h, d[h], i)
    }
    digest() {
        const {buffer: e, outputLen: t} = this;
        this.digestInto(e);
        const r = e.slice(0, t);
        return this.destroy(),
        r
    }
    _cloneInto(e) {
        e || (e = new this.constructor),
        e.set(...this.get());
        const {blockLen: t, buffer: r, length: s, finished: i, destroyed: o, pos: a} = this;
        return e.length = s,
        e.pos = a,
        e.finished = i,
        e.destroyed = o,
        s % t && e.buffer.set(r),
        e
    }
}
const $Z = (n, e, t) => n & e ^ ~n & t
  , HZ = (n, e, t) => n & e ^ n & t ^ e & t
  , VZ = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298])
  , uu = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225])
  , du = new Uint32Array(64);
let qZ = class extends PL {
    constructor() {
        super(64, 32, 8, !1),
        this.A = uu[0] | 0,
        this.B = uu[1] | 0,
        this.C = uu[2] | 0,
        this.D = uu[3] | 0,
        this.E = uu[4] | 0,
        this.F = uu[5] | 0,
        this.G = uu[6] | 0,
        this.H = uu[7] | 0
    }
    get() {
        const {A: e, B: t, C: r, D: s, E: i, F: o, G: a, H: l} = this;
        return [e, t, r, s, i, o, a, l]
    }
    set(e, t, r, s, i, o, a, l) {
        this.A = e | 0,
        this.B = t | 0,
        this.C = r | 0,
        this.D = s | 0,
        this.E = i | 0,
        this.F = o | 0,
        this.G = a | 0,
        this.H = l | 0
    }
    process(e, t) {
        for (let h = 0; h < 16; h++,
        t += 4)
            du[h] = e.getUint32(t, !1);
        for (let h = 16; h < 64; h++) {
            const p = du[h - 15]
              , g = du[h - 2]
              , w = _a(p, 7) ^ _a(p, 18) ^ p >>> 3
              , b = _a(g, 17) ^ _a(g, 19) ^ g >>> 10;
            du[h] = b + du[h - 7] + w + du[h - 16] | 0
        }
        let {A: r, B: s, C: i, D: o, E: a, F: l, G: u, H: d} = this;
        for (let h = 0; h < 64; h++) {
            const p = _a(a, 6) ^ _a(a, 11) ^ _a(a, 25)
              , g = d + p + $Z(a, l, u) + VZ[h] + du[h] | 0
              , b = (_a(r, 2) ^ _a(r, 13) ^ _a(r, 22)) + HZ(r, s, i) | 0;
            d = u,
            u = l,
            l = a,
            a = o + g | 0,
            o = i,
            i = s,
            s = r,
            r = g + b | 0
        }
        r = r + this.A | 0,
        s = s + this.B | 0,
        i = i + this.C | 0,
        o = o + this.D | 0,
        a = a + this.E | 0,
        l = l + this.F | 0,
        u = u + this.G | 0,
        d = d + this.H | 0,
        this.set(r, s, i, o, a, l, u, d)
    }
    roundClean() {
        du.fill(0)
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0),
        this.buffer.fill(0)
    }
}
;
const jL = P8( () => new qZ)
  , E1 = BigInt(2 ** 32 - 1)
  , g4 = BigInt(32);
function LL(n, e=!1) {
    return e ? {
        h: Number(n & E1),
        l: Number(n >> g4 & E1)
    } : {
        h: Number(n >> g4 & E1) | 0,
        l: Number(n & E1) | 0
    }
}
function FL(n, e=!1) {
    let t = new Uint32Array(n.length)
      , r = new Uint32Array(n.length);
    for (let s = 0; s < n.length; s++) {
        const {h: i, l: o} = LL(n[s], e);
        [t[s],r[s]] = [i, o]
    }
    return [t, r]
}
const GZ = (n, e) => BigInt(n >>> 0) << g4 | BigInt(e >>> 0)
  , WZ = (n, e, t) => n >>> t
  , YZ = (n, e, t) => n << 32 - t | e >>> t
  , KZ = (n, e, t) => n >>> t | e << 32 - t
  , XZ = (n, e, t) => n << 32 - t | e >>> t
  , QZ = (n, e, t) => n << 64 - t | e >>> t - 32
  , ZZ = (n, e, t) => n >>> t - 32 | e << 64 - t
  , JZ = (n, e) => e
  , eJ = (n, e) => n
  , UL = (n, e, t) => n << t | e >>> 32 - t
  , zL = (n, e, t) => e << t | n >>> 32 - t
  , $L = (n, e, t) => e << t - 32 | n >>> 64 - t
  , HL = (n, e, t) => n << t - 32 | e >>> 64 - t;
function tJ(n, e, t, r) {
    const s = (e >>> 0) + (r >>> 0);
    return {
        h: n + t + (s / 2 ** 32 | 0) | 0,
        l: s | 0
    }
}
const nJ = (n, e, t) => (n >>> 0) + (e >>> 0) + (t >>> 0)
  , rJ = (n, e, t, r) => e + t + r + (n / 2 ** 32 | 0) | 0
  , sJ = (n, e, t, r) => (n >>> 0) + (e >>> 0) + (t >>> 0) + (r >>> 0)
  , iJ = (n, e, t, r, s) => e + t + r + s + (n / 2 ** 32 | 0) | 0
  , oJ = (n, e, t, r, s) => (n >>> 0) + (e >>> 0) + (t >>> 0) + (r >>> 0) + (s >>> 0)
  , aJ = (n, e, t, r, s, i) => e + t + r + s + i + (n / 2 ** 32 | 0) | 0
  , Rt = {
    fromBig: LL,
    split: FL,
    toBig: GZ,
    shrSH: WZ,
    shrSL: YZ,
    rotrSH: KZ,
    rotrSL: XZ,
    rotrBH: QZ,
    rotrBL: ZZ,
    rotr32H: JZ,
    rotr32L: eJ,
    rotlSH: UL,
    rotlSL: zL,
    rotlBH: $L,
    rotlBL: HL,
    add: tJ,
    add3L: nJ,
    add3H: rJ,
    add4L: sJ,
    add4H: iJ,
    add5H: aJ,
    add5L: oJ
}
  , [lJ,cJ] = Rt.split(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map(n => BigInt(n)))
  , fu = new Uint32Array(80)
  , hu = new Uint32Array(80);
let uJ = class extends PL {
    constructor() {
        super(128, 64, 16, !1),
        this.Ah = 1779033703,
        this.Al = -205731576,
        this.Bh = -1150833019,
        this.Bl = -2067093701,
        this.Ch = 1013904242,
        this.Cl = -23791573,
        this.Dh = -1521486534,
        this.Dl = 1595750129,
        this.Eh = 1359893119,
        this.El = -1377402159,
        this.Fh = -1694144372,
        this.Fl = 725511199,
        this.Gh = 528734635,
        this.Gl = -79577749,
        this.Hh = 1541459225,
        this.Hl = 327033209
    }
    get() {
        const {Ah: e, Al: t, Bh: r, Bl: s, Ch: i, Cl: o, Dh: a, Dl: l, Eh: u, El: d, Fh: h, Fl: p, Gh: g, Gl: w, Hh: b, Hl: v} = this;
        return [e, t, r, s, i, o, a, l, u, d, h, p, g, w, b, v]
    }
    set(e, t, r, s, i, o, a, l, u, d, h, p, g, w, b, v) {
        this.Ah = e | 0,
        this.Al = t | 0,
        this.Bh = r | 0,
        this.Bl = s | 0,
        this.Ch = i | 0,
        this.Cl = o | 0,
        this.Dh = a | 0,
        this.Dl = l | 0,
        this.Eh = u | 0,
        this.El = d | 0,
        this.Fh = h | 0,
        this.Fl = p | 0,
        this.Gh = g | 0,
        this.Gl = w | 0,
        this.Hh = b | 0,
        this.Hl = v | 0
    }
    process(e, t) {
        for (let _ = 0; _ < 16; _++,
        t += 4)
            fu[_] = e.getUint32(t),
            hu[_] = e.getUint32(t += 4);
        for (let _ = 16; _ < 80; _++) {
            const I = fu[_ - 15] | 0
              , k = hu[_ - 15] | 0
              , B = Rt.rotrSH(I, k, 1) ^ Rt.rotrSH(I, k, 8) ^ Rt.shrSH(I, k, 7)
              , P = Rt.rotrSL(I, k, 1) ^ Rt.rotrSL(I, k, 8) ^ Rt.shrSL(I, k, 7)
              , M = fu[_ - 2] | 0
              , R = hu[_ - 2] | 0
              , L = Rt.rotrSH(M, R, 19) ^ Rt.rotrBH(M, R, 61) ^ Rt.shrSH(M, R, 6)
              , q = Rt.rotrSL(M, R, 19) ^ Rt.rotrBL(M, R, 61) ^ Rt.shrSL(M, R, 6)
              , H = Rt.add4L(P, q, hu[_ - 7], hu[_ - 16])
              , j = Rt.add4H(H, B, L, fu[_ - 7], fu[_ - 16]);
            fu[_] = j | 0,
            hu[_] = H | 0
        }
        let {Ah: r, Al: s, Bh: i, Bl: o, Ch: a, Cl: l, Dh: u, Dl: d, Eh: h, El: p, Fh: g, Fl: w, Gh: b, Gl: v, Hh: S, Hl: N} = this;
        for (let _ = 0; _ < 80; _++) {
            const I = Rt.rotrSH(h, p, 14) ^ Rt.rotrSH(h, p, 18) ^ Rt.rotrBH(h, p, 41)
              , k = Rt.rotrSL(h, p, 14) ^ Rt.rotrSL(h, p, 18) ^ Rt.rotrBL(h, p, 41)
              , B = h & g ^ ~h & b
              , P = p & w ^ ~p & v
              , M = Rt.add5L(N, k, P, cJ[_], hu[_])
              , R = Rt.add5H(M, S, I, B, lJ[_], fu[_])
              , L = M | 0
              , q = Rt.rotrSH(r, s, 28) ^ Rt.rotrBH(r, s, 34) ^ Rt.rotrBH(r, s, 39)
              , H = Rt.rotrSL(r, s, 28) ^ Rt.rotrBL(r, s, 34) ^ Rt.rotrBL(r, s, 39)
              , j = r & i ^ r & a ^ i & a
              , A = s & o ^ s & l ^ o & l;
            S = b | 0,
            N = v | 0,
            b = g | 0,
            v = w | 0,
            g = h | 0,
            w = p | 0,
            {h, l: p} = Rt.add(u | 0, d | 0, R | 0, L | 0),
            u = a | 0,
            d = l | 0,
            a = i | 0,
            l = o | 0,
            i = r | 0,
            o = s | 0;
            const E = Rt.add3L(L, H, A);
            r = Rt.add3H(E, R, q, j),
            s = E | 0
        }
        ({h: r, l: s} = Rt.add(this.Ah | 0, this.Al | 0, r | 0, s | 0)),
        {h: i, l: o} = Rt.add(this.Bh | 0, this.Bl | 0, i | 0, o | 0),
        {h: a, l} = Rt.add(this.Ch | 0, this.Cl | 0, a | 0, l | 0),
        {h: u, l: d} = Rt.add(this.Dh | 0, this.Dl | 0, u | 0, d | 0),
        {h, l: p} = Rt.add(this.Eh | 0, this.El | 0, h | 0, p | 0),
        {h: g, l: w} = Rt.add(this.Fh | 0, this.Fl | 0, g | 0, w | 0),
        {h: b, l: v} = Rt.add(this.Gh | 0, this.Gl | 0, b | 0, v | 0),
        {h: S, l: N} = Rt.add(this.Hh | 0, this.Hl | 0, S | 0, N | 0),
        this.set(r, s, i, o, a, l, u, d, h, p, g, w, b, v, S, N)
    }
    roundClean() {
        fu.fill(0),
        hu.fill(0)
    }
    destroy() {
        this.buffer.fill(0),
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
    }
}
;
const dJ = P8( () => new uJ);
function fJ() {
    if (typeof self < "u")
        return self;
    if (typeof window < "u")
        return window;
    if (typeof global < "u")
        return global;
    throw new Error("unable to locate global object")
}
const fI = fJ();
fI.crypto || fI.msCrypto;
function hJ(n) {
    switch (n) {
    case "sha256":
        return jL.create();
    case "sha512":
        return dJ.create()
    }
    he(!1, "invalid hashing algorithm name", "algorithm", n)
}
const [VL,qL,GL] = [[], [], []]
  , pJ = BigInt(0)
  , Om = BigInt(1)
  , mJ = BigInt(2)
  , gJ = BigInt(7)
  , yJ = BigInt(256)
  , bJ = BigInt(113);
for (let n = 0, e = Om, t = 1, r = 0; n < 24; n++) {
    [t,r] = [r, (2 * t + 3 * r) % 5],
    VL.push(2 * (5 * r + t)),
    qL.push((n + 1) * (n + 2) / 2 % 64);
    let s = pJ;
    for (let i = 0; i < 7; i++)
        e = (e << Om ^ (e >> gJ) * bJ) % yJ,
        e & mJ && (s ^= Om << (Om << BigInt(i)) - Om);
    GL.push(s)
}
const [wJ,vJ] = FL(GL, !0)
  , hI = (n, e, t) => t > 32 ? $L(n, e, t) : UL(n, e, t)
  , pI = (n, e, t) => t > 32 ? HL(n, e, t) : zL(n, e, t);
function xJ(n, e=24) {
    const t = new Uint32Array(10);
    for (let r = 24 - e; r < 24; r++) {
        for (let o = 0; o < 10; o++)
            t[o] = n[o] ^ n[o + 10] ^ n[o + 20] ^ n[o + 30] ^ n[o + 40];
        for (let o = 0; o < 10; o += 2) {
            const a = (o + 8) % 10
              , l = (o + 2) % 10
              , u = t[l]
              , d = t[l + 1]
              , h = hI(u, d, 1) ^ t[a]
              , p = pI(u, d, 1) ^ t[a + 1];
            for (let g = 0; g < 50; g += 10)
                n[o + g] ^= h,
                n[o + g + 1] ^= p
        }
        let s = n[2]
          , i = n[3];
        for (let o = 0; o < 24; o++) {
            const a = qL[o]
              , l = hI(s, i, a)
              , u = pI(s, i, a)
              , d = VL[o];
            s = n[d],
            i = n[d + 1],
            n[d] = l,
            n[d + 1] = u
        }
        for (let o = 0; o < 50; o += 10) {
            for (let a = 0; a < 10; a++)
                t[a] = n[o + a];
            for (let a = 0; a < 10; a++)
                n[o + a] ^= ~t[(a + 2) % 10] & t[(a + 4) % 10]
        }
        n[0] ^= wJ[r],
        n[1] ^= vJ[r]
    }
    t.fill(0)
}
let EJ = class WL extends O8 {
    constructor(e, t, r, s=!1, i=24) {
        if (super(),
        this.blockLen = e,
        this.suffix = t,
        this.outputLen = r,
        this.enableXOF = s,
        this.rounds = i,
        this.pos = 0,
        this.posOut = 0,
        this.finished = !1,
        this.destroyed = !1,
        d2(r),
        0 >= this.blockLen || this.blockLen >= 200)
            throw new Error("Sha3 supports only keccak-f1600 function");
        this.state = new Uint8Array(200),
        this.state32 = PZ(this.state)
    }
    keccak() {
        xJ(this.state32, this.rounds),
        this.posOut = 0,
        this.pos = 0
    }
    update(e) {
        qp(this);
        const {blockLen: t, state: r} = this;
        e = Pv(e);
        const s = e.length;
        for (let i = 0; i < s; ) {
            const o = Math.min(t - this.pos, s - i);
            for (let a = 0; a < o; a++)
                r[this.pos++] ^= e[i++];
            this.pos === t && this.keccak()
        }
        return this
    }
    finish() {
        if (this.finished)
            return;
        this.finished = !0;
        const {state: e, suffix: t, pos: r, blockLen: s} = this;
        e[r] ^= t,
        (t & 128) !== 0 && r === s - 1 && this.keccak(),
        e[s - 1] ^= 128,
        this.keccak()
    }
    writeInto(e) {
        qp(this, !1),
        R8(e),
        this.finish();
        const t = this.state
          , {blockLen: r} = this;
        for (let s = 0, i = e.length; s < i; ) {
            this.posOut >= r && this.keccak();
            const o = Math.min(r - this.posOut, i - s);
            e.set(t.subarray(this.posOut, this.posOut + o), s),
            this.posOut += o,
            s += o
        }
        return e
    }
    xofInto(e) {
        if (!this.enableXOF)
            throw new Error("XOF is not possible for this instance");
        return this.writeInto(e)
    }
    xof(e) {
        return d2(e),
        this.xofInto(new Uint8Array(e))
    }
    digestInto(e) {
        if (ML(e, this),
        this.finished)
            throw new Error("digest() was already called");
        return this.writeInto(e),
        this.destroy(),
        e
    }
    digest() {
        return this.digestInto(new Uint8Array(this.outputLen))
    }
    destroy() {
        this.destroyed = !0,
        this.state.fill(0)
    }
    _cloneInto(e) {
        const {blockLen: t, suffix: r, outputLen: s, rounds: i, enableXOF: o} = this;
        return e || (e = new WL(t,r,s,o,i)),
        e.state32.set(this.state32),
        e.pos = this.pos,
        e.posOut = this.posOut,
        e.finished = this.finished,
        e.rounds = i,
        e.suffix = r,
        e.outputLen = s,
        e.enableXOF = o,
        e.destroyed = this.destroyed,
        e
    }
}
;
const SJ = (n, e, t) => P8( () => new EJ(e,n,t))
  , AJ = SJ(1, 136, 256 / 8);
let YL = !1;
const KL = function(n) {
    return AJ(n)
};
let XL = KL;
function Fr(n) {
    const e = zt(n, "data");
    return Ke(XL(e))
}
Fr._ = KL;
Fr.lock = function() {
    YL = !0
}
;
Fr.register = function(n) {
    if (YL)
        throw new TypeError("keccak256 is locked");
    XL = n
}
;
Object.freeze(Fr);
const QL = function(n) {
    return hJ("sha256").update(n).digest()
};
let ZL = QL
  , JL = !1;
function C0(n) {
    const e = zt(n, "data");
    return Ke(ZL(e))
}
C0._ = QL;
C0.lock = function() {
    JL = !0
}
;
C0.register = function(n) {
    if (JL)
        throw new Error("sha256 is locked");
    ZL = n
}
;
Object.freeze(C0);
Object.freeze(C0);
const eF = BigInt(0)
  , jv = BigInt(1)
  , CJ = BigInt(2)
  , Lv = n => n instanceof Uint8Array
  , _J = Array.from({
    length: 256
}, (n, e) => e.toString(16).padStart(2, "0"));
function Gp(n) {
    if (!Lv(n))
        throw new Error("Uint8Array expected");
    let e = "";
    for (let t = 0; t < n.length; t++)
        e += _J[n[t]];
    return e
}
function tF(n) {
    const e = n.toString(16);
    return e.length & 1 ? `0${e}` : e
}
function j8(n) {
    if (typeof n != "string")
        throw new Error("hex string expected, got " + typeof n);
    return BigInt(n === "" ? "0" : `0x${n}`)
}
function Wp(n) {
    if (typeof n != "string")
        throw new Error("hex string expected, got " + typeof n);
    const e = n.length;
    if (e % 2)
        throw new Error("padded hex string expected, got unpadded hex of length " + e);
    const t = new Uint8Array(e / 2);
    for (let r = 0; r < t.length; r++) {
        const s = r * 2
          , i = n.slice(s, s + 2)
          , o = Number.parseInt(i, 16);
        if (Number.isNaN(o) || o < 0)
            throw new Error("Invalid byte sequence");
        t[r] = o
    }
    return t
}
function vf(n) {
    return j8(Gp(n))
}
function L8(n) {
    if (!Lv(n))
        throw new Error("Uint8Array expected");
    return j8(Gp(Uint8Array.from(n).reverse()))
}
function Yp(n, e) {
    return Wp(n.toString(16).padStart(e * 2, "0"))
}
function F8(n, e) {
    return Yp(n, e).reverse()
}
function kJ(n) {
    return Wp(tF(n))
}
function Jo(n, e, t) {
    let r;
    if (typeof e == "string")
        try {
            r = Wp(e)
        } catch (i) {
            throw new Error(`${n} must be valid hex string, got "${e}". Cause: ${i}`)
        }
    else if (Lv(e))
        r = Uint8Array.from(e);
    else
        throw new Error(`${n} must be hex string or Uint8Array`);
    const s = r.length;
    if (typeof t == "number" && s !== t)
        throw new Error(`${n} expected ${t} bytes, got ${s}`);
    return r
}
function Vg(...n) {
    const e = new Uint8Array(n.reduce( (r, s) => r + s.length, 0));
    let t = 0;
    return n.forEach(r => {
        if (!Lv(r))
            throw new Error("Uint8Array expected");
        e.set(r, t),
        t += r.length
    }
    ),
    e
}
function NJ(n, e) {
    if (n.length !== e.length)
        return !1;
    for (let t = 0; t < n.length; t++)
        if (n[t] !== e[t])
            return !1;
    return !0
}
function DJ(n) {
    if (typeof n != "string")
        throw new Error(`utf8ToBytes expected string, got ${typeof n}`);
    return new Uint8Array(new TextEncoder().encode(n))
}
function TJ(n) {
    let e;
    for (e = 0; n > eF; n >>= jv,
    e += 1)
        ;
    return e
}
function IJ(n, e) {
    return n >> BigInt(e) & jv
}
const MJ = (n, e, t) => n | (t ? jv : eF) << BigInt(e)
  , U8 = n => (CJ << BigInt(n - 1)) - jv
  , SS = n => new Uint8Array(n)
  , mI = n => Uint8Array.from(n);
function nF(n, e, t) {
    if (typeof n != "number" || n < 2)
        throw new Error("hashLen must be a number");
    if (typeof e != "number" || e < 2)
        throw new Error("qByteLen must be a number");
    if (typeof t != "function")
        throw new Error("hmacFn must be a function");
    let r = SS(n)
      , s = SS(n)
      , i = 0;
    const o = () => {
        r.fill(1),
        s.fill(0),
        i = 0
    }
      , a = (...h) => t(s, r, ...h)
      , l = (h=SS()) => {
        s = a(mI([0]), h),
        r = a(),
        h.length !== 0 && (s = a(mI([1]), h),
        r = a())
    }
      , u = () => {
        if (i++ >= 1e3)
            throw new Error("drbg: tried 1000 values");
        let h = 0;
        const p = [];
        for (; h < e; ) {
            r = a();
            const g = r.slice();
            p.push(g),
            h += r.length
        }
        return Vg(...p)
    }
    ;
    return (h, p) => {
        o(),
        l(h);
        let g;
        for (; !(g = p(u())); )
            l();
        return o(),
        g
    }
}
const BJ = {
    bigint: n => typeof n == "bigint",
    function: n => typeof n == "function",
    boolean: n => typeof n == "boolean",
    string: n => typeof n == "string",
    stringOrUint8Array: n => typeof n == "string" || n instanceof Uint8Array,
    isSafeInteger: n => Number.isSafeInteger(n),
    array: n => Array.isArray(n),
    field: (n, e) => e.Fp.isValid(n),
    hash: n => typeof n == "function" && Number.isSafeInteger(n.outputLen)
};
function Cy(n, e, t={}) {
    const r = (s, i, o) => {
        const a = BJ[i];
        if (typeof a != "function")
            throw new Error(`Invalid validator "${i}", expected function`);
        const l = n[s];
        if (!(o && l === void 0) && !a(l, n))
            throw new Error(`Invalid param ${String(s)}=${l} (${typeof l}), expected ${i}`)
    }
    ;
    for (const [s,i] of Object.entries(e))
        r(s, i, !1);
    for (const [s,i] of Object.entries(t))
        r(s, i, !0);
    return n
}
const RJ = Object.freeze(Object.defineProperty({
    __proto__: null,
    bitGet: IJ,
    bitLen: TJ,
    bitMask: U8,
    bitSet: MJ,
    bytesToHex: Gp,
    bytesToNumberBE: vf,
    bytesToNumberLE: L8,
    concatBytes: Vg,
    createHmacDrbg: nF,
    ensureBytes: Jo,
    equalBytes: NJ,
    hexToBytes: Wp,
    hexToNumber: j8,
    numberToBytesBE: Yp,
    numberToBytesLE: F8,
    numberToHexUnpadded: tF,
    numberToVarBytesBE: kJ,
    utf8ToBytes: DJ,
    validateObject: Cy
}, Symbol.toStringTag, {
    value: "Module"
}));
const rs = BigInt(0)
  , Er = BigInt(1)
  , Xd = BigInt(2)
  , OJ = BigInt(3)
  , y4 = BigInt(4)
  , gI = BigInt(5)
  , yI = BigInt(8);
BigInt(9);
BigInt(16);
function bi(n, e) {
    const t = n % e;
    return t >= rs ? t : e + t
}
function PJ(n, e, t) {
    if (t <= rs || e < rs)
        throw new Error("Expected power/modulo > 0");
    if (t === Er)
        return rs;
    let r = Er;
    for (; e > rs; )
        e & Er && (r = r * n % t),
        n = n * n % t,
        e >>= Er;
    return r
}
function mo(n, e, t) {
    let r = n;
    for (; e-- > rs; )
        r *= r,
        r %= t;
    return r
}
function b4(n, e) {
    if (n === rs || e <= rs)
        throw new Error(`invert: expected positive integers, got n=${n} mod=${e}`);
    let t = bi(n, e)
      , r = e
      , s = rs
      , i = Er;
    for (; t !== rs; ) {
        const a = r / t
          , l = r % t
          , u = s - i * a;
        r = t,
        t = l,
        s = i,
        i = u
    }
    if (r !== Er)
        throw new Error("invert: does not exist");
    return bi(s, e)
}
function jJ(n) {
    const e = (n - Er) / Xd;
    let t, r, s;
    for (t = n - Er,
    r = 0; t % Xd === rs; t /= Xd,
    r++)
        ;
    for (s = Xd; s < n && PJ(s, e, n) !== n - Er; s++)
        ;
    if (r === 1) {
        const o = (n + Er) / y4;
        return function(l, u) {
            const d = l.pow(u, o);
            if (!l.eql(l.sqr(d), u))
                throw new Error("Cannot find square root");
            return d
        }
    }
    const i = (t + Er) / Xd;
    return function(a, l) {
        if (a.pow(l, e) === a.neg(a.ONE))
            throw new Error("Cannot find square root");
        let u = r
          , d = a.pow(a.mul(a.ONE, s), t)
          , h = a.pow(l, i)
          , p = a.pow(l, t);
        for (; !a.eql(p, a.ONE); ) {
            if (a.eql(p, a.ZERO))
                return a.ZERO;
            let g = 1;
            for (let b = a.sqr(p); g < u && !a.eql(b, a.ONE); g++)
                b = a.sqr(b);
            const w = a.pow(d, Er << BigInt(u - g - 1));
            d = a.sqr(w),
            h = a.mul(h, w),
            p = a.mul(p, d),
            u = g
        }
        return h
    }
}
function LJ(n) {
    if (n % y4 === OJ) {
        const e = (n + Er) / y4;
        return function(r, s) {
            const i = r.pow(s, e);
            if (!r.eql(r.sqr(i), s))
                throw new Error("Cannot find square root");
            return i
        }
    }
    if (n % yI === gI) {
        const e = (n - gI) / yI;
        return function(r, s) {
            const i = r.mul(s, Xd)
              , o = r.pow(i, e)
              , a = r.mul(s, o)
              , l = r.mul(r.mul(a, Xd), o)
              , u = r.mul(a, r.sub(l, r.ONE));
            if (!r.eql(r.sqr(u), s))
                throw new Error("Cannot find square root");
            return u
        }
    }
    return jJ(n)
}
const FJ = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];
function UJ(n) {
    const e = {
        ORDER: "bigint",
        MASK: "bigint",
        BYTES: "isSafeInteger",
        BITS: "isSafeInteger"
    }
      , t = FJ.reduce( (r, s) => (r[s] = "function",
    r), e);
    return Cy(n, t)
}
function zJ(n, e, t) {
    if (t < rs)
        throw new Error("Expected power > 0");
    if (t === rs)
        return n.ONE;
    if (t === Er)
        return e;
    let r = n.ONE
      , s = e;
    for (; t > rs; )
        t & Er && (r = n.mul(r, s)),
        s = n.sqr(s),
        t >>= Er;
    return r
}
function $J(n, e) {
    const t = new Array(e.length)
      , r = e.reduce( (i, o, a) => n.is0(o) ? i : (t[a] = i,
    n.mul(i, o)), n.ONE)
      , s = n.inv(r);
    return e.reduceRight( (i, o, a) => n.is0(o) ? i : (t[a] = n.mul(i, t[a]),
    n.mul(i, o)), s),
    t
}
function rF(n, e) {
    const t = e !== void 0 ? e : n.toString(2).length
      , r = Math.ceil(t / 8);
    return {
        nBitLength: t,
        nByteLength: r
    }
}
function HJ(n, e, t=!1, r={}) {
    if (n <= rs)
        throw new Error(`Expected Field ORDER > 0, got ${n}`);
    const {nBitLength: s, nByteLength: i} = rF(n, e);
    if (i > 2048)
        throw new Error("Field lengths over 2048 bytes are not supported");
    const o = LJ(n)
      , a = Object.freeze({
        ORDER: n,
        BITS: s,
        BYTES: i,
        MASK: U8(s),
        ZERO: rs,
        ONE: Er,
        create: l => bi(l, n),
        isValid: l => {
            if (typeof l != "bigint")
                throw new Error(`Invalid field element: expected bigint, got ${typeof l}`);
            return rs <= l && l < n
        }
        ,
        is0: l => l === rs,
        isOdd: l => (l & Er) === Er,
        neg: l => bi(-l, n),
        eql: (l, u) => l === u,
        sqr: l => bi(l * l, n),
        add: (l, u) => bi(l + u, n),
        sub: (l, u) => bi(l - u, n),
        mul: (l, u) => bi(l * u, n),
        pow: (l, u) => zJ(a, l, u),
        div: (l, u) => bi(l * b4(u, n), n),
        sqrN: l => l * l,
        addN: (l, u) => l + u,
        subN: (l, u) => l - u,
        mulN: (l, u) => l * u,
        inv: l => b4(l, n),
        sqrt: r.sqrt || (l => o(a, l)),
        invertBatch: l => $J(a, l),
        cmov: (l, u, d) => d ? u : l,
        toBytes: l => t ? F8(l, i) : Yp(l, i),
        fromBytes: l => {
            if (l.length !== i)
                throw new Error(`Fp.fromBytes: expected ${i}, got ${l.length}`);
            return t ? L8(l) : vf(l)
        }
    });
    return Object.freeze(a)
}
function sF(n) {
    if (typeof n != "bigint")
        throw new Error("field order must be bigint");
    const e = n.toString(2).length;
    return Math.ceil(e / 8)
}
function iF(n) {
    const e = sF(n);
    return e + Math.ceil(e / 2)
}
function VJ(n, e, t=!1) {
    const r = n.length
      , s = sF(e)
      , i = iF(e);
    if (r < 16 || r < i || r > 1024)
        throw new Error(`expected ${i}-1024 bytes of input, got ${r}`);
    const o = t ? vf(n) : L8(n)
      , a = bi(o, e - Er) + Er;
    return t ? F8(a, s) : Yp(a, s)
}
const qJ = BigInt(0)
  , AS = BigInt(1);
function GJ(n, e) {
    const t = (s, i) => {
        const o = i.negate();
        return s ? o : i
    }
      , r = s => {
        const i = Math.ceil(e / s) + 1
          , o = 2 ** (s - 1);
        return {
            windows: i,
            windowSize: o
        }
    }
    ;
    return {
        constTimeNegate: t,
        unsafeLadder(s, i) {
            let o = n.ZERO
              , a = s;
            for (; i > qJ; )
                i & AS && (o = o.add(a)),
                a = a.double(),
                i >>= AS;
            return o
        },
        precomputeWindow(s, i) {
            const {windows: o, windowSize: a} = r(i)
              , l = [];
            let u = s
              , d = u;
            for (let h = 0; h < o; h++) {
                d = u,
                l.push(d);
                for (let p = 1; p < a; p++)
                    d = d.add(u),
                    l.push(d);
                u = d.double()
            }
            return l
        },
        wNAF(s, i, o) {
            const {windows: a, windowSize: l} = r(s);
            let u = n.ZERO
              , d = n.BASE;
            const h = BigInt(2 ** s - 1)
              , p = 2 ** s
              , g = BigInt(s);
            for (let w = 0; w < a; w++) {
                const b = w * l;
                let v = Number(o & h);
                o >>= g,
                v > l && (v -= p,
                o += AS);
                const S = b
                  , N = b + Math.abs(v) - 1
                  , _ = w % 2 !== 0
                  , I = v < 0;
                v === 0 ? d = d.add(t(_, i[S])) : u = u.add(t(I, i[N]))
            }
            return {
                p: u,
                f: d
            }
        },
        wNAFCached(s, i, o, a) {
            const l = s._WINDOW_SIZE || 1;
            let u = i.get(s);
            return u || (u = this.precomputeWindow(s, l),
            l !== 1 && i.set(s, a(u))),
            this.wNAF(l, u, o)
        }
    }
}
function oF(n) {
    return UJ(n.Fp),
    Cy(n, {
        n: "bigint",
        h: "bigint",
        Gx: "field",
        Gy: "field"
    }, {
        nBitLength: "isSafeInteger",
        nByteLength: "isSafeInteger"
    }),
    Object.freeze({
        ...rF(n.n, n.nBitLength),
        ...n,
        p: n.Fp.ORDER
    })
}
function WJ(n) {
    const e = oF(n);
    Cy(e, {
        a: "field",
        b: "field"
    }, {
        allowedPrivateKeyLengths: "array",
        wrapPrivateKey: "boolean",
        isTorsionFree: "function",
        clearCofactor: "function",
        allowInfinityPoint: "boolean",
        fromBytes: "function",
        toBytes: "function"
    });
    const {endo: t, Fp: r, a: s} = e;
    if (t) {
        if (!r.eql(s, r.ZERO))
            throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
        if (typeof t != "object" || typeof t.beta != "bigint" || typeof t.splitScalar != "function")
            throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")
    }
    return Object.freeze({
        ...e
    })
}
const {bytesToNumberBE: YJ, hexToBytes: KJ} = RJ
  , nf = {
    Err: class extends Error {
        constructor(e="") {
            super(e)
        }
    }
    ,
    _parseInt(n) {
        const {Err: e} = nf;
        if (n.length < 2 || n[0] !== 2)
            throw new e("Invalid signature integer tag");
        const t = n[1]
          , r = n.subarray(2, t + 2);
        if (!t || r.length !== t)
            throw new e("Invalid signature integer: wrong length");
        if (r[0] & 128)
            throw new e("Invalid signature integer: negative");
        if (r[0] === 0 && !(r[1] & 128))
            throw new e("Invalid signature integer: unnecessary leading zero");
        return {
            d: YJ(r),
            l: n.subarray(t + 2)
        }
    },
    toSig(n) {
        const {Err: e} = nf
          , t = typeof n == "string" ? KJ(n) : n;
        if (!(t instanceof Uint8Array))
            throw new Error("ui8a expected");
        let r = t.length;
        if (r < 2 || t[0] != 48)
            throw new e("Invalid signature tag");
        if (t[1] !== r - 2)
            throw new e("Invalid signature: incorrect length");
        const {d: s, l: i} = nf._parseInt(t.subarray(2))
          , {d: o, l: a} = nf._parseInt(i);
        if (a.length)
            throw new e("Invalid signature: left bytes after parsing");
        return {
            r: s,
            s: o
        }
    },
    hexFromSig(n) {
        const e = u => Number.parseInt(u[0], 16) & 8 ? "00" + u : u
          , t = u => {
            const d = u.toString(16);
            return d.length & 1 ? `0${d}` : d
        }
          , r = e(t(n.s))
          , s = e(t(n.r))
          , i = r.length / 2
          , o = s.length / 2
          , a = t(i)
          , l = t(o);
        return `30${t(o + i + 4)}02${l}${s}02${a}${r}`
    }
}
  , rc = BigInt(0)
  , Ao = BigInt(1);
BigInt(2);
const bI = BigInt(3);
BigInt(4);
function XJ(n) {
    const e = WJ(n)
      , {Fp: t} = e
      , r = e.toBytes || ( (w, b, v) => {
        const S = b.toAffine();
        return Vg(Uint8Array.from([4]), t.toBytes(S.x), t.toBytes(S.y))
    }
    )
      , s = e.fromBytes || (w => {
        const b = w.subarray(1)
          , v = t.fromBytes(b.subarray(0, t.BYTES))
          , S = t.fromBytes(b.subarray(t.BYTES, 2 * t.BYTES));
        return {
            x: v,
            y: S
        }
    }
    );
    function i(w) {
        const {a: b, b: v} = e
          , S = t.sqr(w)
          , N = t.mul(S, w);
        return t.add(t.add(N, t.mul(w, b)), v)
    }
    if (!t.eql(t.sqr(e.Gy), i(e.Gx)))
        throw new Error("bad generator point: equation left != right");
    function o(w) {
        return typeof w == "bigint" && rc < w && w < e.n
    }
    function a(w) {
        if (!o(w))
            throw new Error("Expected valid bigint: 0 < bigint < curve.n")
    }
    function l(w) {
        const {allowedPrivateKeyLengths: b, nByteLength: v, wrapPrivateKey: S, n: N} = e;
        if (b && typeof w != "bigint") {
            if (w instanceof Uint8Array && (w = Gp(w)),
            typeof w != "string" || !b.includes(w.length))
                throw new Error("Invalid key");
            w = w.padStart(v * 2, "0")
        }
        let _;
        try {
            _ = typeof w == "bigint" ? w : vf(Jo("private key", w, v))
        } catch {
            throw new Error(`private key must be ${v} bytes, hex or bigint, not ${typeof w}`)
        }
        return S && (_ = bi(_, N)),
        a(_),
        _
    }
    const u = new Map;
    function d(w) {
        if (!(w instanceof h))
            throw new Error("ProjectivePoint expected")
    }
    class h {
        constructor(b, v, S) {
            if (this.px = b,
            this.py = v,
            this.pz = S,
            b == null || !t.isValid(b))
                throw new Error("x required");
            if (v == null || !t.isValid(v))
                throw new Error("y required");
            if (S == null || !t.isValid(S))
                throw new Error("z required")
        }
        static fromAffine(b) {
            const {x: v, y: S} = b || {};
            if (!b || !t.isValid(v) || !t.isValid(S))
                throw new Error("invalid affine point");
            if (b instanceof h)
                throw new Error("projective point not allowed");
            const N = _ => t.eql(_, t.ZERO);
            return N(v) && N(S) ? h.ZERO : new h(v,S,t.ONE)
        }
        get x() {
            return this.toAffine().x
        }
        get y() {
            return this.toAffine().y
        }
        static normalizeZ(b) {
            const v = t.invertBatch(b.map(S => S.pz));
            return b.map( (S, N) => S.toAffine(v[N])).map(h.fromAffine)
        }
        static fromHex(b) {
            const v = h.fromAffine(s(Jo("pointHex", b)));
            return v.assertValidity(),
            v
        }
        static fromPrivateKey(b) {
            return h.BASE.multiply(l(b))
        }
        _setWindowSize(b) {
            this._WINDOW_SIZE = b,
            u.delete(this)
        }
        assertValidity() {
            if (this.is0()) {
                if (e.allowInfinityPoint && !t.is0(this.py))
                    return;
                throw new Error("bad point: ZERO")
            }
            const {x: b, y: v} = this.toAffine();
            if (!t.isValid(b) || !t.isValid(v))
                throw new Error("bad point: x or y not FE");
            const S = t.sqr(v)
              , N = i(b);
            if (!t.eql(S, N))
                throw new Error("bad point: equation left != right");
            if (!this.isTorsionFree())
                throw new Error("bad point: not in prime-order subgroup")
        }
        hasEvenY() {
            const {y: b} = this.toAffine();
            if (t.isOdd)
                return !t.isOdd(b);
            throw new Error("Field doesn't support isOdd")
        }
        equals(b) {
            d(b);
            const {px: v, py: S, pz: N} = this
              , {px: _, py: I, pz: k} = b
              , B = t.eql(t.mul(v, k), t.mul(_, N))
              , P = t.eql(t.mul(S, k), t.mul(I, N));
            return B && P
        }
        negate() {
            return new h(this.px,t.neg(this.py),this.pz)
        }
        double() {
            const {a: b, b: v} = e
              , S = t.mul(v, bI)
              , {px: N, py: _, pz: I} = this;
            let k = t.ZERO
              , B = t.ZERO
              , P = t.ZERO
              , M = t.mul(N, N)
              , R = t.mul(_, _)
              , L = t.mul(I, I)
              , q = t.mul(N, _);
            return q = t.add(q, q),
            P = t.mul(N, I),
            P = t.add(P, P),
            k = t.mul(b, P),
            B = t.mul(S, L),
            B = t.add(k, B),
            k = t.sub(R, B),
            B = t.add(R, B),
            B = t.mul(k, B),
            k = t.mul(q, k),
            P = t.mul(S, P),
            L = t.mul(b, L),
            q = t.sub(M, L),
            q = t.mul(b, q),
            q = t.add(q, P),
            P = t.add(M, M),
            M = t.add(P, M),
            M = t.add(M, L),
            M = t.mul(M, q),
            B = t.add(B, M),
            L = t.mul(_, I),
            L = t.add(L, L),
            M = t.mul(L, q),
            k = t.sub(k, M),
            P = t.mul(L, R),
            P = t.add(P, P),
            P = t.add(P, P),
            new h(k,B,P)
        }
        add(b) {
            d(b);
            const {px: v, py: S, pz: N} = this
              , {px: _, py: I, pz: k} = b;
            let B = t.ZERO
              , P = t.ZERO
              , M = t.ZERO;
            const R = e.a
              , L = t.mul(e.b, bI);
            let q = t.mul(v, _)
              , H = t.mul(S, I)
              , j = t.mul(N, k)
              , A = t.add(v, S)
              , E = t.add(_, I);
            A = t.mul(A, E),
            E = t.add(q, H),
            A = t.sub(A, E),
            E = t.add(v, N);
            let C = t.add(_, k);
            return E = t.mul(E, C),
            C = t.add(q, j),
            E = t.sub(E, C),
            C = t.add(S, N),
            B = t.add(I, k),
            C = t.mul(C, B),
            B = t.add(H, j),
            C = t.sub(C, B),
            M = t.mul(R, E),
            B = t.mul(L, j),
            M = t.add(B, M),
            B = t.sub(H, M),
            M = t.add(H, M),
            P = t.mul(B, M),
            H = t.add(q, q),
            H = t.add(H, q),
            j = t.mul(R, j),
            E = t.mul(L, E),
            H = t.add(H, j),
            j = t.sub(q, j),
            j = t.mul(R, j),
            E = t.add(E, j),
            q = t.mul(H, E),
            P = t.add(P, q),
            q = t.mul(C, E),
            B = t.mul(A, B),
            B = t.sub(B, q),
            q = t.mul(A, H),
            M = t.mul(C, M),
            M = t.add(M, q),
            new h(B,P,M)
        }
        subtract(b) {
            return this.add(b.negate())
        }
        is0() {
            return this.equals(h.ZERO)
        }
        wNAF(b) {
            return g.wNAFCached(this, u, b, v => {
                const S = t.invertBatch(v.map(N => N.pz));
                return v.map( (N, _) => N.toAffine(S[_])).map(h.fromAffine)
            }
            )
        }
        multiplyUnsafe(b) {
            const v = h.ZERO;
            if (b === rc)
                return v;
            if (a(b),
            b === Ao)
                return this;
            const {endo: S} = e;
            if (!S)
                return g.unsafeLadder(this, b);
            let {k1neg: N, k1: _, k2neg: I, k2: k} = S.splitScalar(b)
              , B = v
              , P = v
              , M = this;
            for (; _ > rc || k > rc; )
                _ & Ao && (B = B.add(M)),
                k & Ao && (P = P.add(M)),
                M = M.double(),
                _ >>= Ao,
                k >>= Ao;
            return N && (B = B.negate()),
            I && (P = P.negate()),
            P = new h(t.mul(P.px, S.beta),P.py,P.pz),
            B.add(P)
        }
        multiply(b) {
            a(b);
            let v = b, S, N;
            const {endo: _} = e;
            if (_) {
                const {k1neg: I, k1: k, k2neg: B, k2: P} = _.splitScalar(v);
                let {p: M, f: R} = this.wNAF(k)
                  , {p: L, f: q} = this.wNAF(P);
                M = g.constTimeNegate(I, M),
                L = g.constTimeNegate(B, L),
                L = new h(t.mul(L.px, _.beta),L.py,L.pz),
                S = M.add(L),
                N = R.add(q)
            } else {
                const {p: I, f: k} = this.wNAF(v);
                S = I,
                N = k
            }
            return h.normalizeZ([S, N])[0]
        }
        multiplyAndAddUnsafe(b, v, S) {
            const N = h.BASE
              , _ = (k, B) => B === rc || B === Ao || !k.equals(N) ? k.multiplyUnsafe(B) : k.multiply(B)
              , I = _(this, v).add(_(b, S));
            return I.is0() ? void 0 : I
        }
        toAffine(b) {
            const {px: v, py: S, pz: N} = this
              , _ = this.is0();
            b == null && (b = _ ? t.ONE : t.inv(N));
            const I = t.mul(v, b)
              , k = t.mul(S, b)
              , B = t.mul(N, b);
            if (_)
                return {
                    x: t.ZERO,
                    y: t.ZERO
                };
            if (!t.eql(B, t.ONE))
                throw new Error("invZ was invalid");
            return {
                x: I,
                y: k
            }
        }
        isTorsionFree() {
            const {h: b, isTorsionFree: v} = e;
            if (b === Ao)
                return !0;
            if (v)
                return v(h, this);
            throw new Error("isTorsionFree() has not been declared for the elliptic curve")
        }
        clearCofactor() {
            const {h: b, clearCofactor: v} = e;
            return b === Ao ? this : v ? v(h, this) : this.multiplyUnsafe(e.h)
        }
        toRawBytes(b=!0) {
            return this.assertValidity(),
            r(h, this, b)
        }
        toHex(b=!0) {
            return Gp(this.toRawBytes(b))
        }
    }
    h.BASE = new h(e.Gx,e.Gy,t.ONE),
    h.ZERO = new h(t.ZERO,t.ONE,t.ZERO);
    const p = e.nBitLength
      , g = GJ(h, e.endo ? Math.ceil(p / 2) : p);
    return {
        CURVE: e,
        ProjectivePoint: h,
        normPrivateKeyToScalar: l,
        weierstrassEquation: i,
        isWithinCurveOrder: o
    }
}
function QJ(n) {
    const e = oF(n);
    return Cy(e, {
        hash: "hash",
        hmac: "function",
        randomBytes: "function"
    }, {
        bits2int: "function",
        bits2int_modN: "function",
        lowS: "boolean"
    }),
    Object.freeze({
        lowS: !0,
        ...e
    })
}
function ZJ(n) {
    const e = QJ(n)
      , {Fp: t, n: r} = e
      , s = t.BYTES + 1
      , i = 2 * t.BYTES + 1;
    function o(E) {
        return rc < E && E < t.ORDER
    }
    function a(E) {
        return bi(E, r)
    }
    function l(E) {
        return b4(E, r)
    }
    const {ProjectivePoint: u, normPrivateKeyToScalar: d, weierstrassEquation: h, isWithinCurveOrder: p} = XJ({
        ...e,
        toBytes(E, C, O) {
            const z = C.toAffine()
              , G = t.toBytes(z.x)
              , Y = Vg;
            return O ? Y(Uint8Array.from([C.hasEvenY() ? 2 : 3]), G) : Y(Uint8Array.from([4]), G, t.toBytes(z.y))
        },
        fromBytes(E) {
            const C = E.length
              , O = E[0]
              , z = E.subarray(1);
            if (C === s && (O === 2 || O === 3)) {
                const G = vf(z);
                if (!o(G))
                    throw new Error("Point is not on curve");
                const Y = h(G);
                let $ = t.sqrt(Y);
                const D = ($ & Ao) === Ao;
                return (O & 1) === 1 !== D && ($ = t.neg($)),
                {
                    x: G,
                    y: $
                }
            } else if (C === i && O === 4) {
                const G = t.fromBytes(z.subarray(0, t.BYTES))
                  , Y = t.fromBytes(z.subarray(t.BYTES, 2 * t.BYTES));
                return {
                    x: G,
                    y: Y
                }
            } else
                throw new Error(`Point of length ${C} was invalid. Expected ${s} compressed bytes or ${i} uncompressed bytes`)
        }
    })
      , g = E => Gp(Yp(E, e.nByteLength));
    function w(E) {
        const C = r >> Ao;
        return E > C
    }
    function b(E) {
        return w(E) ? a(-E) : E
    }
    const v = (E, C, O) => vf(E.slice(C, O));
    class S {
        constructor(C, O, z) {
            this.r = C,
            this.s = O,
            this.recovery = z,
            this.assertValidity()
        }
        static fromCompact(C) {
            const O = e.nByteLength;
            return C = Jo("compactSignature", C, O * 2),
            new S(v(C, 0, O),v(C, O, 2 * O))
        }
        static fromDER(C) {
            const {r: O, s: z} = nf.toSig(Jo("DER", C));
            return new S(O,z)
        }
        assertValidity() {
            if (!p(this.r))
                throw new Error("r must be 0 < r < CURVE.n");
            if (!p(this.s))
                throw new Error("s must be 0 < s < CURVE.n")
        }
        addRecoveryBit(C) {
            return new S(this.r,this.s,C)
        }
        recoverPublicKey(C) {
            const {r: O, s: z, recovery: G} = this
              , Y = P(Jo("msgHash", C));
            if (G == null || ![0, 1, 2, 3].includes(G))
                throw new Error("recovery id invalid");
            const $ = G === 2 || G === 3 ? O + e.n : O;
            if ($ >= t.ORDER)
                throw new Error("recovery id 2 or 3 invalid");
            const D = (G & 1) === 0 ? "02" : "03"
              , U = u.fromHex(D + g($))
              , W = l($)
              , Q = a(-Y * W)
              , J = a(z * W)
              , ne = u.BASE.multiplyAndAddUnsafe(U, Q, J);
            if (!ne)
                throw new Error("point at infinify");
            return ne.assertValidity(),
            ne
        }
        hasHighS() {
            return w(this.s)
        }
        normalizeS() {
            return this.hasHighS() ? new S(this.r,a(-this.s),this.recovery) : this
        }
        toDERRawBytes() {
            return Wp(this.toDERHex())
        }
        toDERHex() {
            return nf.hexFromSig({
                r: this.r,
                s: this.s
            })
        }
        toCompactRawBytes() {
            return Wp(this.toCompactHex())
        }
        toCompactHex() {
            return g(this.r) + g(this.s)
        }
    }
    const N = {
        isValidPrivateKey(E) {
            try {
                return d(E),
                !0
            } catch {
                return !1
            }
        },
        normPrivateKeyToScalar: d,
        randomPrivateKey: () => {
            const E = iF(e.n);
            return VJ(e.randomBytes(E), e.n)
        }
        ,
        precompute(E=8, C=u.BASE) {
            return C._setWindowSize(E),
            C.multiply(BigInt(3)),
            C
        }
    };
    function _(E, C=!0) {
        return u.fromPrivateKey(E).toRawBytes(C)
    }
    function I(E) {
        const C = E instanceof Uint8Array
          , O = typeof E == "string"
          , z = (C || O) && E.length;
        return C ? z === s || z === i : O ? z === 2 * s || z === 2 * i : E instanceof u
    }
    function k(E, C, O=!0) {
        if (I(E))
            throw new Error("first arg must be private key");
        if (!I(C))
            throw new Error("second arg must be public key");
        return u.fromHex(C).multiply(d(E)).toRawBytes(O)
    }
    const B = e.bits2int || function(E) {
        const C = vf(E)
          , O = E.length * 8 - e.nBitLength;
        return O > 0 ? C >> BigInt(O) : C
    }
      , P = e.bits2int_modN || function(E) {
        return a(B(E))
    }
      , M = U8(e.nBitLength);
    function R(E) {
        if (typeof E != "bigint")
            throw new Error("bigint expected");
        if (!(rc <= E && E < M))
            throw new Error(`bigint expected < 2^${e.nBitLength}`);
        return Yp(E, e.nByteLength)
    }
    function L(E, C, O=q) {
        if (["recovered", "canonical"].some(ae => ae in O))
            throw new Error("sign() legacy options not supported");
        const {hash: z, randomBytes: G} = e;
        let {lowS: Y, prehash: $, extraEntropy: D} = O;
        Y == null && (Y = !0),
        E = Jo("msgHash", E),
        $ && (E = Jo("prehashed msgHash", z(E)));
        const U = P(E)
          , W = d(C)
          , Q = [R(W), R(U)];
        if (D != null) {
            const ae = D === !0 ? G(t.BYTES) : D;
            Q.push(Jo("extraEntropy", ae))
        }
        const J = Vg(...Q)
          , ne = U;
        function ie(ae) {
            const xe = B(ae);
            if (!p(xe))
                return;
            const ue = l(xe)
              , ce = u.BASE.multiply(xe).toAffine()
              , me = a(ce.x);
            if (me === rc)
                return;
            const Ee = a(ue * a(ne + me * W));
            if (Ee === rc)
                return;
            let Oe = (ce.x === me ? 0 : 2) | Number(ce.y & Ao)
              , mt = Ee;
            return Y && w(Ee) && (mt = b(Ee),
            Oe ^= 1),
            new S(me,mt,Oe)
        }
        return {
            seed: J,
            k2sig: ie
        }
    }
    const q = {
        lowS: e.lowS,
        prehash: !1
    }
      , H = {
        lowS: e.lowS,
        prehash: !1
    };
    function j(E, C, O=q) {
        const {seed: z, k2sig: G} = L(E, C, O)
          , Y = e;
        return nF(Y.hash.outputLen, Y.nByteLength, Y.hmac)(z, G)
    }
    u.BASE._setWindowSize(8);
    function A(E, C, O, z=H) {
        const G = E;
        if (C = Jo("msgHash", C),
        O = Jo("publicKey", O),
        "strict"in z)
            throw new Error("options.strict was renamed to lowS");
        const {lowS: Y, prehash: $} = z;
        let D, U;
        try {
            if (typeof G == "string" || G instanceof Uint8Array)
                try {
                    D = S.fromDER(G)
                } catch (ce) {
                    if (!(ce instanceof nf.Err))
                        throw ce;
                    D = S.fromCompact(G)
                }
            else if (typeof G == "object" && typeof G.r == "bigint" && typeof G.s == "bigint") {
                const {r: ce, s: me} = G;
                D = new S(ce,me)
            } else
                throw new Error("PARSE");
            U = u.fromHex(O)
        } catch (ce) {
            if (ce.message === "PARSE")
                throw new Error("signature must be Signature instance, Uint8Array or hex string");
            return !1
        }
        if (Y && D.hasHighS())
            return !1;
        $ && (C = e.hash(C));
        const {r: W, s: Q} = D
          , J = P(C)
          , ne = l(Q)
          , ie = a(J * ne)
          , ae = a(W * ne)
          , xe = u.BASE.multiplyAndAddUnsafe(U, ie, ae)?.toAffine();
        return xe ? a(xe.x) === W : !1
    }
    return {
        CURVE: e,
        getPublicKey: _,
        getSharedSecret: k,
        sign: j,
        verify: A,
        ProjectivePoint: u,
        Signature: S,
        utils: N
    }
}
function JJ(n) {
    return {
        hash: n,
        hmac: (e, ...t) => OL(n, e, FZ(...t)),
        randomBytes: UZ
    }
}
function eee(n, e) {
    const t = r => ZJ({
        ...n,
        ...JJ(r)
    });
    return Object.freeze({
        ...t(e),
        create: t
    })
}
const aF = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f")
  , wI = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141")
  , tee = BigInt(1)
  , w4 = BigInt(2)
  , vI = (n, e) => (n + e / w4) / e;
function nee(n) {
    const e = aF
      , t = BigInt(3)
      , r = BigInt(6)
      , s = BigInt(11)
      , i = BigInt(22)
      , o = BigInt(23)
      , a = BigInt(44)
      , l = BigInt(88)
      , u = n * n * n % e
      , d = u * u * n % e
      , h = mo(d, t, e) * d % e
      , p = mo(h, t, e) * d % e
      , g = mo(p, w4, e) * u % e
      , w = mo(g, s, e) * g % e
      , b = mo(w, i, e) * w % e
      , v = mo(b, a, e) * b % e
      , S = mo(v, l, e) * v % e
      , N = mo(S, a, e) * b % e
      , _ = mo(N, t, e) * d % e
      , I = mo(_, o, e) * w % e
      , k = mo(I, r, e) * u % e
      , B = mo(k, w4, e);
    if (!v4.eql(v4.sqr(B), n))
        throw new Error("Cannot find square root");
    return B
}
const v4 = HJ(aF, void 0, void 0, {
    sqrt: nee
})
  , Tu = eee({
    a: BigInt(0),
    b: BigInt(7),
    Fp: v4,
    n: wI,
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    h: BigInt(1),
    lowS: !0,
    endo: {
        beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
        splitScalar: n => {
            const e = wI
              , t = BigInt("0x3086d221a7d46bcde86c90e49284eb15")
              , r = -tee * BigInt("0xe4437ed6010e88286f547fa90abfe4c3")
              , s = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8")
              , i = t
              , o = BigInt("0x100000000000000000000000000000000")
              , a = vI(i * n, e)
              , l = vI(-r * n, e);
            let u = bi(n - a * t - l * s, e)
              , d = bi(-a * r - l * i, e);
            const h = u > o
              , p = d > o;
            if (h && (u = e - u),
            p && (d = e - d),
            u > o || d > o)
                throw new Error("splitScalar: Endomorphism failed, k=" + n);
            return {
                k1neg: h,
                k1: u,
                k2neg: p,
                k2: d
            }
        }
    }
}, jL);
BigInt(0);
Tu.ProjectivePoint;
const _c = "0x0000000000000000000000000000000000000000"
  , xI = "0x0000000000000000000000000000000000000000000000000000000000000000"
  , EI = BigInt(0)
  , SI = BigInt(1)
  , AI = BigInt(2)
  , CI = BigInt(27)
  , _I = BigInt(28)
  , S1 = BigInt(35)
  , $h = {};
function kI(n) {
    return Cc(qr(n), 32)
}
class pr {
    #e;
    #t;
    #n;
    #r;
    get r() {
        return this.#e
    }
    set r(e) {
        he(Sp(e) === 32, "invalid r", "value", e),
        this.#e = Ke(e)
    }
    get s() {
        return he(parseInt(this.#t.substring(0, 3)) < 8, "non-canonical s; use ._s", "s", this.#t),
        this.#t
    }
    set s(e) {
        he(Sp(e) === 32, "invalid s", "value", e),
        this.#t = Ke(e)
    }
    get _s() {
        return this.#t
    }
    isValid() {
        return parseInt(this.#t.substring(0, 3)) < 8
    }
    get v() {
        return this.#n
    }
    set v(e) {
        const t = Bt(e, "value");
        he(t === 27 || t === 28, "invalid v", "v", e),
        this.#n = t
    }
    get networkV() {
        return this.#r
    }
    get legacyChainId() {
        const e = this.networkV;
        return e == null ? null : pr.getChainId(e)
    }
    get yParity() {
        return this.v === 27 ? 0 : 1
    }
    get yParityAndS() {
        const e = zt(this.s);
        return this.yParity && (e[0] |= 128),
        Ke(e)
    }
    get compactSerialized() {
        return gr([this.r, this.yParityAndS])
    }
    get serialized() {
        return gr([this.r, this.s, this.yParity ? "0x1c" : "0x1b"])
    }
    constructor(e, t, r, s) {
        Sy(e, $h, "Signature"),
        this.#e = t,
        this.#t = r,
        this.#n = s,
        this.#r = null
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
        return `Signature { r: "${this.r}", s: "${this._s}"${this.isValid() ? "" : ', valid: "false"'}, yParity: ${this.yParity}, networkV: ${this.networkV} }`
    }
    clone() {
        const e = new pr($h,this.r,this._s,this.v);
        return this.networkV && (e.#r = this.networkV),
        e
    }
    toJSON() {
        const e = this.networkV;
        return {
            _type: "signature",
            networkV: e != null ? e.toString() : null,
            r: this.r,
            s: this._s,
            v: this.v
        }
    }
    static getChainId(e) {
        const t = nt(e, "v");
        return t == CI || t == _I ? EI : (he(t >= S1, "invalid EIP-155 v", "v", e),
        (t - S1) / AI)
    }
    static getChainIdV(e, t) {
        return nt(e) * AI + BigInt(35 + t - 27)
    }
    static getNormalizedV(e) {
        const t = nt(e);
        return t === EI || t === CI ? 27 : t === SI || t === _I ? 28 : (he(t >= S1, "invalid v", "v", e),
        t & SI ? 27 : 28)
    }
    static from(e) {
        function t(u, d) {
            he(u, d, "signature", e)
        }
        if (e == null)
            return new pr($h,xI,xI,27);
        if (typeof e == "string") {
            const u = zt(e, "signature");
            if (u.length === 64) {
                const d = Ke(u.slice(0, 32))
                  , h = u.slice(32, 64)
                  , p = h[0] & 128 ? 28 : 27;
                return h[0] &= 127,
                new pr($h,d,Ke(h),p)
            }
            if (u.length === 65) {
                const d = Ke(u.slice(0, 32))
                  , h = Ke(u.slice(32, 64))
                  , p = pr.getNormalizedV(u[64]);
                return new pr($h,d,h,p)
            }
            t(!1, "invalid raw signature length")
        }
        if (e instanceof pr)
            return e.clone();
        const r = e.r;
        t(r != null, "missing r");
        const s = kI(r)
          , i = (function(u, d) {
            if (u != null)
                return kI(u);
            if (d != null) {
                t(zn(d, 32), "invalid yParityAndS");
                const h = zt(d);
                return h[0] &= 127,
                Ke(h)
            }
            t(!1, "missing s")
        }
        )(e.s, e.yParityAndS)
          , {networkV: o, v: a} = (function(u, d, h) {
            if (u != null) {
                const p = nt(u);
                return {
                    networkV: p >= S1 ? p : void 0,
                    v: pr.getNormalizedV(p)
                }
            }
            if (d != null)
                return t(zn(d, 32), "invalid yParityAndS"),
                {
                    v: zt(d)[0] & 128 ? 28 : 27
                };
            if (h != null) {
                switch (Bt(h, "sig.yParity")) {
                case 0:
                    return {
                        v: 27
                    };
                case 1:
                    return {
                        v: 28
                    }
                }
                t(!1, "invalid yParity")
            }
            t(!1, "missing v")
        }
        )(e.v, e.yParityAndS, e.yParity)
          , l = new pr($h,s,i,a);
        return o && (l.#r = o),
        t(e.yParity == null || Bt(e.yParity, "sig.yParity") === l.yParity, "yParity mismatch"),
        t(e.yParityAndS == null || e.yParityAndS === l.yParityAndS, "yParityAndS mismatch"),
        l
    }
}
class sc {
    #e;
    constructor(e) {
        he(Sp(e) === 32, "invalid private key", "privateKey", "[REDACTED]"),
        this.#e = Ke(e)
    }
    get privateKey() {
        return this.#e
    }
    get publicKey() {
        return sc.computePublicKey(this.#e)
    }
    get compressedPublicKey() {
        return sc.computePublicKey(this.#e, !0)
    }
    sign(e) {
        he(Sp(e) === 32, "invalid digest length", "digest", e);
        const t = Tu.sign(Ws(e), Ws(this.#e), {
            lowS: !0
        });
        return pr.from({
            r: Ku(t.r, 32),
            s: Ku(t.s, 32),
            v: t.recovery ? 28 : 27
        })
    }
    computeSharedSecret(e) {
        const t = sc.computePublicKey(e);
        return Ke(Tu.getSharedSecret(Ws(this.#e), zt(t), !1))
    }
    static computePublicKey(e, t) {
        let r = zt(e, "key");
        if (r.length === 32) {
            const i = Tu.getPublicKey(r, !!t);
            return Ke(i)
        }
        if (r.length === 64) {
            const i = new Uint8Array(65);
            i[0] = 4,
            i.set(r, 1),
            r = i
        }
        const s = Tu.ProjectivePoint.fromHex(r);
        return Ke(s.toRawBytes(t))
    }
    static recoverPublicKey(e, t) {
        he(Sp(e) === 32, "invalid digest length", "digest", e);
        const r = pr.from(t);
        let s = Tu.Signature.fromCompact(Ws(gr([r.r, r.s])));
        s = s.addRecoveryBit(r.yParity);
        const i = s.recoverPublicKey(Ws(e));
        return he(i != null, "invalid signature for digest", "signature", t),
        "0x" + i.toHex(!1)
    }
    static addPoints(e, t, r) {
        const s = Tu.ProjectivePoint.fromHex(sc.computePublicKey(e).substring(2))
          , i = Tu.ProjectivePoint.fromHex(sc.computePublicKey(t).substring(2));
        return "0x" + s.add(i).toHex(!!r)
    }
}
const ree = BigInt(0)
  , see = BigInt(36);
function NI(n) {
    n = n.toLowerCase();
    const e = n.substring(2).split("")
      , t = new Uint8Array(40);
    for (let s = 0; s < 40; s++)
        t[s] = e[s].charCodeAt(0);
    const r = zt(Fr(t));
    for (let s = 0; s < 40; s += 2)
        r[s >> 1] >> 4 >= 8 && (e[s] = e[s].toUpperCase()),
        (r[s >> 1] & 15) >= 8 && (e[s + 1] = e[s + 1].toUpperCase());
    return "0x" + e.join("")
}
const z8 = {};
for (let n = 0; n < 10; n++)
    z8[String(n)] = String(n);
for (let n = 0; n < 26; n++)
    z8[String.fromCharCode(65 + n)] = String(10 + n);
const DI = 15;
function iee(n) {
    n = n.toUpperCase(),
    n = n.substring(4) + n.substring(0, 2) + "00";
    let e = n.split("").map(r => z8[r]).join("");
    for (; e.length >= DI; ) {
        let r = e.substring(0, DI);
        e = parseInt(r, 10) % 97 + e.substring(r.length)
    }
    let t = String(98 - parseInt(e, 10) % 97);
    for (; t.length < 2; )
        t = "0" + t;
    return t
}
const oee = (function() {
    const n = {};
    for (let e = 0; e < 36; e++) {
        const t = "0123456789abcdefghijklmnopqrstuvwxyz"[e];
        n[t] = BigInt(e)
    }
    return n
}
)();
function aee(n) {
    n = n.toLowerCase();
    let e = ree;
    for (let t = 0; t < n.length; t++)
        e = e * see + oee[n[t]];
    return e
}
function yn(n) {
    if (he(typeof n == "string", "invalid address", "address", n),
    n.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
        n.startsWith("0x") || (n = "0x" + n);
        const e = NI(n);
        return he(!n.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || e === n, "bad address checksum", "address", n),
        e
    }
    if (n.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
        he(n.substring(2, 4) === iee(n), "bad icap checksum", "address", n);
        let e = aee(n.substring(4)).toString(16);
        for (; e.length < 40; )
            e = "0" + e;
        return NI("0x" + e)
    }
    he(!1, "invalid address", "address", n)
}
function lee(n) {
    const e = yn(n.from);
    let r = nt(n.nonce, "tx.nonce").toString(16);
    return r === "0" ? r = "0x" : r.length % 2 ? r = "0x0" + r : r = "0x" + r,
    yn(fr(Fr(Xu([e, r])), 12))
}
function lF(n) {
    return n && typeof n.getAddress == "function"
}
function Df(n) {
    try {
        return yn(n),
        !0
    } catch {}
    return !1
}
async function CS(n, e) {
    const t = await e;
    return (t == null || t === "0x0000000000000000000000000000000000000000") && (Ie(typeof n != "string", "unconfigured name", "UNCONFIGURED_NAME", {
        value: n
    }),
    he(!1, "invalid AddressLike value; did not resolve to a value address", "target", n)),
    yn(t)
}
function Xs(n, e) {
    if (typeof n == "string")
        return n.match(/^0x[0-9a-f]{40}$/i) ? yn(n) : (Ie(e != null, "ENS resolution requires a provider", "UNSUPPORTED_OPERATION", {
            operation: "resolveName"
        }),
        CS(n, e.resolveName(n)));
    if (lF(n))
        return CS(n, n.getAddress());
    if (n && typeof n.then == "function")
        return CS(n, n);
    he(!1, "unsupported addressable value", "target", n)
}
const Wl = {};
function tt(n, e) {
    let t = !1;
    return e < 0 && (t = !0,
    e *= -1),
    new mr(Wl,`${t ? "" : "u"}int${e}`,n,{
        signed: t,
        width: e
    })
}
function fn(n, e) {
    return new mr(Wl,`bytes${e || ""}`,n,{
        size: e
    })
}
const TI = Symbol.for("_ethers_typed");
class mr {
    type;
    value;
    #e;
    _typedSymbol;
    constructor(e, t, r, s) {
        s == null && (s = null),
        Sy(Wl, e, "Typed"),
        xt(this, {
            _typedSymbol: TI,
            type: t,
            value: r
        }),
        this.#e = s,
        this.format()
    }
    format() {
        if (this.type === "array")
            throw new Error("");
        if (this.type === "dynamicArray")
            throw new Error("");
        return this.type === "tuple" ? `tuple(${this.value.map(e => e.format()).join(",")})` : this.type
    }
    defaultValue() {
        return 0
    }
    minValue() {
        return 0
    }
    maxValue() {
        return 0
    }
    isBigInt() {
        return !!this.type.match(/^u?int[0-9]+$/)
    }
    isData() {
        return this.type.startsWith("bytes")
    }
    isString() {
        return this.type === "string"
    }
    get tupleName() {
        if (this.type !== "tuple")
            throw TypeError("not a tuple");
        return this.#e
    }
    get arrayLength() {
        if (this.type !== "array")
            throw TypeError("not an array");
        return this.#e === !0 ? -1 : this.#e === !1 ? this.value.length : null
    }
    static from(e, t) {
        return new mr(Wl,e,t)
    }
    static uint8(e) {
        return tt(e, 8)
    }
    static uint16(e) {
        return tt(e, 16)
    }
    static uint24(e) {
        return tt(e, 24)
    }
    static uint32(e) {
        return tt(e, 32)
    }
    static uint40(e) {
        return tt(e, 40)
    }
    static uint48(e) {
        return tt(e, 48)
    }
    static uint56(e) {
        return tt(e, 56)
    }
    static uint64(e) {
        return tt(e, 64)
    }
    static uint72(e) {
        return tt(e, 72)
    }
    static uint80(e) {
        return tt(e, 80)
    }
    static uint88(e) {
        return tt(e, 88)
    }
    static uint96(e) {
        return tt(e, 96)
    }
    static uint104(e) {
        return tt(e, 104)
    }
    static uint112(e) {
        return tt(e, 112)
    }
    static uint120(e) {
        return tt(e, 120)
    }
    static uint128(e) {
        return tt(e, 128)
    }
    static uint136(e) {
        return tt(e, 136)
    }
    static uint144(e) {
        return tt(e, 144)
    }
    static uint152(e) {
        return tt(e, 152)
    }
    static uint160(e) {
        return tt(e, 160)
    }
    static uint168(e) {
        return tt(e, 168)
    }
    static uint176(e) {
        return tt(e, 176)
    }
    static uint184(e) {
        return tt(e, 184)
    }
    static uint192(e) {
        return tt(e, 192)
    }
    static uint200(e) {
        return tt(e, 200)
    }
    static uint208(e) {
        return tt(e, 208)
    }
    static uint216(e) {
        return tt(e, 216)
    }
    static uint224(e) {
        return tt(e, 224)
    }
    static uint232(e) {
        return tt(e, 232)
    }
    static uint240(e) {
        return tt(e, 240)
    }
    static uint248(e) {
        return tt(e, 248)
    }
    static uint256(e) {
        return tt(e, 256)
    }
    static uint(e) {
        return tt(e, 256)
    }
    static int8(e) {
        return tt(e, -8)
    }
    static int16(e) {
        return tt(e, -16)
    }
    static int24(e) {
        return tt(e, -24)
    }
    static int32(e) {
        return tt(e, -32)
    }
    static int40(e) {
        return tt(e, -40)
    }
    static int48(e) {
        return tt(e, -48)
    }
    static int56(e) {
        return tt(e, -56)
    }
    static int64(e) {
        return tt(e, -64)
    }
    static int72(e) {
        return tt(e, -72)
    }
    static int80(e) {
        return tt(e, -80)
    }
    static int88(e) {
        return tt(e, -88)
    }
    static int96(e) {
        return tt(e, -96)
    }
    static int104(e) {
        return tt(e, -104)
    }
    static int112(e) {
        return tt(e, -112)
    }
    static int120(e) {
        return tt(e, -120)
    }
    static int128(e) {
        return tt(e, -128)
    }
    static int136(e) {
        return tt(e, -136)
    }
    static int144(e) {
        return tt(e, -144)
    }
    static int152(e) {
        return tt(e, -152)
    }
    static int160(e) {
        return tt(e, -160)
    }
    static int168(e) {
        return tt(e, -168)
    }
    static int176(e) {
        return tt(e, -176)
    }
    static int184(e) {
        return tt(e, -184)
    }
    static int192(e) {
        return tt(e, -192)
    }
    static int200(e) {
        return tt(e, -200)
    }
    static int208(e) {
        return tt(e, -208)
    }
    static int216(e) {
        return tt(e, -216)
    }
    static int224(e) {
        return tt(e, -224)
    }
    static int232(e) {
        return tt(e, -232)
    }
    static int240(e) {
        return tt(e, -240)
    }
    static int248(e) {
        return tt(e, -248)
    }
    static int256(e) {
        return tt(e, -256)
    }
    static int(e) {
        return tt(e, -256)
    }
    static bytes1(e) {
        return fn(e, 1)
    }
    static bytes2(e) {
        return fn(e, 2)
    }
    static bytes3(e) {
        return fn(e, 3)
    }
    static bytes4(e) {
        return fn(e, 4)
    }
    static bytes5(e) {
        return fn(e, 5)
    }
    static bytes6(e) {
        return fn(e, 6)
    }
    static bytes7(e) {
        return fn(e, 7)
    }
    static bytes8(e) {
        return fn(e, 8)
    }
    static bytes9(e) {
        return fn(e, 9)
    }
    static bytes10(e) {
        return fn(e, 10)
    }
    static bytes11(e) {
        return fn(e, 11)
    }
    static bytes12(e) {
        return fn(e, 12)
    }
    static bytes13(e) {
        return fn(e, 13)
    }
    static bytes14(e) {
        return fn(e, 14)
    }
    static bytes15(e) {
        return fn(e, 15)
    }
    static bytes16(e) {
        return fn(e, 16)
    }
    static bytes17(e) {
        return fn(e, 17)
    }
    static bytes18(e) {
        return fn(e, 18)
    }
    static bytes19(e) {
        return fn(e, 19)
    }
    static bytes20(e) {
        return fn(e, 20)
    }
    static bytes21(e) {
        return fn(e, 21)
    }
    static bytes22(e) {
        return fn(e, 22)
    }
    static bytes23(e) {
        return fn(e, 23)
    }
    static bytes24(e) {
        return fn(e, 24)
    }
    static bytes25(e) {
        return fn(e, 25)
    }
    static bytes26(e) {
        return fn(e, 26)
    }
    static bytes27(e) {
        return fn(e, 27)
    }
    static bytes28(e) {
        return fn(e, 28)
    }
    static bytes29(e) {
        return fn(e, 29)
    }
    static bytes30(e) {
        return fn(e, 30)
    }
    static bytes31(e) {
        return fn(e, 31)
    }
    static bytes32(e) {
        return fn(e, 32)
    }
    static address(e) {
        return new mr(Wl,"address",e)
    }
    static bool(e) {
        return new mr(Wl,"bool",!!e)
    }
    static bytes(e) {
        return new mr(Wl,"bytes",e)
    }
    static string(e) {
        return new mr(Wl,"string",e)
    }
    static array(e, t) {
        throw new Error("not implemented yet")
    }
    static tuple(e, t) {
        throw new Error("not implemented yet")
    }
    static overrides(e) {
        return new mr(Wl,"overrides",Object.assign({}, e))
    }
    static isTyped(e) {
        return e && typeof e == "object" && "_typedSymbol"in e && e._typedSymbol === TI
    }
    static dereference(e, t) {
        if (mr.isTyped(e)) {
            if (e.type !== t)
                throw new Error(`invalid type: expecetd ${t}, got ${e.type}`);
            return e.value
        }
        return e
    }
}
class cee extends jc {
    constructor(e) {
        super("address", "address", e, !1)
    }
    defaultValue() {
        return "0x0000000000000000000000000000000000000000"
    }
    encode(e, t) {
        let r = mr.dereference(t, "string");
        try {
            r = yn(r)
        } catch (s) {
            return this._throwError(s.message, t)
        }
        return e.writeValue(r)
    }
    decode(e) {
        return yn(Ku(e.readValue(), 20))
    }
}
class uee extends jc {
    coder;
    constructor(e) {
        super(e.name, e.type, "_", e.dynamic),
        this.coder = e
    }
    defaultValue() {
        return this.coder.defaultValue()
    }
    encode(e, t) {
        return this.coder.encode(e, t)
    }
    decode(e) {
        return this.coder.decode(e)
    }
}
function cF(n, e, t) {
    let r = [];
    if (Array.isArray(t))
        r = t;
    else if (t && typeof t == "object") {
        let l = {};
        r = e.map(u => {
            const d = u.localName;
            return Ie(d, "cannot encode object for signature with missing names", "INVALID_ARGUMENT", {
                argument: "values",
                info: {
                    coder: u
                },
                value: t
            }),
            Ie(!l[d], "cannot encode object for signature with duplicate names", "INVALID_ARGUMENT", {
                argument: "values",
                info: {
                    coder: u
                },
                value: t
            }),
            l[d] = !0,
            t[d]
        }
        )
    } else
        he(!1, "invalid tuple value", "tuple", t);
    he(e.length === r.length, "types/value length mismatch", "tuple", t);
    let s = new m4
      , i = new m4
      , o = [];
    e.forEach( (l, u) => {
        let d = r[u];
        if (l.dynamic) {
            let h = i.length;
            l.encode(i, d);
            let p = s.writeUpdatableValue();
            o.push(g => {
                p(g + h)
            }
            )
        } else
            l.encode(s, d)
    }
    ),
    o.forEach(l => {
        l(s.length)
    }
    );
    let a = n.appendWriter(s);
    return a += n.appendWriter(i),
    a
}
function uF(n, e) {
    let t = []
      , r = []
      , s = n.subReader(0);
    return e.forEach(i => {
        let o = null;
        if (i.dynamic) {
            let a = n.readIndex()
              , l = s.subReader(a);
            try {
                o = i.decode(l)
            } catch (u) {
                if (xs(u, "BUFFER_OVERRUN"))
                    throw u;
                o = u,
                o.baseType = i.name,
                o.name = i.localName,
                o.type = i.type
            }
        } else
            try {
                o = i.decode(n)
            } catch (a) {
                if (xs(a, "BUFFER_OVERRUN"))
                    throw a;
                o = a,
                o.baseType = i.name,
                o.name = i.localName,
                o.type = i.type
            }
        if (o == null)
            throw new Error("investigate");
        t.push(o),
        r.push(i.localName || null)
    }
    ),
    lc.fromItems(t, r)
}
class dee extends jc {
    coder;
    length;
    constructor(e, t, r) {
        const s = e.type + "[" + (t >= 0 ? t : "") + "]"
          , i = t === -1 || e.dynamic;
        super("array", s, r, i),
        xt(this, {
            coder: e,
            length: t
        })
    }
    defaultValue() {
        const e = this.coder.defaultValue()
          , t = [];
        for (let r = 0; r < this.length; r++)
            t.push(e);
        return t
    }
    encode(e, t) {
        const r = mr.dereference(t, "array");
        Array.isArray(r) || this._throwError("expected array value", r);
        let s = this.length;
        s === -1 && (s = r.length,
        e.writeValue(r.length)),
        bL(r.length, s, "coder array" + (this.localName ? " " + this.localName : ""));
        let i = [];
        for (let o = 0; o < r.length; o++)
            i.push(this.coder);
        return cF(e, i, r)
    }
    decode(e) {
        let t = this.length;
        t === -1 && (t = e.readIndex(),
        Ie(t * Ks <= e.dataLength, "insufficient data length", "BUFFER_OVERRUN", {
            buffer: e.bytes,
            offset: t * Ks,
            length: e.dataLength
        }));
        let r = [];
        for (let s = 0; s < t; s++)
            r.push(new uee(this.coder));
        return uF(e, r)
    }
}
class fee extends jc {
    constructor(e) {
        super("bool", "bool", e, !1)
    }
    defaultValue() {
        return !1
    }
    encode(e, t) {
        const r = mr.dereference(t, "bool");
        return e.writeValue(r ? 1 : 0)
    }
    decode(e) {
        return !!e.readValue()
    }
}
class dF extends jc {
    constructor(e, t) {
        super(e, e, t, !0)
    }
    defaultValue() {
        return "0x"
    }
    encode(e, t) {
        t = Ws(t);
        let r = e.writeValue(t.length);
        return r += e.writeBytes(t),
        r
    }
    decode(e) {
        return e.readBytes(e.readIndex(), !0)
    }
}
class hee extends dF {
    constructor(e) {
        super("bytes", e)
    }
    decode(e) {
        return Ke(super.decode(e))
    }
}
class pee extends jc {
    size;
    constructor(e, t) {
        let r = "bytes" + String(e);
        super(r, r, t, !1),
        xt(this, {
            size: e
        }, {
            size: "number"
        })
    }
    defaultValue() {
        return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2)
    }
    encode(e, t) {
        let r = Ws(mr.dereference(t, this.type));
        return r.length !== this.size && this._throwError("incorrect data length", t),
        e.writeBytes(r)
    }
    decode(e) {
        return Ke(e.readBytes(this.size))
    }
}
const mee = new Uint8Array([]);
class gee extends jc {
    constructor(e) {
        super("null", "", e, !1)
    }
    defaultValue() {
        return null
    }
    encode(e, t) {
        return t != null && this._throwError("not null", t),
        e.writeBytes(mee)
    }
    decode(e) {
        return e.readBytes(0),
        null
    }
}
const yee = BigInt(0)
  , bee = BigInt(1)
  , wee = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
class vee extends jc {
    size;
    signed;
    constructor(e, t, r) {
        const s = (t ? "int" : "uint") + e * 8;
        super(s, s, r, !1),
        xt(this, {
            size: e,
            signed: t
        }, {
            size: "number",
            signed: "boolean"
        })
    }
    defaultValue() {
        return 0
    }
    encode(e, t) {
        let r = nt(mr.dereference(t, this.type))
          , s = tf(wee, Ks * 8);
        if (this.signed) {
            let i = tf(s, this.size * 8 - 1);
            (r > i || r < -(i + bee)) && this._throwError("value out-of-bounds", t),
            r = xL(r, 8 * Ks)
        } else
            (r < yee || r > tf(s, this.size * 8)) && this._throwError("value out-of-bounds", t);
        return e.writeValue(r)
    }
    decode(e) {
        let t = tf(e.readValue(), this.size * 8);
        return this.signed && (t = c2(t, this.size * 8)),
        t
    }
}
class xee extends dF {
    constructor(e) {
        super("string", e)
    }
    defaultValue() {
        return ""
    }
    encode(e, t) {
        return super.encode(e, pc(mr.dereference(t, "string")))
    }
    decode(e) {
        return u2(super.decode(e))
    }
}
class A1 extends jc {
    coders;
    constructor(e, t) {
        let r = !1;
        const s = [];
        e.forEach(o => {
            o.dynamic && (r = !0),
            s.push(o.type)
        }
        );
        const i = "tuple(" + s.join(",") + ")";
        super("tuple", i, t, r),
        xt(this, {
            coders: Object.freeze(e.slice())
        })
    }
    defaultValue() {
        const e = [];
        this.coders.forEach(r => {
            e.push(r.defaultValue())
        }
        );
        const t = this.coders.reduce( (r, s) => {
            const i = s.localName;
            return i && (r[i] || (r[i] = 0),
            r[i]++),
            r
        }
        , {});
        return this.coders.forEach( (r, s) => {
            let i = r.localName;
            !i || t[i] !== 1 || (i === "length" && (i = "_length"),
            e[i] == null && (e[i] = e[s]))
        }
        ),
        Object.freeze(e)
    }
    encode(e, t) {
        const r = mr.dereference(t, "tuple");
        return cF(e, this.coders, r)
    }
    decode(e) {
        return uF(e, this.coders)
    }
}
function _S(n, e) {
    return {
        address: yn(n),
        storageKeys: e.map( (t, r) => (he(zn(t, 32), "invalid slot", `storageKeys[${r}]`, t),
        t.toLowerCase()))
    }
}
function $f(n) {
    if (Array.isArray(n))
        return n.map( (t, r) => Array.isArray(t) ? (he(t.length === 2, "invalid slot set", `value[${r}]`, t),
        _S(t[0], t[1])) : (he(t != null && typeof t == "object", "invalid address-slot set", "value", n),
        _S(t.address, t.storageKeys)));
    he(n != null && typeof n == "object", "invalid access list", "value", n);
    const e = Object.keys(n).map(t => {
        const r = n[t].reduce( (s, i) => (s[i] = !0,
        s), {});
        return _S(t, Object.keys(r).sort())
    }
    );
    return e.sort( (t, r) => t.address.localeCompare(r.address)),
    e
}
function fF(n) {
    return {
        address: yn(n.address),
        nonce: nt(n.nonce != null ? n.nonce : 0),
        chainId: nt(n.chainId != null ? n.chainId : 0),
        signature: pr.from(n.signature)
    }
}
function Eee(n) {
    let e;
    return typeof n == "string" ? e = sc.computePublicKey(n, !1) : e = n.publicKey,
    yn(Fr("0x" + e.substring(4)).substring(26))
}
function See(n, e) {
    return Eee(sc.recoverPublicKey(n, e))
}
const es = BigInt(0)
  , Aee = BigInt(2)
  , Cee = BigInt(27)
  , _ee = BigInt(28)
  , kee = BigInt(35)
  , Nee = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff")
  , kS = 4096 * 32;
function Dee(n) {
    return {
        blobToKzgCommitment: r => {
            if ("computeBlobProof"in n) {
                if ("blobToKzgCommitment"in n && typeof n.blobToKzgCommitment == "function")
                    return zt(n.blobToKzgCommitment(Ke(r)))
            } else if ("blobToKzgCommitment"in n && typeof n.blobToKzgCommitment == "function")
                return zt(n.blobToKzgCommitment(r));
            if ("blobToKZGCommitment"in n && typeof n.blobToKZGCommitment == "function")
                return zt(n.blobToKZGCommitment(Ke(r)));
            he(!1, "unsupported KZG library", "kzg", n)
        }
        ,
        computeBlobKzgProof: (r, s) => {
            if ("computeBlobProof"in n && typeof n.computeBlobProof == "function")
                return zt(n.computeBlobProof(Ke(r), Ke(s)));
            if ("computeBlobKzgProof"in n && typeof n.computeBlobKzgProof == "function")
                return n.computeBlobKzgProof(r, s);
            if ("computeBlobKZGProof"in n && typeof n.computeBlobKZGProof == "function")
                return zt(n.computeBlobKZGProof(Ke(r), Ke(s)));
            he(!1, "unsupported KZG library", "kzg", n)
        }
    }
}
function II(n, e) {
    let t = n.toString(16);
    for (; t.length < 2; )
        t = "0" + t;
    return t += C0(e).substring(4),
    "0x" + t
}
function _0(n) {
    return n === "0x" ? null : yn(n)
}
function Fv(n, e) {
    try {
        return $f(n)
    } catch (t) {
        he(!1, t.message, e, n)
    }
}
function Tee(n, e) {
    try {
        if (!Array.isArray(n))
            throw new Error("authorizationList: invalid array");
        const t = [];
        for (let r = 0; r < n.length; r++) {
            const s = n[r];
            if (!Array.isArray(s))
                throw new Error(`authorization[${r}]: invalid array`);
            if (s.length !== 6)
                throw new Error(`authorization[${r}]: wrong length`);
            if (!s[1])
                throw new Error(`authorization[${r}]: null address`);
            t.push({
                address: _0(s[1]),
                nonce: Bn(s[2], "nonce"),
                chainId: Bn(s[0], "chainId"),
                signature: pr.from({
                    yParity: Hf(s[3], "yParity"),
                    r: Cc(s[4], 32),
                    s: Cc(s[5], 32)
                })
            })
        }
        return t
    } catch (t) {
        he(!1, t.message, e, n)
    }
}
function Hf(n, e) {
    return n === "0x" ? 0 : Bt(n, e)
}
function Bn(n, e) {
    if (n === "0x")
        return es;
    const t = nt(n, e);
    return he(t <= Nee, "value exceeds uint size", e, t),
    t
}
function sn(n, e) {
    const t = nt(n, "value")
      , r = qr(t);
    return he(r.length <= 32, "value too large", `tx.${e}`, t),
    r
}
function Uv(n) {
    return $f(n).map(e => [e.address, e.storageKeys])
}
function Iee(n) {
    return n.map(e => [sn(e.chainId, "chainId"), e.address, sn(e.nonce, "nonce"), sn(e.signature.yParity, "yParity"), qr(e.signature.r), qr(e.signature.s)])
}
function Mee(n, e) {
    he(Array.isArray(n), `invalid ${e}`, "value", n);
    for (let t = 0; t < n.length; t++)
        he(zn(n[t], 32), "invalid ${ param } hash", `value[${t}]`, n[t]);
    return n
}
function Bee(n) {
    const e = Ay(n);
    he(Array.isArray(e) && (e.length === 9 || e.length === 6), "invalid field count for legacy transaction", "data", n);
    const t = {
        type: 0,
        nonce: Hf(e[0], "nonce"),
        gasPrice: Bn(e[1], "gasPrice"),
        gasLimit: Bn(e[2], "gasLimit"),
        to: _0(e[3]),
        value: Bn(e[4], "value"),
        data: Ke(e[5]),
        chainId: es
    };
    if (e.length === 6)
        return t;
    const r = Bn(e[6], "v")
      , s = Bn(e[7], "r")
      , i = Bn(e[8], "s");
    if (s === es && i === es)
        t.chainId = r;
    else {
        let o = (r - kee) / Aee;
        o < es && (o = es),
        t.chainId = o,
        he(o !== es || r === Cee || r === _ee, "non-canonical legacy v", "v", e[6]),
        t.signature = pr.from({
            r: Cc(e[7], 32),
            s: Cc(e[8], 32),
            v: r
        })
    }
    return t
}
function Ree(n, e) {
    const t = [sn(n.nonce, "nonce"), sn(n.gasPrice || 0, "gasPrice"), sn(n.gasLimit, "gasLimit"), n.to || "0x", sn(n.value, "value"), n.data];
    let r = es;
    if (n.chainId != es)
        r = nt(n.chainId, "tx.chainId"),
        he(!e || e.networkV == null || e.legacyChainId === r, "tx.chainId/sig.v mismatch", "sig", e);
    else if (n.signature) {
        const i = n.signature.legacyChainId;
        i != null && (r = i)
    }
    if (!e)
        return r !== es && (t.push(qr(r)),
        t.push("0x"),
        t.push("0x")),
        Xu(t);
    let s = BigInt(27 + e.yParity);
    return r !== es ? s = pr.getChainIdV(r, e.v) : BigInt(e.v) !== s && he(!1, "tx.chainId/sig.v mismatch", "sig", e),
    t.push(qr(s)),
    t.push(qr(e.r)),
    t.push(qr(e.s)),
    Xu(t)
}
function zv(n, e) {
    let t;
    try {
        if (t = Hf(e[0], "yParity"),
        t !== 0 && t !== 1)
            throw new Error("bad yParity")
    } catch {
        he(!1, "invalid yParity", "yParity", e[0])
    }
    const r = Cc(e[1], 32)
      , s = Cc(e[2], 32)
      , i = pr.from({
        r,
        s,
        yParity: t
    });
    n.signature = i
}
function Oee(n) {
    const e = Ay(zt(n).slice(1));
    he(Array.isArray(e) && (e.length === 9 || e.length === 12), "invalid field count for transaction type: 2", "data", Ke(n));
    const t = {
        type: 2,
        chainId: Bn(e[0], "chainId"),
        nonce: Hf(e[1], "nonce"),
        maxPriorityFeePerGas: Bn(e[2], "maxPriorityFeePerGas"),
        maxFeePerGas: Bn(e[3], "maxFeePerGas"),
        gasPrice: null,
        gasLimit: Bn(e[4], "gasLimit"),
        to: _0(e[5]),
        value: Bn(e[6], "value"),
        data: Ke(e[7]),
        accessList: Fv(e[8], "accessList")
    };
    return e.length === 9 || zv(t, e.slice(9)),
    t
}
function Pee(n, e) {
    const t = [sn(n.chainId, "chainId"), sn(n.nonce, "nonce"), sn(n.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"), sn(n.maxFeePerGas || 0, "maxFeePerGas"), sn(n.gasLimit, "gasLimit"), n.to || "0x", sn(n.value, "value"), n.data, Uv(n.accessList || [])];
    return e && (t.push(sn(e.yParity, "yParity")),
    t.push(qr(e.r)),
    t.push(qr(e.s))),
    gr(["0x02", Xu(t)])
}
function jee(n) {
    const e = Ay(zt(n).slice(1));
    he(Array.isArray(e) && (e.length === 8 || e.length === 11), "invalid field count for transaction type: 1", "data", Ke(n));
    const t = {
        type: 1,
        chainId: Bn(e[0], "chainId"),
        nonce: Hf(e[1], "nonce"),
        gasPrice: Bn(e[2], "gasPrice"),
        gasLimit: Bn(e[3], "gasLimit"),
        to: _0(e[4]),
        value: Bn(e[5], "value"),
        data: Ke(e[6]),
        accessList: Fv(e[7], "accessList")
    };
    return e.length === 8 || zv(t, e.slice(8)),
    t
}
function Lee(n, e) {
    const t = [sn(n.chainId, "chainId"), sn(n.nonce, "nonce"), sn(n.gasPrice || 0, "gasPrice"), sn(n.gasLimit, "gasLimit"), n.to || "0x", sn(n.value, "value"), n.data, Uv(n.accessList || [])];
    return e && (t.push(sn(e.yParity, "recoveryParam")),
    t.push(qr(e.r)),
    t.push(qr(e.s))),
    gr(["0x01", Xu(t)])
}
function Fee(n) {
    let e = Ay(zt(n).slice(1))
      , t = "3"
      , r = null;
    if (e.length === 4 && Array.isArray(e[0])) {
        t = "3 (network format)";
        const i = e[1]
          , o = e[2]
          , a = e[3];
        he(Array.isArray(i), "invalid network format: blobs not an array", "fields[1]", i),
        he(Array.isArray(o), "invalid network format: commitments not an array", "fields[2]", o),
        he(Array.isArray(a), "invalid network format: proofs not an array", "fields[3]", a),
        he(i.length === o.length, "invalid network format: blobs/commitments length mismatch", "fields", e),
        he(i.length === a.length, "invalid network format: blobs/proofs length mismatch", "fields", e),
        r = [];
        for (let l = 0; l < e[1].length; l++)
            r.push({
                data: i[l],
                commitment: o[l],
                proof: a[l]
            });
        e = e[0]
    }
    he(Array.isArray(e) && (e.length === 11 || e.length === 14), `invalid field count for transaction type: ${t}`, "data", Ke(n));
    const s = {
        type: 3,
        chainId: Bn(e[0], "chainId"),
        nonce: Hf(e[1], "nonce"),
        maxPriorityFeePerGas: Bn(e[2], "maxPriorityFeePerGas"),
        maxFeePerGas: Bn(e[3], "maxFeePerGas"),
        gasPrice: null,
        gasLimit: Bn(e[4], "gasLimit"),
        to: _0(e[5]),
        value: Bn(e[6], "value"),
        data: Ke(e[7]),
        accessList: Fv(e[8], "accessList"),
        maxFeePerBlobGas: Bn(e[9], "maxFeePerBlobGas"),
        blobVersionedHashes: e[10]
    };
    r && (s.blobs = r),
    he(s.to != null, `invalid address for transaction type: ${t}`, "data", n),
    he(Array.isArray(s.blobVersionedHashes), "invalid blobVersionedHashes: must be an array", "data", n);
    for (let i = 0; i < s.blobVersionedHashes.length; i++)
        he(zn(s.blobVersionedHashes[i], 32), `invalid blobVersionedHash at index ${i}: must be length 32`, "data", n);
    return e.length === 11 || zv(s, e.slice(11)),
    s
}
function Uee(n, e, t) {
    const r = [sn(n.chainId, "chainId"), sn(n.nonce, "nonce"), sn(n.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"), sn(n.maxFeePerGas || 0, "maxFeePerGas"), sn(n.gasLimit, "gasLimit"), n.to || _c, sn(n.value, "value"), n.data, Uv(n.accessList || []), sn(n.maxFeePerBlobGas || 0, "maxFeePerBlobGas"), Mee(n.blobVersionedHashes || [], "blobVersionedHashes")];
    return e && (r.push(sn(e.yParity, "yParity")),
    r.push(qr(e.r)),
    r.push(qr(e.s)),
    t) ? gr(["0x03", Xu([r, t.map(s => s.data), t.map(s => s.commitment), t.map(s => s.proof)])]) : gr(["0x03", Xu(r)])
}
function zee(n) {
    const e = Ay(zt(n).slice(1));
    he(Array.isArray(e) && (e.length === 10 || e.length === 13), "invalid field count for transaction type: 4", "data", Ke(n));
    const t = {
        type: 4,
        chainId: Bn(e[0], "chainId"),
        nonce: Hf(e[1], "nonce"),
        maxPriorityFeePerGas: Bn(e[2], "maxPriorityFeePerGas"),
        maxFeePerGas: Bn(e[3], "maxFeePerGas"),
        gasPrice: null,
        gasLimit: Bn(e[4], "gasLimit"),
        to: _0(e[5]),
        value: Bn(e[6], "value"),
        data: Ke(e[7]),
        accessList: Fv(e[8], "accessList"),
        authorizationList: Tee(e[9], "authorizationList")
    };
    return e.length === 10 || zv(t, e.slice(10)),
    t
}
function $ee(n, e) {
    const t = [sn(n.chainId, "chainId"), sn(n.nonce, "nonce"), sn(n.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"), sn(n.maxFeePerGas || 0, "maxFeePerGas"), sn(n.gasLimit, "gasLimit"), n.to || "0x", sn(n.value, "value"), n.data, Uv(n.accessList || []), Iee(n.authorizationList || [])];
    return e && (t.push(sn(e.yParity, "yParity")),
    t.push(qr(e.r)),
    t.push(qr(e.s))),
    gr(["0x04", Xu(t)])
}
let hF = class $l {
    #e;
    #t;
    #n;
    #r;
    #s;
    #o;
    #i;
    #a;
    #d;
    #c;
    #p;
    #m;
    #l;
    #u;
    #f;
    #h;
    #y;
    get type() {
        return this.#e
    }
    set type(e) {
        switch (e) {
        case null:
            this.#e = null;
            break;
        case 0:
        case "legacy":
            this.#e = 0;
            break;
        case 1:
        case "berlin":
        case "eip-2930":
            this.#e = 1;
            break;
        case 2:
        case "london":
        case "eip-1559":
            this.#e = 2;
            break;
        case 3:
        case "cancun":
        case "eip-4844":
            this.#e = 3;
            break;
        case 4:
        case "pectra":
        case "eip-7702":
            this.#e = 4;
            break;
        default:
            he(!1, "unsupported transaction type", "type", e)
        }
    }
    get typeName() {
        switch (this.type) {
        case 0:
            return "legacy";
        case 1:
            return "eip-2930";
        case 2:
            return "eip-1559";
        case 3:
            return "eip-4844";
        case 4:
            return "eip-7702"
        }
        return null
    }
    get to() {
        const e = this.#t;
        return e == null && this.type === 3 ? _c : e
    }
    set to(e) {
        this.#t = e == null ? null : yn(e)
    }
    get nonce() {
        return this.#r
    }
    set nonce(e) {
        this.#r = Bt(e, "value")
    }
    get gasLimit() {
        return this.#s
    }
    set gasLimit(e) {
        this.#s = nt(e)
    }
    get gasPrice() {
        const e = this.#o;
        return e == null && (this.type === 0 || this.type === 1) ? es : e
    }
    set gasPrice(e) {
        this.#o = e == null ? null : nt(e, "gasPrice")
    }
    get maxPriorityFeePerGas() {
        const e = this.#i;
        return e ?? (this.type === 2 || this.type === 3 ? es : null)
    }
    set maxPriorityFeePerGas(e) {
        this.#i = e == null ? null : nt(e, "maxPriorityFeePerGas")
    }
    get maxFeePerGas() {
        const e = this.#a;
        return e ?? (this.type === 2 || this.type === 3 ? es : null)
    }
    set maxFeePerGas(e) {
        this.#a = e == null ? null : nt(e, "maxFeePerGas")
    }
    get data() {
        return this.#n
    }
    set data(e) {
        this.#n = Ke(e)
    }
    get value() {
        return this.#d
    }
    set value(e) {
        this.#d = nt(e, "value")
    }
    get chainId() {
        return this.#c
    }
    set chainId(e) {
        this.#c = nt(e)
    }
    get signature() {
        return this.#p || null
    }
    set signature(e) {
        this.#p = e == null ? null : pr.from(e)
    }
    get accessList() {
        const e = this.#m || null;
        return e ?? (this.type === 1 || this.type === 2 || this.type === 3 ? [] : null)
    }
    set accessList(e) {
        this.#m = e == null ? null : $f(e)
    }
    get authorizationList() {
        const e = this.#y || null;
        return e == null && this.type === 4 ? [] : e
    }
    set authorizationList(e) {
        this.#y = e == null ? null : e.map(t => fF(t))
    }
    get maxFeePerBlobGas() {
        const e = this.#l;
        return e == null && this.type === 3 ? es : e
    }
    set maxFeePerBlobGas(e) {
        this.#l = e == null ? null : nt(e, "maxFeePerBlobGas")
    }
    get blobVersionedHashes() {
        let e = this.#u;
        return e == null && this.type === 3 ? [] : e
    }
    set blobVersionedHashes(e) {
        if (e != null) {
            he(Array.isArray(e), "blobVersionedHashes must be an Array", "value", e),
            e = e.slice();
            for (let t = 0; t < e.length; t++)
                he(zn(e[t], 32), "invalid blobVersionedHash", `value[${t}]`, e[t])
        }
        this.#u = e
    }
    get blobs() {
        return this.#h == null ? null : this.#h.map(e => Object.assign({}, e))
    }
    set blobs(e) {
        if (e == null) {
            this.#h = null;
            return
        }
        const t = []
          , r = [];
        for (let s = 0; s < e.length; s++) {
            const i = e[s];
            if (M8(i)) {
                Ie(this.#f, "adding a raw blob requires a KZG library", "UNSUPPORTED_OPERATION", {
                    operation: "set blobs()"
                });
                let o = zt(i);
                if (he(o.length <= kS, "blob is too large", `blobs[${s}]`, i),
                o.length !== kS) {
                    const u = new Uint8Array(kS);
                    u.set(o),
                    o = u
                }
                const a = this.#f.blobToKzgCommitment(o)
                  , l = Ke(this.#f.computeBlobKzgProof(o, a));
                t.push({
                    data: Ke(o),
                    commitment: Ke(a),
                    proof: l
                }),
                r.push(II(1, a))
            } else {
                const o = Ke(i.commitment);
                t.push({
                    data: Ke(i.data),
                    commitment: o,
                    proof: Ke(i.proof)
                }),
                r.push(II(1, o))
            }
        }
        this.#h = t,
        this.#u = r
    }
    get kzg() {
        return this.#f
    }
    set kzg(e) {
        e == null ? this.#f = null : this.#f = Dee(e)
    }
    constructor() {
        this.#e = null,
        this.#t = null,
        this.#r = 0,
        this.#s = es,
        this.#o = null,
        this.#i = null,
        this.#a = null,
        this.#n = "0x",
        this.#d = es,
        this.#c = es,
        this.#p = null,
        this.#m = null,
        this.#l = null,
        this.#u = null,
        this.#f = null,
        this.#h = null,
        this.#y = null
    }
    get hash() {
        return this.signature == null ? null : Fr(this.#g(!0, !1))
    }
    get unsignedHash() {
        return Fr(this.unsignedSerialized)
    }
    get from() {
        return this.signature == null ? null : See(this.unsignedHash, this.signature)
    }
    get fromPublicKey() {
        return this.signature == null ? null : sc.recoverPublicKey(this.unsignedHash, this.signature)
    }
    isSigned() {
        return this.signature != null
    }
    #g(e, t) {
        Ie(!e || this.signature != null, "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized", "UNSUPPORTED_OPERATION", {
            operation: ".serialized"
        });
        const r = e ? this.signature : null;
        switch (this.inferType()) {
        case 0:
            return Ree(this, r);
        case 1:
            return Lee(this, r);
        case 2:
            return Pee(this, r);
        case 3:
            return Uee(this, r, t ? this.blobs : null);
        case 4:
            return $ee(this, r)
        }
        Ie(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", {
            operation: ".serialized"
        })
    }
    get serialized() {
        return this.#g(!0, !0)
    }
    get unsignedSerialized() {
        return this.#g(!1, !1)
    }
    inferType() {
        const e = this.inferTypes();
        return e.indexOf(2) >= 0 ? 2 : e.pop()
    }
    inferTypes() {
        const e = this.gasPrice != null
          , t = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null
          , r = this.accessList != null
          , s = this.#l != null || this.#u;
        this.maxFeePerGas != null && this.maxPriorityFeePerGas != null && Ie(this.maxFeePerGas >= this.maxPriorityFeePerGas, "priorityFee cannot be more than maxFee", "BAD_DATA", {
            value: this
        }),
        Ie(!t || this.type !== 0 && this.type !== 1, "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas", "BAD_DATA", {
            value: this
        }),
        Ie(this.type !== 0 || !r, "legacy transaction cannot have accessList", "BAD_DATA", {
            value: this
        });
        const i = [];
        return this.type != null ? i.push(this.type) : this.authorizationList && this.authorizationList.length ? i.push(4) : t ? i.push(2) : e ? (i.push(1),
        r || i.push(0)) : r ? (i.push(1),
        i.push(2)) : (s && this.to || (i.push(0),
        i.push(1),
        i.push(2)),
        i.push(3)),
        i.sort(),
        i
    }
    isLegacy() {
        return this.type === 0
    }
    isBerlin() {
        return this.type === 1
    }
    isLondon() {
        return this.type === 2
    }
    isCancun() {
        return this.type === 3
    }
    clone() {
        return $l.from(this)
    }
    toJSON() {
        const e = t => t == null ? null : t.toString();
        return {
            type: this.type,
            to: this.to,
            data: this.data,
            nonce: this.nonce,
            gasLimit: e(this.gasLimit),
            gasPrice: e(this.gasPrice),
            maxPriorityFeePerGas: e(this.maxPriorityFeePerGas),
            maxFeePerGas: e(this.maxFeePerGas),
            value: e(this.value),
            chainId: e(this.chainId),
            sig: this.signature ? this.signature.toJSON() : null,
            accessList: this.accessList
        }
    }
    static from(e) {
        if (e == null)
            return new $l;
        if (typeof e == "string") {
            const r = zt(e);
            if (r[0] >= 127)
                return $l.from(Bee(r));
            switch (r[0]) {
            case 1:
                return $l.from(jee(r));
            case 2:
                return $l.from(Oee(r));
            case 3:
                return $l.from(Fee(r));
            case 4:
                return $l.from(zee(r))
            }
            Ie(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", {
                operation: "from"
            })
        }
        const t = new $l;
        return e.type != null && (t.type = e.type),
        e.to != null && (t.to = e.to),
        e.nonce != null && (t.nonce = e.nonce),
        e.gasLimit != null && (t.gasLimit = e.gasLimit),
        e.gasPrice != null && (t.gasPrice = e.gasPrice),
        e.maxPriorityFeePerGas != null && (t.maxPriorityFeePerGas = e.maxPriorityFeePerGas),
        e.maxFeePerGas != null && (t.maxFeePerGas = e.maxFeePerGas),
        e.maxFeePerBlobGas != null && (t.maxFeePerBlobGas = e.maxFeePerBlobGas),
        e.data != null && (t.data = e.data),
        e.value != null && (t.value = e.value),
        e.chainId != null && (t.chainId = e.chainId),
        e.signature != null && (t.signature = pr.from(e.signature)),
        e.accessList != null && (t.accessList = e.accessList),
        e.authorizationList != null && (t.authorizationList = e.authorizationList),
        e.blobVersionedHashes != null && (t.blobVersionedHashes = e.blobVersionedHashes),
        e.kzg != null && (t.kzg = e.kzg),
        e.blobs != null && (t.blobs = e.blobs),
        e.hash != null && (he(t.isSigned(), "unsigned transaction cannot define '.hash'", "tx", e),
        he(t.hash === e.hash, "hash mismatch", "tx", e)),
        e.from != null && (he(t.isSigned(), "unsigned transaction cannot define '.from'", "tx", e),
        he(t.from.toLowerCase() === (e.from || "").toLowerCase(), "from mismatch", "tx", e)),
        t
    }
}
;
function Tf(n) {
    return Fr(pc(n))
}
var Hee = "AEEUdwmgDS8BxQKKAP4BOgDjATAAngDUAIMAoABoAOAAagCOAEQAhABMAHIAOwA9ACsANgAmAGIAHgAuACgAJwAXAC0AGgAjAB8ALwAUACkAEgAeAAkAGwARABkAFgA5ACgALQArADcAFQApABAAHgAiABAAGgAeABMAGAUhBe8BFxREN8sF2wC5AK5HAW8ArQkDzQCuhzc3NzcBP68NEfMABQdHBuw5BV8FYAA9MzkI9r4ZBg7QyQAWA9CeOwLNCjcCjqkChuA/lm+RAsXTAoP6ASfnEQDytQFJAjWVCkeXAOsA6godAB/cwdAUE0WlBCN/AQUCQRjFD/MRBjHxDQSJbw0jBzUAswBxme+tnIcAYwabAysG8QAjAEMMmxcDqgPKQyDXCMMxA7kUQwD3NXOrAKmFIAAfBC0D3x4BJQDBGdUFAhEgVD8JnwmQJiNWYUzrg0oAGwAUAB0AFnNcACkAFgBP9h3gPfsDOWDKneY2ChglX1UDYD30ABsAFAAdABZzIGRAnwDD8wAjAEEMzRbDqgMB2sAFYwXqAtCnAsS4AwpUJKRtFHsadUz9AMMVbwLpABM1NJEX0ZkCgYMBEyMAxRVvAukAEzUBUFAtmUwSAy4DBTER33EftQHfSwB5MxJ/AjkWKQLzL8E/cwBB6QH9LQDPDtO9ASNriQC5DQANAwCK21EFI91zHwCoL9kBqQcHBwcHKzUDowBvAQohPvU3fAQgHwCyAc8CKQMA5zMSezr7ULgFmDp/LzVQBgEGAi8FYQVgt8AFcTtlQhpCWEmfe5tmZ6IAExsDzQ8t+X8rBKtTAltbAn0jsy8Bl6utPWMDTR8Ei2kRANkDBrNHNysDBzECQWUAcwFpJ3kAiyUhAJ0BUb8AL3EfAbfNAz81KUsFWwF3YQZtAm0A+VEfAzEJDQBRSQCzAQBlAHsAM70GD/v3IZWHBwARKQAxALsjTwHZAeMPEzmXgIHwABIAGQA8AEUAQDt3gdvIEGcQZAkGTRFMdEIVEwK0D64L7REdDNkq09PgADSxB/MDWwfzA1sDWwfzB/MDWwfzA1sDWwNbA1scEvAi28gQZw9QBHUFlgWTBN4IiyZREYkHMAjaVBV0JhxPA00BBCMtSSQ7mzMTJUpMFE0LCAQ2SmyvfUADTzGzVP2QqgPTMlc5dAkGHnkSqAAyD3skNb1OhnpPcagKU0+2tYdJak5vAsY6sEAACikJm2/Dd1YGRRAfJ6kQ+ww3AbkBPw3xS9wE9QY/BM0fgRkdD9GVoAipLeEM8SbnLqWAXiP5KocF8Uv4POELUVFsD10LaQnnOmeBUgMlAREijwrhDT0IcRD3Cs1vDekRSQc9A9lJngCpBwULFR05FbkmFGKwCw05ewb/GvoLkyazEy17AAXXGiUGUQEtGwMA0y7rhbRaNVwgT2MGBwspI8sUrFAkDSlAu3hMGh8HGSWtApVDdEqLUToelyH6PEENai4XUYAH+TwJGVMLhTyiRq9FEhHWPpE9TCJNTDAEOYMsMyePCdMPiQy9fHYBXQklCbUMdRM1ERs3yQg9Bx0xlygnGQglRplgngT7owP3E9UDDwVDCUUHFwO5HDETMhUtBRGBKNsC9zbZLrcCk1aEARsFzw8pH+MQVEfkDu0InwJpA4cl7wAxFSUAGyKfCEdnAGOP3FMJLs8Iy2pwI3gDaxTrZRF3B5UOWwerHDcVwxzlcMxeD4YMKKezCV8BeQmdAWME5wgNNV+MpCBFZ1eLXBifIGVBQ14AAjUMaRWjRMGHfAKPD28SHwE5AXcHPQ0FAnsR8RFvEJkI74YINbkz/DopBFMhhyAVCisDU2zSCysm/Qz8bQGnEmYDEDRBd/Jnr2C6KBgBBx0yyUFkIfULlk/RDKAaxRhGVDIZ6AfDA/ca9yfuQVsGAwOnBxc6UTPyBMELbQiPCUMATQ6nGwfbGG4KdYzUATWPAbudA1uVhwJzkwY7Bw8Aaw+LBX3pACECqwinAAkA0wNbAD0CsQehAB0AiUUBQQMrMwEl6QKTA5cINc8BmTMB9y0EH8cMGQD7O25OAsO1AoBuZqYF4VwCkgJNOQFRKQQJUktVA7N15QDfAE8GF+NLARmvTs8e50cB43MvAMsA/wAJOQcJRQHRAfdxALsBYws1Caa3uQFR7S0AhwAZbwHbAo0A4QA5AIP1AVcAUQVd/QXXAlNNARU1HC9bZQG/AyMBNwERAH0Gz5GpzQsjBHEH1wIQHxXlAu8yB7kFAyLjE9FCyQK94lkAMhoKPAqrCqpgX2Q3CjV2PVQAEh+sPss/UgVVO1c7XDtXO1w7VztcO1c7XDtXO1wDm8Pmw+YKcF9JYe8Mqg3YRMw6TRPfYFVgNhPMLbsUxRXSJVoZQRrAJwkl6FUNDwgt12Y0CDA0eRfAAEMpbINFY4oeNApPHOtTlVT8LR8AtUumM7MNsBsZREQFS3XxYi4WEgomAmSFAmJGX1GzAV83JAKh+wJonAJmDQKfiDgfDwJmPwJmKgRyBIMDfxcDfpY5Cjl7GzmGOicnAmwhAjI6OA4CbcsCbbLzjgM3a0kvAWsA4gDlAE4JB5wMkQECD8YAEbkCdzMCdqZDAnlPRwJ4viFg30WyRvcCfEMCeswCfQ0CfPRIBEiBZygALxlJXEpfGRtK0ALRBQLQ0EsrA4hTA4fqRMmRNgLypV0HAwOyS9JMMSkH001QTbMCi0MCitzFHwshR2sJuwKOOwKOYESbhQKO3QKOYHxRuFM5AQ5S2FSJApP/ApMQAO0AIFUiVbNV1AosHymZijLleGpFPz0Cl6MC77ZYJawAXSkClpMCloCgAK1ZsFoNhVEAPwKWuQKWUlxIXNUCmc8CmWhczl0LHQKcnznGOqECnBoCn58CnryOACETNS4TAp31Ap6WALlBYThh8wKe1wKgcgGtAp6jIwKeUqljzGQrKS8CJ7MCJoICoP8CoFDbAqYzAqXSAqgDAIECp/ZogGi1AAdNaiBq1QKs5wKssgKtawKtBgJXIQJV4AKx5dsDH1JsmwKywRECsuwbbORtZ21MYwMl0QK2YD9DbpQDKUkCuGICuUsZArkue3A6cOUCvR0DLbYDMhUCvoxyBgMzdQK+HnMmc1MCw88CwwhzhnRPOUl05AM8qwEDPJ4DPcMCxYACxksCxhSNAshtVQLISALJUwLJMgJkoQLd1nh9ZXiyeSlL1AMYp2cGAmH4GfeVKHsPXpZevxUCz28Cz3AzT1fW9xejAMqxAs93AS3uA04Wfk8JAtwrAtuOAtJTA1JgA1NjAQUDVZCAjUMEzxrxZEl5A4LSg5EC2ssC2eKEFIRNp0ADhqkAMwNkEoZ1Xf0AWQLfaQLevHd7AuIz7RgB8zQrAfSfAfLWiwLr9wLpdH0DAur9AuroAP1LAb0C7o0C66CWrpcHAu5DA4XkmH1w5HGlAvMHAG0DjhqZlwL3FwORcgOSiwL3nAL53QL4apogmq+/O5siA52HAv7+AR8APZ8gAZ+3AwWRA6ZuA6bdANXJAwZuoYyiCQ0DDE0BEwEjB3EGZb1rCQC/BG/DFY8etxEAG3k9ACcDNxJRA42DAWcrJQCM8wAlAOanC6OVCLsGI6fJBgCvBRnDBvElRUYFFoAFcD9GSDNCKUK8X3kZX8QAls0FOgCQVCGbwTsuYDoZutcONxjOGJHJ/gVfBWAFXwVgBWsFYAVfBWAFXwVgBV8FYAVfBWBOHQjfjW8KCgoKbF7xMwTRA7kGN8PDAMMEr8MA70gxFroFTj5xPnhCR0K+X30/X/AAWBkzswCNBsxzzASm70aCRS4rDDMeLz49fnXfcsH5GcoscQFz13Y4HwVnBXLJycnACNdRYwgICAqEXoWTxgA7P4kACxbZBu21Kw0AjMsTAwkVAOVtJUUsJ1JCuULESUArXy9gPi9AKwnJRQYKTD9LPoA+iT54PnkCkULEUUpDX9NWV3JVEjQAc1w3A3IBE3YnX+g7QiMJb6MKaiszRCUuQrNCxDPMCcwEX9EWJzYREBEEBwIHKn6l33JCNVIfybPJtAltydPUCmhBZw/tEKsZAJOVJU1CLRuxbUHOQAo7P0s+eEJHHA8SJVRPdGM0NVrpvBoKhfUlM0JHHGUQUhEWO1xLSj8MO0ucNAqJIzVCRxv9EFsqKyA4OQgNj2nwZgp5ZNFgE2A1K3YHS2AhQQojJmC7DgpzGG1WYFUZCQYHZO9gHWCdYIVgu2BTYJlwFh8GvRbcXbG8YgtDHrMBwzPVyQonHQgkCyYBgQJ0Ajc4nVqIAwGSCsBPIgDsK3SWEtIVBa5N8gGjAo+kVwVIZwD/AEUSCDweX4ITrRQsJ8K3TwBXFDwEAB0TvzVcAtoTS20RIwDgVgZ9BBImYgA5AL4Coi8LFnezOkCnIQFjAY4KBAPh9RcGsgZSBsEAJctdsWIRu2kTkQstRw7DAcMBKgpPBGIGMDAwKCYnKTQaLg4AKRSVAFwCdl+YUZ0JdicFD3lPAdt1F9ZZKCGxuE3yBxkFVGcA/wBFEgiCBwAOLHQSjxOtQDg1z7deFRMAZ8QTAGtKb1ApIiPHADkAvgKiLy1DFtYCmBiDAlDDWNB0eo7fpaMO/aEVRRv0ATEQZBIODyMEAc8JQhCbDRgzFD4TAEMAu9YBCgCsAOkAm5I3ABwAYxvONnR+MhXJAxgKQyxL2+kkJhMbhQKDBMkSsvF0AD9BNQ6uQC7WqSQHwxEAEEIu1hkhAH2z4iQPwyJPHNWpdyYBRSpnJALzoBAEVPPsH20MxA0CCEQKRgAFyAtFAlMNwwjEDUQJRArELtapMg7DDZgJIw+TGukEIwvDFkMAqAtDEMMMBhioe+QAO3MMRAACrgnEBSPY9Q0FDnbSBoMAB8MSYxkSxAEJAPIJAAB8FWMOFtMc/HcXwxhDAC7DAvOowwAewwJdKDKHAAHDAALrFUQVwwAbwyvzpWMWv8wA/ABpAy++bcYDUKPD0KhDCwKmJ1MAAmMA5+UZwxAagwipBRL/eADfw6fDGOMCGsOjk3l6BwOpo4sAEsMOGxMAA5sAbcMOAAvDp0MJGkMDwgipnNIPAwfIqUMGAOGDAAPzABXDAAcDAAnDAGmTABrDAA7DChjDjnEWAwABYwAOcwAuUyYABsMAF8MIKQANUgC6wy4AA8MADqMq8wCyYgAcIwAB8wqpAAXOCx0V4wAHowBCwwEKAGnDAAuDAB3DAAjDCakABdIAbqcZ3QCZCCkABdIAAAFDAAfjAB2jCCkABqIACYMAGzMAbSMA5sOIAAhjAAhDABTDBAkpAAbSAOOTAAlDC6kOzPtnAAdDAG6kQFAATwAKwwwAA0MACbUDPwAHIwAZgwACE6cDAAojAApDAAoDp/MGwwAJIwADEwAQQwgAFEMAEXMAD5MADfMADcMAGRMOFiMAFUMAbqMWuwHDAMIAE0MLAGkzEgDhUwACQwAEWgAXgwUjAAbYABjDBSYBgzBaAEFNALcQBxUMegAwMngBrA0IZgJ0KxQHBREPd1N0ZzKRJwaIHAZqNT4DqQq8BwngAB4DAwt2AX56T1ocKQNXAh1GATQGC3tOxYNagkgAMQA5CQADAQEAWxLjAIOYNAEzAH7tFRk6TglSAF8NAAlYAQ+S1ACAQwQorQBiAN4dAJ1wPyeTANVzuQDX3AIeEMp9eyMgXiUAEdkBkJizKltbVVAaRMqRAAEAhyQ/SDEz6BmfVwB6ATEsOClKIRcDOF0E/832AFNt5AByAnkCRxGCOs94NjXdAwINGBonDBwPALW2AwICAgAAAAAAAAYDBQMDARrUAwAtAAAAAgEGBgYGBgYFBQUFBQUEBQYHCAkEBQUFBQQAAAICAAAAIgCNAJAAlT0A6gC7ANwApEQAwgCyAK0AqADuAKYA2gCjAOcBCAEDAMcAgQBiANIA1AEDAN4A8gCQAKkBMQDqAN8A3AsBCQ8yO9ra2tq8xuLT1tRJOB0BUgFcNU0BWgFpAWgBWwFMUUlLbhMBUxsNEAs6PhMOACcUKy0vMj5AQENDQ0RFFEYGJFdXV1dZWVhZL1pbXVxcI2NnZ2ZoZypsbnZ1eHh4eHh4enp6enp6enp6enp8fH18e2IARPIASQCaAHgAMgBm+ACOAFcAVwA3AnbvAIsABfj4AGQAk/IAnwBPAGIAZP//sACFAIUAaQBWALEAJAC2AIMCQAJDAPwA5wD+AP4A6AD/AOkA6QDoAOYALwJ7AVEBQAE+AVQBPgE+AT4BOQE4ATgBOAEcAVgXADEQCAEAUx8SHgsdHhYAjgCWAKYAUQBqIAIxAHYAbwCXAxUDJzIDIUlGTzEAkQJPAMcCVwKkAMAClgKWApYClgKWApYCiwKWApYClgKWApYClgKVApUCmAKgApcClgKWApQClAKUApQCkgKVAnUB1AKXAp8ClgKWApUeAIETBQD+DQOfAmECOh8BVBg9AuIZEjMbAU4/G1WZAXusRAFpYQEFA0FPAQYAmTEeIJdyADFoAHEANgCRA5zMk/C2jGINwjMWygIZCaXdfDILBCs5dAE7YnQBugDlhoiHhoiGiYqKhouOjIaNkI6Ij4qQipGGkoaThpSSlYaWhpeKmIaZhpqGm4aci52QnoqfhuIC4XTpAt90AIp0LHSoAIsAdHQEQwRABEIERQRDBEkERgRBBEcESQRIBEQERgRJAJ5udACrA490ALxuAQ10ANFZdHQA13QCFHQA/mJ0AP4BIQD+APwA/AD9APwDhGZ03ASMK23HAP4A/AD8AP0A/CR0dACRYnQA/gCRASEA/gCRAvQA/gCRA4RmdNwEjCttxyR0AP9idAEhAP4A/gD8APwA/QD8AP8A/AD8AP0A/AOEZnTcBIwrbcckdHQAkWJ0ASEA/gCRAP4AkQL0AP4AkQOEZnTcBIwrbcckdAJLAT50AlIBQXQCU8l0dAJfdHQDpgL0A6YDpgOnA6cDpwOnA4RmdNwEjCttxyR0dACRYnQBIQOmAJEDpgCRAvQDpgCRA4RmdNwEjCttxyR0BDh0AJEEOQCRDpU5dSgCADR03gV2CwArdAEFAM5iCnR0AF1iAAYcOgp0dACRCnQAXAEIwWZ0CnRmdHQAkWZ0CnRmdEXgAFF03gp0dEY0tlT2u3SOAQTwscwhjZZKrhYcBSfFp9XNbKiVDOD2b+cpe4/Z17mQnbtzzhaeQtE2GGj0IDNTjRUSyTxxw/RPHW/+vS7d1NfRt9z9QPZg4X7QFfhCnkvgNPIItOsC2eV6hPannZNHlZ9xrwZXIMOlu3jSoQSq78WEjwLjw1ELSlF1aBvfzwk5ZX7AUvQzjPQKbDuQ+sm4wNOp4A6AdVuRS0t1y/DZpg4R6m7FNjM9HgvW7Bi88zaMjOo6lM8wtBBdj8LP4ylv3zCXPhebMKJc066o9sF71oFW/8JXu86HJbwDID5lzw5GWLR/LhT0Qqnp2JQxNZNfcbLIzPy+YypqRm/lBmGmex+82+PisxUumSeJkALIT6rJezxMH+CTJmQtt5uwTVbL3ptmjDUQzlSIvWi8Tl7ng1NpuRn1Ng4n14Qc+3Iil7OwkvNWogLSPkn3pihIFytyIGmMhOe3n1tWsuMy9BdKyqF4Z3v2SgggTL9KVvMXPnCbRe+oOuFFP3HejBG/w9gvmfNYvg6JuWia2lcSSN1uIjBktzoIazOHPJZ7kKHPz8mRWVdW3lA8WGF9dQF6Bm673boov3BUWDU2JNcahR23GtfHKLOz/viZ+rYnZFaIznXO67CYEJ1fXuTRpZhYZkKe54xeoagkNGLs+NTZHE0rX45/XvQ2RGADX6vcAvdxIUBV27wxGm2zjZo4X3ILgAlrOFheuZ6wtsvaIj4yLY7qqawlliaIcrz2G+c3vscAnCkCuMzMmZvMfu9lLwTvfX+3cVSyPdN9ZwgDZhfjRgNJcLiJ67b9xx8JHswprbiE3v9UphotAPIgnXVIN5KmMc0piXhc6cChPnN+MRhG9adtdttQTTwSIpl8I4/j//d3sz1326qTBTpPRM/Hgh3kzqEXs8ZAk4ErQhNO8hzrQ0DLkWMA/N+91tn2MdOJnWC2FCZehkQrwzwbKOjhvZsbM95QoeL9skYyMf4srVPVJSgg7pOLUtr/n9eT99oe9nLtFRpjA9okV2Kj8h9k5HaC0oivRD8VyXkJ81tcd4fHNXPCfloIQasxsuO18/46dR2jgul/UIet2G0kRvnyONMKhHs6J26FEoqSqd+rfYjeEGwHWVDpX1fh1jBBcKGMqRepju9Y00mDVHC+Xdij/j44rKfvfjGinNs1jO/0F3jB83XCDINN/HB84axlP+3E/klktRo+vl3U/aiyMJbIodE1XSsDn6UAzIoMtUObY2+k/4gY/l+AkZJ5Sj2vQrkyLm3FoxjhDX+31UXBFf9XrAH31fFqoBmDEZvhvvpnZ87N+oZEu7U9O/nnk+QWj3x8uyoRbEnf+O5UMr9i0nHP38IF5AvzrBW8YWBUR0mIAzIvndQq9N3v/Jto3aPjPXUPl8ASdPPyAp7jENf8bk7VMM9ol9XGmlBmeDMuGqt+WzuL6CXAxXjIhCPM5vACchgMJ/8XBGLO/D1isVvGhwwHHr1DLaI5mn2Jr/b1pUD90uciDaS8cXNDzCWvNmT/PhQe5e8nTnnnkt8Ds/SIjibcum/fqDhKopxAY8AkSrPn+IGDEKOO+U3XOP6djFs2H5N9+orhOahiQk5KnEUWa+CzkVzhp8bMHRbg81qhjjXuIKbHjSLSIBKWqockGtKinY+z4/RdBUF6pcc3JmnlxVcNgrI4SEzKUZSwcD2QCyxzKve+gAmg6ZuSRkpPFa6mfThu7LJNu3H5K42uCpNvPAsoedolKV/LHe/eJ+BbaG5MG0NaSGVPRUmNFMFFSSpXEcXwbVh7UETOZZtoVNRGOIbbkig3McEtR68cG0RZAoJevWYo7Dg/lZ1CQzblWeUvVHmr8fY4Nqd9JJiH/zEX24mJviH60fAyFr0A3c4bC1j3yZU60VgJxXn8JgJXLUIsiBnmKmMYz+7yBQFBvqb2eYnuW59joZBf56/wXvWIR4R8wTmV80i1mZy+S4+BUES+hzjk0uXpC///z/IlqHZ1monzlXp8aCfhGKMti73FI1KbL1q6IKO4fuBuZ59gagjn5xU79muMpHXg6S+e+gDM/U9BKLHbl9l6o8czQKl4RUkJJiqftQG2i3BMg/TQlUYFkJDYBOOvAugYuzYSDnZbDDd/aSd9x0Oe6F+bJcHfl9+gp6L5/TgA+BdFFovbfCrQ40s5vMPw8866pNX8zyFGeFWdxIpPVp9Rg1UPOVFbFZrvaFq/YAzHQgqMWpahMYfqHpmwXfHL1/kpYmGuHFwT55mQu0dylfNuq2Oq0hTMCPwqfxnuBIPLXfci4Y1ANy+1CUipQxld/izVh16WyG2Q0CQQ9NqtAnx1HCHwDj7sYxOSB0wopZSnOzxQOcExmxrVTF2BkOthVpGfuhaGECfCJpJKpjnihY+xOT2QJxN61+9K6QSqtv2Shr82I3jgJrqBg0wELFZPjvHpvzTtaJnLK6Vb97Yn933koO/saN7fsjwNKzp4l2lJVx2orjCGzC/4ZL4zCver6aQYtC5sdoychuFE6ufOiog+VWi5UDkbmvmtah/3aArEBIi39s5ILUnlFLgilcGuz9CQshEY7fw2ouoILAYPVT/gyAIq3TFAIwVsl+ktkRz/qGfnCDGrm5gsl/l9QdvCWGsjPz3dU7XuqKfdUrr/6XIgjp4rey6AJBmCmUJMjITHVdFb5m1p+dLMCL8t55zD42cmftmLEJC0Da04YiRCVUBLLa8D071/N5UBNBXDh0LFsmhV/5B5ExOB4j3WVG/S3lfK5o+V6ELHvy6RR9n4ac+VsK4VE4yphPvV+kG9FegTBH4ZRXL2HytUHCduJazB/KykjfetYxOXTLws267aGOd+I+JhKP//+VnXmS90OD/jvLcVu0asyqcuYN1mSb6XTlCkqv1vigZPIYwNF/zpWcT1GR/6aEIRjkh0yhg4LXJfaGobYJTY4JI58KiAKgmmgAKWdl5nYCeLqavRJGQNuYuZtZFGx+IkI4w4NS2xwbetNMunOjBu/hmKCI/w7tfiiyUd//4rbTeWt4izBY8YvGIN6vyKYmP/8X8wHKCeN+WRcKM70+tXKNGyevU9H2Dg5BsljnTf8YbsJ1TmMs74Ce2XlHisleguhyeg44rQOHZuw/6HTkhnnurK2d62q6yS7210SsAIaR+jXMQA+svkrLpsUY+F30Uw89uOdGAR6vo4FIME0EfVVeHTu6eKicfhSqOeXJhbftcd08sWEnNUL1C9fnprTgd83IMut8onVUF0hvqzZfHduPjbjwEXIcoYmy+P6tcJZHmeOv6VrvEdkHDJecjHuHeWANe79VG662qTjA/HCvumVv3qL+LrOcpqGps2ZGwQdFJ7PU4iuyRlBrwfO+xnPyr47s2cXVbWzAyznDiBGjCM3ksxjjqM62GE9C8f5U38kB3VjtabKp/nRdvMESPGDG90bWRLAt1Qk5DyLuazRR1YzdC1c+hZXvAWV8xA72S4A8B67vjVhbba3MMop293FeEXpe7zItMWrJG/LOH9ByOXmYnNJfjmfuX9KbrpgLOba4nZ+fl8Gbdv/ihv+6wFGKHCYrVwmhFC0J3V2bn2tIB1wCc1CST3d3X2OyxhguXcs4sm679UngzofuSeBewMFJboIQHbUh/m2JhW2hG9DIvG2t7yZIzKBTz9wBtnNC+2pCRYhSIuQ1j8xsz5VvqnyUIthvuoyyu7fNIrg/KQUVmGQaqkqZk/Vx5b33/gsEs8yX7SC1J+NV4icz6bvIE7C5G6McBaI8rVg56q5QBJWxn/87Q1sPK4+sQa8fLU5gXo4paaq4cOcQ4wR0VBHPGjKh+UlPCbA1nLXyEUX45qZ8J7/Ln4FPJE2TdzD0Z8MLSNQiykMMmSyOCiFfy84Rq60emYB2vD09KjYwsoIpeDcBDTElBbXxND72yhd9pC/1CMid/5HUMvAL27OtcIJDzNKpRPNqPOpyt2aPGz9QWIs9hQ9LiX5s8m9hjTUu/f7MyIatjjd+tSfQ3ufZxPpmJhTaBtZtKLUcfOCUqADuO+QoH8B9v6U+P0HV1GLQmtoNFTb3s74ivZgjES0qfK+8RdGgBbcCMSy8eBvh98+et1KIFqSe1KQPyXULBMTsIYnysIwiZBJYdI20vseV+wuJkcqGemehKjaAb9L57xZm3g2zX0bZ2xk/fU+bCo7TlnbW7JuF1YdURo/2Gw7VclDG1W7LOtas2LX4upifZ/23rzpsnY/ALfRgrcWP5hYmV9VxVOQA1fZvp9F2UNU+7d7xRyVm5wiLp3/0dlV7vdw1PMiZrbDAYzIVqEjRY2YU03sJhPnlwIPcZUG5ltL6S8XCxU1eYS5cjr34veBmXAvy7yN4ZjArIG0dfD/5UpBNlX1ZPoxJOwyqRi3wQWtOzd4oNKh0LkoTm8cwqgIfKhqqGOhwo71I+zXnMemTv2B2AUzABWyFztGgGULjDDzWYwJUVBTjKCn5K2QGMK1CQT7SzziOjo+BhAmqBjzuc3xYym2eedGeOIRJVyTwDw37iCMe4g5Vbnsb5ZBdxOAnMT7HU4DHpxWGuQ7GeiY30Cpbvzss55+5Km1YsbD5ea3NI9QNYIXol5apgSu9dZ8f8xS5dtHpido5BclDuLWY4lhik0tbJa07yJhH0BOyEut/GRbYTS6RfiTYWGMCkNpfSHi7HvdiTglEVHKZXaVhezH4kkXiIvKopYAlPusftpE4a5IZwvw1x/eLvoDIh/zpo9FiQInsTb2SAkKHV42XYBjpJDg4374XiVb3ws4qM0s9eSQ5HzsMU4OZJKuopFjBM+dAZEl8RUMx5uU2N486Kr141tVsGQfGjORYMCJAMsxELeNT4RmWjRcpdTGBwcx6XN9drWqPmJzcrGrH4+DRc7+n1w3kPZwu0BkNr6hQrqgo7JTB9A5kdJ/H7P4cWBMwsmuixAzJB3yrQpnGIq90lxAXLzDCdn1LPibsRt7rHNjgQBklRgPZ8vTbjXdgXrTWQsK5MdrXXQVPp0Rinq3frzZKJ0qD6Qhc40VzAraUXlob1gvkhK3vpmHgI6FRlQZNx6eRqkp0zy4AQlX813fAPtL3jMRaitGFFjo0zmErloC+h+YYdVQ6k4F/epxAoF0BmqEoKNTt6j4vQZNQ2BoqF9Vj53TOIoNmDiu9Xp15RkIgQIGcoLpfoIbenzpGUAtqFJp5W+LLnx38jHeECTJ/navKY1NWfN0sY1T8/pB8kIH3DU3DX+u6W3YwpypBMYOhbSxGjq84RZ84fWJow8pyHqn4S/9J15EcCMsXqrfwyd9mhiu3+rEo9pPpoJkdZqHjra4NvzFwuThNKy6hao/SlLw3ZADUcUp3w3SRVfW2rhl80zOgTYnKE0Hs2qp1J6H3xqPqIkvUDRMFDYyRbsFI3M9MEyovPk8rlw7/0a81cDVLmBsR2ze2pBuKb23fbeZC0uXoIvDppfTwIDxk1Oq2dGesGc+oJXWJLGkOha3CX+DUnzgAp9HGH9RsPZN63Hn4RMA5eSVhPHO+9RcRb/IOgtW31V1Q5IPGtoxPjC+MEJbVlIMYADd9aHYWUIQKopuPOHmoqSkubnAKnzgKHqgIOfW5RdAgotN6BN+O2ZYHkuemLnvQ8U9THVrS1RtLmKbcC7PeeDsYznvqzeg6VCNwmr0Yyx1wnLjyT84BZz3EJyCptD3yeueAyDWIs0L2qs/VQ3HUyqfrja0V1LdDzqAikeWuV4sc7RLIB69jEIBjCkyZedoUHqCrOvShVzyd73OdrJW0hPOuQv2qOoHDc9xVb6Yu6uq3Xqp2ZaH46A7lzevbxQEmfrzvAYSJuZ4WDk1Hz3QX1LVdiUK0EvlAGAYlG3Md30r7dcPN63yqBCIj25prpvZP0nI4+EgWoFG95V596CurXpKRBGRjQlHCvy5Ib/iW8nZJWwrET3mgd6mEhfP4KCuaLjopWs7h+MdXFdIv8dHQJgg1xi1eYqB0uDYjxwVmri0Sv5XKut/onqapC+FQiC2C1lvYJ9MVco6yDYsS3AANUfMtvtbYI2hfwZatiSsnoUeMZd34GVjkMMKA+XnjJpXgRW2SHTZplVowPmJsvXy6w3cfO1AK2dvtZEKTkC/TY9LFiKHCG0DnrMQdGm2lzlBHM9iEYynH2UcVMhUEjsc0oDBTgo2ZSQ1gzkAHeWeBXYFjYLuuf8yzTCy7/RFR81WDjXMbq2BOH5dURnxo6oivmxL3cKzKInlZkD31nvpHB9Kk7GfcfE1t+1V64b9LtgeJGlpRFxQCAqWJ5DoY77ski8gsOEOr2uywZaoO/NGa0X0y1pNQHBi3b2SUGNpcZxDT7rLbBf1FSnQ8guxGW3W+36BW0gBje4DOz6Ba6SVk0xiKgt+q2JOFyr4SYfnu+Ic1QZYIuwHBrgzr6UvOcSCzPTOo7D6IC4ISeS7zkl4h+2VoeHpnG/uWR3+ysNgPcOIXQbv0n4mr3BwQcdKJxgPSeyuP/z1Jjg4e9nUvoXegqQVIE30EHx5GHv+FAVUNTowYDJgyFhf5IvlYmEqRif6+WN1MkEJmDcQITx9FX23a4mxy1AQRsOHO/+eImX9l8EMJI3oPWzVXxSOeHU1dUWYr2uAA7AMb+vAEZSbU3qob9ibCyXeypEMpZ6863o6QPqlqGHZkuWABSTVNd4cOh9hv3qEpSx2Zy/DJMP6cItEmiBJ5PFqQnDEIt3NrA3COlOSgz43D7gpNFNJ5MBh4oFzhDPiglC2ypsNU4ISywY2erkyb1NC3Qh/IfWj0eDgZI4/ln8WPfBsT3meTjq1Uqt1E7Zl/qftqkx6aM9KueMCekSnMrcHj1CqTWWzEzPsZGcDe3Ue4Ws+XFYVxNbOFF8ezkvQGR6ZOtOLU2lQEnMBStx47vE6Pb7AYMBRj2OOfZXfisjJnpTfSNjo6sZ6qSvNxZNmDeS7Gk3yYyCk1HtKN2UnhMIjOXUzAqDv90lx9O/q/AT1ZMnit5XQe9wmQxnE/WSH0CqZ9/2Hy+Sfmpeg8RwsHI5Z8kC8H293m/LHVVM/BA7HaTJYg5Enk7M/xWpq0192ACfBai2LA/qrCjCr6Dh1BIMzMXINBmX96MJ5Hn2nxln/RXPFhwHxUmSV0EV2V0jm86/dxxuYSU1W7sVkEbN9EzkG0QFwPhyHKyb3t+Fj5WoUUTErcazE/N6EW6Lvp0d//SDPj7EV9UdJN+Amnf3Wwk3A0SlJ9Z00yvXZ7n3z70G47Hfsow8Wq1JXcfwnA+Yxa5mFsgV464KKP4T31wqIgzFPd3eCe3j5ory5fBF2hgCFyVFrLzI9eetNXvM7oQqyFgDo4CTp/hDV9NMX9JDHQ/nyHTLvZLNLF6ftn2OxjGm8+PqOwhxnPHWipkE/8wbtyri80Sr7pMNkQGMfo4ZYK9OcCC4ESVFFbLMIvlxSoRqWie0wxqnLfcLSXMSpMMQEJYDVObYsXIQNv4TGNwjq1kvT1UOkicTrG3IaBZ3XdScS3u8sgeZPVpOLkbiF940FjbCeNRINNvDbd01EPBrTCPpm12m43ze1bBB59Ia6Ovhnur/Nvx3IxwSWol+3H2qfCJR8df6aQf4v6WiONxkK+IqT4pKQrZK/LplgDI/PJZbOep8dtbV7oCr6CgfpWa8NczOkPx81iSHbsNhVSJBOtrLIMrL31LK9TqHqAbAHe0RLmmV806kRLDLNEhUEJfm9u0sxpkL93Zgd6rw+tqBfTMi59xqXHLXSHwSbSBl0EK0+loECOPtrl+/nsaFe197di4yUgoe4jKoAJDXc6DGDjrQOoFDWZJ9HXwt8xDrQP+7aRwWKWI1GF8s8O4KzxWBBcwnl3vnl1Oez3oh6Ea1vjR7/z7DDTrFtqU2W/KAEzAuXDNZ7MY73MF216dzdSbWmUp4lcm7keJfWaMHgut9x5C9mj66Z0lJ+yhsjVvyiWrfk1lzPOTdhG15Y7gQlXtacvI7qv/XNSscDwqkgwHT/gUsD5yB7LdRRvJxQGYINn9hTpodKFVSTPrtGvyQw+HlRFXIkodErAGu9Iy1YpfSPc3jkFh5CX3lPxv7aqjE/JAfTIpEjGb/H7MO0e2vsViSW1qa/Lmi4/n4DEI3g7lYrcanspDfEpKkdV1OjSLOy0BCUqVoECaB55vs06rXl4jqmLsPsFM/7vYJ0vrBhDCm/00A/H81l1uekJ/6Lml3Hb9+NKiLqATJmDpyzfYZFHumEjC662L0Bwkxi7E9U4cQA0XMVDuMYAIeLMPgQaMVOd8fmt5SflFIfuBoszeAw7ow5gXPE2Y/yBc/7jExARUf/BxIHQBF5Sn3i61w4z5xJdCyO1F1X3+3ax+JSvMeZ7S6QSKp1Fp/sjYz6Z+VgCZzibGeEoujryfMulH7Rai5kAft9ebcW50DyJr2uo2z97mTWIu45YsSnNSMrrNUuG1XsYBtD9TDYzQffKB87vWbkM4EbPAFgoBV4GQS+vtFDUqOFAoi1nTtmIOvg38N4hT2Sn8r8clmBCXspBlMBYTnrqFJGBT3wZOzAyJDre9dHH7+x7qaaKDOB4UQALD5ecS0DE4obubQEiuJZ0EpBVpLuYcce8Aa4PYd/V4DLDAJBYKQPCWTcrEaZ5HYbJi11Gd6hjGom1ii18VHYnG28NKpkz2UKVPxlhYSp8uZr367iOmoy7zsxehW9wzcy2zG0a80PBMCRQMb32hnaHeOR8fnNDzZhaNYhkOdDsBUZ3loDMa1YP0uS0cjUP3b/6DBlqmZOeNABDsLl5BI5QJups8uxAuWJdkUB/pO6Zax6tsg7fN5mjjDgMGngO+DPcKqiHIDbFIGudxtPTIyDi9SFMKBDcfdGQRv41q1AqmxgkVfJMnP8w/Bc7N9/TR6C7mGObFqFkIEom8sKi2xYqJLTCHK7cxzaZvqODo22c3wisBCP4HeAgcRbNPAsBkNRhSmD48dHupdBRw4mIvtS5oeF6zeT1KMCyhMnmhpkFAGWnGscoNkwvQ8ZM5lE/vgTHFYL99OuNxdFBxTEDd5v2qLR8y9WkXsWgG6kZNndFG+pO/UAkOCipqIhL3hq7cRSdrCq7YhUsTocEcnaFa6nVkhnSeRYUA1YO0z5itF9Sly3VlxYDw239TJJH6f3EUfYO5lb7bcFcz8Bp7Oo8QmnsUHOz/fagVUBtKEw1iT88j+aKkv8cscKNkMxjYr8344D1kFoZ7/td1W6LCNYN594301tUGRmFjAzeRg5vyoM1F6+bJZ/Q54jN/k8SFd3DxPTYaAUsivsBfgTn7Mx8H2SpPt4GOdYRnEJOH6jHM2p6SgB0gzIRq6fHxGMmSmqaPCmlfwxiuloaVIitLGN8wie2CDWhkzLoCJcODh7KIOAqbHEvXdUxaS4TTTs07Clzj/6GmVs9kiZDerMxEnhUB6QQPlcfqkG9882RqHoLiHGBoHfQuXIsAG8GTAtao2KVwRnvvam8jo1e312GQAKWEa4sUVEAMG4G6ckcONDwRcg1e2D3+ohXgY4UAWF8wHKQMrSnzCgfFpsxh+aHXMGtPQroQasRY4U6UdG0rz1Vjbka0MekOGRZQEvqQFlxseFor8zWFgHek3v29+WqN6gaK5gZOTOMZzpQIC1201LkMCXild3vWXSc5UX9xcFYfbRPzGFa1FDcPfPB/jUEq/FeGt419CI3YmBlVoHsa4KdcwQP5ZSwHHhFJ7/Ph/Rap/4vmG91eDwPP0lDfCDRCLszTqfzM71xpmiKi2HwS4WlqvGNwtvwF5Dqpn6KTq8ax00UMPkxDcZrEEEsIvHiUXXEphdb4GB4FymlPwBz4Gperqq5pW7TQ6/yNRhW8VT5NhuP0udlxo4gILq5ZxAZk8ZGh3g4CqxJlPKY7AQxupfUcVpWT5VItp1+30UqoyP4wWsRo3olRRgkWZZ2ZN6VC3OZFeXB8NbnUrSdikNptD1QiGuKkr8EmSR/AK9Rw+FF3s5uwuPbvHGiPeFOViltMK7AUaOsq9+x9cndk3iJEE5LKZRlWJbKOZweROzmPNVPkjE3K/TyA57Rs68TkZ3MR8akKpm7cFjnjPd/DdkWjgYoKHSr5Wu5ssoBYU4acRs5g2DHxUmdq8VXOXRbunD8QN0LhgkssgahcdoYsNvuXGUK/KXD/7oFb+VGdhqIn02veuM5bLudJOc2Ky0GMaG4W/xWBxIJcL7yliJOXOpx0AkBqUgzlDczmLT4iILXDxxtRR1oZa2JWFgiAb43obrJnG/TZC2KSK2wqOzRZTXavZZFMb1f3bXvVaNaK828w9TO610gk8JNf3gMfETzXXsbcvRGCG9JWQZ6+cDPqc4466Yo2RcKH+PILeKOqtnlbInR3MmBeGG3FH10yzkybuqEC2HSQwpA0An7d9+73BkDUTm30bZmoP/RGbgFN+GrCOfADgqr0WbI1a1okpFms8iHYw9hm0zUvlEMivBRxModrbJJ+9/p3jUdQQ9BCtQdxnOGrT5dzRUmw0593/mbRSdBg0nRvRZM5/E16m7ZHmDEtWhwvfdZCZ8J8M12W0yRMszXamWfQTwIZ4ayYktrnscQuWr8idp3PjT2eF/jmtdhIfcpMnb+IfZY2FebW6UY/AK3jP4u3Tu4zE4qlnQgLFbM19EBIsNf7KhjdbqQ/D6yiDb+NlEi2SKD+ivXVUK8ib0oBo366gXkR8ZxGjpJIDcEgZPa9TcYe0TIbiPl/rPUQDu3XBJ9X/GNq3FAUsKsll57DzaGMrjcT+gctp+9MLYXCq+sqP81eVQ0r9lt+gcQfZbACRbEjvlMskztZG8gbC8Qn9tt26Q7y7nDrbZq/LEz7kR6Jc6pg3N9rVX8Y5MJrGlML9p9lU4jbTkKqCveeZUJjHB03m2KRKR2TytoFkTXOLg7keU1s1lrPMQJpoOKLuAAC+y1HlJucU6ysB5hsXhvSPPLq5J7JtnqHKZ4vYjC4Vy8153QY+6780xDuGARsGbOs1WqzH0QS765rnSKEbbKlkO8oI/VDwUd0is13tKpqILu1mDJFNy/iJAWcvDgjxvusIT+PGz3ST/J9r9Mtfd0jpaGeiLYIqXc7DiHSS8TcjFVksi66PEkxW1z6ujbLLUGNNYnzOWpH8BZGK4bCK7iR+MbIv8ncDAz1u4StN3vTTzewr9IQjk9wxFxn+6N1ddKs0vffJiS08N3a4G1SVrlZ97Q/M+8G9fe5AP6d9/Qq4WRnORVhofPIKEdCr3llspUfE0oKIIYoByBRPh+bX1HLS3JWGJRhIvE1aW4NTd8ePi4Z+kXb+Z8snYfSNcqijhAgVsx4RCM54cXUiYkjeBmmC4ajOHrChoELscJJC7+9jjMjw5BagZKlgRMiSNYz7h7vvZIoQqbtQmspc0cUk1G/73iXtSpROl5wtLgQi0mW2Ex8i3WULhcggx6E1LMVHUsdc9GHI1PH3U2Ko0PyGdn9KdVOLm7FPBui0i9a0HpA60MsewVE4z8CAt5d401Gv6zXlIT5Ybit1VIA0FCs7wtvYreru1fUyW3oLAZ/+aTnZrOcYRNVA8spoRtlRoWflsRClFcgzkqiHOrf0/SVw+EpVaFlJ0g4Kxq1MMOmiQdpMNpte8lMMQqm6cIFXlnGbfJllysKDi+0JJMotkqgIxOSQgU9dn/lWkeVf8nUm3iwX2Nl3WDw9i6AUK3vBAbZZrcJpDQ/N64AVwjT07Jef30GSSmtNu2WlW7YoyW2FlWfZFQUwk867EdLYKk9VG6JgEnBiBxkY7LMo4YLQJJlAo9l/oTvJkSARDF/XtyAzM8O2t3eT/iXa6wDN3WewNmQHdPfsxChU/KtLG2Mn8i4ZqKdSlIaBZadxJmRzVS/o4yA65RTSViq60oa395Lqw0pzY4SipwE0SXXsKV+GZraGSkr/RW08wPRvqvSUkYBMA9lPx4m24az+IHmCbXA+0faxTRE9wuGeO06DIXa6QlKJ3puIyiuAVfPr736vzo2pBirS+Vxel3TMm3JKhz9o2ZoRvaFVpIkykb0Hcm4oHFBMcNSNj7/4GJt43ogonY2Vg4nsDQIWxAcorpXACzgBqQPjYsE/VUpXpwNManEru4NwMCFPkXvMoqvoeLN3qyu/N1eWEHttMD65v19l/0kH2mR35iv/FI+yjoHJ9gPMz67af3Mq/BoWXqu3rphiWMXVkmnPSEkpGpUI2h1MThideGFEOK6YZHPwYzMBvpNC7+ZHxPb7epfefGyIB4JzO9DTNEYnDLVVHdQyvOEVefrk6Uv5kTQYVYWWdqrdcIl7yljwwIWdfQ/y+2QB3eR/qxYObuYyB4gTbo2in4PzarU1sO9nETkmj9/AoxDA+JM3GMqQtJR4jtduHtnoCLxd1gQUscHRB/MoRYIEsP2pDZ9KvHgtlk1iTbWWbHhohwFEYX7y51fUV2nuUmnoUcqnWIQAAgl9LTVX+Bc0QGNEhChxHR4YjfE51PUdGfsSFE6ck7BL3/hTf9jLq4G1IafINxOLKeAtO7quulYvH5YOBc+zX7CrMgWnW47/jfRsWnJjYYoE7xMfWV2HN2iyIqLI";
const MI = new Map([[8217, "apostrophe"], [8260, "fraction slash"], [12539, "middle dot"]])
  , BI = 4;
function Vee(n) {
    let e = 0;
    function t() {
        return n[e++] << 8 | n[e++]
    }
    let r = t()
      , s = 1
      , i = [0, 1];
    for (let k = 1; k < r; k++)
        i.push(s += t());
    let o = t()
      , a = e;
    e += o;
    let l = 0
      , u = 0;
    function d() {
        return l == 0 && (u = u << 8 | n[e++],
        l = 8),
        u >> --l & 1
    }
    const h = 31
      , p = 2 ** h
      , g = p >>> 1
      , w = g >> 1
      , b = p - 1;
    let v = 0;
    for (let k = 0; k < h; k++)
        v = v << 1 | d();
    let S = []
      , N = 0
      , _ = p;
    for (; ; ) {
        let k = Math.floor(((v - N + 1) * s - 1) / _)
          , B = 0
          , P = r;
        for (; P - B > 1; ) {
            let L = B + P >>> 1;
            k < i[L] ? P = L : B = L
        }
        if (B == 0)
            break;
        S.push(B);
        let M = N + Math.floor(_ * i[B] / s)
          , R = N + Math.floor(_ * i[B + 1] / s) - 1;
        for (; ((M ^ R) & g) == 0; )
            v = v << 1 & b | d(),
            M = M << 1 & b,
            R = R << 1 & b | 1;
        for (; M & ~R & w; )
            v = v & g | v << 1 & b >>> 1 | d(),
            M = M << 1 ^ g,
            R = (R ^ g) << 1 | g | 1;
        N = M,
        _ = 1 + R - M
    }
    let I = r - 4;
    return S.map(k => {
        switch (k - I) {
        case 3:
            return I + 65792 + (n[a++] << 16 | n[a++] << 8 | n[a++]);
        case 2:
            return I + 256 + (n[a++] << 8 | n[a++]);
        case 1:
            return I + n[a++];
        default:
            return k - 1
        }
    }
    )
}
function qee(n) {
    let e = 0;
    return () => n[e++]
}
function pF(n) {
    return qee(Vee(Gee(n)))
}
function Gee(n) {
    let e = [];
    [..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"].forEach( (s, i) => e[s.charCodeAt(0)] = i);
    let t = n.length
      , r = new Uint8Array(6 * t >> 3);
    for (let s = 0, i = 0, o = 0, a = 0; s < t; s++)
        a = a << 6 | e[n.charCodeAt(s)],
        o += 6,
        o >= 8 && (r[i++] = a >> (o -= 8));
    return r
}
function Wee(n) {
    return n & 1 ? ~n >> 1 : n >> 1
}
function Yee(n, e) {
    let t = Array(n);
    for (let r = 0, s = 0; r < n; r++)
        t[r] = s += Wee(e());
    return t
}
function qg(n, e=0) {
    let t = [];
    for (; ; ) {
        let r = n()
          , s = n();
        if (!s)
            break;
        e += r;
        for (let i = 0; i < s; i++)
            t.push(e + i);
        e += s + 1
    }
    return t
}
function mF(n) {
    return Gg( () => {
        let e = qg(n);
        if (e.length)
            return e
    }
    )
}
function gF(n) {
    let e = [];
    for (; ; ) {
        let t = n();
        if (t == 0)
            break;
        e.push(Kee(t, n))
    }
    for (; ; ) {
        let t = n() - 1;
        if (t < 0)
            break;
        e.push(Xee(t, n))
    }
    return e.flat()
}
function Gg(n) {
    let e = [];
    for (; ; ) {
        let t = n(e.length);
        if (!t)
            break;
        e.push(t)
    }
    return e
}
function yF(n, e, t) {
    let r = Array(n).fill().map( () => []);
    for (let s = 0; s < e; s++)
        Yee(n, t).forEach( (i, o) => r[o].push(i));
    return r
}
function Kee(n, e) {
    let t = 1 + e()
      , r = e()
      , s = Gg(e);
    return yF(s.length, 1 + n, e).flatMap( (o, a) => {
        let[l,...u] = o;
        return Array(s[a]).fill().map( (d, h) => {
            let p = h * r;
            return [l + h * t, u.map(g => g + p)]
        }
        )
    }
    )
}
function Xee(n, e) {
    let t = 1 + e();
    return yF(t, 1 + n, e).map(s => [s[0], s.slice(1)])
}
function Qee(n) {
    let e = []
      , t = qg(n);
    return s(r([]), []),
    e;
    function r(i) {
        let o = n()
          , a = Gg( () => {
            let l = qg(n).map(u => t[u]);
            if (l.length)
                return r(l)
        }
        );
        return {
            S: o,
            B: a,
            Q: i
        }
    }
    function s({S: i, B: o}, a, l) {
        if (!(i & 4 && l === a[a.length - 1])) {
            i & 2 && (l = a[a.length - 1]),
            i & 1 && e.push(a);
            for (let u of o)
                for (let d of u.Q)
                    s(u, [...a, d], l)
        }
    }
}
function Zee(n) {
    return n.toString(16).toUpperCase().padStart(2, "0")
}
function bF(n) {
    return `{${Zee(n)}}`
}
function Jee(n) {
    let e = [];
    for (let t = 0, r = n.length; t < r; ) {
        let s = n.codePointAt(t);
        t += s < 65536 ? 1 : 2,
        e.push(s)
    }
    return e
}
function Kp(n) {
    let t = n.length;
    if (t < 4096)
        return String.fromCodePoint(...n);
    let r = [];
    for (let s = 0; s < t; )
        r.push(String.fromCodePoint(...n.slice(s, s += 4096)));
    return r.join("")
}
function ete(n, e) {
    let t = n.length
      , r = t - e.length;
    for (let s = 0; r == 0 && s < t; s++)
        r = n[s] - e[s];
    return r
}
var tte = "AEUDTAHBCFQATQDRADAAcgAgADQAFAAsABQAHwAOACQADQARAAoAFwAHABIACAAPAAUACwAFAAwABAAQAAMABwAEAAoABQAIAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACgANAA0AAwAKAAkABAAdAAYAZwDSAdsDJgC0CkMB8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgsj26PTQyy8FfEQ8AY8IPAGcEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiACnwRZEkkVsS7tANAsBG0RuAQLEPABv9HICTUBXigPZwRBApMDOwAamhtaABqEAY8KvKx3LQ4ArAB8UhwEBAVSagD8AEFZADkBIadVj2UMUgx5Il4ANQC9AxIB1BlbEPMAs30CGxlXAhwZKQIECBc6EbsCoxngzv7UzRQA8M0BawL6ZwkN7wABAD33OQRcsgLJCjMCjqUChtw/km+NAsXPAoP2BT84PwURAK0RAvptb6cApQS/OMMey5HJS84UdxpxTPkCogVFITaTOwERAK5pAvkNBOVyA7q3BKlOJSALAgUIBRcEdASpBXqzABXFSWZOawLCOqw//AolCZdvv3dSBkEQGyelEPcMMwG1ATsN7UvYBPEGOwTJH30ZGQ/NlZwIpS3dDO0m4y6hgFoj9SqDBe1L9DzdC01RaA9ZC2UJ4zpjgU4DIQENIosK3Q05CG0Q8wrJaw3lEUUHOQPVSZoApQcBCxEdNRW1JhBirAsJOXcG+xr2C48mrxMpevwF0xohBk0BKRr/AM8u54WwWjFcHE9fBgMLJSPHFKhQIA0lQLd4SBobBxUlqQKRQ3BKh1E2HpMh9jw9DWYuE1F8B/U8BRlPC4E8nkarRQ4R0j6NPUgiSUwsBDV/LC8niwnPD4UMuXxyAVkJIQmxDHETMREXN8UIOQcZLZckJxUIIUaVYJoE958D8xPRAwsFPwlBBxMDtRwtEy4VKQUNgSTXAvM21S6zAo9WgAEXBcsPJR/fEFBH4A7pCJsCZQODJesALRUhABcimwhDYwBfj9hTBS7LCMdqbCN0A2cU52ERcweRDlcHpxwzFb8c4XDIXguGCCijrwlbAXUJmQFfBOMICTVbjKAgQWdTi1gYmyBhQT9d/AIxDGUVn0S9h3gCiw9rEhsBNQFzBzkNAQJ3Ee0RaxCVCOuGBDW1M/g6JQRPIYMgEQonA09szgsnJvkM+GkBoxJiAww0PXfuZ6tgtiQX/QcZMsVBYCHxC5JPzQycGsEYQlQuGeQHvwPzGvMn6kFXBf8DowMTOk0z7gS9C2kIiwk/AEkOoxcH1xhqCnGM0AExiwG3mQNXkYMCb48GNwcLAGcLhwV55QAdAqcIowAFAM8DVwA5Aq0HnQAZAIVBAT0DJy8BIeUCjwOTCDHLAZUvAfMpBBvDDBUA9zduSgLDsQKAamaiBd1YAo4CSTUBTSUEBU5HUQOvceEA2wBLBhPfRwEVq0rLGuNDAd9vKwDHAPsABTUHBUEBzQHzbQC3AV8LMQmis7UBTekpAIMAFWsB1wKJAN0ANQB/8QFTAE0FWfkF0wJPSQERMRgrV2EBuwMfATMBDQB5BsuNpckHHwRtB9MCEBsV4QLvLge1AQMi3xPNQsUCvd5VoWACZIECYkJbTa9bNyACofcCaJgCZgkCn4Q4GwsCZjsCZiYEbgR/A38TA36SOQY5dxc5gjojIwJsHQIyNjgKAm3HAm2u74ozZ0UrAWcA3gDhAEoFB5gMjQD+C8IADbUCdy8CdqI/AnlLQwJ4uh1c20WuRtcCfD8CesgCfQkCfPAFWQUgSABIfWMkAoFtAoAAAoAFAn+uSVhKWxUXSswC0QEC0MxLJwOITwOH5kTFkTIC8qFdAwMDrkvOTC0lA89NTE2vAos/AorYwRsHHUNnBbcCjjcCjlxAl4ECjtkCjlx4UbRTNQpS1FSFApP7ApMMAOkAHFUeVa9V0AYsGymVhjLheGZFOzkCl58C77JYIagAWSUClo8ClnycAKlZrFoJgU0AOwKWtQKWTlxEXNECmcsCmWRcyl0HGQKcmznCOp0CnBYCn5sCnriKAB0PMSoPAp3xAp6SALU9YTRh7wKe0wKgbgGpAp6fHwKeTqVjyGQnJSsCJ68CJn4CoPsCoEwCot0CocQCpi8Cpc4Cp/8AfQKn8mh8aLEAA0lqHGrRAqzjAqyuAq1nAq0CAlcdAlXcArHh1wMfTmyXArK9DQKy6Bds4G1jbUhfAyXNArZcOz9ukAMpRQK4XgK5RxUCuSp3cDZw4QK9GQK72nCWAzIRAr6IcgIDM3ECvhpzInNPAsPLAsMEc4J0SzVFdOADPKcDPJoDPb8CxXwCxkcCxhCJAshpUQLIRALJTwLJLgJknQLd0nh5YXiueSVL0AMYo2cCAmH0GfOVJHsLXpJeuxECz2sCz2wvS1PS8xOfAMatAs9zASnqA04SfksFAtwnAtuKAtJPA1JcA1NfAQEDVYyAiT8AyxbtYEWCHILTgs6DjQLaxwLZ3oQQhEmnPAOGpQAvA2QOhnFZ+QBVAt9lAt64c3cC4i/tFAHzMCcB9JsB8tKHAuvzAulweQLq+QLq5AD5RwG5Au6JAuuclqqXAwLuPwOF4Jh5cOBxoQLzAwBpA44WmZMC9xMDkW4DkocC95gC+dkC+GaaHJqruzebHgOdgwL++gEbADmfHJ+zAwWNA6ZqA6bZANHFAwZqoYiiBQkDDEkCwAA/AwDhQRdTARHzA2sHl2cFAJMtK7evvdsBiZkUfxEEOQH7KQUhDp0JnwCS/SlXxQL3AZ0AtwW5AG8LbUEuFCaNLgFDAYD8AbUmAHUDDgRtACwCFgyhAAAKAj0CagPdA34EkQEgRQUhfAoABQBEABMANhICdwEABdUDa+8KxQIA9wqfJ7+xt+UBkSFBQgHpFH8RNMCJAAQAGwBaAkUChIsABjpTOpSNbQC4Oo860ACNOME63AClAOgAywE6gTo7Ofw5+Tt2iTpbO56JOm85GAFWATMBbAUvNV01njWtNWY1dTW2NcU1gjWRNdI14TWeNa017jX9NbI1wTYCNhE1xjXVNhY2JzXeNe02LjY9Ni41LSE2OjY9Njw2yTcIBJA8VzY4Nt03IDcPNsogN4k3MAoEsDxnNiQ3GTdsOo03IULUQwdC4EMLHA8PCZsobShRVQYA6X8A6bABFCnXAukBowC9BbcAbwNzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgBFLWZAu0BhQCjBcEAbykBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUABavAj626xQAJP0A3etzuf4NNRA7efy2Z9NQrCnC0OSyANz5BBIbJ5IFDR6miIavYS6tprjjmuKebxm5C74Q225X1pkaYYPb6f1DK4k3xMEBb9S2WMjEibTNWhsRJIA+vwNVEiXTE5iXs/wezV66oFLfp9NZGYW+Gk19J2+bCT6Ye2w6LDYdgzKMUabk595eLBCXANz9HUpWbATq9vqXVx9XDg+Pc9Xp4+bsS005SVM/BJBM4687WUuf+Uj9dEi8aDNaPxtpbDxcG1THTImUMZq4UCaaNYpsVqraNyKLJXDYsFZ/5jl7bLRtO88t7P3xZaAxhb5OdPMXqsSkp1WCieG8jXm1U99+blvLlXzPCS+M93VnJCiK+09LfaSaBAVBomyDgJua8dfUzR7ga34IvR2Nvj+A9heJ6lsl1KG4NkI1032Cnff1m1wof2B9oHJK4bi6JkEdSqeNeiuo6QoZZincoc73/TH9SXF8sCE7XyuYyW8WSgbGFCjPV0ihLKhdPs08Tx82fYAkLLc4I2wdl4apY7GU5lHRFzRWJep7Ww3wbeA3qmd59/86P4xuNaqDpygXt6M85glSBHOCGgJDnt+pN9bK7HApMguX6+06RZNjzVmcZJ+wcUrJ9//bpRNxNuKpNl9uFds+S9tdx7LaM5ZkIrPj6nIU9mnbFtVbs9s/uLgl8MVczAwet+iOEzzBlYW7RCMgE6gyNLeq6+1tIx4dpgZnd0DksJS5f+JNDpwwcPNXaaVspq1fbQajOrJgK0ofKtJ1Ne90L6VO4MOl5S886p7u6xo7OLjG8TGL+HU1JXGJgppg4nNbNJ5nlzSpuPYy21JUEcUA94PoFiZfjZue+QnyQ80ekOuZVkxx4g+cvhJfHgNl4hy1/a6+RKcKlar/J29y//EztlbVPHVUeQ1zX86eQVAjR/M3dA9w4W8LfaXp4EgM85wOWasli837PzVMOnsLzR+k3o75/lRPAJSE1xAKQzEi5v10ke+VBvRt1cwQRMd+U5mLCTGVd6XiZtgBG5cDi0w22GKcVNvHiu5LQbZEDVtz0onn7k5+heuKXVsZtSzilkLRAUmjMXEMB3J9YC50XBxPiz53SC+EhnPl9WsKCv92SM/OFFIMJZYfl0WW8tIO3UxYcwdMAj7FSmgrsZ2aAZO03BOhP1bNNZItyXYQFTpC3SG1VuPDqH9GkiCDmE+JwxyIVSO5siDErAOpEXFgjy6PQtOVDj+s6e1r8heWVvmZnTciuf4EiNZzCAd7SOMhXERIOlsHIMG399i9aLTy3m2hRLZjJVDNLS53iGIK11dPqQt0zBDyg6qc7YqkDm2M5Ve6dCWCaCbTXX2rToaIgz6+zh4lYUi/+6nqcFMAkQJKHYLK0wYk5N9szV6xihDbDDFr45lN1K4aCXBq/FitPSud9gLt5ZVn+ZqGX7cwm2z5EGMgfFpIFyhGGuDPmso6TItTMwny+7uPnLCf4W6goFQFV0oQSsc9VfMmVLcLr6ZetDZbaSFTLqnSO/bIPjA3/zAUoqgGFAEQS4IhuMzEp2I3jJzbzkk/IEmyax+rhZTwd6f+CGtwPixu8IvzACquPWPREu9ZvGkUzpRwvRRuaNN6cr0W1wWits9ICdYJ7ltbgMiSL3sTPeufgNcVqMVWFkCPDH4jG2jA0XcVgQj62Cb29v9f/z/+2KbYvIv/zzjpQAPkliaVDzNrW57TZ/ZOyZD0nlfMmAIBIAGAI0D3k/mdN4xr9v85ZbZbbqfH2jGd5hUqNZWwl5SPfoGmfElmazUIeNL1j/mkF7VNAzTq4jNt8JoQ11NQOcmhprXoxSxfRGJ9LDEOAQ+dmxAQH90iti9e2u/MoeuaGcDTHoC+xsmEeWmxEKefQuIzHbpw5Tc5cEocboAD09oipWQhtTO1wivf/O+DRe2rpl/E9wlrzBorjJsOeG1B/XPW4EaJEFdNlECEZga5ZoGRHXgYouGRuVkm8tDESiEyFNo+3s5M5puSdTyUL2llnINVHEt91XUNW4ewdMgJ4boJfEyt/iY5WXqbA+A2Fkt5Z0lutiWhe9nZIyIUjyXDC3UsaG1t+eNx6z4W/OYoTB7A6x+dNSTOi9AInctbESqm5gvOLww7OWXPrmHwVZasrl4eD113pm+JtT7JVOvnCXqdzzdTRHgJ0PiGTFYW5Gvt9R9LD6Lzfs0v/TZZHSmyVNq7viIHE6DBK7Qp07Iz55EM8SYtQvZf/obBniTWi5C2/ovHfw4VndkE5XYdjOhCMRjDeOEfXeN/CwfGduiUIfsoFeUxXeQXba7c7972XNv8w+dTjjUM0QeNAReW+J014dKAD/McQYXT7c0GQPIkn3Ll6R7gGjuiQoZD0TEeEqQpKoZ15g/0OPQI17QiSv9AUROa/V/TQN3dvLArec3RrsYlvBm1b8LWzltdugsC50lNKYLEp2a+ZZYqPejULRlOJh5zj/LVMyTDvwKhMxxwuDkxJ1QpoNI0OTWLom4Z71SNzI9TV1iXJrIu9Wcnd+MCaAw8o1jSXd94YU/1gnkrC9BUEOtQvEIQ7g0i6h+KL2JKk8Ydl7HruvgWMSAmNe+LshGhV4qnWHhO9/RIPQzY1tHRj2VqOyNsDpK0cww+56AdDC4gsWwY0XxoucIWIqs/GcwnWqlaT0KPr8mbK5U94/301i1WLt4YINTVvCFBrFZbIbY8eycOdeJ2teD5IfPLCRg7jjcFTwlMFNl9zdh/o3E/hHPwj7BWg0MU09pPrBLbrCgm54A6H+I6v27+jL5gkjWg/iYdks9jbfVP5y/n0dlgWEMlKasl7JvFZd56LfybW1eeaVO0gxTfXZwD8G4SI116yx7UKVRgui6Ya1YpixqXeNLc8IxtAwCU5IhwQgn+NqHnRaDv61CxKhOq4pOX7M6pkA+Pmpd4j1vn6ACUALoLLc4vpXci8VidLxzm7qFBe7s+quuJs6ETYmnpgS3LwSZxPIltgBDXz8M1k/W2ySNv2f9/NPhxLGK2D21dkHeSGmenRT3Yqcdl0m/h3OYr8V+lXNYGf8aCCpd4bWjE4QIPj7vUKN4Nrfs7ML6Y2OyS830JCnofg/k7lpFpt4SqZc5HGg1HCOrHvOdC8bP6FGDbE/VV0mX4IakzbdS/op+Kt3G24/8QbBV7y86sGSQ/vZzU8FXs7u6jIvwchsEP2BpIhW3G8uWNwa3HmjfH/ZjhhCWvluAcF+nMf14ClKg5hGgtPLJ98ueNAkc5Hs2WZlk2QHvfreCK1CCGO6nMZVSb99VM/ajr8WHTte9JSmkXq/i/U943HEbdzW6Re/S88dKgg8pGOLlAeNiqrcLkUR3/aClFpMXcOUP3rmETcWSfMXZE3TUOi8i+fqRnTYLflVx/Vb/6GJ7eIRZUA6k3RYR3iFSK9c4iDdNwJuZL2FKz/IK5VimcNWEqdXjSoxSgmF0UPlDoUlNrPcM7ftmA8Y9gKiqKEHuWN+AZRIwtVSxye2Kf8rM3lhJ5XcBXU9n4v0Oy1RU2M+4qM8AQPVwse8ErNSob5oFPWxuqZnVzo1qB/IBxkM3EVUKFUUlO3e51259GgNcJbCmlvrdjtoTW7rChm1wyCKzpCTwozUUEOIcWLneRLgMXh+SjGSFkAllzbGS5HK7LlfCMRNRDSvbQPjcXaenNYxCvu2Qyznz6StuxVj66SgI0T8B6/sfHAJYZaZ78thjOSIFumNWLQbeZixDCCC+v0YBtkxiBB3jefHqZ/dFHU+crbj6OvS1x/JDD7vlm7zOVPwpUC01nhxZuY/63E7g";
const Wg = 44032
  , f2 = 4352
  , h2 = 4449
  , p2 = 4519
  , wF = 19
  , vF = 21
  , Xp = 28
  , m2 = vF * Xp
  , nte = wF * m2
  , rte = Wg + nte
  , ste = f2 + wF
  , ite = h2 + vF
  , ote = p2 + Xp;
function mg(n) {
    return n >> 24 & 255
}
function xF(n) {
    return n & 16777215
}
let x4, RI, E4, Lw;
function ate() {
    let n = pF(tte);
    x4 = new Map(mF(n).flatMap( (e, t) => e.map(r => [r, t + 1 << 24]))),
    RI = new Set(qg(n)),
    E4 = new Map,
    Lw = new Map;
    for (let[e,t] of gF(n)) {
        if (!RI.has(e) && t.length == 2) {
            let[r,s] = t
              , i = Lw.get(r);
            i || (i = new Map,
            Lw.set(r, i)),
            i.set(s, e)
        }
        E4.set(e, t.reverse())
    }
}
function EF(n) {
    return n >= Wg && n < rte
}
function lte(n, e) {
    if (n >= f2 && n < ste && e >= h2 && e < ite)
        return Wg + (n - f2) * m2 + (e - h2) * Xp;
    if (EF(n) && e > p2 && e < ote && (n - Wg) % Xp == 0)
        return n + (e - p2);
    {
        let t = Lw.get(n);
        return t && (t = t.get(e),
        t) ? t : -1
    }
}
function SF(n) {
    x4 || ate();
    let e = []
      , t = []
      , r = !1;
    function s(i) {
        let o = x4.get(i);
        o && (r = !0,
        i |= o),
        e.push(i)
    }
    for (let i of n)
        for (; ; ) {
            if (i < 128)
                e.push(i);
            else if (EF(i)) {
                let o = i - Wg
                  , a = o / m2 | 0
                  , l = o % m2 / Xp | 0
                  , u = o % Xp;
                s(f2 + a),
                s(h2 + l),
                u > 0 && s(p2 + u)
            } else {
                let o = E4.get(i);
                o ? t.push(...o) : s(i)
            }
            if (!t.length)
                break;
            i = t.pop()
        }
    if (r && e.length > 1) {
        let i = mg(e[0]);
        for (let o = 1; o < e.length; o++) {
            let a = mg(e[o]);
            if (a == 0 || i <= a) {
                i = a;
                continue
            }
            let l = o - 1;
            for (; ; ) {
                let u = e[l + 1];
                if (e[l + 1] = e[l],
                e[l] = u,
                !l || (i = mg(e[--l]),
                i <= a))
                    break
            }
            i = mg(e[o])
        }
    }
    return e
}
function cte(n) {
    let e = []
      , t = []
      , r = -1
      , s = 0;
    for (let i of n) {
        let o = mg(i)
          , a = xF(i);
        if (r == -1)
            o == 0 ? r = a : e.push(a);
        else if (s > 0 && s >= o)
            o == 0 ? (e.push(r, ...t),
            t.length = 0,
            r = a) : t.push(a),
            s = o;
        else {
            let l = lte(r, a);
            l >= 0 ? r = l : s == 0 && o == 0 ? (e.push(r),
            r = a) : (t.push(a),
            s = o)
        }
    }
    return r >= 0 && e.push(r, ...t),
    e
}
function AF(n) {
    return SF(n).map(xF)
}
function ute(n) {
    return cte(SF(n))
}
const OI = 45
  , CF = "."
  , _F = 65039
  , kF = 1
  , g2 = n => Array.from(n);
function Yg(n, e) {
    return n.P.has(e) || n.Q.has(e)
}
class dte extends Array {
    get is_emoji() {
        return !0
    }
}
let S4, NF, rf, A4, DF, Cp, NS, ap, zd, PI, C4;
function $8() {
    if (S4)
        return;
    let n = pF(Hee);
    const e = () => qg(n)
      , t = () => new Set(e())
      , r = (d, h) => h.forEach(p => d.add(p));
    S4 = new Map(gF(n)),
    NF = t(),
    rf = e(),
    A4 = new Set(e().map(d => rf[d])),
    rf = new Set(rf),
    DF = t(),
    t();
    let s = mF(n)
      , i = n();
    const o = () => {
        let d = new Set;
        return e().forEach(h => r(d, s[h])),
        r(d, e()),
        d
    }
    ;
    Cp = Gg(d => {
        let h = Gg(n).map(p => p + 96);
        if (h.length) {
            let p = d >= i;
            h[0] -= 32,
            h = Kp(h),
            p && (h = `Restricted[${h}]`);
            let g = o()
              , w = o()
              , b = !n();
            return {
                N: h,
                P: g,
                Q: w,
                M: b,
                R: p
            }
        }
    }
    ),
    NS = t(),
    ap = new Map;
    let a = e().concat(g2(NS)).sort( (d, h) => d - h);
    a.forEach( (d, h) => {
        let p = n()
          , g = a[h] = p ? a[h - p] : {
            V: [],
            M: new Map
        };
        g.V.push(d),
        NS.has(d) || ap.set(d, g)
    }
    );
    for (let {V: d, M: h} of new Set(ap.values())) {
        let p = [];
        for (let w of d) {
            let b = Cp.filter(S => Yg(S, w))
              , v = p.find( ({G: S}) => b.some(N => S.has(N)));
            v || (v = {
                G: new Set,
                V: []
            },
            p.push(v)),
            v.V.push(w),
            r(v.G, b)
        }
        let g = p.flatMap(w => g2(w.G));
        for (let {G: w, V: b} of p) {
            let v = new Set(g.filter(S => !w.has(S)));
            for (let S of b)
                h.set(S, v)
        }
    }
    zd = new Set;
    let l = new Set;
    const u = d => zd.has(d) ? l.add(d) : zd.add(d);
    for (let d of Cp) {
        for (let h of d.P)
            u(h);
        for (let h of d.Q)
            u(h)
    }
    for (let d of zd)
        !ap.has(d) && !l.has(d) && ap.set(d, kF);
    r(zd, AF(zd)),
    PI = Qee(n).map(d => dte.from(d)).sort(ete),
    C4 = new Map;
    for (let d of PI) {
        let h = [C4];
        for (let p of d) {
            let g = h.map(w => {
                let b = w.get(p);
                return b || (b = new Map,
                w.set(p, b)),
                b
            }
            );
            p === _F ? h.push(...g) : h = g
        }
        for (let p of h)
            p.V = d
    }
}
function H8(n) {
    return (TF(n) ? "" : `${V8($v([n]))} `) + bF(n)
}
function V8(n) {
    return `"${n}"`
}
function fte(n) {
    if (n.length >= 4 && n[2] == OI && n[3] == OI)
        throw new Error(`invalid label extension: "${Kp(n.slice(0, 4))}"`)
}
function hte(n) {
    for (let t = n.lastIndexOf(95); t > 0; )
        if (n[--t] !== 95)
            throw new Error("underscore allowed only at start")
}
function pte(n) {
    let e = n[0]
      , t = MI.get(e);
    if (t)
        throw _g(`leading ${t}`);
    let r = n.length
      , s = -1;
    for (let i = 1; i < r; i++) {
        e = n[i];
        let o = MI.get(e);
        if (o) {
            if (s == i)
                throw _g(`${t} + ${o}`);
            s = i + 1,
            t = o
        }
    }
    if (s == r)
        throw _g(`trailing ${t}`)
}
function $v(n, e=1 / 0, t=bF) {
    let r = [];
    mte(n[0]) && r.push(""),
    n.length > e && (e >>= 1,
    n = [...n.slice(0, e), 8230, ...n.slice(-e)]);
    let s = 0
      , i = n.length;
    for (let o = 0; o < i; o++) {
        let a = n[o];
        TF(a) && (r.push(Kp(n.slice(s, o))),
        r.push(t(a)),
        s = o + 1)
    }
    return r.push(Kp(n.slice(s, i))),
    r.join("")
}
function mte(n) {
    return $8(),
    rf.has(n)
}
function TF(n) {
    return $8(),
    DF.has(n)
}
function gte(n) {
    return vte(yte(n, ute, Ste))
}
function yte(n, e, t) {
    if (!n)
        return [];
    $8();
    let r = 0;
    return n.split(CF).map(s => {
        let i = Jee(s)
          , o = {
            input: i,
            offset: r
        };
        r += i.length + 1;
        try {
            let a = o.tokens = Ete(i, e, t), l = a.length, u;
            if (!l)
                throw new Error("empty label");
            let d = o.output = a.flat();
            if (hte(d),
            !(o.emoji = l > 1 || a[0].is_emoji) && d.every(p => p < 128))
                fte(d),
                u = "ASCII";
            else {
                let p = a.flatMap(g => g.is_emoji ? [] : g);
                if (!p.length)
                    u = "Emoji";
                else {
                    if (rf.has(d[0]))
                        throw _g("leading combining mark");
                    for (let b = 1; b < l; b++) {
                        let v = a[b];
                        if (!v.is_emoji && rf.has(v[0]))
                            throw _g(`emoji + combining mark: "${Kp(a[b - 1])} + ${$v([v[0]])}"`)
                    }
                    pte(d);
                    let g = g2(new Set(p))
                      , [w] = wte(g);
                    xte(w, p),
                    bte(w, g),
                    u = w.N
                }
            }
            o.type = u
        } catch (a) {
            o.error = a
        }
        return o
    }
    )
}
function bte(n, e) {
    let t, r = [];
    for (let s of e) {
        let i = ap.get(s);
        if (i === kF)
            return;
        if (i) {
            let o = i.M.get(s);
            if (t = t ? t.filter(a => o.has(a)) : g2(o),
            !t.length)
                return
        } else
            r.push(s)
    }
    if (t) {
        for (let s of t)
            if (r.every(i => Yg(s, i)))
                throw new Error(`whole-script confusable: ${n.N}/${s.N}`)
    }
}
function wte(n) {
    let e = Cp;
    for (let t of n) {
        let r = e.filter(s => Yg(s, t));
        if (!r.length)
            throw Cp.some(s => Yg(s, t)) ? MF(e[0], t) : IF(t);
        if (e = r,
        r.length == 1)
            break
    }
    return e
}
function vte(n) {
    return n.map( ({input: e, error: t, output: r}) => {
        if (t) {
            let s = t.message;
            throw new Error(n.length == 1 ? s : `Invalid label ${V8($v(e, 63))}: ${s}`)
        }
        return Kp(r)
    }
    ).join(CF)
}
function IF(n) {
    return new Error(`disallowed character: ${H8(n)}`)
}
function MF(n, e) {
    let t = H8(e)
      , r = Cp.find(s => s.P.has(e));
    return r && (t = `${r.N} ${t}`),
    new Error(`illegal mixture: ${n.N} + ${t}`)
}
function _g(n) {
    return new Error(`illegal placement: ${n}`)
}
function xte(n, e) {
    for (let t of e)
        if (!Yg(n, t))
            throw MF(n, t);
    if (n.M) {
        let t = AF(e);
        for (let r = 1, s = t.length; r < s; r++)
            if (A4.has(t[r])) {
                let i = r + 1;
                for (let o; i < s && A4.has(o = t[i]); i++)
                    for (let a = r; a < i; a++)
                        if (t[a] == o)
                            throw new Error(`duplicate non-spacing marks: ${H8(o)}`);
                if (i - r > BI)
                    throw new Error(`excessive non-spacing marks: ${V8($v(t.slice(r - 1, i)))} (${i - r}/${BI})`);
                r = i
            }
    }
}
function Ete(n, e, t) {
    let r = []
      , s = [];
    for (n = n.slice().reverse(); n.length; ) {
        let i = Ate(n);
        if (i)
            s.length && (r.push(e(s)),
            s = []),
            r.push(t(i));
        else {
            let o = n.pop();
            if (zd.has(o))
                s.push(o);
            else {
                let a = S4.get(o);
                if (a)
                    s.push(...a);
                else if (!NF.has(o))
                    throw IF(o)
            }
        }
    }
    return s.length && r.push(e(s)),
    r
}
function Ste(n) {
    return n.filter(e => e != _F)
}
function Ate(n, e) {
    let t = C4, r, s = n.length;
    for (; s && (t = t.get(n[--s]),
    !!t); ) {
        let {V: i} = t;
        i && (r = i,
        n.length = s)
    }
    return r
}
const BF = new Uint8Array(32);
BF.fill(0);
function jI(n) {
    return he(n.length !== 0, "invalid ENS name; empty component", "comp", n),
    n
}
function RF(n) {
    const e = pc(Cte(n))
      , t = [];
    if (n.length === 0)
        return t;
    let r = 0;
    for (let s = 0; s < e.length; s++)
        e[s] === 46 && (t.push(jI(e.slice(r, s))),
        r = s + 1);
    return he(r < e.length, "invalid ENS name; empty component", "name", n),
    t.push(jI(e.slice(r))),
    t
}
function Cte(n) {
    try {
        if (n.length === 0)
            throw new Error("empty label");
        return gte(n)
    } catch (e) {
        he(!1, `invalid ENS name (${e.message})`, "name", n)
    }
}
function _4(n) {
    he(typeof n == "string", "invalid ENS name; not a string", "name", n),
    he(n.length, "invalid ENS name (empty label)", "name", n);
    let e = BF;
    const t = RF(n);
    for (; t.length; )
        e = Fr(gr([e, Fr(t.pop())]));
    return Ke(e)
}
function _te(n, e) {
    const t = e;
    return he(t <= 255, "DNS encoded label cannot exceed 255", "length", t),
    Ke(gr(RF(n).map(r => {
        he(r.length <= t, `label ${JSON.stringify(n)} exceeds ${t} bytes`, "name", n);
        const s = new Uint8Array(r.length + 1);
        return s.set(r, 1),
        s[0] = s.length - 1,
        s
    }
    ))) + "00"
}
const OF = new Uint8Array(32);
OF.fill(0);
const kte = BigInt(-1)
  , PF = BigInt(0)
  , jF = BigInt(1)
  , Nte = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function Dte(n) {
    const e = zt(n)
      , t = e.length % 32;
    return t ? gr([e, OF.slice(t)]) : Ke(e)
}
const Tte = Ku(jF, 32)
  , Ite = Ku(PF, 32)
  , LI = {
    name: "string",
    version: "string",
    chainId: "uint256",
    verifyingContract: "address",
    salt: "bytes32"
}
  , DS = ["name", "version", "chainId", "verifyingContract", "salt"];
function FI(n) {
    return function(e) {
        return he(typeof e == "string", `invalid domain value for ${JSON.stringify(n)}`, `domain.${n}`, e),
        e
    }
}
const Mte = {
    name: FI("name"),
    version: FI("version"),
    chainId: function(n) {
        const e = nt(n, "domain.chainId");
        return he(e >= 0, "invalid chain ID", "domain.chainId", n),
        Number.isSafeInteger(e) ? Number(e) : ea(e)
    },
    verifyingContract: function(n) {
        try {
            return yn(n).toLowerCase()
        } catch {}
        he(!1, 'invalid domain value "verifyingContract"', "domain.verifyingContract", n)
    },
    salt: function(n) {
        const e = zt(n, "domain.salt");
        return he(e.length === 32, 'invalid domain value "salt"', "domain.salt", n),
        Ke(e)
    }
};
function TS(n) {
    {
        const e = n.match(/^(u?)int(\d+)$/);
        if (e) {
            const t = e[1] === ""
              , r = parseInt(e[2]);
            he(r % 8 === 0 && r !== 0 && r <= 256 && e[2] === String(r), "invalid numeric width", "type", n);
            const s = tf(Nte, t ? r - 1 : r)
              , i = t ? (s + jF) * kte : PF;
            return function(o) {
                const a = nt(o, "value");
                return he(a >= i && a <= s, `value out-of-bounds for ${n}`, "value", a),
                Ku(t ? xL(a, 256) : a, 32)
            }
        }
    }
    {
        const e = n.match(/^bytes(\d+)$/);
        if (e) {
            const t = parseInt(e[1]);
            return he(t !== 0 && t <= 32 && e[1] === String(t), "invalid bytes width", "type", n),
            function(r) {
                const s = zt(r);
                return he(s.length === t, `invalid length for ${n}`, "value", r),
                Dte(r)
            }
        }
    }
    switch (n) {
    case "address":
        return function(e) {
            return Cc(yn(e), 32)
        }
        ;
    case "bool":
        return function(e) {
            return e ? Tte : Ite
        }
        ;
    case "bytes":
        return function(e) {
            return Fr(e)
        }
        ;
    case "string":
        return function(e) {
            return Tf(e)
        }
    }
    return null
}
function UI(n, e) {
    return `${n}(${e.map( ({name: t, type: r}) => r + " " + t).join(",")})`
}
function C1(n) {
    const e = n.match(/^([^\x5b]*)((\x5b\d*\x5d)*)(\x5b(\d*)\x5d)$/);
    return e ? {
        base: e[1],
        index: e[2] + e[4],
        array: {
            base: e[1],
            prefix: e[1] + e[2],
            count: e[5] ? parseInt(e[5]) : -1
        }
    } : {
        base: n
    }
}
class Vi {
    primaryType;
    #e;
    get types() {
        return JSON.parse(this.#e)
    }
    #t;
    #n;
    constructor(e) {
        this.#t = new Map,
        this.#n = new Map;
        const t = new Map
          , r = new Map
          , s = new Map
          , i = {};
        Object.keys(e).forEach(l => {
            i[l] = e[l].map( ({name: u, type: d}) => {
                let {base: h, index: p} = C1(d);
                return h === "int" && !e.int && (h = "int256"),
                h === "uint" && !e.uint && (h = "uint256"),
                {
                    name: u,
                    type: h + (p || "")
                }
            }
            ),
            t.set(l, new Set),
            r.set(l, []),
            s.set(l, new Set)
        }
        ),
        this.#e = JSON.stringify(i);
        for (const l in i) {
            const u = new Set;
            for (const d of i[l]) {
                he(!u.has(d.name), `duplicate variable name ${JSON.stringify(d.name)} in ${JSON.stringify(l)}`, "types", e),
                u.add(d.name);
                const h = C1(d.type).base;
                he(h !== l, `circular type reference to ${JSON.stringify(h)}`, "types", e),
                !TS(h) && (he(r.has(h), `unknown type ${JSON.stringify(h)}`, "types", e),
                r.get(h).push(l),
                t.get(l).add(h))
            }
        }
        const o = Array.from(r.keys()).filter(l => r.get(l).length === 0);
        he(o.length !== 0, "missing primary type", "types", e),
        he(o.length === 1, `ambiguous primary types or unused types: ${o.map(l => JSON.stringify(l)).join(", ")}`, "types", e),
        xt(this, {
            primaryType: o[0]
        });
        function a(l, u) {
            he(!u.has(l), `circular type reference to ${JSON.stringify(l)}`, "types", e),
            u.add(l);
            for (const d of t.get(l))
                if (r.has(d)) {
                    a(d, u);
                    for (const h of u)
                        s.get(h).add(d)
                }
            u.delete(l)
        }
        a(this.primaryType, new Set);
        for (const [l,u] of s) {
            const d = Array.from(u);
            d.sort(),
            this.#t.set(l, UI(l, i[l]) + d.map(h => UI(h, i[h])).join(""))
        }
    }
    getEncoder(e) {
        let t = this.#n.get(e);
        return t || (t = this.#r(e),
        this.#n.set(e, t)),
        t
    }
    #r(e) {
        {
            const s = TS(e);
            if (s)
                return s
        }
        const t = C1(e).array;
        if (t) {
            const s = t.prefix
              , i = this.getEncoder(s);
            return o => {
                he(t.count === -1 || t.count === o.length, `array length mismatch; expected length ${t.count}`, "value", o);
                let a = o.map(i);
                return this.#t.has(s) && (a = a.map(Fr)),
                Fr(gr(a))
            }
        }
        const r = this.types[e];
        if (r) {
            const s = Tf(this.#t.get(e));
            return i => {
                const o = r.map( ({name: a, type: l}) => {
                    const u = this.getEncoder(l)(i[a]);
                    return this.#t.has(l) ? Fr(u) : u
                }
                );
                return o.unshift(s),
                gr(o)
            }
        }
        he(!1, `unknown type: ${e}`, "type", e)
    }
    encodeType(e) {
        const t = this.#t.get(e);
        return he(t, `unknown type: ${JSON.stringify(e)}`, "name", e),
        t
    }
    encodeData(e, t) {
        return this.getEncoder(e)(t)
    }
    hashStruct(e, t) {
        return Fr(this.encodeData(e, t))
    }
    encode(e) {
        return this.encodeData(this.primaryType, e)
    }
    hash(e) {
        return this.hashStruct(this.primaryType, e)
    }
    _visit(e, t, r) {
        if (TS(e))
            return r(e, t);
        const s = C1(e).array;
        if (s)
            return he(s.count === -1 || s.count === t.length, `array length mismatch; expected length ${s.count}`, "value", t),
            t.map(o => this._visit(s.prefix, o, r));
        const i = this.types[e];
        if (i)
            return i.reduce( (o, {name: a, type: l}) => (o[a] = this._visit(l, t[a], r),
            o), {});
        he(!1, `unknown type: ${e}`, "type", e)
    }
    visit(e, t) {
        return this._visit(this.primaryType, e, t)
    }
    static from(e) {
        return new Vi(e)
    }
    static getPrimaryType(e) {
        return Vi.from(e).primaryType
    }
    static hashStruct(e, t, r) {
        return Vi.from(t).hashStruct(e, r)
    }
    static hashDomain(e) {
        const t = [];
        for (const r in e) {
            if (e[r] == null)
                continue;
            const s = LI[r];
            he(s, `invalid typed-data domain key: ${JSON.stringify(r)}`, "domain", e),
            t.push({
                name: r,
                type: s
            })
        }
        return t.sort( (r, s) => DS.indexOf(r.name) - DS.indexOf(s.name)),
        Vi.hashStruct("EIP712Domain", {
            EIP712Domain: t
        }, e)
    }
    static encode(e, t, r) {
        return gr(["0x1901", Vi.hashDomain(e), Vi.from(t).hash(r)])
    }
    static hash(e, t, r) {
        return Fr(Vi.encode(e, t, r))
    }
    static async resolveNames(e, t, r, s) {
        e = Object.assign({}, e);
        for (const a in e)
            e[a] == null && delete e[a];
        const i = {};
        e.verifyingContract && !zn(e.verifyingContract, 20) && (i[e.verifyingContract] = "0x");
        const o = Vi.from(t);
        o.visit(r, (a, l) => (a === "address" && !zn(l, 20) && (i[l] = "0x"),
        l));
        for (const a in i)
            i[a] = await s(a);
        return e.verifyingContract && i[e.verifyingContract] && (e.verifyingContract = i[e.verifyingContract]),
        r = o.visit(r, (a, l) => a === "address" && i[l] ? i[l] : l),
        {
            domain: e,
            value: r
        }
    }
    static getPayload(e, t, r) {
        Vi.hashDomain(e);
        const s = {}
          , i = [];
        DS.forEach(l => {
            const u = e[l];
            u != null && (s[l] = Mte[l](u),
            i.push({
                name: l,
                type: LI[l]
            }))
        }
        );
        const o = Vi.from(t);
        t = o.types;
        const a = Object.assign({}, t);
        return he(a.EIP712Domain == null, "types must not contain EIP712Domain type", "types.EIP712Domain", t),
        a.EIP712Domain = i,
        o.encode(r),
        {
            types: a,
            domain: s,
            primaryType: o.primaryType,
            message: o.visit(r, (l, u) => {
                if (l.match(/^bytes(\d*)/))
                    return Ke(zt(u));
                if (l.match(/^u?int/))
                    return nt(u).toString();
                switch (l) {
                case "address":
                    return u.toLowerCase();
                case "bool":
                    return !!u;
                case "string":
                    return he(typeof u == "string", "invalid string", "value", u),
                    u
                }
                he(!1, "unsupported type", "type", l)
            }
            )
        }
    }
}
function Qs(n) {
    const e = new Set;
    return n.forEach(t => e.add(t)),
    Object.freeze(e)
}
const Bte = "external public payable override"
  , Rte = Qs(Bte.split(" "))
  , LF = "constant external internal payable private public pure view override"
  , Ote = Qs(LF.split(" "))
  , FF = "constructor error event fallback function receive struct"
  , UF = Qs(FF.split(" "))
  , zF = "calldata memory storage payable indexed"
  , Pte = Qs(zF.split(" "))
  , jte = "tuple returns"
  , Lte = [FF, zF, jte, LF].join(" ")
  , Fte = Qs(Lte.split(" "))
  , Ute = {
    "(": "OPEN_PAREN",
    ")": "CLOSE_PAREN",
    "[": "OPEN_BRACKET",
    "]": "CLOSE_BRACKET",
    ",": "COMMA",
    "@": "AT"
}
  , zte = new RegExp("^(\\s*)")
  , $te = new RegExp("^([0-9]+)")
  , Hte = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)")
  , $F = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$")
  , HF = new RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");
class Po {
    #e;
    #t;
    get offset() {
        return this.#e
    }
    get length() {
        return this.#t.length - this.#e
    }
    constructor(e) {
        this.#e = 0,
        this.#t = e.slice()
    }
    clone() {
        return new Po(this.#t)
    }
    reset() {
        this.#e = 0
    }
    #n(e=0, t=0) {
        return new Po(this.#t.slice(e, t).map(r => Object.freeze(Object.assign({}, r, {
            match: r.match - e,
            linkBack: r.linkBack - e,
            linkNext: r.linkNext - e
        }))))
    }
    popKeyword(e) {
        const t = this.peek();
        if (t.type !== "KEYWORD" || !e.has(t.text))
            throw new Error(`expected keyword ${t.text}`);
        return this.pop().text
    }
    popType(e) {
        if (this.peek().type !== e) {
            const t = this.peek();
            throw new Error(`expected ${e}; got ${t.type} ${JSON.stringify(t.text)}`)
        }
        return this.pop().text
    }
    popParen() {
        const e = this.peek();
        if (e.type !== "OPEN_PAREN")
            throw new Error("bad start");
        const t = this.#n(this.#e + 1, e.match + 1);
        return this.#e = e.match + 1,
        t
    }
    popParams() {
        const e = this.peek();
        if (e.type !== "OPEN_PAREN")
            throw new Error("bad start");
        const t = [];
        for (; this.#e < e.match - 1; ) {
            const r = this.peek().linkNext;
            t.push(this.#n(this.#e + 1, r)),
            this.#e = r
        }
        return this.#e = e.match + 1,
        t
    }
    peek() {
        if (this.#e >= this.#t.length)
            throw new Error("out-of-bounds");
        return this.#t[this.#e]
    }
    peekKeyword(e) {
        const t = this.peekType("KEYWORD");
        return t != null && e.has(t) ? t : null
    }
    peekType(e) {
        if (this.length === 0)
            return null;
        const t = this.peek();
        return t.type === e ? t.text : null
    }
    pop() {
        const e = this.peek();
        return this.#e++,
        e
    }
    toString() {
        const e = [];
        for (let t = this.#e; t < this.#t.length; t++) {
            const r = this.#t[t];
            e.push(`${r.type}:${r.text}`)
        }
        return `<TokenString ${e.join(" ")}>`
    }
}
function ad(n) {
    const e = []
      , t = o => {
        const a = i < n.length ? JSON.stringify(n[i]) : "$EOI";
        throw new Error(`invalid token ${a} at ${i}: ${o}`)
    }
    ;
    let r = []
      , s = []
      , i = 0;
    for (; i < n.length; ) {
        let o = n.substring(i)
          , a = o.match(zte);
        a && (i += a[1].length,
        o = n.substring(i));
        const l = {
            depth: r.length,
            linkBack: -1,
            linkNext: -1,
            match: -1,
            type: "",
            text: "",
            offset: i,
            value: -1
        };
        e.push(l);
        let u = Ute[o[0]] || "";
        if (u) {
            if (l.type = u,
            l.text = o[0],
            i++,
            u === "OPEN_PAREN")
                r.push(e.length - 1),
                s.push(e.length - 1);
            else if (u == "CLOSE_PAREN")
                r.length === 0 && t("no matching open bracket"),
                l.match = r.pop(),
                e[l.match].match = e.length - 1,
                l.depth--,
                l.linkBack = s.pop(),
                e[l.linkBack].linkNext = e.length - 1;
            else if (u === "COMMA")
                l.linkBack = s.pop(),
                e[l.linkBack].linkNext = e.length - 1,
                s.push(e.length - 1);
            else if (u === "OPEN_BRACKET")
                l.type = "BRACKET";
            else if (u === "CLOSE_BRACKET") {
                let d = e.pop().text;
                if (e.length > 0 && e[e.length - 1].type === "NUMBER") {
                    const h = e.pop().text;
                    d = h + d,
                    e[e.length - 1].value = Bt(h)
                }
                if (e.length === 0 || e[e.length - 1].type !== "BRACKET")
                    throw new Error("missing opening bracket");
                e[e.length - 1].text += d
            }
            continue
        }
        if (a = o.match(Hte),
        a) {
            if (l.text = a[1],
            i += l.text.length,
            Fte.has(l.text)) {
                l.type = "KEYWORD";
                continue
            }
            if (l.text.match(HF)) {
                l.type = "TYPE";
                continue
            }
            l.type = "ID";
            continue
        }
        if (a = o.match($te),
        a) {
            l.text = a[1],
            l.type = "NUMBER",
            i += l.text.length;
            continue
        }
        throw new Error(`unexpected token ${JSON.stringify(o[0])} at position ${i}`)
    }
    return new Po(e.map(o => Object.freeze(o)))
}
function zI(n, e) {
    let t = [];
    for (const r in e.keys())
        n.has(r) && t.push(r);
    if (t.length > 1)
        throw new Error(`conflicting types: ${t.join(", ")}`)
}
function Hv(n, e) {
    if (e.peekKeyword(UF)) {
        const t = e.pop().text;
        if (t !== n)
            throw new Error(`expected ${n}, got ${t}`)
    }
    return e.popType("ID")
}
function kc(n, e) {
    const t = new Set;
    for (; ; ) {
        const r = n.peekType("KEYWORD");
        if (r == null || e && !e.has(r))
            break;
        if (n.pop(),
        t.has(r))
            throw new Error(`duplicate keywords: ${JSON.stringify(r)}`);
        t.add(r)
    }
    return Object.freeze(t)
}
function VF(n) {
    let e = kc(n, Ote);
    return zI(e, Qs("constant payable nonpayable".split(" "))),
    zI(e, Qs("pure view payable nonpayable".split(" "))),
    e.has("view") ? "view" : e.has("pure") ? "pure" : e.has("payable") ? "payable" : e.has("nonpayable") ? "nonpayable" : e.has("constant") ? "view" : "nonpayable"
}
function mc(n, e) {
    return n.popParams().map(t => Un.from(t, e))
}
function qF(n) {
    if (n.peekType("AT")) {
        if (n.pop(),
        n.peekType("NUMBER"))
            return nt(n.pop().text);
        throw new Error("invalid gas")
    }
    return null
}
function If(n) {
    if (n.length)
        throw new Error(`unexpected tokens at offset ${n.offset}: ${n.toString()}`)
}
const Vte = new RegExp(/^(.*)\[([0-9]*)\]$/);
function $I(n) {
    const e = n.match(HF);
    if (he(e, "invalid type", "type", n),
    n === "uint")
        return "uint256";
    if (n === "int")
        return "int256";
    if (e[2]) {
        const t = parseInt(e[2]);
        he(t !== 0 && t <= 32, "invalid bytes length", "type", n)
    } else if (e[3]) {
        const t = parseInt(e[3]);
        he(t !== 0 && t <= 256 && t % 8 === 0, "invalid numeric width", "type", n)
    }
    return n
}
const nr = {}
  , Di = Symbol.for("_ethers_internal")
  , HI = "_ParamTypeInternal"
  , VI = "_ErrorInternal"
  , qI = "_EventInternal"
  , GI = "_ConstructorInternal"
  , WI = "_FallbackInternal"
  , YI = "_FunctionInternal"
  , KI = "_StructInternal";
class Un {
    name;
    type;
    baseType;
    indexed;
    components;
    arrayLength;
    arrayChildren;
    constructor(e, t, r, s, i, o, a, l) {
        if (Sy(e, nr, "ParamType"),
        Object.defineProperty(this, Di, {
            value: HI
        }),
        o && (o = Object.freeze(o.slice())),
        s === "array") {
            if (a == null || l == null)
                throw new Error("")
        } else if (a != null || l != null)
            throw new Error("");
        if (s === "tuple") {
            if (o == null)
                throw new Error("")
        } else if (o != null)
            throw new Error("");
        xt(this, {
            name: t,
            type: r,
            baseType: s,
            indexed: i,
            components: o,
            arrayLength: a,
            arrayChildren: l
        })
    }
    format(e) {
        if (e == null && (e = "sighash"),
        e === "json") {
            const r = this.name || "";
            if (this.isArray()) {
                const i = JSON.parse(this.arrayChildren.format("json"));
                return i.name = r,
                i.type += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`,
                JSON.stringify(i)
            }
            const s = {
                type: this.baseType === "tuple" ? "tuple" : this.type,
                name: r
            };
            return typeof this.indexed == "boolean" && (s.indexed = this.indexed),
            this.isTuple() && (s.components = this.components.map(i => JSON.parse(i.format(e)))),
            JSON.stringify(s)
        }
        let t = "";
        return this.isArray() ? (t += this.arrayChildren.format(e),
        t += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`) : this.isTuple() ? t += "(" + this.components.map(r => r.format(e)).join(e === "full" ? ", " : ",") + ")" : t += this.type,
        e !== "sighash" && (this.indexed === !0 && (t += " indexed"),
        e === "full" && this.name && (t += " " + this.name)),
        t
    }
    isArray() {
        return this.baseType === "array"
    }
    isTuple() {
        return this.baseType === "tuple"
    }
    isIndexable() {
        return this.indexed != null
    }
    walk(e, t) {
        if (this.isArray()) {
            if (!Array.isArray(e))
                throw new Error("invalid array value");
            if (this.arrayLength !== -1 && e.length !== this.arrayLength)
                throw new Error("array is wrong length");
            const r = this;
            return e.map(s => r.arrayChildren.walk(s, t))
        }
        if (this.isTuple()) {
            if (!Array.isArray(e))
                throw new Error("invalid tuple value");
            if (e.length !== this.components.length)
                throw new Error("array is wrong length");
            const r = this;
            return e.map( (s, i) => r.components[i].walk(s, t))
        }
        return t(this.type, e)
    }
    #e(e, t, r, s) {
        if (this.isArray()) {
            if (!Array.isArray(t))
                throw new Error("invalid array value");
            if (this.arrayLength !== -1 && t.length !== this.arrayLength)
                throw new Error("array is wrong length");
            const o = this.arrayChildren
              , a = t.slice();
            a.forEach( (l, u) => {
                o.#e(e, l, r, d => {
                    a[u] = d
                }
                )
            }
            ),
            s(a);
            return
        }
        if (this.isTuple()) {
            const o = this.components;
            let a;
            if (Array.isArray(t))
                a = t.slice();
            else {
                if (t == null || typeof t != "object")
                    throw new Error("invalid tuple value");
                a = o.map(l => {
                    if (!l.name)
                        throw new Error("cannot use object value with unnamed components");
                    if (!(l.name in t))
                        throw new Error(`missing value for component ${l.name}`);
                    return t[l.name]
                }
                )
            }
            if (a.length !== this.components.length)
                throw new Error("array is wrong length");
            a.forEach( (l, u) => {
                o[u].#e(e, l, r, d => {
                    a[u] = d
                }
                )
            }
            ),
            s(a);
            return
        }
        const i = r(this.type, t);
        i.then ? e.push((async function() {
            s(await i)
        }
        )()) : s(i)
    }
    async walkAsync(e, t) {
        const r = []
          , s = [e];
        return this.#e(r, e, t, i => {
            s[0] = i
        }
        ),
        r.length && await Promise.all(r),
        s[0]
    }
    static from(e, t) {
        if (Un.isParamType(e))
            return e;
        if (typeof e == "string")
            try {
                return Un.from(ad(e), t)
            } catch {
                he(!1, "invalid param type", "obj", e)
            }
        else if (e instanceof Po) {
            let a = ""
              , l = ""
              , u = null;
            kc(e, Qs(["tuple"])).has("tuple") || e.peekType("OPEN_PAREN") ? (l = "tuple",
            u = e.popParams().map(b => Un.from(b)),
            a = `tuple(${u.map(b => b.format()).join(",")})`) : (a = $I(e.popType("TYPE")),
            l = a);
            let d = null
              , h = null;
            for (; e.length && e.peekType("BRACKET"); ) {
                const b = e.pop();
                d = new Un(nr,"",a,l,null,u,h,d),
                h = b.value,
                a += b.text,
                l = "array",
                u = null
            }
            let p = null;
            if (kc(e, Pte).has("indexed")) {
                if (!t)
                    throw new Error("");
                p = !0
            }
            const w = e.peekType("ID") ? e.pop().text : "";
            if (e.length)
                throw new Error("leftover tokens");
            return new Un(nr,w,a,l,p,u,h,d)
        }
        const r = e.name;
        he(!r || typeof r == "string" && r.match($F), "invalid name", "obj.name", r);
        let s = e.indexed;
        s != null && (he(t, "parameter cannot be indexed", "obj.indexed", e.indexed),
        s = !!s);
        let i = e.type
          , o = i.match(Vte);
        if (o) {
            const a = parseInt(o[2] || "-1")
              , l = Un.from({
                type: o[1],
                components: e.components
            });
            return new Un(nr,r || "",i,"array",s,null,a,l)
        }
        if (i === "tuple" || i.startsWith("tuple(") || i.startsWith("(")) {
            const a = e.components != null ? e.components.map(u => Un.from(u)) : null;
            return new Un(nr,r || "",i,"tuple",s,a,null,null)
        }
        return i = $I(e.type),
        new Un(nr,r || "",i,i,s,null,null,null)
    }
    static isParamType(e) {
        return e && e[Di] === HI
    }
}
class Mf {
    type;
    inputs;
    constructor(e, t, r) {
        Sy(e, nr, "Fragment"),
        r = Object.freeze(r.slice()),
        xt(this, {
            type: t,
            inputs: r
        })
    }
    static from(e) {
        if (typeof e == "string") {
            try {
                Mf.from(JSON.parse(e))
            } catch {}
            return Mf.from(ad(e))
        }
        if (e instanceof Po)
            switch (e.peekKeyword(UF)) {
            case "constructor":
                return cc.from(e);
            case "error":
                return Ei.from(e);
            case "event":
                return Ha.from(e);
            case "fallback":
            case "receive":
                return Xl.from(e);
            case "function":
                return Va.from(e);
            case "struct":
                return xf.from(e)
            }
        else if (typeof e == "object") {
            switch (e.type) {
            case "constructor":
                return cc.from(e);
            case "error":
                return Ei.from(e);
            case "event":
                return Ha.from(e);
            case "fallback":
            case "receive":
                return Xl.from(e);
            case "function":
                return Va.from(e);
            case "struct":
                return xf.from(e)
            }
            Ie(!1, `unsupported type: ${e.type}`, "UNSUPPORTED_OPERATION", {
                operation: "Fragment.from"
            })
        }
        he(!1, "unsupported frgament object", "obj", e)
    }
    static isConstructor(e) {
        return cc.isFragment(e)
    }
    static isError(e) {
        return Ei.isFragment(e)
    }
    static isEvent(e) {
        return Ha.isFragment(e)
    }
    static isFunction(e) {
        return Va.isFragment(e)
    }
    static isStruct(e) {
        return xf.isFragment(e)
    }
}
class Vv extends Mf {
    name;
    constructor(e, t, r, s) {
        super(e, t, s),
        he(typeof r == "string" && r.match($F), "invalid identifier", "name", r),
        s = Object.freeze(s.slice()),
        xt(this, {
            name: r
        })
    }
}
function Kg(n, e) {
    return "(" + e.map(t => t.format(n)).join(n === "full" ? ", " : ",") + ")"
}
class Ei extends Vv {
    constructor(e, t, r) {
        super(e, "error", t, r),
        Object.defineProperty(this, Di, {
            value: VI
        })
    }
    get selector() {
        return Tf(this.format("sighash")).substring(0, 10)
    }
    format(e) {
        if (e == null && (e = "sighash"),
        e === "json")
            return JSON.stringify({
                type: "error",
                name: this.name,
                inputs: this.inputs.map(r => JSON.parse(r.format(e)))
            });
        const t = [];
        return e !== "sighash" && t.push("error"),
        t.push(this.name + Kg(e, this.inputs)),
        t.join(" ")
    }
    static from(e) {
        if (Ei.isFragment(e))
            return e;
        if (typeof e == "string")
            return Ei.from(ad(e));
        if (e instanceof Po) {
            const t = Hv("error", e)
              , r = mc(e);
            return If(e),
            new Ei(nr,t,r)
        }
        return new Ei(nr,e.name,e.inputs ? e.inputs.map(Un.from) : [])
    }
    static isFragment(e) {
        return e && e[Di] === VI
    }
}
class Ha extends Vv {
    anonymous;
    constructor(e, t, r, s) {
        super(e, "event", t, r),
        Object.defineProperty(this, Di, {
            value: qI
        }),
        xt(this, {
            anonymous: s
        })
    }
    get topicHash() {
        return Tf(this.format("sighash"))
    }
    format(e) {
        if (e == null && (e = "sighash"),
        e === "json")
            return JSON.stringify({
                type: "event",
                anonymous: this.anonymous,
                name: this.name,
                inputs: this.inputs.map(r => JSON.parse(r.format(e)))
            });
        const t = [];
        return e !== "sighash" && t.push("event"),
        t.push(this.name + Kg(e, this.inputs)),
        e !== "sighash" && this.anonymous && t.push("anonymous"),
        t.join(" ")
    }
    static getTopicHash(e, t) {
        return t = (t || []).map(s => Un.from(s)),
        new Ha(nr,e,t,!1).topicHash
    }
    static from(e) {
        if (Ha.isFragment(e))
            return e;
        if (typeof e == "string")
            try {
                return Ha.from(ad(e))
            } catch {
                he(!1, "invalid event fragment", "obj", e)
            }
        else if (e instanceof Po) {
            const t = Hv("event", e)
              , r = mc(e, !0)
              , s = !!kc(e, Qs(["anonymous"])).has("anonymous");
            return If(e),
            new Ha(nr,t,r,s)
        }
        return new Ha(nr,e.name,e.inputs ? e.inputs.map(t => Un.from(t, !0)) : [],!!e.anonymous)
    }
    static isFragment(e) {
        return e && e[Di] === qI
    }
}
class cc extends Mf {
    payable;
    gas;
    constructor(e, t, r, s, i) {
        super(e, t, r),
        Object.defineProperty(this, Di, {
            value: GI
        }),
        xt(this, {
            payable: s,
            gas: i
        })
    }
    format(e) {
        if (Ie(e != null && e !== "sighash", "cannot format a constructor for sighash", "UNSUPPORTED_OPERATION", {
            operation: "format(sighash)"
        }),
        e === "json")
            return JSON.stringify({
                type: "constructor",
                stateMutability: this.payable ? "payable" : "undefined",
                payable: this.payable,
                gas: this.gas != null ? this.gas : void 0,
                inputs: this.inputs.map(r => JSON.parse(r.format(e)))
            });
        const t = [`constructor${Kg(e, this.inputs)}`];
        return this.payable && t.push("payable"),
        this.gas != null && t.push(`@${this.gas.toString()}`),
        t.join(" ")
    }
    static from(e) {
        if (cc.isFragment(e))
            return e;
        if (typeof e == "string")
            try {
                return cc.from(ad(e))
            } catch {
                he(!1, "invalid constuctor fragment", "obj", e)
            }
        else if (e instanceof Po) {
            kc(e, Qs(["constructor"]));
            const t = mc(e)
              , r = !!kc(e, Rte).has("payable")
              , s = qF(e);
            return If(e),
            new cc(nr,"constructor",t,r,s)
        }
        return new cc(nr,"constructor",e.inputs ? e.inputs.map(Un.from) : [],!!e.payable,e.gas != null ? e.gas : null)
    }
    static isFragment(e) {
        return e && e[Di] === GI
    }
}
class Xl extends Mf {
    payable;
    constructor(e, t, r) {
        super(e, "fallback", t),
        Object.defineProperty(this, Di, {
            value: WI
        }),
        xt(this, {
            payable: r
        })
    }
    format(e) {
        const t = this.inputs.length === 0 ? "receive" : "fallback";
        if (e === "json") {
            const r = this.payable ? "payable" : "nonpayable";
            return JSON.stringify({
                type: t,
                stateMutability: r
            })
        }
        return `${t}()${this.payable ? " payable" : ""}`
    }
    static from(e) {
        if (Xl.isFragment(e))
            return e;
        if (typeof e == "string")
            try {
                return Xl.from(ad(e))
            } catch {
                he(!1, "invalid fallback fragment", "obj", e)
            }
        else if (e instanceof Po) {
            const t = e.toString()
              , r = e.peekKeyword(Qs(["fallback", "receive"]));
            if (he(r, "type must be fallback or receive", "obj", t),
            e.popKeyword(Qs(["fallback", "receive"])) === "receive") {
                const a = mc(e);
                return he(a.length === 0, "receive cannot have arguments", "obj.inputs", a),
                kc(e, Qs(["payable"])),
                If(e),
                new Xl(nr,[],!0)
            }
            let i = mc(e);
            i.length ? he(i.length === 1 && i[0].type === "bytes", "invalid fallback inputs", "obj.inputs", i.map(a => a.format("minimal")).join(", ")) : i = [Un.from("bytes")];
            const o = VF(e);
            if (he(o === "nonpayable" || o === "payable", "fallback cannot be constants", "obj.stateMutability", o),
            kc(e, Qs(["returns"])).has("returns")) {
                const a = mc(e);
                he(a.length === 1 && a[0].type === "bytes", "invalid fallback outputs", "obj.outputs", a.map(l => l.format("minimal")).join(", "))
            }
            return If(e),
            new Xl(nr,i,o === "payable")
        }
        if (e.type === "receive")
            return new Xl(nr,[],!0);
        if (e.type === "fallback") {
            const t = [Un.from("bytes")]
              , r = e.stateMutability === "payable";
            return new Xl(nr,t,r)
        }
        he(!1, "invalid fallback description", "obj", e)
    }
    static isFragment(e) {
        return e && e[Di] === WI
    }
}
class Va extends Vv {
    constant;
    outputs;
    stateMutability;
    payable;
    gas;
    constructor(e, t, r, s, i, o) {
        super(e, "function", t, s),
        Object.defineProperty(this, Di, {
            value: YI
        }),
        i = Object.freeze(i.slice()),
        xt(this, {
            constant: r === "view" || r === "pure",
            gas: o,
            outputs: i,
            payable: r === "payable",
            stateMutability: r
        })
    }
    get selector() {
        return Tf(this.format("sighash")).substring(0, 10)
    }
    format(e) {
        if (e == null && (e = "sighash"),
        e === "json")
            return JSON.stringify({
                type: "function",
                name: this.name,
                constant: this.constant,
                stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
                payable: this.payable,
                gas: this.gas != null ? this.gas : void 0,
                inputs: this.inputs.map(r => JSON.parse(r.format(e))),
                outputs: this.outputs.map(r => JSON.parse(r.format(e)))
            });
        const t = [];
        return e !== "sighash" && t.push("function"),
        t.push(this.name + Kg(e, this.inputs)),
        e !== "sighash" && (this.stateMutability !== "nonpayable" && t.push(this.stateMutability),
        this.outputs && this.outputs.length && (t.push("returns"),
        t.push(Kg(e, this.outputs))),
        this.gas != null && t.push(`@${this.gas.toString()}`)),
        t.join(" ")
    }
    static getSelector(e, t) {
        return t = (t || []).map(s => Un.from(s)),
        new Va(nr,e,"view",t,[],null).selector
    }
    static from(e) {
        if (Va.isFragment(e))
            return e;
        if (typeof e == "string")
            try {
                return Va.from(ad(e))
            } catch {
                he(!1, "invalid function fragment", "obj", e)
            }
        else if (e instanceof Po) {
            const r = Hv("function", e)
              , s = mc(e)
              , i = VF(e);
            let o = [];
            kc(e, Qs(["returns"])).has("returns") && (o = mc(e));
            const a = qF(e);
            return If(e),
            new Va(nr,r,i,s,o,a)
        }
        let t = e.stateMutability;
        return t == null && (t = "payable",
        typeof e.constant == "boolean" ? (t = "view",
        e.constant || (t = "payable",
        typeof e.payable == "boolean" && !e.payable && (t = "nonpayable"))) : typeof e.payable == "boolean" && !e.payable && (t = "nonpayable")),
        new Va(nr,e.name,t,e.inputs ? e.inputs.map(Un.from) : [],e.outputs ? e.outputs.map(Un.from) : [],e.gas != null ? e.gas : null)
    }
    static isFragment(e) {
        return e && e[Di] === YI
    }
}
class xf extends Vv {
    constructor(e, t, r) {
        super(e, "struct", t, r),
        Object.defineProperty(this, Di, {
            value: KI
        })
    }
    format() {
        throw new Error("@TODO")
    }
    static from(e) {
        if (typeof e == "string")
            try {
                return xf.from(ad(e))
            } catch {
                he(!1, "invalid struct fragment", "obj", e)
            }
        else if (e instanceof Po) {
            const t = Hv("struct", e)
              , r = mc(e);
            return If(e),
            new xf(nr,t,r)
        }
        return new xf(nr,e.name,e.inputs ? e.inputs.map(Un.from) : [])
    }
    static isFragment(e) {
        return e && e[Di] === KI
    }
}
const ya = new Map;
ya.set(0, "GENERIC_PANIC");
ya.set(1, "ASSERT_FALSE");
ya.set(17, "OVERFLOW");
ya.set(18, "DIVIDE_BY_ZERO");
ya.set(33, "ENUM_RANGE_ERROR");
ya.set(34, "BAD_STORAGE_DATA");
ya.set(49, "STACK_UNDERFLOW");
ya.set(50, "ARRAY_RANGE_ERROR");
ya.set(65, "OUT_OF_MEMORY");
ya.set(81, "UNINITIALIZED_FUNCTION_CALL");
const qte = new RegExp(/^bytes([0-9]*)$/)
  , Gte = new RegExp(/^(u?int)([0-9]*)$/);
let IS = null
  , XI = 1024;
function Wte(n, e, t, r) {
    let s = "missing revert data"
      , i = null;
    const o = null;
    let a = null;
    if (t) {
        s = "execution reverted";
        const u = zt(t);
        if (t = Ke(t),
        u.length === 0)
            s += " (no data present; likely require(false) occurred",
            i = "require(false)";
        else if (u.length % 32 !== 4)
            s += " (could not decode reason; invalid data length)";
        else if (Ke(u.slice(0, 4)) === "0x08c379a0")
            try {
                i = r.decode(["string"], u.slice(4))[0],
                a = {
                    signature: "Error(string)",
                    name: "Error",
                    args: [i]
                },
                s += `: ${JSON.stringify(i)}`
            } catch {
                s += " (could not decode reason; invalid string data)"
            }
        else if (Ke(u.slice(0, 4)) === "0x4e487b71")
            try {
                const d = Number(r.decode(["uint256"], u.slice(4))[0]);
                a = {
                    signature: "Panic(uint256)",
                    name: "Panic",
                    args: [d]
                },
                i = `Panic due to ${ya.get(d) || "UNKNOWN"}(${d})`,
                s += `: ${i}`
            } catch {
                s += " (could not decode panic code)"
            }
        else
            s += " (unknown custom error)"
    }
    const l = {
        to: e.to ? yn(e.to) : null,
        data: e.data || "0x"
    };
    return e.from && (l.from = yn(e.from)),
    Zn(s, "CALL_EXCEPTION", {
        action: n,
        data: t,
        reason: i,
        transaction: l,
        invocation: o,
        revert: a
    })
}
class Qp {
    #e(e) {
        if (e.isArray())
            return new dee(this.#e(e.arrayChildren),e.arrayLength,e.name);
        if (e.isTuple())
            return new A1(e.components.map(r => this.#e(r)),e.name);
        switch (e.baseType) {
        case "address":
            return new cee(e.name);
        case "bool":
            return new fee(e.name);
        case "string":
            return new xee(e.name);
        case "bytes":
            return new hee(e.name);
        case "":
            return new gee(e.name)
        }
        let t = e.type.match(Gte);
        if (t) {
            let r = parseInt(t[2] || "256");
            return he(r !== 0 && r <= 256 && r % 8 === 0, "invalid " + t[1] + " bit length", "param", e),
            new vee(r / 8,t[1] === "int",e.name)
        }
        if (t = e.type.match(qte),
        t) {
            let r = parseInt(t[1]);
            return he(r !== 0 && r <= 32, "invalid bytes length", "param", e),
            new pee(r,e.name)
        }
        he(!1, "invalid type", "type", e.type)
    }
    getDefaultValue(e) {
        const t = e.map(s => this.#e(Un.from(s)));
        return new A1(t,"_").defaultValue()
    }
    encode(e, t) {
        bL(t.length, e.length, "types/values length mismatch");
        const r = e.map(o => this.#e(Un.from(o)))
          , s = new A1(r,"_")
          , i = new m4;
        return s.encode(i, t),
        i.data
    }
    decode(e, t, r) {
        const s = e.map(o => this.#e(Un.from(o)));
        return new A1(s,"_").decode(new B8(t,r,XI))
    }
    static _setDefaultMaxInflation(e) {
        he(typeof e == "number" && Number.isInteger(e), "invalid defaultMaxInflation factor", "value", e),
        XI = e
    }
    static defaultAbiCoder() {
        return IS == null && (IS = new Qp),
        IS
    }
    static getBuiltinCallException(e, t, r) {
        return Wte(e, t, r, Qp.defaultAbiCoder())
    }
}
class Yte {
    fragment;
    name;
    signature;
    topic;
    args;
    constructor(e, t, r) {
        const s = e.name
          , i = e.format();
        xt(this, {
            fragment: e,
            name: s,
            signature: i,
            topic: t,
            args: r
        })
    }
}
class Kte {
    fragment;
    name;
    args;
    signature;
    selector;
    value;
    constructor(e, t, r, s) {
        const i = e.name
          , o = e.format();
        xt(this, {
            fragment: e,
            name: i,
            args: r,
            signature: o,
            selector: t,
            value: s
        })
    }
}
class Xte {
    fragment;
    name;
    args;
    signature;
    selector;
    constructor(e, t, r) {
        const s = e.name
          , i = e.format();
        xt(this, {
            fragment: e,
            name: s,
            args: r,
            signature: i,
            selector: t
        })
    }
}
class QI {
    hash;
    _isIndexed;
    static isIndexed(e) {
        return !!(e && e._isIndexed)
    }
    constructor(e) {
        xt(this, {
            hash: e,
            _isIndexed: !0
        })
    }
}
const ZI = {
    0: "generic panic",
    1: "assert(false)",
    17: "arithmetic overflow",
    18: "division or modulo by zero",
    33: "enum overflow",
    34: "invalid encoded storage byte array accessed",
    49: "out-of-bounds array access; popping on an empty array",
    50: "out-of-bounds access of an array or bytesN",
    65: "out of memory",
    81: "uninitialized function"
}
  , JI = {
    "0x08c379a0": {
        signature: "Error(string)",
        name: "Error",
        inputs: ["string"],
        reason: n => `reverted with reason string ${JSON.stringify(n)}`
    },
    "0x4e487b71": {
        signature: "Panic(uint256)",
        name: "Panic",
        inputs: ["uint256"],
        reason: n => {
            let e = "unknown panic code";
            return n >= 0 && n <= 255 && ZI[n.toString()] && (e = ZI[n.toString()]),
            `reverted with panic code 0x${n.toString(16)} (${e})`
        }
    }
};
class Qd {
    fragments;
    deploy;
    fallback;
    receive;
    #e;
    #t;
    #n;
    #r;
    constructor(e) {
        let t = [];
        typeof e == "string" ? t = JSON.parse(e) : t = e,
        this.#n = new Map,
        this.#e = new Map,
        this.#t = new Map;
        const r = [];
        for (const o of t)
            try {
                r.push(Mf.from(o))
            } catch (a) {
                console.log(`[Warning] Invalid Fragment ${JSON.stringify(o)}:`, a.message)
            }
        xt(this, {
            fragments: Object.freeze(r)
        });
        let s = null
          , i = !1;
        this.#r = this.getAbiCoder(),
        this.fragments.forEach( (o, a) => {
            let l;
            switch (o.type) {
            case "constructor":
                if (this.deploy) {
                    console.log("duplicate definition - constructor");
                    return
                }
                xt(this, {
                    deploy: o
                });
                return;
            case "fallback":
                o.inputs.length === 0 ? i = !0 : (he(!s || o.payable !== s.payable, "conflicting fallback fragments", `fragments[${a}]`, o),
                s = o,
                i = s.payable);
                return;
            case "function":
                l = this.#n;
                break;
            case "event":
                l = this.#t;
                break;
            case "error":
                l = this.#e;
                break;
            default:
                return
            }
            const u = o.format();
            l.has(u) || l.set(u, o)
        }
        ),
        this.deploy || xt(this, {
            deploy: cc.from("constructor()")
        }),
        xt(this, {
            fallback: s,
            receive: i
        })
    }
    format(e) {
        const t = e ? "minimal" : "full";
        return this.fragments.map(s => s.format(t))
    }
    formatJson() {
        const e = this.fragments.map(t => t.format("json"));
        return JSON.stringify(e.map(t => JSON.parse(t)))
    }
    getAbiCoder() {
        return Qp.defaultAbiCoder()
    }
    #s(e, t, r) {
        if (zn(e)) {
            const i = e.toLowerCase();
            for (const o of this.#n.values())
                if (i === o.selector)
                    return o;
            return null
        }
        if (e.indexOf("(") === -1) {
            const i = [];
            for (const [o,a] of this.#n)
                o.split("(")[0] === e && i.push(a);
            if (t) {
                const o = t.length > 0 ? t[t.length - 1] : null;
                let a = t.length
                  , l = !0;
                mr.isTyped(o) && o.type === "overrides" && (l = !1,
                a--);
                for (let u = i.length - 1; u >= 0; u--) {
                    const d = i[u].inputs.length;
                    d !== a && (!l || d !== a - 1) && i.splice(u, 1)
                }
                for (let u = i.length - 1; u >= 0; u--) {
                    const d = i[u].inputs;
                    for (let h = 0; h < t.length; h++)
                        if (mr.isTyped(t[h])) {
                            if (h >= d.length) {
                                if (t[h].type === "overrides")
                                    continue;
                                i.splice(u, 1);
                                break
                            }
                            if (t[h].type !== d[h].baseType) {
                                i.splice(u, 1);
                                break
                            }
                        }
                }
            }
            if (i.length === 1 && t && t.length !== i[0].inputs.length) {
                const o = t[t.length - 1];
                (o == null || Array.isArray(o) || typeof o != "object") && i.splice(0, 1)
            }
            if (i.length === 0)
                return null;
            if (i.length > 1 && r) {
                const o = i.map(a => JSON.stringify(a.format())).join(", ");
                he(!1, `ambiguous function description (i.e. matches ${o})`, "key", e)
            }
            return i[0]
        }
        const s = this.#n.get(Va.from(e).format());
        return s || null
    }
    getFunctionName(e) {
        const t = this.#s(e, null, !1);
        return he(t, "no matching function", "key", e),
        t.name
    }
    hasFunction(e) {
        return !!this.#s(e, null, !1)
    }
    getFunction(e, t) {
        return this.#s(e, t || null, !0)
    }
    forEachFunction(e) {
        const t = Array.from(this.#n.keys());
        t.sort( (r, s) => r.localeCompare(s));
        for (let r = 0; r < t.length; r++) {
            const s = t[r];
            e(this.#n.get(s), r)
        }
    }
    #o(e, t, r) {
        if (zn(e)) {
            const i = e.toLowerCase();
            for (const o of this.#t.values())
                if (i === o.topicHash)
                    return o;
            return null
        }
        if (e.indexOf("(") === -1) {
            const i = [];
            for (const [o,a] of this.#t)
                o.split("(")[0] === e && i.push(a);
            if (t) {
                for (let o = i.length - 1; o >= 0; o--)
                    i[o].inputs.length < t.length && i.splice(o, 1);
                for (let o = i.length - 1; o >= 0; o--) {
                    const a = i[o].inputs;
                    for (let l = 0; l < t.length; l++)
                        if (mr.isTyped(t[l]) && t[l].type !== a[l].baseType) {
                            i.splice(o, 1);
                            break
                        }
                }
            }
            if (i.length === 0)
                return null;
            if (i.length > 1 && r) {
                const o = i.map(a => JSON.stringify(a.format())).join(", ");
                he(!1, `ambiguous event description (i.e. matches ${o})`, "key", e)
            }
            return i[0]
        }
        const s = this.#t.get(Ha.from(e).format());
        return s || null
    }
    getEventName(e) {
        const t = this.#o(e, null, !1);
        return he(t, "no matching event", "key", e),
        t.name
    }
    hasEvent(e) {
        return !!this.#o(e, null, !1)
    }
    getEvent(e, t) {
        return this.#o(e, t || null, !0)
    }
    forEachEvent(e) {
        const t = Array.from(this.#t.keys());
        t.sort( (r, s) => r.localeCompare(s));
        for (let r = 0; r < t.length; r++) {
            const s = t[r];
            e(this.#t.get(s), r)
        }
    }
    getError(e, t) {
        if (zn(e)) {
            const s = e.toLowerCase();
            if (JI[s])
                return Ei.from(JI[s].signature);
            for (const i of this.#e.values())
                if (s === i.selector)
                    return i;
            return null
        }
        if (e.indexOf("(") === -1) {
            const s = [];
            for (const [i,o] of this.#e)
                i.split("(")[0] === e && s.push(o);
            if (s.length === 0)
                return e === "Error" ? Ei.from("error Error(string)") : e === "Panic" ? Ei.from("error Panic(uint256)") : null;
            if (s.length > 1) {
                const i = s.map(o => JSON.stringify(o.format())).join(", ");
                he(!1, `ambiguous error description (i.e. ${i})`, "name", e)
            }
            return s[0]
        }
        if (e = Ei.from(e).format(),
        e === "Error(string)")
            return Ei.from("error Error(string)");
        if (e === "Panic(uint256)")
            return Ei.from("error Panic(uint256)");
        const r = this.#e.get(e);
        return r || null
    }
    forEachError(e) {
        const t = Array.from(this.#e.keys());
        t.sort( (r, s) => r.localeCompare(s));
        for (let r = 0; r < t.length; r++) {
            const s = t[r];
            e(this.#e.get(s), r)
        }
    }
    _decodeParams(e, t) {
        return this.#r.decode(e, t)
    }
    _encodeParams(e, t) {
        return this.#r.encode(e, t)
    }
    encodeDeploy(e) {
        return this._encodeParams(this.deploy.inputs, e || [])
    }
    decodeErrorResult(e, t) {
        if (typeof e == "string") {
            const r = this.getError(e);
            he(r, "unknown error", "fragment", e),
            e = r
        }
        return he(fr(t, 0, 4) === e.selector, `data signature does not match error ${e.name}.`, "data", t),
        this._decodeParams(e.inputs, fr(t, 4))
    }
    encodeErrorResult(e, t) {
        if (typeof e == "string") {
            const r = this.getError(e);
            he(r, "unknown error", "fragment", e),
            e = r
        }
        return gr([e.selector, this._encodeParams(e.inputs, t || [])])
    }
    decodeFunctionData(e, t) {
        if (typeof e == "string") {
            const r = this.getFunction(e);
            he(r, "unknown function", "fragment", e),
            e = r
        }
        return he(fr(t, 0, 4) === e.selector, `data signature does not match function ${e.name}.`, "data", t),
        this._decodeParams(e.inputs, fr(t, 4))
    }
    encodeFunctionData(e, t) {
        if (typeof e == "string") {
            const r = this.getFunction(e);
            he(r, "unknown function", "fragment", e),
            e = r
        }
        return gr([e.selector, this._encodeParams(e.inputs, t || [])])
    }
    decodeFunctionResult(e, t) {
        if (typeof e == "string") {
            const i = this.getFunction(e);
            he(i, "unknown function", "fragment", e),
            e = i
        }
        let r = "invalid length for result data";
        const s = Ws(t);
        if (s.length % 32 === 0)
            try {
                return this.#r.decode(e.outputs, s)
            } catch {
                r = "could not decode result data"
            }
        Ie(!1, r, "BAD_DATA", {
            value: Ke(s),
            info: {
                method: e.name,
                signature: e.format()
            }
        })
    }
    makeError(e, t) {
        const r = zt(e, "data")
          , s = Qp.getBuiltinCallException("call", t, r);
        if (s.message.startsWith("execution reverted (unknown custom error)")) {
            const a = Ke(r.slice(0, 4))
              , l = this.getError(a);
            if (l)
                try {
                    const u = this.#r.decode(l.inputs, r.slice(4));
                    s.revert = {
                        name: l.name,
                        signature: l.format(),
                        args: u
                    },
                    s.reason = s.revert.signature,
                    s.message = `execution reverted: ${s.reason}`
                } catch {
                    s.message = "execution reverted (coult not decode custom error)"
                }
        }
        const o = this.parseTransaction(t);
        return o && (s.invocation = {
            method: o.name,
            signature: o.signature,
            args: o.args
        }),
        s
    }
    encodeFunctionResult(e, t) {
        if (typeof e == "string") {
            const r = this.getFunction(e);
            he(r, "unknown function", "fragment", e),
            e = r
        }
        return Ke(this.#r.encode(e.outputs, t || []))
    }
    encodeFilterTopics(e, t) {
        if (typeof e == "string") {
            const i = this.getEvent(e);
            he(i, "unknown event", "eventFragment", e),
            e = i
        }
        Ie(t.length <= e.inputs.length, `too many arguments for ${e.format()}`, "UNEXPECTED_ARGUMENT", {
            count: t.length,
            expectedCount: e.inputs.length
        });
        const r = [];
        e.anonymous || r.push(e.topicHash);
        const s = (i, o) => i.type === "string" ? Tf(o) : i.type === "bytes" ? Fr(Ke(o)) : (i.type === "bool" && typeof o == "boolean" ? o = o ? "0x01" : "0x00" : i.type.match(/^u?int/) ? o = Ku(o) : i.type.match(/^bytes/) ? o = dZ(o, 32) : i.type === "address" && this.#r.encode(["address"], [o]),
        Cc(Ke(o), 32));
        for (t.forEach( (i, o) => {
            const a = e.inputs[o];
            if (!a.indexed) {
                he(i == null, "cannot filter non-indexed parameters; must be null", "contract." + a.name, i);
                return
            }
            i == null ? r.push(null) : a.baseType === "array" || a.baseType === "tuple" ? he(!1, "filtering with tuples or arrays not supported", "contract." + a.name, i) : Array.isArray(i) ? r.push(i.map(l => s(a, l))) : r.push(s(a, i))
        }
        ); r.length && r[r.length - 1] === null; )
            r.pop();
        return r
    }
    encodeEventLog(e, t) {
        if (typeof e == "string") {
            const o = this.getEvent(e);
            he(o, "unknown event", "eventFragment", e),
            e = o
        }
        const r = []
          , s = []
          , i = [];
        return e.anonymous || r.push(e.topicHash),
        he(t.length === e.inputs.length, "event arguments/values mismatch", "values", t),
        e.inputs.forEach( (o, a) => {
            const l = t[a];
            if (o.indexed)
                if (o.type === "string")
                    r.push(Tf(l));
                else if (o.type === "bytes")
                    r.push(Fr(l));
                else {
                    if (o.baseType === "tuple" || o.baseType === "array")
                        throw new Error("not implemented");
                    r.push(this.#r.encode([o.type], [l]))
                }
            else
                s.push(o),
                i.push(l)
        }
        ),
        {
            data: this.#r.encode(s, i),
            topics: r
        }
    }
    decodeEventLog(e, t, r) {
        if (typeof e == "string") {
            const g = this.getEvent(e);
            he(g, "unknown event", "eventFragment", e),
            e = g
        }
        if (r != null && !e.anonymous) {
            const g = e.topicHash;
            he(zn(r[0], 32) && r[0].toLowerCase() === g, "fragment/topic mismatch", "topics[0]", r[0]),
            r = r.slice(1)
        }
        const s = []
          , i = []
          , o = [];
        e.inputs.forEach( (g, w) => {
            g.indexed ? g.type === "string" || g.type === "bytes" || g.baseType === "tuple" || g.baseType === "array" ? (s.push(Un.from({
                type: "bytes32",
                name: g.name
            })),
            o.push(!0)) : (s.push(g),
            o.push(!1)) : (i.push(g),
            o.push(!1))
        }
        );
        const a = r != null ? this.#r.decode(s, gr(r)) : null
          , l = this.#r.decode(i, t, !0)
          , u = []
          , d = [];
        let h = 0
          , p = 0;
        return e.inputs.forEach( (g, w) => {
            let b = null;
            if (g.indexed)
                if (a == null)
                    b = new QI(null);
                else if (o[w])
                    b = new QI(a[p++]);
                else
                    try {
                        b = a[p++]
                    } catch (v) {
                        b = v
                    }
            else
                try {
                    b = l[h++]
                } catch (v) {
                    b = v
                }
            u.push(b),
            d.push(g.name || null)
        }
        ),
        lc.fromItems(u, d)
    }
    parseTransaction(e) {
        const t = zt(e.data, "tx.data")
          , r = nt(e.value != null ? e.value : 0, "tx.value")
          , s = this.getFunction(Ke(t.slice(0, 4)));
        if (!s)
            return null;
        const i = this.#r.decode(s.inputs, t.slice(4));
        return new Kte(s,s.selector,i,r)
    }
    parseCallResult(e) {
        throw new Error("@TODO")
    }
    parseLog(e) {
        const t = this.getEvent(e.topics[0]);
        return !t || t.anonymous ? null : new Yte(t,t.topicHash,this.decodeEventLog(t, e.data, e.topics))
    }
    parseError(e) {
        const t = Ke(e)
          , r = this.getError(fr(t, 0, 4));
        if (!r)
            return null;
        const s = this.#r.decode(r.inputs, fr(t, 4));
        return new Xte(r,r.selector,s)
    }
    static from(e) {
        return e instanceof Qd ? e : typeof e == "string" ? new Qd(JSON.parse(e)) : typeof e.formatJson == "function" ? new Qd(e.formatJson()) : typeof e.format == "function" ? new Qd(e.format("json")) : new Qd(e)
    }
}
const GF = BigInt(0);
function _p(n) {
    return n ?? null
}
function xr(n) {
    return n == null ? null : n.toString()
}
class eM {
    gasPrice;
    maxFeePerGas;
    maxPriorityFeePerGas;
    constructor(e, t, r) {
        xt(this, {
            gasPrice: _p(e),
            maxFeePerGas: _p(t),
            maxPriorityFeePerGas: _p(r)
        })
    }
    toJSON() {
        const {gasPrice: e, maxFeePerGas: t, maxPriorityFeePerGas: r} = this;
        return {
            _type: "FeeData",
            gasPrice: xr(e),
            maxFeePerGas: xr(t),
            maxPriorityFeePerGas: xr(r)
        }
    }
}
function y2(n) {
    const e = {};
    n.to && (e.to = n.to),
    n.from && (e.from = n.from),
    n.data && (e.data = Ke(n.data));
    const t = "chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value".split(/,/);
    for (const s of t)
        !(s in n) || n[s] == null || (e[s] = nt(n[s], `request.${s}`));
    const r = "type,nonce".split(/,/);
    for (const s of r)
        !(s in n) || n[s] == null || (e[s] = Bt(n[s], `request.${s}`));
    return n.accessList && (e.accessList = $f(n.accessList)),
    n.authorizationList && (e.authorizationList = n.authorizationList.slice()),
    "blockTag"in n && (e.blockTag = n.blockTag),
    "enableCcipRead"in n && (e.enableCcipRead = !!n.enableCcipRead),
    "customData"in n && (e.customData = n.customData),
    "blobVersionedHashes"in n && n.blobVersionedHashes && (e.blobVersionedHashes = n.blobVersionedHashes.slice()),
    "kzg"in n && (e.kzg = n.kzg),
    "blobs"in n && n.blobs && (e.blobs = n.blobs.map(s => M8(s) ? Ke(s) : Object.assign({}, s))),
    e
}
class Qte {
    provider;
    number;
    hash;
    timestamp;
    parentHash;
    parentBeaconBlockRoot;
    nonce;
    difficulty;
    gasLimit;
    gasUsed;
    stateRoot;
    receiptsRoot;
    blobGasUsed;
    excessBlobGas;
    miner;
    prevRandao;
    extraData;
    baseFeePerGas;
    #e;
    constructor(e, t) {
        this.#e = e.transactions.map(r => typeof r != "string" ? new ky(r,t) : r),
        xt(this, {
            provider: t,
            hash: _p(e.hash),
            number: e.number,
            timestamp: e.timestamp,
            parentHash: e.parentHash,
            parentBeaconBlockRoot: e.parentBeaconBlockRoot,
            nonce: e.nonce,
            difficulty: e.difficulty,
            gasLimit: e.gasLimit,
            gasUsed: e.gasUsed,
            blobGasUsed: e.blobGasUsed,
            excessBlobGas: e.excessBlobGas,
            miner: e.miner,
            prevRandao: _p(e.prevRandao),
            extraData: e.extraData,
            baseFeePerGas: _p(e.baseFeePerGas),
            stateRoot: e.stateRoot,
            receiptsRoot: e.receiptsRoot
        })
    }
    get transactions() {
        return this.#e.map(e => typeof e == "string" ? e : e.hash)
    }
    get prefetchedTransactions() {
        const e = this.#e.slice();
        return e.length === 0 ? [] : (Ie(typeof e[0] == "object", "transactions were not prefetched with block request", "UNSUPPORTED_OPERATION", {
            operation: "transactionResponses()"
        }),
        e)
    }
    toJSON() {
        const {baseFeePerGas: e, difficulty: t, extraData: r, gasLimit: s, gasUsed: i, hash: o, miner: a, prevRandao: l, nonce: u, number: d, parentHash: h, parentBeaconBlockRoot: p, stateRoot: g, receiptsRoot: w, timestamp: b, transactions: v} = this;
        return {
            _type: "Block",
            baseFeePerGas: xr(e),
            difficulty: xr(t),
            extraData: r,
            gasLimit: xr(s),
            gasUsed: xr(i),
            blobGasUsed: xr(this.blobGasUsed),
            excessBlobGas: xr(this.excessBlobGas),
            hash: o,
            miner: a,
            prevRandao: l,
            nonce: u,
            number: d,
            parentHash: h,
            timestamp: b,
            parentBeaconBlockRoot: p,
            stateRoot: g,
            receiptsRoot: w,
            transactions: v
        }
    }
    [Symbol.iterator]() {
        let e = 0;
        const t = this.transactions;
        return {
            next: () => e < this.length ? {
                value: t[e++],
                done: !1
            } : {
                value: void 0,
                done: !0
            }
        }
    }
    get length() {
        return this.#e.length
    }
    get date() {
        return this.timestamp == null ? null : new Date(this.timestamp * 1e3)
    }
    async getTransaction(e) {
        let t;
        if (typeof e == "number")
            t = this.#e[e];
        else {
            const r = e.toLowerCase();
            for (const s of this.#e)
                if (typeof s == "string") {
                    if (s !== r)
                        continue;
                    t = s;
                    break
                } else {
                    if (s.hash !== r)
                        continue;
                    t = s;
                    break
                }
        }
        if (t == null)
            throw new Error("no such tx");
        return typeof t == "string" ? await this.provider.getTransaction(t) : t
    }
    getPrefetchedTransaction(e) {
        const t = this.prefetchedTransactions;
        if (typeof e == "number")
            return t[e];
        e = e.toLowerCase();
        for (const r of t)
            if (r.hash === e)
                return r;
        he(!1, "no matching transaction", "indexOrHash", e)
    }
    isMined() {
        return !!this.hash
    }
    isLondon() {
        return !!this.baseFeePerGas
    }
    orphanedEvent() {
        if (!this.isMined())
            throw new Error("");
        return Zte(this)
    }
}
class _y {
    provider;
    transactionHash;
    blockHash;
    blockNumber;
    removed;
    address;
    data;
    topics;
    index;
    transactionIndex;
    constructor(e, t) {
        this.provider = t;
        const r = Object.freeze(e.topics.slice());
        xt(this, {
            transactionHash: e.transactionHash,
            blockHash: e.blockHash,
            blockNumber: e.blockNumber,
            removed: e.removed,
            address: e.address,
            data: e.data,
            topics: r,
            index: e.index,
            transactionIndex: e.transactionIndex
        })
    }
    toJSON() {
        const {address: e, blockHash: t, blockNumber: r, data: s, index: i, removed: o, topics: a, transactionHash: l, transactionIndex: u} = this;
        return {
            _type: "log",
            address: e,
            blockHash: t,
            blockNumber: r,
            data: s,
            index: i,
            removed: o,
            topics: a,
            transactionHash: l,
            transactionIndex: u
        }
    }
    async getBlock() {
        const e = await this.provider.getBlock(this.blockHash);
        return Ie(!!e, "failed to find transaction", "UNKNOWN_ERROR", {}),
        e
    }
    async getTransaction() {
        const e = await this.provider.getTransaction(this.transactionHash);
        return Ie(!!e, "failed to find transaction", "UNKNOWN_ERROR", {}),
        e
    }
    async getTransactionReceipt() {
        const e = await this.provider.getTransactionReceipt(this.transactionHash);
        return Ie(!!e, "failed to find transaction receipt", "UNKNOWN_ERROR", {}),
        e
    }
    removedEvent() {
        return Jte(this)
    }
}
class WF {
    provider;
    to;
    from;
    contractAddress;
    hash;
    index;
    blockHash;
    blockNumber;
    logsBloom;
    gasUsed;
    blobGasUsed;
    cumulativeGasUsed;
    gasPrice;
    blobGasPrice;
    type;
    status;
    root;
    #e;
    constructor(e, t) {
        this.#e = Object.freeze(e.logs.map(s => new _y(s,t)));
        let r = GF;
        e.effectiveGasPrice != null ? r = e.effectiveGasPrice : e.gasPrice != null && (r = e.gasPrice),
        xt(this, {
            provider: t,
            to: e.to,
            from: e.from,
            contractAddress: e.contractAddress,
            hash: e.hash,
            index: e.index,
            blockHash: e.blockHash,
            blockNumber: e.blockNumber,
            logsBloom: e.logsBloom,
            gasUsed: e.gasUsed,
            cumulativeGasUsed: e.cumulativeGasUsed,
            blobGasUsed: e.blobGasUsed,
            gasPrice: r,
            blobGasPrice: e.blobGasPrice,
            type: e.type,
            status: e.status,
            root: e.root
        })
    }
    get logs() {
        return this.#e
    }
    toJSON() {
        const {to: e, from: t, contractAddress: r, hash: s, index: i, blockHash: o, blockNumber: a, logsBloom: l, logs: u, status: d, root: h} = this;
        return {
            _type: "TransactionReceipt",
            blockHash: o,
            blockNumber: a,
            contractAddress: r,
            cumulativeGasUsed: xr(this.cumulativeGasUsed),
            from: t,
            gasPrice: xr(this.gasPrice),
            blobGasUsed: xr(this.blobGasUsed),
            blobGasPrice: xr(this.blobGasPrice),
            gasUsed: xr(this.gasUsed),
            hash: s,
            index: i,
            logs: u,
            logsBloom: l,
            root: h,
            status: d,
            to: e
        }
    }
    get length() {
        return this.logs.length
    }
    [Symbol.iterator]() {
        let e = 0;
        return {
            next: () => e < this.length ? {
                value: this.logs[e++],
                done: !1
            } : {
                value: void 0,
                done: !0
            }
        }
    }
    get fee() {
        return this.gasUsed * this.gasPrice
    }
    async getBlock() {
        const e = await this.provider.getBlock(this.blockHash);
        if (e == null)
            throw new Error("TODO");
        return e
    }
    async getTransaction() {
        const e = await this.provider.getTransaction(this.hash);
        if (e == null)
            throw new Error("TODO");
        return e
    }
    async getResult() {
        return await this.provider.getTransactionResult(this.hash)
    }
    async confirmations() {
        return await this.provider.getBlockNumber() - this.blockNumber + 1
    }
    removedEvent() {
        return KF(this)
    }
    reorderedEvent(e) {
        return Ie(!e || e.isMined(), "unmined 'other' transction cannot be orphaned", "UNSUPPORTED_OPERATION", {
            operation: "reorderedEvent(other)"
        }),
        YF(this, e)
    }
}
class ky {
    provider;
    blockNumber;
    blockHash;
    index;
    hash;
    type;
    to;
    from;
    nonce;
    gasLimit;
    gasPrice;
    maxPriorityFeePerGas;
    maxFeePerGas;
    maxFeePerBlobGas;
    data;
    value;
    chainId;
    signature;
    accessList;
    blobVersionedHashes;
    authorizationList;
    #e;
    constructor(e, t) {
        this.provider = t,
        this.blockNumber = e.blockNumber != null ? e.blockNumber : null,
        this.blockHash = e.blockHash != null ? e.blockHash : null,
        this.hash = e.hash,
        this.index = e.index,
        this.type = e.type,
        this.from = e.from,
        this.to = e.to || null,
        this.gasLimit = e.gasLimit,
        this.nonce = e.nonce,
        this.data = e.data,
        this.value = e.value,
        this.gasPrice = e.gasPrice,
        this.maxPriorityFeePerGas = e.maxPriorityFeePerGas != null ? e.maxPriorityFeePerGas : null,
        this.maxFeePerGas = e.maxFeePerGas != null ? e.maxFeePerGas : null,
        this.maxFeePerBlobGas = e.maxFeePerBlobGas != null ? e.maxFeePerBlobGas : null,
        this.chainId = e.chainId,
        this.signature = e.signature,
        this.accessList = e.accessList != null ? e.accessList : null,
        this.blobVersionedHashes = e.blobVersionedHashes != null ? e.blobVersionedHashes : null,
        this.authorizationList = e.authorizationList != null ? e.authorizationList : null,
        this.#e = -1
    }
    toJSON() {
        const {blockNumber: e, blockHash: t, index: r, hash: s, type: i, to: o, from: a, nonce: l, data: u, signature: d, accessList: h, blobVersionedHashes: p} = this;
        return {
            _type: "TransactionResponse",
            accessList: h,
            blockNumber: e,
            blockHash: t,
            blobVersionedHashes: p,
            chainId: xr(this.chainId),
            data: u,
            from: a,
            gasLimit: xr(this.gasLimit),
            gasPrice: xr(this.gasPrice),
            hash: s,
            maxFeePerGas: xr(this.maxFeePerGas),
            maxPriorityFeePerGas: xr(this.maxPriorityFeePerGas),
            maxFeePerBlobGas: xr(this.maxFeePerBlobGas),
            nonce: l,
            signature: d,
            to: o,
            index: r,
            type: i,
            value: xr(this.value)
        }
    }
    async getBlock() {
        let e = this.blockNumber;
        if (e == null) {
            const r = await this.getTransaction();
            r && (e = r.blockNumber)
        }
        if (e == null)
            return null;
        const t = this.provider.getBlock(e);
        if (t == null)
            throw new Error("TODO");
        return t
    }
    async getTransaction() {
        return this.provider.getTransaction(this.hash)
    }
    async confirmations() {
        if (this.blockNumber == null) {
            const {tx: t, blockNumber: r} = await qs({
                tx: this.getTransaction(),
                blockNumber: this.provider.getBlockNumber()
            });
            return t == null || t.blockNumber == null ? 0 : r - t.blockNumber + 1
        }
        return await this.provider.getBlockNumber() - this.blockNumber + 1
    }
    async wait(e, t) {
        const r = e ?? 1
          , s = t ?? 0;
        let i = this.#e
          , o = -1
          , a = i === -1;
        const l = async () => {
            if (a)
                return null;
            const {blockNumber: p, nonce: g} = await qs({
                blockNumber: this.provider.getBlockNumber(),
                nonce: this.provider.getTransactionCount(this.from)
            });
            if (g < this.nonce) {
                i = p;
                return
            }
            if (a)
                return null;
            const w = await this.getTransaction();
            if (!(w && w.blockNumber != null))
                for (o === -1 && (o = i - 3,
                o < this.#e && (o = this.#e)); o <= p; ) {
                    if (a)
                        return null;
                    const b = await this.provider.getBlock(o, !0);
                    if (b == null)
                        return;
                    for (const v of b)
                        if (v === this.hash)
                            return;
                    for (let v = 0; v < b.length; v++) {
                        const S = await b.getTransaction(v);
                        if (S.from === this.from && S.nonce === this.nonce) {
                            if (a)
                                return null;
                            const N = await this.provider.getTransactionReceipt(S.hash);
                            if (N == null || p - N.blockNumber + 1 < r)
                                return;
                            let _ = "replaced";
                            S.data === this.data && S.to === this.to && S.value === this.value ? _ = "repriced" : S.data === "0x" && S.from === S.to && S.value === GF && (_ = "cancelled"),
                            Ie(!1, "transaction was replaced", "TRANSACTION_REPLACED", {
                                cancelled: _ === "replaced" || _ === "cancelled",
                                reason: _,
                                replacement: S.replaceableTransaction(i),
                                hash: S.hash,
                                receipt: N
                            })
                        }
                    }
                    o++
                }
        }
          , u = p => {
            if (p == null || p.status !== 0)
                return p;
            Ie(!1, "transaction execution reverted", "CALL_EXCEPTION", {
                action: "sendTransaction",
                data: null,
                reason: null,
                invocation: null,
                revert: null,
                transaction: {
                    to: p.to,
                    from: p.from,
                    data: ""
                },
                receipt: p
            })
        }
          , d = await this.provider.getTransactionReceipt(this.hash);
        if (r === 0)
            return u(d);
        if (d) {
            if (r === 1 || await d.confirmations() >= r)
                return u(d)
        } else if (await l(),
        r === 0)
            return null;
        return await new Promise( (p, g) => {
            const w = []
              , b = () => {
                w.forEach(S => S())
            }
            ;
            if (w.push( () => {
                a = !0
            }
            ),
            s > 0) {
                const S = setTimeout( () => {
                    b(),
                    g(Zn("wait for transaction timeout", "TIMEOUT"))
                }
                , s);
                w.push( () => {
                    clearTimeout(S)
                }
                )
            }
            const v = async S => {
                if (await S.confirmations() >= r) {
                    b();
                    try {
                        p(u(S))
                    } catch (N) {
                        g(N)
                    }
                }
            }
            ;
            if (w.push( () => {
                this.provider.off(this.hash, v)
            }
            ),
            this.provider.on(this.hash, v),
            i >= 0) {
                const S = async () => {
                    try {
                        await l()
                    } catch (N) {
                        if (xs(N, "TRANSACTION_REPLACED")) {
                            b(),
                            g(N);
                            return
                        }
                    }
                    a || this.provider.once("block", S)
                }
                ;
                w.push( () => {
                    this.provider.off("block", S)
                }
                ),
                this.provider.once("block", S)
            }
        }
        )
    }
    isMined() {
        return this.blockHash != null
    }
    isLegacy() {
        return this.type === 0
    }
    isBerlin() {
        return this.type === 1
    }
    isLondon() {
        return this.type === 2
    }
    isCancun() {
        return this.type === 3
    }
    removedEvent() {
        return Ie(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", {
            operation: "removeEvent()"
        }),
        KF(this)
    }
    reorderedEvent(e) {
        return Ie(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", {
            operation: "removeEvent()"
        }),
        Ie(!e || e.isMined(), "unmined 'other' transaction canot be orphaned", "UNSUPPORTED_OPERATION", {
            operation: "removeEvent()"
        }),
        YF(this, e)
    }
    replaceableTransaction(e) {
        he(Number.isInteger(e) && e >= 0, "invalid startBlock", "startBlock", e);
        const t = new ky(this,this.provider);
        return t.#e = e,
        t
    }
}
function Zte(n) {
    return {
        orphan: "drop-block",
        hash: n.hash,
        number: n.number
    }
}
function YF(n, e) {
    return {
        orphan: "reorder-transaction",
        tx: n,
        other: e
    }
}
function KF(n) {
    return {
        orphan: "drop-transaction",
        tx: n
    }
}
function Jte(n) {
    return {
        orphan: "drop-log",
        log: {
            transactionHash: n.transactionHash,
            blockHash: n.blockHash,
            blockNumber: n.blockNumber,
            address: n.address,
            data: n.data,
            topics: Object.freeze(n.topics.slice()),
            index: n.index
        }
    }
}
class q8 extends _y {
    interface;
    fragment;
    args;
    constructor(e, t, r) {
        super(e, e.provider);
        const s = t.decodeEventLog(r, e.data, e.topics);
        xt(this, {
            args: s,
            fragment: r,
            interface: t
        })
    }
    get eventName() {
        return this.fragment.name
    }
    get eventSignature() {
        return this.fragment.format()
    }
}
class XF extends _y {
    error;
    constructor(e, t) {
        super(e, e.provider),
        xt(this, {
            error: t
        })
    }
}
class ene extends WF {
    #e;
    constructor(e, t, r) {
        super(r, t),
        this.#e = e
    }
    get logs() {
        return super.logs.map(e => {
            const t = e.topics.length ? this.#e.getEvent(e.topics[0]) : null;
            if (t)
                try {
                    return new q8(e,this.#e,t)
                } catch (r) {
                    return new XF(e,r)
                }
            return e
        }
        )
    }
}
class G8 extends ky {
    #e;
    constructor(e, t, r) {
        super(r, t),
        this.#e = e
    }
    async wait(e, t) {
        const r = await super.wait(e, t);
        return r == null ? null : new ene(this.#e,this.provider,r)
    }
}
class QF extends EL {
    log;
    constructor(e, t, r, s) {
        super(e, t, r),
        xt(this, {
            log: s
        })
    }
    async getBlock() {
        return await this.log.getBlock()
    }
    async getTransaction() {
        return await this.log.getTransaction()
    }
    async getTransactionReceipt() {
        return await this.log.getTransactionReceipt()
    }
}
class tne extends QF {
    constructor(e, t, r, s, i) {
        super(e, t, r, new q8(i,e.interface,s));
        const o = e.interface.decodeEventLog(s, this.log.data, this.log.topics);
        xt(this, {
            args: o,
            fragment: s
        })
    }
    get eventName() {
        return this.fragment.name
    }
    get eventSignature() {
        return this.fragment.format()
    }
}
const tM = BigInt(0);
function ZF(n) {
    return n && typeof n.call == "function"
}
function JF(n) {
    return n && typeof n.estimateGas == "function"
}
function qv(n) {
    return n && typeof n.resolveName == "function"
}
function eU(n) {
    return n && typeof n.sendTransaction == "function"
}
function tU(n) {
    if (n != null) {
        if (qv(n))
            return n;
        if (n.provider)
            return n.provider
    }
}
class nne {
    #e;
    fragment;
    constructor(e, t, r) {
        if (xt(this, {
            fragment: t
        }),
        t.inputs.length < r.length)
            throw new Error("too many arguments");
        const s = Bf(e.runner, "resolveName")
          , i = qv(s) ? s : null;
        this.#e = (async function() {
            const o = await Promise.all(t.inputs.map( (a, l) => r[l] == null ? null : a.walkAsync(r[l], (d, h) => d === "address" ? Array.isArray(h) ? Promise.all(h.map(p => Xs(p, i))) : Xs(h, i) : h)));
            return e.interface.encodeFilterTopics(t, o)
        }
        )()
    }
    getTopicFilter() {
        return this.#e
    }
}
function Bf(n, e) {
    return n == null ? null : typeof n[e] == "function" ? n : n.provider && typeof n.provider[e] == "function" ? n.provider : null
}
function sf(n) {
    return n == null ? null : n.provider || null
}
async function nU(n, e) {
    const t = mr.dereference(n, "overrides");
    he(typeof t == "object", "invalid overrides parameter", "overrides", n);
    const r = y2(t);
    return he(r.to == null || (e || []).indexOf("to") >= 0, "cannot override to", "overrides.to", r.to),
    he(r.data == null || (e || []).indexOf("data") >= 0, "cannot override data", "overrides.data", r.data),
    r.from && (r.from = r.from),
    r
}
async function rne(n, e, t) {
    const r = Bf(n, "resolveName")
      , s = qv(r) ? r : null;
    return await Promise.all(e.map( (i, o) => i.walkAsync(t[o], (a, l) => (l = mr.dereference(l, a),
    a === "address" ? Xs(l, s) : l))))
}
function sne(n) {
    const e = async function(o) {
        const a = await nU(o, ["data"]);
        a.to = await n.getAddress(),
        a.from && (a.from = await Xs(a.from, tU(n.runner)));
        const l = n.interface
          , u = nt(a.value || tM, "overrides.value") === tM
          , d = (a.data || "0x") === "0x";
        l.fallback && !l.fallback.payable && l.receive && !d && !u && he(!1, "cannot send data to receive or send value to non-payable fallback", "overrides", o),
        he(l.fallback || d, "cannot send data to receive-only contract", "overrides.data", a.data);
        const h = l.receive || l.fallback && l.fallback.payable;
        return he(h || u, "cannot send value to non-payable fallback", "overrides.value", a.value),
        he(l.fallback || d, "cannot send data to receive-only contract", "overrides.data", a.data),
        a
    }
      , t = async function(o) {
        const a = Bf(n.runner, "call");
        Ie(ZF(a), "contract runner does not support calling", "UNSUPPORTED_OPERATION", {
            operation: "call"
        });
        const l = await e(o);
        try {
            return await a.call(l)
        } catch (u) {
            throw I8(u) && u.data ? n.interface.makeError(u.data, l) : u
        }
    }
      , r = async function(o) {
        const a = n.runner;
        Ie(eU(a), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", {
            operation: "sendTransaction"
        });
        const l = await a.sendTransaction(await e(o))
          , u = sf(n.runner);
        return new G8(n.interface,u,l)
    }
      , s = async function(o) {
        const a = Bf(n.runner, "estimateGas");
        return Ie(JF(a), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", {
            operation: "estimateGas"
        }),
        await a.estimateGas(await e(o))
    }
      , i = async o => await r(o);
    return xt(i, {
        _contract: n,
        estimateGas: s,
        populateTransaction: e,
        send: r,
        staticCall: t
    }),
    i
}
function ine(n, e) {
    const t = function(...u) {
        const d = n.interface.getFunction(e, u);
        return Ie(d, "no matching fragment", "UNSUPPORTED_OPERATION", {
            operation: "fragment",
            info: {
                key: e,
                args: u
            }
        }),
        d
    }
      , r = async function(...u) {
        const d = t(...u);
        let h = {};
        if (d.inputs.length + 1 === u.length && (h = await nU(u.pop()),
        h.from && (h.from = await Xs(h.from, tU(n.runner)))),
        d.inputs.length !== u.length)
            throw new Error("internal error: fragment inputs doesn't match arguments; should not happen");
        const p = await rne(n.runner, d.inputs, u);
        return Object.assign({}, h, await qs({
            to: n.getAddress(),
            data: n.interface.encodeFunctionData(d, p)
        }))
    }
      , s = async function(...u) {
        const d = await a(...u);
        return d.length === 1 ? d[0] : d
    }
      , i = async function(...u) {
        const d = n.runner;
        Ie(eU(d), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", {
            operation: "sendTransaction"
        });
        const h = await d.sendTransaction(await r(...u))
          , p = sf(n.runner);
        return new G8(n.interface,p,h)
    }
      , o = async function(...u) {
        const d = Bf(n.runner, "estimateGas");
        return Ie(JF(d), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", {
            operation: "estimateGas"
        }),
        await d.estimateGas(await r(...u))
    }
      , a = async function(...u) {
        const d = Bf(n.runner, "call");
        Ie(ZF(d), "contract runner does not support calling", "UNSUPPORTED_OPERATION", {
            operation: "call"
        });
        const h = await r(...u);
        let p = "0x";
        try {
            p = await d.call(h)
        } catch (w) {
            throw I8(w) && w.data ? n.interface.makeError(w.data, h) : w
        }
        const g = t(...u);
        return n.interface.decodeFunctionResult(g, p)
    }
      , l = async (...u) => t(...u).constant ? await s(...u) : await i(...u);
    return xt(l, {
        name: n.interface.getFunctionName(e),
        _contract: n,
        _key: e,
        getFragment: t,
        estimateGas: o,
        populateTransaction: r,
        send: i,
        staticCall: s,
        staticCallResult: a
    }),
    Object.defineProperty(l, "fragment", {
        configurable: !1,
        enumerable: !0,
        get: () => {
            const u = n.interface.getFunction(e);
            return Ie(u, "no matching fragment", "UNSUPPORTED_OPERATION", {
                operation: "fragment",
                info: {
                    key: e
                }
            }),
            u
        }
    }),
    l
}
function one(n, e) {
    const t = function(...s) {
        const i = n.interface.getEvent(e, s);
        return Ie(i, "no matching fragment", "UNSUPPORTED_OPERATION", {
            operation: "fragment",
            info: {
                key: e,
                args: s
            }
        }),
        i
    }
      , r = function(...s) {
        return new nne(n,t(...s),s)
    };
    return xt(r, {
        name: n.interface.getEventName(e),
        _contract: n,
        _key: e,
        getFragment: t
    }),
    Object.defineProperty(r, "fragment", {
        configurable: !1,
        enumerable: !0,
        get: () => {
            const s = n.interface.getEvent(e);
            return Ie(s, "no matching fragment", "UNSUPPORTED_OPERATION", {
                operation: "fragment",
                info: {
                    key: e
                }
            }),
            s
        }
    }),
    r
}
const b2 = Symbol.for("_ethersInternal_contract")
  , rU = new WeakMap;
function ane(n, e) {
    rU.set(n[b2], e)
}
function qi(n) {
    return rU.get(n[b2])
}
function lne(n) {
    return n && typeof n == "object" && "getTopicFilter"in n && typeof n.getTopicFilter == "function" && n.fragment
}
async function W8(n, e) {
    let t, r = null;
    if (Array.isArray(e)) {
        const i = function(o) {
            if (zn(o, 32))
                return o;
            const a = n.interface.getEvent(o);
            return he(a, "unknown fragment", "name", o),
            a.topicHash
        };
        t = e.map(o => o == null ? null : Array.isArray(o) ? o.map(i) : i(o))
    } else
        e === "*" ? t = [null] : typeof e == "string" ? zn(e, 32) ? t = [e] : (r = n.interface.getEvent(e),
        he(r, "unknown fragment", "event", e),
        t = [r.topicHash]) : lne(e) ? t = await e.getTopicFilter() : "fragment"in e ? (r = e.fragment,
        t = [r.topicHash]) : he(!1, "unknown event name", "event", e);
    t = t.map(i => {
        if (i == null)
            return null;
        if (Array.isArray(i)) {
            const o = Array.from(new Set(i.map(a => a.toLowerCase())).values());
            return o.length === 1 ? o[0] : (o.sort(),
            o)
        }
        return i.toLowerCase()
    }
    );
    const s = t.map(i => i == null ? "null" : Array.isArray(i) ? i.join("|") : i).join("&");
    return {
        fragment: r,
        tag: s,
        topics: t
    }
}
async function gg(n, e) {
    const {subs: t} = qi(n);
    return t.get((await W8(n, e)).tag) || null
}
async function nM(n, e, t) {
    const r = sf(n.runner);
    Ie(r, "contract runner does not support subscribing", "UNSUPPORTED_OPERATION", {
        operation: e
    });
    const {fragment: s, tag: i, topics: o} = await W8(n, t)
      , {addr: a, subs: l} = qi(n);
    let u = l.get(i);
    if (!u) {
        const h = {
            address: a || n,
            topics: o
        }
          , p = v => {
            let S = s;
            if (S == null)
                try {
                    S = n.interface.getEvent(v.topics[0])
                } catch {}
            if (S) {
                const N = S
                  , _ = s ? n.interface.decodeEventLog(s, v.data, v.topics) : [];
                N4(n, t, _, I => new tne(n,I,t,N,v))
            } else
                N4(n, t, [], N => new QF(n,N,t,v))
        }
        ;
        let g = [];
        u = {
            tag: i,
            listeners: [],
            start: () => {
                g.length || g.push(r.on(h, p))
            }
            ,
            stop: async () => {
                if (g.length == 0)
                    return;
                let v = g;
                g = [],
                await Promise.all(v),
                r.off(h, p)
            }
        },
        l.set(i, u)
    }
    return u
}
let k4 = Promise.resolve();
async function cne(n, e, t, r) {
    await k4;
    const s = await gg(n, e);
    if (!s)
        return !1;
    const i = s.listeners.length;
    return s.listeners = s.listeners.filter( ({listener: o, once: a}) => {
        const l = Array.from(t);
        r && l.push(r(a ? null : o));
        try {
            o.call(n, ...l)
        } catch {}
        return !a
    }
    ),
    s.listeners.length === 0 && (s.stop(),
    qi(n).subs.delete(s.tag)),
    i > 0
}
async function N4(n, e, t, r) {
    try {
        await k4
    } catch {}
    const s = cne(n, e, t, r);
    return k4 = s,
    await s
}
const _1 = ["then"];
class kg {
    target;
    interface;
    runner;
    filters;
    [b2];
    fallback;
    constructor(e, t, r, s) {
        he(typeof e == "string" || lF(e), "invalid value for Contract target", "target", e),
        r == null && (r = null);
        const i = Qd.from(t);
        xt(this, {
            target: e,
            runner: r,
            interface: i
        }),
        Object.defineProperty(this, b2, {
            value: {}
        });
        let o, a = null, l = null;
        if (s) {
            const h = sf(r);
            l = new G8(this.interface,h,s)
        }
        let u = new Map;
        if (typeof e == "string")
            if (zn(e))
                a = e,
                o = Promise.resolve(e);
            else {
                const h = Bf(r, "resolveName");
                if (!qv(h))
                    throw Zn("contract runner does not support name resolution", "UNSUPPORTED_OPERATION", {
                        operation: "resolveName"
                    });
                o = h.resolveName(e).then(p => {
                    if (p == null)
                        throw Zn("an ENS name used for a contract target must be correctly configured", "UNCONFIGURED_NAME", {
                            value: e
                        });
                    return qi(this).addr = p,
                    p
                }
                )
            }
        else
            o = e.getAddress().then(h => {
                if (h == null)
                    throw new Error("TODO");
                return qi(this).addr = h,
                h
            }
            );
        ane(this, {
            addrPromise: o,
            addr: a,
            deployTx: l,
            subs: u
        });
        const d = new Proxy({},{
            get: (h, p, g) => {
                if (typeof p == "symbol" || _1.indexOf(p) >= 0)
                    return Reflect.get(h, p, g);
                try {
                    return this.getEvent(p)
                } catch (w) {
                    if (!xs(w, "INVALID_ARGUMENT") || w.argument !== "key")
                        throw w
                }
            }
            ,
            has: (h, p) => _1.indexOf(p) >= 0 ? Reflect.has(h, p) : Reflect.has(h, p) || this.interface.hasEvent(String(p))
        });
        return xt(this, {
            filters: d
        }),
        xt(this, {
            fallback: i.receive || i.fallback ? sne(this) : null
        }),
        new Proxy(this,{
            get: (h, p, g) => {
                if (typeof p == "symbol" || p in h || _1.indexOf(p) >= 0)
                    return Reflect.get(h, p, g);
                try {
                    return h.getFunction(p)
                } catch (w) {
                    if (!xs(w, "INVALID_ARGUMENT") || w.argument !== "key")
                        throw w
                }
            }
            ,
            has: (h, p) => typeof p == "symbol" || p in h || _1.indexOf(p) >= 0 ? Reflect.has(h, p) : h.interface.hasFunction(p)
        })
    }
    connect(e) {
        return new kg(this.target,this.interface,e)
    }
    attach(e) {
        return new kg(e,this.interface,this.runner)
    }
    async getAddress() {
        return await qi(this).addrPromise
    }
    async getDeployedCode() {
        const e = sf(this.runner);
        Ie(e, "runner does not support .provider", "UNSUPPORTED_OPERATION", {
            operation: "getDeployedCode"
        });
        const t = await e.getCode(await this.getAddress());
        return t === "0x" ? null : t
    }
    async waitForDeployment() {
        const e = this.deploymentTransaction();
        if (e)
            return await e.wait(),
            this;
        if (await this.getDeployedCode() != null)
            return this;
        const r = sf(this.runner);
        return Ie(r != null, "contract runner does not support .provider", "UNSUPPORTED_OPERATION", {
            operation: "waitForDeployment"
        }),
        new Promise( (s, i) => {
            const o = async () => {
                try {
                    if (await this.getDeployedCode() != null)
                        return s(this);
                    r.once("block", o)
                } catch (a) {
                    i(a)
                }
            }
            ;
            o()
        }
        )
    }
    deploymentTransaction() {
        return qi(this).deployTx
    }
    getFunction(e) {
        return typeof e != "string" && (e = e.format()),
        ine(this, e)
    }
    getEvent(e) {
        return typeof e != "string" && (e = e.format()),
        one(this, e)
    }
    async queryTransaction(e) {
        throw new Error("@TODO")
    }
    async queryFilter(e, t, r) {
        t == null && (t = 0),
        r == null && (r = "latest");
        const {addr: s, addrPromise: i} = qi(this)
          , o = s || await i
          , {fragment: a, topics: l} = await W8(this, e)
          , u = {
            address: o,
            topics: l,
            fromBlock: t,
            toBlock: r
        }
          , d = sf(this.runner);
        return Ie(d, "contract runner does not have a provider", "UNSUPPORTED_OPERATION", {
            operation: "queryFilter"
        }),
        (await d.getLogs(u)).map(h => {
            let p = a;
            if (p == null)
                try {
                    p = this.interface.getEvent(h.topics[0])
                } catch {}
            if (p)
                try {
                    return new q8(h,this.interface,p)
                } catch (g) {
                    return new XF(h,g)
                }
            return new _y(h,d)
        }
        )
    }
    async on(e, t) {
        const r = await nM(this, "on", e);
        return r.listeners.push({
            listener: t,
            once: !1
        }),
        r.start(),
        this
    }
    async once(e, t) {
        const r = await nM(this, "once", e);
        return r.listeners.push({
            listener: t,
            once: !0
        }),
        r.start(),
        this
    }
    async emit(e, ...t) {
        return await N4(this, e, t, null)
    }
    async listenerCount(e) {
        if (e) {
            const s = await gg(this, e);
            return s ? s.listeners.length : 0
        }
        const {subs: t} = qi(this);
        let r = 0;
        for (const {listeners: s} of t.values())
            r += s.length;
        return r
    }
    async listeners(e) {
        if (e) {
            const s = await gg(this, e);
            return s ? s.listeners.map( ({listener: i}) => i) : []
        }
        const {subs: t} = qi(this);
        let r = [];
        for (const {listeners: s} of t.values())
            r = r.concat(s.map( ({listener: i}) => i));
        return r
    }
    async off(e, t) {
        const r = await gg(this, e);
        if (!r)
            return this;
        if (t) {
            const s = r.listeners.map( ({listener: i}) => i).indexOf(t);
            s >= 0 && r.listeners.splice(s, 1)
        }
        return (t == null || r.listeners.length === 0) && (r.stop(),
        qi(this).subs.delete(r.tag)),
        this
    }
    async removeAllListeners(e) {
        if (e) {
            const t = await gg(this, e);
            if (!t)
                return this;
            t.stop(),
            qi(this).subs.delete(t.tag)
        } else {
            const {subs: t} = qi(this);
            for (const {tag: r, stop: s} of t.values())
                s(),
                t.delete(r)
        }
        return this
    }
    async addListener(e, t) {
        return await this.on(e, t)
    }
    async removeListener(e, t) {
        return await this.off(e, t)
    }
    static buildClass(e) {
        class t extends kg {
            constructor(s, i=null) {
                super(s, e, i)
            }
        }
        return t
    }
    static from(e, t, r) {
        return r == null && (r = null),
        new this(e,t,r)
    }
}
function une() {
    return kg
}
class Ro extends une() {
}
function MS(n) {
    return n.match(/^ipfs:\/\/ipfs\//i) ? n = n.substring(12) : n.match(/^ipfs:\/\//i) ? n = n.substring(7) : he(!1, "unsupported IPFS format", "link", n),
    `https://gateway.ipfs.io/ipfs/${n}`
}
class dne {
    name;
    constructor(e) {
        xt(this, {
            name: e
        })
    }
    connect(e) {
        return this
    }
    supportsCoinType(e) {
        return !1
    }
    async encodeAddress(e, t) {
        throw new Error("unsupported coin")
    }
    async decodeAddress(e, t) {
        throw new Error("unsupported coin")
    }
}
const sU = new RegExp("^(ipfs)://(.*)$","i")
  , rM = [new RegExp("^(https)://(.*)$","i"), new RegExp("^(data):(.*)$","i"), sU, new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$","i")];
class kp {
    provider;
    address;
    name;
    #e;
    #t;
    constructor(e, t, r) {
        xt(this, {
            provider: e,
            address: t,
            name: r
        }),
        this.#e = null,
        this.#t = new Ro(t,["function supportsInterface(bytes4) view returns (bool)", "function resolve(bytes, bytes) view returns (bytes)", "function addr(bytes32) view returns (address)", "function addr(bytes32, uint) view returns (bytes)", "function text(bytes32, string) view returns (string)", "function contenthash(bytes32) view returns (bytes)"],e)
    }
    async supportsWildcard() {
        return this.#e == null && (this.#e = (async () => {
            try {
                return await this.#t.supportsInterface("0x9061b923")
            } catch (e) {
                if (xs(e, "CALL_EXCEPTION"))
                    return !1;
                throw this.#e = null,
                e
            }
        }
        )()),
        await this.#e
    }
    async #n(e, t) {
        t = (t || []).slice();
        const r = this.#t.interface;
        t.unshift(_4(this.name));
        let s = null;
        await this.supportsWildcard() && (s = r.getFunction(e),
        Ie(s, "missing fragment", "UNKNOWN_ERROR", {
            info: {
                funcName: e
            }
        }),
        t = [_te(this.name, 255), r.encodeFunctionData(s, t)],
        e = "resolve(bytes,bytes)"),
        t.push({
            enableCcipRead: !0
        });
        try {
            const i = await this.#t[e](...t);
            return s ? r.decodeFunctionResult(s, i)[0] : i
        } catch (i) {
            if (!xs(i, "CALL_EXCEPTION"))
                throw i
        }
        return null
    }
    async getAddress(e) {
        if (e == null && (e = 60),
        e === 60)
            try {
                const i = await this.#n("addr(bytes32)");
                return i == null || i === _c ? null : i
            } catch (i) {
                if (xs(i, "CALL_EXCEPTION"))
                    return null;
                throw i
            }
        if (e >= 0 && e < 2147483648) {
            let i = e + 2147483648;
            const o = await this.#n("addr(bytes32,uint)", [i]);
            if (zn(o, 20))
                return yn(o)
        }
        let t = null;
        for (const i of this.provider.plugins)
            if (i instanceof dne && i.supportsCoinType(e)) {
                t = i;
                break
            }
        if (t == null)
            return null;
        const r = await this.#n("addr(bytes32,uint)", [e]);
        if (r == null || r === "0x")
            return null;
        const s = await t.decodeAddress(e, r);
        if (s != null)
            return s;
        Ie(!1, "invalid coin data", "UNSUPPORTED_OPERATION", {
            operation: `getAddress(${e})`,
            info: {
                coinType: e,
                data: r
            }
        })
    }
    async getText(e) {
        const t = await this.#n("text(bytes32,string)", [e]);
        return t == null || t === "0x" ? null : t
    }
    async getContentHash() {
        const e = await this.#n("contenthash(bytes32)");
        if (e == null || e === "0x")
            return null;
        const t = e.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
        if (t) {
            const s = t[1] === "e3010170" ? "ipfs" : "ipns"
              , i = parseInt(t[4], 16);
            if (t[5].length === i * 2)
                return `${s}://${hZ("0x" + t[2])}`
        }
        const r = e.match(/^0xe40101fa011b20([0-9a-f]*)$/);
        if (r && r[1].length === 64)
            return `bzz://${r[1]}`;
        Ie(!1, "invalid or unsupported content hash data", "UNSUPPORTED_OPERATION", {
            operation: "getContentHash()",
            info: {
                data: e
            }
        })
    }
    async getAvatar() {
        return (await this._getAvatar()).url
    }
    async _getAvatar() {
        const e = [{
            type: "name",
            value: this.name
        }];
        try {
            const t = await this.getText("avatar");
            if (t == null)
                return e.push({
                    type: "!avatar",
                    value: ""
                }),
                {
                    url: null,
                    linkage: e
                };
            e.push({
                type: "avatar",
                value: t
            });
            for (let r = 0; r < rM.length; r++) {
                const s = t.match(rM[r]);
                if (s == null)
                    continue;
                const i = s[1].toLowerCase();
                switch (i) {
                case "https":
                case "data":
                    return e.push({
                        type: "url",
                        value: t
                    }),
                    {
                        linkage: e,
                        url: t
                    };
                case "ipfs":
                    {
                        const o = MS(t);
                        return e.push({
                            type: "ipfs",
                            value: t
                        }),
                        e.push({
                            type: "url",
                            value: o
                        }),
                        {
                            linkage: e,
                            url: o
                        }
                    }
                case "erc721":
                case "erc1155":
                    {
                        const o = i === "erc721" ? "tokenURI(uint256)" : "uri(uint256)";
                        e.push({
                            type: i,
                            value: t
                        });
                        const a = await this.getAddress();
                        if (a == null)
                            return e.push({
                                type: "!owner",
                                value: ""
                            }),
                            {
                                url: null,
                                linkage: e
                            };
                        const l = (s[2] || "").split("/");
                        if (l.length !== 2)
                            return e.push({
                                type: `!${i}caip`,
                                value: s[2] || ""
                            }),
                            {
                                url: null,
                                linkage: e
                            };
                        const u = l[1]
                          , d = new Ro(l[0],["function tokenURI(uint) view returns (string)", "function ownerOf(uint) view returns (address)", "function uri(uint) view returns (string)", "function balanceOf(address, uint256) view returns (uint)"],this.provider);
                        if (i === "erc721") {
                            const b = await d.ownerOf(u);
                            if (a !== b)
                                return e.push({
                                    type: "!owner",
                                    value: b
                                }),
                                {
                                    url: null,
                                    linkage: e
                                };
                            e.push({
                                type: "owner",
                                value: b
                            })
                        } else if (i === "erc1155") {
                            const b = await d.balanceOf(a, u);
                            if (!b)
                                return e.push({
                                    type: "!balance",
                                    value: "0"
                                }),
                                {
                                    url: null,
                                    linkage: e
                                };
                            e.push({
                                type: "balance",
                                value: b.toString()
                            })
                        }
                        let h = await d[o](u);
                        if (h == null || h === "0x")
                            return e.push({
                                type: "!metadata-url",
                                value: ""
                            }),
                            {
                                url: null,
                                linkage: e
                            };
                        e.push({
                            type: "metadata-url-base",
                            value: h
                        }),
                        i === "erc1155" && (h = h.replace("{id}", Ku(u, 32).substring(2)),
                        e.push({
                            type: "metadata-url-expanded",
                            value: h
                        })),
                        h.match(/^ipfs:/i) && (h = MS(h)),
                        e.push({
                            type: "metadata-url",
                            value: h
                        });
                        let p = {};
                        const g = await new tl(h).send();
                        g.assertOk();
                        try {
                            p = g.bodyJson
                        } catch {
                            try {
                                e.push({
                                    type: "!metadata",
                                    value: g.bodyText
                                })
                            } catch {
                                const S = g.body;
                                return S && e.push({
                                    type: "!metadata",
                                    value: Ke(S)
                                }),
                                {
                                    url: null,
                                    linkage: e
                                }
                            }
                            return {
                                url: null,
                                linkage: e
                            }
                        }
                        if (!p)
                            return e.push({
                                type: "!metadata",
                                value: ""
                            }),
                            {
                                url: null,
                                linkage: e
                            };
                        e.push({
                            type: "metadata",
                            value: JSON.stringify(p)
                        });
                        let w = p.image;
                        if (typeof w != "string")
                            return e.push({
                                type: "!imageUrl",
                                value: ""
                            }),
                            {
                                url: null,
                                linkage: e
                            };
                        if (!w.match(/^(https:\/\/|data:)/i)) {
                            if (w.match(sU) == null)
                                return e.push({
                                    type: "!imageUrl-ipfs",
                                    value: w
                                }),
                                {
                                    url: null,
                                    linkage: e
                                };
                            e.push({
                                type: "imageUrl-ipfs",
                                value: w
                            }),
                            w = MS(w)
                        }
                        return e.push({
                            type: "url",
                            value: w
                        }),
                        {
                            linkage: e,
                            url: w
                        }
                    }
                }
            }
        } catch {}
        return {
            linkage: e,
            url: null
        }
    }
    static async getEnsAddress(e) {
        const t = await e.getNetwork()
          , r = t.getPlugin("org.ethers.plugins.network.Ens");
        return Ie(r, "network does not support ENS", "UNSUPPORTED_OPERATION", {
            operation: "getEnsAddress",
            info: {
                network: t
            }
        }),
        r.address
    }
    static async #r(e, t) {
        const r = await kp.getEnsAddress(e);
        try {
            const i = await new Ro(r,["function resolver(bytes32) view returns (address)"],e).resolver(_4(t), {
                enableCcipRead: !0
            });
            return i === _c ? null : i
        } catch (s) {
            throw s
        }
        return null
    }
    static async fromName(e, t) {
        let r = t;
        for (; ; ) {
            if (r === "" || r === "." || t !== "eth" && r === "eth")
                return null;
            const s = await kp.#r(e, r);
            if (s != null) {
                const i = new kp(e,s,t);
                return r !== t && !await i.supportsWildcard() ? null : i
            }
            r = r.split(".").slice(1).join(".")
        }
    }
}
const sM = BigInt(0);
function rn(n, e) {
    return (function(t) {
        return t == null ? e : n(t)
    }
    )
}
function Xg(n, e) {
    return (t => {
        if (e && t == null)
            return null;
        if (!Array.isArray(t))
            throw new Error("not an array");
        return t.map(r => n(r))
    }
    )
}
function Ny(n, e) {
    return (t => {
        const r = {};
        for (const s in n) {
            let i = s;
            if (e && s in e && !(i in t)) {
                for (const o of e[s])
                    if (o in t) {
                        i = o;
                        break
                    }
            }
            try {
                const o = n[s](t[i]);
                o !== void 0 && (r[s] = o)
            } catch (o) {
                const a = o instanceof Error ? o.message : "not-an-error";
                Ie(!1, `invalid value for value.${s} (${a})`, "BAD_DATA", {
                    value: t
                })
            }
        }
        return r
    }
    )
}
function fne(n) {
    switch (n) {
    case !0:
    case "true":
        return !0;
    case !1:
    case "false":
        return !1
    }
    he(!1, `invalid boolean; ${JSON.stringify(n)}`, "value", n)
}
function Zp(n) {
    return he(zn(n, !0), "invalid data", "value", n),
    n
}
function bs(n) {
    return he(zn(n, 32), "invalid hash", "value", n),
    n
}
const hne = Ny({
    address: yn,
    blockHash: bs,
    blockNumber: Bt,
    data: Zp,
    index: Bt,
    removed: rn(fne, !1),
    topics: Xg(bs),
    transactionHash: bs,
    transactionIndex: Bt
}, {
    index: ["logIndex"]
});
function pne(n) {
    return hne(n)
}
const mne = Ny({
    hash: rn(bs),
    parentHash: bs,
    parentBeaconBlockRoot: rn(bs, null),
    number: Bt,
    timestamp: Bt,
    nonce: rn(Zp),
    difficulty: nt,
    gasLimit: nt,
    gasUsed: nt,
    stateRoot: rn(bs, null),
    receiptsRoot: rn(bs, null),
    blobGasUsed: rn(nt, null),
    excessBlobGas: rn(nt, null),
    miner: rn(yn),
    prevRandao: rn(bs, null),
    extraData: Zp,
    baseFeePerGas: rn(nt)
}, {
    prevRandao: ["mixHash"]
});
function gne(n) {
    const e = mne(n);
    return e.transactions = n.transactions.map(t => typeof t == "string" ? t : iU(t)),
    e
}
const yne = Ny({
    transactionIndex: Bt,
    blockNumber: Bt,
    transactionHash: bs,
    address: yn,
    topics: Xg(bs),
    data: Zp,
    index: Bt,
    blockHash: bs
}, {
    index: ["logIndex"]
});
function bne(n) {
    return yne(n)
}
const wne = Ny({
    to: rn(yn, null),
    from: rn(yn, null),
    contractAddress: rn(yn, null),
    index: Bt,
    root: rn(Ke),
    gasUsed: nt,
    blobGasUsed: rn(nt, null),
    logsBloom: rn(Zp),
    blockHash: bs,
    hash: bs,
    logs: Xg(bne),
    blockNumber: Bt,
    cumulativeGasUsed: nt,
    effectiveGasPrice: rn(nt),
    blobGasPrice: rn(nt, null),
    status: rn(Bt),
    type: rn(Bt, 0)
}, {
    effectiveGasPrice: ["gasPrice"],
    hash: ["transactionHash"],
    index: ["transactionIndex"]
});
function vne(n) {
    return wne(n)
}
function iU(n) {
    n.to && nt(n.to) === sM && (n.to = "0x0000000000000000000000000000000000000000");
    const e = Ny({
        hash: bs,
        index: rn(Bt, void 0),
        type: t => t === "0x" || t == null ? 0 : Bt(t),
        accessList: rn($f, null),
        blobVersionedHashes: rn(Xg(bs, !0), null),
        authorizationList: rn(Xg(t => {
            let r;
            if (t.signature)
                r = t.signature;
            else {
                let s = t.yParity;
                s === "0x1b" ? s = 0 : s === "0x1c" && (s = 1),
                r = Object.assign({}, t, {
                    yParity: s
                })
            }
            return {
                address: yn(t.address),
                chainId: nt(t.chainId),
                nonce: nt(t.nonce),
                signature: pr.from(r)
            }
        }
        , !1), null),
        blockHash: rn(bs, null),
        blockNumber: rn(Bt, null),
        transactionIndex: rn(Bt, null),
        from: yn,
        gasPrice: rn(nt),
        maxPriorityFeePerGas: rn(nt),
        maxFeePerGas: rn(nt),
        maxFeePerBlobGas: rn(nt, null),
        gasLimit: nt,
        to: rn(yn, null),
        value: nt,
        nonce: Bt,
        data: Zp,
        creates: rn(yn, null),
        chainId: rn(nt, null)
    }, {
        data: ["input"],
        gasLimit: ["gas"],
        index: ["transactionIndex"]
    })(n);
    if (e.to == null && e.creates == null && (e.creates = lee(e)),
    (n.type === 1 || n.type === 2) && n.accessList == null && (e.accessList = []),
    n.signature ? e.signature = pr.from(n.signature) : e.signature = pr.from(n),
    e.chainId == null) {
        const t = e.signature.legacyChainId;
        t != null && (e.chainId = t)
    }
    return e.blockHash && nt(e.blockHash) === sM && (e.blockHash = null),
    e
}
const xne = "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e";
class Dy {
    name;
    constructor(e) {
        xt(this, {
            name: e
        })
    }
    clone() {
        return new Dy(this.name)
    }
}
class Gv extends Dy {
    effectiveBlock;
    txBase;
    txCreate;
    txDataZero;
    txDataNonzero;
    txAccessListStorageKey;
    txAccessListAddress;
    constructor(e, t) {
        e == null && (e = 0),
        super(`org.ethers.network.plugins.GasCost#${e || 0}`);
        const r = {
            effectiveBlock: e
        };
        function s(i, o) {
            let a = (t || {})[i];
            a == null && (a = o),
            he(typeof a == "number", `invalud value for ${i}`, "costs", t),
            r[i] = a
        }
        s("txBase", 21e3),
        s("txCreate", 32e3),
        s("txDataZero", 4),
        s("txDataNonzero", 16),
        s("txAccessListStorageKey", 1900),
        s("txAccessListAddress", 2400),
        xt(this, r)
    }
    clone() {
        return new Gv(this.effectiveBlock,this)
    }
}
class Wv extends Dy {
    address;
    targetNetwork;
    constructor(e, t) {
        super("org.ethers.plugins.network.Ens"),
        xt(this, {
            address: e || xne,
            targetNetwork: t ?? 1
        })
    }
    clone() {
        return new Wv(this.address,this.targetNetwork)
    }
}
class Ene extends Dy {
    #e;
    #t;
    get url() {
        return this.#e
    }
    get processFunc() {
        return this.#t
    }
    constructor(e, t) {
        super("org.ethers.plugins.network.FetchUrlFeeDataPlugin"),
        this.#e = e,
        this.#t = t
    }
    clone() {
        return this
    }
}
const BS = new Map;
class Qi {
    #e;
    #t;
    #n;
    constructor(e, t) {
        this.#e = e,
        this.#t = nt(t),
        this.#n = new Map
    }
    toJSON() {
        return {
            name: this.name,
            chainId: String(this.chainId)
        }
    }
    get name() {
        return this.#e
    }
    set name(e) {
        this.#e = e
    }
    get chainId() {
        return this.#t
    }
    set chainId(e) {
        this.#t = nt(e, "chainId")
    }
    matches(e) {
        if (e == null)
            return !1;
        if (typeof e == "string") {
            try {
                return this.chainId === nt(e)
            } catch {}
            return this.name === e
        }
        if (typeof e == "number" || typeof e == "bigint") {
            try {
                return this.chainId === nt(e)
            } catch {}
            return !1
        }
        if (typeof e == "object") {
            if (e.chainId != null) {
                try {
                    return this.chainId === nt(e.chainId)
                } catch {}
                return !1
            }
            return e.name != null ? this.name === e.name : !1
        }
        return !1
    }
    get plugins() {
        return Array.from(this.#n.values())
    }
    attachPlugin(e) {
        if (this.#n.get(e.name))
            throw new Error(`cannot replace existing plugin: ${e.name} `);
        return this.#n.set(e.name, e.clone()),
        this
    }
    getPlugin(e) {
        return this.#n.get(e) || null
    }
    getPlugins(e) {
        return this.plugins.filter(t => t.name.split("#")[0] === e)
    }
    clone() {
        const e = new Qi(this.name,this.chainId);
        return this.plugins.forEach(t => {
            e.attachPlugin(t.clone())
        }
        ),
        e
    }
    computeIntrinsicGas(e) {
        const t = this.getPlugin("org.ethers.plugins.network.GasCost") || new Gv;
        let r = t.txBase;
        if (e.to == null && (r += t.txCreate),
        e.data)
            for (let s = 2; s < e.data.length; s += 2)
                e.data.substring(s, s + 2) === "00" ? r += t.txDataZero : r += t.txDataNonzero;
        if (e.accessList) {
            const s = $f(e.accessList);
            for (const i in s)
                r += t.txAccessListAddress + t.txAccessListStorageKey * s[i].storageKeys.length
        }
        return r
    }
    static from(e) {
        if (Sne(),
        e == null)
            return Qi.from("mainnet");
        if (typeof e == "number" && (e = BigInt(e)),
        typeof e == "string" || typeof e == "bigint") {
            const t = BS.get(e);
            if (t)
                return t();
            if (typeof e == "bigint")
                return new Qi("unknown",e);
            he(!1, "unknown network", "network", e)
        }
        if (typeof e.clone == "function")
            return e.clone();
        if (typeof e == "object") {
            he(typeof e.name == "string" && typeof e.chainId == "number", "invalid network object name or chainId", "network", e);
            const t = new Qi(e.name,e.chainId);
            return (e.ensAddress || e.ensNetwork != null) && t.attachPlugin(new Wv(e.ensAddress,e.ensNetwork)),
            t
        }
        he(!1, "invalid network", "network", e)
    }
    static register(e, t) {
        typeof e == "number" && (e = BigInt(e));
        const r = BS.get(e);
        r && he(!1, `conflicting network for ${JSON.stringify(r.name)}`, "nameOrChainId", e),
        BS.set(e, t)
    }
}
function iM(n, e) {
    const t = String(n);
    if (!t.match(/^[0-9.]+$/))
        throw new Error(`invalid gwei value: ${n}`);
    const r = t.split(".");
    if (r.length === 1 && r.push(""),
    r.length !== 2)
        throw new Error(`invalid gwei value: ${n}`);
    for (; r[1].length < e; )
        r[1] += "0";
    if (r[1].length > 9) {
        let s = BigInt(r[1].substring(0, 9));
        r[1].substring(9).match(/^0+$/) || s++,
        r[1] = s.toString()
    }
    return BigInt(r[0] + r[1])
}
function oM(n) {
    return new Ene(n,async (e, t, r) => {
        r.setHeader("User-Agent", "ethers");
        let s;
        try {
            const [i,o] = await Promise.all([r.send(), e()]);
            s = i;
            const a = s.bodyJson.standard;
            return {
                gasPrice: o.gasPrice,
                maxFeePerGas: iM(a.maxFee, 9),
                maxPriorityFeePerGas: iM(a.maxPriorityFee, 9)
            }
        } catch (i) {
            Ie(!1, `error encountered with polygon gas station (${JSON.stringify(r.url)})`, "SERVER_ERROR", {
                request: r,
                response: s,
                error: i
            })
        }
    }
    )
}
let aM = !1;
function Sne() {
    if (aM)
        return;
    aM = !0;
    function n(e, t, r) {
        const s = function() {
            const i = new Qi(e,t);
            return r.ensNetwork != null && i.attachPlugin(new Wv(null,r.ensNetwork)),
            i.attachPlugin(new Gv),
            (r.plugins || []).forEach(o => {
                i.attachPlugin(o)
            }
            ),
            i
        };
        Qi.register(e, s),
        Qi.register(t, s),
        r.altNames && r.altNames.forEach(i => {
            Qi.register(i, s)
        }
        )
    }
    n("mainnet", 1, {
        ensNetwork: 1,
        altNames: ["homestead"]
    }),
    n("ropsten", 3, {
        ensNetwork: 3
    }),
    n("rinkeby", 4, {
        ensNetwork: 4
    }),
    n("goerli", 5, {
        ensNetwork: 5
    }),
    n("kovan", 42, {
        ensNetwork: 42
    }),
    n("sepolia", 11155111, {
        ensNetwork: 11155111
    }),
    n("holesky", 17e3, {
        ensNetwork: 17e3
    }),
    n("classic", 61, {}),
    n("classicKotti", 6, {}),
    n("arbitrum", 42161, {
        ensNetwork: 1
    }),
    n("arbitrum-goerli", 421613, {}),
    n("arbitrum-sepolia", 421614, {}),
    n("base", 8453, {
        ensNetwork: 1
    }),
    n("base-goerli", 84531, {}),
    n("base-sepolia", 84532, {}),
    n("bnb", 56, {
        ensNetwork: 1
    }),
    n("bnbt", 97, {}),
    n("linea", 59144, {
        ensNetwork: 1
    }),
    n("linea-goerli", 59140, {}),
    n("linea-sepolia", 59141, {}),
    n("matic", 137, {
        ensNetwork: 1,
        plugins: [oM("https://gasstation.polygon.technology/v2")]
    }),
    n("matic-amoy", 80002, {}),
    n("matic-mumbai", 80001, {
        altNames: ["maticMumbai", "maticmum"],
        plugins: [oM("https://gasstation-testnet.polygon.technology/v2")]
    }),
    n("optimism", 10, {
        ensNetwork: 1,
        plugins: []
    }),
    n("optimism-goerli", 420, {}),
    n("optimism-sepolia", 11155420, {}),
    n("xdai", 100, {
        ensNetwork: 1
    })
}
function D4(n) {
    return JSON.parse(JSON.stringify(n))
}
class Ane {
    #e;
    #t;
    #n;
    #r;
    constructor(e) {
        this.#e = e,
        this.#t = null,
        this.#n = 4e3,
        this.#r = -2
    }
    get pollingInterval() {
        return this.#n
    }
    set pollingInterval(e) {
        this.#n = e
    }
    async #s() {
        try {
            const e = await this.#e.getBlockNumber();
            if (this.#r === -2) {
                this.#r = e;
                return
            }
            if (e !== this.#r) {
                for (let t = this.#r + 1; t <= e; t++) {
                    if (this.#t == null)
                        return;
                    await this.#e.emit("block", t)
                }
                this.#r = e
            }
        } catch {}
        this.#t != null && (this.#t = this.#e._setTimeout(this.#s.bind(this), this.#n))
    }
    start() {
        this.#t || (this.#t = this.#e._setTimeout(this.#s.bind(this), this.#n),
        this.#s())
    }
    stop() {
        this.#t && (this.#e._clearTimeout(this.#t),
        this.#t = null)
    }
    pause(e) {
        this.stop(),
        e && (this.#r = -2)
    }
    resume() {
        this.start()
    }
}
class Y8 {
    #e;
    #t;
    #n;
    constructor(e) {
        this.#e = e,
        this.#n = !1,
        this.#t = t => {
            this._poll(t, this.#e)
        }
    }
    async _poll(e, t) {
        throw new Error("sub-classes must override this")
    }
    start() {
        this.#n || (this.#n = !0,
        this.#t(-2),
        this.#e.on("block", this.#t))
    }
    stop() {
        this.#n && (this.#n = !1,
        this.#e.off("block", this.#t))
    }
    pause(e) {
        this.stop()
    }
    resume() {
        this.start()
    }
}
class Cne extends Y8 {
    #e;
    #t;
    constructor(e, t) {
        super(e),
        this.#e = t,
        this.#t = -2
    }
    pause(e) {
        e && (this.#t = -2),
        super.pause(e)
    }
    async _poll(e, t) {
        const r = await t.getBlock(this.#e);
        r != null && (this.#t === -2 ? this.#t = r.number : r.number > this.#t && (t.emit(this.#e, r.number),
        this.#t = r.number))
    }
}
class _ne extends Y8 {
    #e;
    constructor(e, t) {
        super(e),
        this.#e = D4(t)
    }
    async _poll(e, t) {
        throw new Error("@TODO")
    }
}
class kne extends Y8 {
    #e;
    constructor(e, t) {
        super(e),
        this.#e = t
    }
    async _poll(e, t) {
        const r = await t.getTransactionReceipt(this.#e);
        r && t.emit(this.#e, r)
    }
}
class K8 {
    #e;
    #t;
    #n;
    #r;
    #s;
    constructor(e, t) {
        this.#e = e,
        this.#t = D4(t),
        this.#n = this.#o.bind(this),
        this.#r = !1,
        this.#s = -2
    }
    async #o(e) {
        if (this.#s === -2)
            return;
        const t = D4(this.#t);
        t.fromBlock = this.#s + 1,
        t.toBlock = e;
        const r = await this.#e.getLogs(t);
        if (r.length === 0) {
            this.#s < e - 60 && (this.#s = e - 60);
            return
        }
        for (const s of r)
            this.#e.emit(this.#t, s),
            this.#s = s.blockNumber
    }
    start() {
        this.#r || (this.#r = !0,
        this.#s === -2 && this.#e.getBlockNumber().then(e => {
            this.#s = e
        }
        ),
        this.#e.on("block", this.#n))
    }
    stop() {
        this.#r && (this.#r = !1,
        this.#e.off("block", this.#n))
    }
    pause(e) {
        this.stop(),
        e && (this.#s = -2)
    }
    resume() {
        this.start()
    }
}
const Nne = BigInt(2)
  , Dne = 10;
function k1(n) {
    return n && typeof n.then == "function"
}
function Fw(n, e) {
    return n + ":" + JSON.stringify(e, (t, r) => {
        if (r == null)
            return "null";
        if (typeof r == "bigint")
            return `bigint:${r.toString()}`;
        if (typeof r == "string")
            return r.toLowerCase();
        if (typeof r == "object" && !Array.isArray(r)) {
            const s = Object.keys(r);
            return s.sort(),
            s.reduce( (i, o) => (i[o] = r[o],
            i), {})
        }
        return r
    }
    )
}
class oU {
    name;
    constructor(e) {
        xt(this, {
            name: e
        })
    }
    start() {}
    stop() {}
    pause(e) {}
    resume() {}
}
function Tne(n) {
    return JSON.parse(JSON.stringify(n))
}
function T4(n) {
    return n = Array.from(new Set(n).values()),
    n.sort(),
    n
}
async function RS(n, e) {
    if (n == null)
        throw new Error("invalid event");
    if (Array.isArray(n) && (n = {
        topics: n
    }),
    typeof n == "string")
        switch (n) {
        case "block":
        case "debug":
        case "error":
        case "finalized":
        case "network":
        case "pending":
        case "safe":
            return {
                type: n,
                tag: n
            }
        }
    if (zn(n, 32)) {
        const t = n.toLowerCase();
        return {
            type: "transaction",
            tag: Fw("tx", {
                hash: t
            }),
            hash: t
        }
    }
    if (n.orphan) {
        const t = n;
        return {
            type: "orphan",
            tag: Fw("orphan", t),
            filter: Tne(t)
        }
    }
    if (n.address || n.topics) {
        const t = n
          , r = {
            topics: (t.topics || []).map(s => s == null ? null : Array.isArray(s) ? T4(s.map(i => i.toLowerCase())) : s.toLowerCase())
        };
        if (t.address) {
            const s = []
              , i = []
              , o = a => {
                zn(a) ? s.push(a) : i.push((async () => {
                    s.push(await Xs(a, e))
                }
                )())
            }
            ;
            Array.isArray(t.address) ? t.address.forEach(o) : o(t.address),
            i.length && await Promise.all(i),
            r.address = T4(s.map(a => a.toLowerCase()))
        }
        return {
            filter: r,
            tag: Fw("event", r),
            type: "event"
        }
    }
    he(!1, "unknown ProviderEvent", "event", n)
}
function OS() {
    return new Date().getTime()
}
const Ine = {
    cacheTimeout: 250,
    pollingInterval: 4e3
};
class Mne {
    #e;
    #t;
    #n;
    #r;
    #s;
    #o;
    #i;
    #a;
    #d;
    #c;
    #p;
    #m;
    constructor(e, t) {
        if (this.#m = Object.assign({}, Ine, t || {}),
        e === "any")
            this.#o = !0,
            this.#s = null;
        else if (e) {
            const r = Qi.from(e);
            this.#o = !1,
            this.#s = Promise.resolve(r),
            setTimeout( () => {
                this.emit("network", r, null)
            }
            , 0)
        } else
            this.#o = !1,
            this.#s = null;
        this.#a = -1,
        this.#i = new Map,
        this.#e = new Map,
        this.#t = new Map,
        this.#n = null,
        this.#r = !1,
        this.#d = 1,
        this.#c = new Map,
        this.#p = !1
    }
    get pollingInterval() {
        return this.#m.pollingInterval
    }
    get provider() {
        return this
    }
    get plugins() {
        return Array.from(this.#t.values())
    }
    attachPlugin(e) {
        if (this.#t.get(e.name))
            throw new Error(`cannot replace existing plugin: ${e.name} `);
        return this.#t.set(e.name, e.connect(this)),
        this
    }
    getPlugin(e) {
        return this.#t.get(e) || null
    }
    get disableCcipRead() {
        return this.#p
    }
    set disableCcipRead(e) {
        this.#p = !!e
    }
    async #l(e) {
        const t = this.#m.cacheTimeout;
        if (t < 0)
            return await this._perform(e);
        const r = Fw(e.method, e);
        let s = this.#i.get(r);
        return s || (s = this._perform(e),
        this.#i.set(r, s),
        setTimeout( () => {
            this.#i.get(r) === s && this.#i.delete(r)
        }
        , t)),
        await s
    }
    async ccipReadFetch(e, t, r) {
        if (this.disableCcipRead || r.length === 0 || e.to == null)
            return null;
        const s = e.to.toLowerCase()
          , i = t.toLowerCase()
          , o = [];
        for (let a = 0; a < r.length; a++) {
            const l = r[a]
              , u = l.replace("{sender}", s).replace("{data}", i)
              , d = new tl(u);
            l.indexOf("{data}") === -1 && (d.body = {
                data: i,
                sender: s
            }),
            this.emit("debug", {
                action: "sendCcipReadFetchRequest",
                request: d,
                index: a,
                urls: r
            });
            let h = "unknown error", p;
            try {
                p = await d.send()
            } catch (g) {
                o.push(g.message),
                this.emit("debug", {
                    action: "receiveCcipReadFetchError",
                    request: d,
                    result: {
                        error: g
                    }
                });
                continue
            }
            try {
                const g = p.bodyJson;
                if (g.data)
                    return this.emit("debug", {
                        action: "receiveCcipReadFetchResult",
                        request: d,
                        result: g
                    }),
                    g.data;
                g.message && (h = g.message),
                this.emit("debug", {
                    action: "receiveCcipReadFetchError",
                    request: d,
                    result: g
                })
            } catch {}
            Ie(p.statusCode < 400 || p.statusCode >= 500, `response not found during CCIP fetch: ${h}`, "OFFCHAIN_FAULT", {
                reason: "404_MISSING_RESOURCE",
                transaction: e,
                info: {
                    url: l,
                    errorMessage: h
                }
            }),
            o.push(h)
        }
        Ie(!1, `error encountered during CCIP fetch: ${o.map(a => JSON.stringify(a)).join(", ")}`, "OFFCHAIN_FAULT", {
            reason: "500_SERVER_ERROR",
            transaction: e,
            info: {
                urls: r,
                errorMessages: o
            }
        })
    }
    _wrapBlock(e, t) {
        return new Qte(gne(e),this)
    }
    _wrapLog(e, t) {
        return new _y(pne(e),this)
    }
    _wrapTransactionReceipt(e, t) {
        return new WF(vne(e),this)
    }
    _wrapTransactionResponse(e, t) {
        return new ky(iU(e),this)
    }
    _detectNetwork() {
        Ie(!1, "sub-classes must implement this", "UNSUPPORTED_OPERATION", {
            operation: "_detectNetwork"
        })
    }
    async _perform(e) {
        Ie(!1, `unsupported method: ${e.method}`, "UNSUPPORTED_OPERATION", {
            operation: e.method,
            info: e
        })
    }
    async getBlockNumber() {
        const e = Bt(await this.#l({
            method: "getBlockNumber"
        }), "%response");
        return this.#a >= 0 && (this.#a = e),
        e
    }
    _getAddress(e) {
        return Xs(e, this)
    }
    _getBlockTag(e) {
        if (e == null)
            return "latest";
        switch (e) {
        case "earliest":
            return "0x0";
        case "finalized":
        case "latest":
        case "pending":
        case "safe":
            return e
        }
        if (zn(e))
            return zn(e, 32) ? e : ea(e);
        if (typeof e == "bigint" && (e = Bt(e, "blockTag")),
        typeof e == "number")
            return e >= 0 ? ea(e) : this.#a >= 0 ? ea(this.#a + e) : this.getBlockNumber().then(t => ea(t + e));
        he(!1, "invalid blockTag", "blockTag", e)
    }
    _getFilter(e) {
        const t = (e.topics || []).map(l => l == null ? null : Array.isArray(l) ? T4(l.map(u => u.toLowerCase())) : l.toLowerCase())
          , r = "blockHash"in e ? e.blockHash : void 0
          , s = (l, u, d) => {
            let h;
            switch (l.length) {
            case 0:
                break;
            case 1:
                h = l[0];
                break;
            default:
                l.sort(),
                h = l
            }
            if (r && (u != null || d != null))
                throw new Error("invalid filter");
            const p = {};
            return h && (p.address = h),
            t.length && (p.topics = t),
            u && (p.fromBlock = u),
            d && (p.toBlock = d),
            r && (p.blockHash = r),
            p
        }
        ;
        let i = [];
        if (e.address)
            if (Array.isArray(e.address))
                for (const l of e.address)
                    i.push(this._getAddress(l));
            else
                i.push(this._getAddress(e.address));
        let o;
        "fromBlock"in e && (o = this._getBlockTag(e.fromBlock));
        let a;
        return "toBlock"in e && (a = this._getBlockTag(e.toBlock)),
        i.filter(l => typeof l != "string").length || o != null && typeof o != "string" || a != null && typeof a != "string" ? Promise.all([Promise.all(i), o, a]).then(l => s(l[0], l[1], l[2])) : s(i, o, a)
    }
    _getTransactionRequest(e) {
        const t = y2(e)
          , r = [];
        if (["to", "from"].forEach(s => {
            if (t[s] == null)
                return;
            const i = Xs(t[s], this);
            k1(i) ? r.push((async function() {
                t[s] = await i
            }
            )()) : t[s] = i
        }
        ),
        t.blockTag != null) {
            const s = this._getBlockTag(t.blockTag);
            k1(s) ? r.push((async function() {
                t.blockTag = await s
            }
            )()) : t.blockTag = s
        }
        return r.length ? (async function() {
            return await Promise.all(r),
            t
        }
        )() : t
    }
    async getNetwork() {
        if (this.#s == null) {
            const s = (async () => {
                try {
                    const i = await this._detectNetwork();
                    return this.emit("network", i, null),
                    i
                } catch (i) {
                    throw this.#s === s && (this.#s = null),
                    i
                }
            }
            )();
            return this.#s = s,
            (await s).clone()
        }
        const e = this.#s
          , [t,r] = await Promise.all([e, this._detectNetwork()]);
        return t.chainId !== r.chainId && (this.#o ? (this.emit("network", r, t),
        this.#s === e && (this.#s = Promise.resolve(r))) : Ie(!1, `network changed: ${t.chainId} => ${r.chainId} `, "NETWORK_ERROR", {
            event: "changed"
        })),
        t.clone()
    }
    async getFeeData() {
        const e = await this.getNetwork()
          , t = async () => {
            const {_block: s, gasPrice: i, priorityFee: o} = await qs({
                _block: this.#y("latest", !1),
                gasPrice: (async () => {
                    try {
                        const d = await this.#l({
                            method: "getGasPrice"
                        });
                        return nt(d, "%response")
                    } catch {}
                    return null
                }
                )(),
                priorityFee: (async () => {
                    try {
                        const d = await this.#l({
                            method: "getPriorityFee"
                        });
                        return nt(d, "%response")
                    } catch {}
                    return null
                }
                )()
            });
            let a = null
              , l = null;
            const u = this._wrapBlock(s, e);
            return u && u.baseFeePerGas && (l = o ?? BigInt("1000000000"),
            a = u.baseFeePerGas * Nne + l),
            new eM(i,a,l)
        }
          , r = e.getPlugin("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
        if (r) {
            const s = new tl(r.url)
              , i = await r.processFunc(t, this, s);
            return new eM(i.gasPrice,i.maxFeePerGas,i.maxPriorityFeePerGas)
        }
        return await t()
    }
    async estimateGas(e) {
        let t = this._getTransactionRequest(e);
        return k1(t) && (t = await t),
        nt(await this.#l({
            method: "estimateGas",
            transaction: t
        }), "%response")
    }
    async #u(e, t, r) {
        Ie(r < Dne, "CCIP read exceeded maximum redirections", "OFFCHAIN_FAULT", {
            reason: "TOO_MANY_REDIRECTS",
            transaction: Object.assign({}, e, {
                blockTag: t,
                enableCcipRead: !0
            })
        });
        const s = y2(e);
        try {
            return Ke(await this._perform({
                method: "call",
                transaction: s,
                blockTag: t
            }))
        } catch (i) {
            if (!this.disableCcipRead && I8(i) && i.data && r >= 0 && t === "latest" && s.to != null && fr(i.data, 0, 4) === "0x556f1830") {
                const o = i.data
                  , a = await Xs(s.to, this);
                let l;
                try {
                    l = jne(fr(i.data, 4))
                } catch (h) {
                    Ie(!1, h.message, "OFFCHAIN_FAULT", {
                        reason: "BAD_DATA",
                        transaction: s,
                        info: {
                            data: o
                        }
                    })
                }
                Ie(l.sender.toLowerCase() === a.toLowerCase(), "CCIP Read sender mismatch", "CALL_EXCEPTION", {
                    action: "call",
                    data: o,
                    reason: "OffchainLookup",
                    transaction: s,
                    invocation: null,
                    revert: {
                        signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                        name: "OffchainLookup",
                        args: l.errorArgs
                    }
                });
                const u = await this.ccipReadFetch(s, l.calldata, l.urls);
                Ie(u != null, "CCIP Read failed to fetch data", "OFFCHAIN_FAULT", {
                    reason: "FETCH_FAILED",
                    transaction: s,
                    info: {
                        data: i.data,
                        errorArgs: l.errorArgs
                    }
                });
                const d = {
                    to: a,
                    data: gr([l.selector, Pne([u, l.extraData])])
                };
                this.emit("debug", {
                    action: "sendCcipReadCall",
                    transaction: d
                });
                try {
                    const h = await this.#u(d, t, r + 1);
                    return this.emit("debug", {
                        action: "receiveCcipReadCallResult",
                        transaction: Object.assign({}, d),
                        result: h
                    }),
                    h
                } catch (h) {
                    throw this.emit("debug", {
                        action: "receiveCcipReadCallError",
                        transaction: Object.assign({}, d),
                        error: h
                    }),
                    h
                }
            }
            throw i
        }
    }
    async #f(e) {
        const {value: t} = await qs({
            network: this.getNetwork(),
            value: e
        });
        return t
    }
    async call(e) {
        const {tx: t, blockTag: r} = await qs({
            tx: this._getTransactionRequest(e),
            blockTag: this._getBlockTag(e.blockTag)
        });
        return await this.#f(this.#u(t, r, e.enableCcipRead ? 0 : -1))
    }
    async #h(e, t, r) {
        let s = this._getAddress(t)
          , i = this._getBlockTag(r);
        return (typeof s != "string" || typeof i != "string") && ([s,i] = await Promise.all([s, i])),
        await this.#f(this.#l(Object.assign(e, {
            address: s,
            blockTag: i
        })))
    }
    async getBalance(e, t) {
        return nt(await this.#h({
            method: "getBalance"
        }, e, t), "%response")
    }
    async getTransactionCount(e, t) {
        return Bt(await this.#h({
            method: "getTransactionCount"
        }, e, t), "%response")
    }
    async getCode(e, t) {
        return Ke(await this.#h({
            method: "getCode"
        }, e, t))
    }
    async getStorage(e, t, r) {
        const s = nt(t, "position");
        return Ke(await this.#h({
            method: "getStorage",
            position: s
        }, e, r))
    }
    async broadcastTransaction(e) {
        const {blockNumber: t, hash: r, network: s} = await qs({
            blockNumber: this.getBlockNumber(),
            hash: this._perform({
                method: "broadcastTransaction",
                signedTransaction: e
            }),
            network: this.getNetwork()
        })
          , i = hF.from(e);
        if (i.hash !== r)
            throw new Error("@TODO: the returned hash did not match");
        return this._wrapTransactionResponse(i, s).replaceableTransaction(t)
    }
    async #y(e, t) {
        if (zn(e, 32))
            return await this.#l({
                method: "getBlock",
                blockHash: e,
                includeTransactions: t
            });
        let r = this._getBlockTag(e);
        return typeof r != "string" && (r = await r),
        await this.#l({
            method: "getBlock",
            blockTag: r,
            includeTransactions: t
        })
    }
    async getBlock(e, t) {
        const {network: r, params: s} = await qs({
            network: this.getNetwork(),
            params: this.#y(e, !!t)
        });
        return s == null ? null : this._wrapBlock(s, r)
    }
    async getTransaction(e) {
        const {network: t, params: r} = await qs({
            network: this.getNetwork(),
            params: this.#l({
                method: "getTransaction",
                hash: e
            })
        });
        return r == null ? null : this._wrapTransactionResponse(r, t)
    }
    async getTransactionReceipt(e) {
        const {network: t, params: r} = await qs({
            network: this.getNetwork(),
            params: this.#l({
                method: "getTransactionReceipt",
                hash: e
            })
        });
        if (r == null)
            return null;
        if (r.gasPrice == null && r.effectiveGasPrice == null) {
            const s = await this.#l({
                method: "getTransaction",
                hash: e
            });
            if (s == null)
                throw new Error("report this; could not find tx or effectiveGasPrice");
            r.effectiveGasPrice = s.gasPrice
        }
        return this._wrapTransactionReceipt(r, t)
    }
    async getTransactionResult(e) {
        const {result: t} = await qs({
            network: this.getNetwork(),
            result: this.#l({
                method: "getTransactionResult",
                hash: e
            })
        });
        return t == null ? null : Ke(t)
    }
    async getLogs(e) {
        let t = this._getFilter(e);
        k1(t) && (t = await t);
        const {network: r, params: s} = await qs({
            network: this.getNetwork(),
            params: this.#l({
                method: "getLogs",
                filter: t
            })
        });
        return s.map(i => this._wrapLog(i, r))
    }
    _getProvider(e) {
        Ie(!1, "provider cannot connect to target network", "UNSUPPORTED_OPERATION", {
            operation: "_getProvider()"
        })
    }
    async getResolver(e) {
        return await kp.fromName(this, e)
    }
    async getAvatar(e) {
        const t = await this.getResolver(e);
        return t ? await t.getAvatar() : null
    }
    async resolveName(e) {
        const t = await this.getResolver(e);
        return t ? await t.getAddress() : null
    }
    async lookupAddress(e) {
        e = yn(e);
        const t = _4(e.substring(2).toLowerCase() + ".addr.reverse");
        try {
            const r = await kp.getEnsAddress(this)
              , i = await new Ro(r,["function resolver(bytes32) view returns (address)"],this).resolver(t);
            if (i == null || i === _c)
                return null;
            const a = await new Ro(i,["function name(bytes32) view returns (string)"],this).name(t);
            return await this.resolveName(a) !== e ? null : a
        } catch (r) {
            if (xs(r, "BAD_DATA") && r.value === "0x" || xs(r, "CALL_EXCEPTION"))
                return null;
            throw r
        }
        return null
    }
    async waitForTransaction(e, t, r) {
        const s = t ?? 1;
        return s === 0 ? this.getTransactionReceipt(e) : new Promise(async (i, o) => {
            let a = null;
            const l = (async u => {
                try {
                    const d = await this.getTransactionReceipt(e);
                    if (d != null && u - d.blockNumber + 1 >= s) {
                        i(d),
                        a && (clearTimeout(a),
                        a = null);
                        return
                    }
                } catch (d) {
                    console.log("EEE", d)
                }
                this.once("block", l)
            }
            );
            r != null && (a = setTimeout( () => {
                a != null && (a = null,
                this.off("block", l),
                o(Zn("timeout", "TIMEOUT", {
                    reason: "timeout"
                })))
            }
            , r)),
            l(await this.getBlockNumber())
        }
        )
    }
    async waitForBlock(e) {
        Ie(!1, "not implemented yet", "NOT_IMPLEMENTED", {
            operation: "waitForBlock"
        })
    }
    _clearTimeout(e) {
        const t = this.#c.get(e);
        t && (t.timer && clearTimeout(t.timer),
        this.#c.delete(e))
    }
    _setTimeout(e, t) {
        t == null && (t = 0);
        const r = this.#d++
          , s = () => {
            this.#c.delete(r),
            e()
        }
        ;
        if (this.paused)
            this.#c.set(r, {
                timer: null,
                func: s,
                time: t
            });
        else {
            const i = setTimeout(s, t);
            this.#c.set(r, {
                timer: i,
                func: s,
                time: OS()
            })
        }
        return r
    }
    _forEachSubscriber(e) {
        for (const t of this.#e.values())
            e(t.subscriber)
    }
    _getSubscriber(e) {
        switch (e.type) {
        case "debug":
        case "error":
        case "network":
            return new oU(e.type);
        case "block":
            {
                const t = new Ane(this);
                return t.pollingInterval = this.pollingInterval,
                t
            }
        case "safe":
        case "finalized":
            return new Cne(this,e.type);
        case "event":
            return new K8(this,e.filter);
        case "transaction":
            return new kne(this,e.hash);
        case "orphan":
            return new _ne(this,e.filter)
        }
        throw new Error(`unsupported event: ${e.type}`)
    }
    _recoverSubscriber(e, t) {
        for (const r of this.#e.values())
            if (r.subscriber === e) {
                r.started && r.subscriber.stop(),
                r.subscriber = t,
                r.started && t.start(),
                this.#n != null && t.pause(this.#n);
                break
            }
    }
    async #g(e, t) {
        let r = await RS(e, this);
        return r.type === "event" && t && t.length > 0 && t[0].removed === !0 && (r = await RS({
            orphan: "drop-log",
            log: t[0]
        }, this)),
        this.#e.get(r.tag) || null
    }
    async #b(e) {
        const t = await RS(e, this)
          , r = t.tag;
        let s = this.#e.get(r);
        return s || (s = {
            subscriber: this._getSubscriber(t),
            tag: r,
            addressableMap: new WeakMap,
            nameMap: new Map,
            started: !1,
            listeners: []
        },
        this.#e.set(r, s)),
        s
    }
    async on(e, t) {
        const r = await this.#b(e);
        return r.listeners.push({
            listener: t,
            once: !1
        }),
        r.started || (r.subscriber.start(),
        r.started = !0,
        this.#n != null && r.subscriber.pause(this.#n)),
        this
    }
    async once(e, t) {
        const r = await this.#b(e);
        return r.listeners.push({
            listener: t,
            once: !0
        }),
        r.started || (r.subscriber.start(),
        r.started = !0,
        this.#n != null && r.subscriber.pause(this.#n)),
        this
    }
    async emit(e, ...t) {
        const r = await this.#g(e, t);
        if (!r || r.listeners.length === 0)
            return !1;
        const s = r.listeners.length;
        return r.listeners = r.listeners.filter( ({listener: i, once: o}) => {
            const a = new EL(this,o ? null : i,e);
            try {
                i.call(this, ...t, a)
            } catch {}
            return !o
        }
        ),
        r.listeners.length === 0 && (r.started && r.subscriber.stop(),
        this.#e.delete(r.tag)),
        s > 0
    }
    async listenerCount(e) {
        if (e) {
            const r = await this.#g(e);
            return r ? r.listeners.length : 0
        }
        let t = 0;
        for (const {listeners: r} of this.#e.values())
            t += r.length;
        return t
    }
    async listeners(e) {
        if (e) {
            const r = await this.#g(e);
            return r ? r.listeners.map( ({listener: s}) => s) : []
        }
        let t = [];
        for (const {listeners: r} of this.#e.values())
            t = t.concat(r.map( ({listener: s}) => s));
        return t
    }
    async off(e, t) {
        const r = await this.#g(e);
        if (!r)
            return this;
        if (t) {
            const s = r.listeners.map( ({listener: i}) => i).indexOf(t);
            s >= 0 && r.listeners.splice(s, 1)
        }
        return (!t || r.listeners.length === 0) && (r.started && r.subscriber.stop(),
        this.#e.delete(r.tag)),
        this
    }
    async removeAllListeners(e) {
        if (e) {
            const {tag: t, started: r, subscriber: s} = await this.#b(e);
            r && s.stop(),
            this.#e.delete(t)
        } else
            for (const [t,{started: r, subscriber: s}] of this.#e)
                r && s.stop(),
                this.#e.delete(t);
        return this
    }
    async addListener(e, t) {
        return await this.on(e, t)
    }
    async removeListener(e, t) {
        return this.off(e, t)
    }
    get destroyed() {
        return this.#r
    }
    destroy() {
        this.removeAllListeners();
        for (const e of this.#c.keys())
            this._clearTimeout(e);
        this.#r = !0
    }
    get paused() {
        return this.#n != null
    }
    set paused(e) {
        !!e !== this.paused && (this.paused ? this.resume() : this.pause(!1))
    }
    pause(e) {
        if (this.#a = -1,
        this.#n != null) {
            if (this.#n == !!e)
                return;
            Ie(!1, "cannot change pause type; resume first", "UNSUPPORTED_OPERATION", {
                operation: "pause"
            })
        }
        this._forEachSubscriber(t => t.pause(e)),
        this.#n = !!e;
        for (const t of this.#c.values())
            t.timer && clearTimeout(t.timer),
            t.time = OS() - t.time
    }
    resume() {
        if (this.#n != null) {
            this._forEachSubscriber(e => e.resume()),
            this.#n = null;
            for (const e of this.#c.values()) {
                let t = e.time;
                t < 0 && (t = 0),
                e.time = OS(),
                setTimeout(e.func, t)
            }
        }
    }
}
function Bne(n, e) {
    try {
        const t = I4(n, e);
        if (t)
            return u2(t)
    } catch {}
    return null
}
function I4(n, e) {
    if (n === "0x")
        return null;
    try {
        const t = Bt(fr(n, e, e + 32))
          , r = Bt(fr(n, t, t + 32));
        return fr(n, t + 32, t + 32 + r)
    } catch {}
    return null
}
function lM(n) {
    const e = qr(n);
    if (e.length > 32)
        throw new Error("internal; should not happen");
    const t = new Uint8Array(32);
    return t.set(e, 32 - e.length),
    t
}
function Rne(n) {
    if (n.length % 32 === 0)
        return n;
    const e = new Uint8Array(Math.ceil(n.length / 32) * 32);
    return e.set(n),
    e
}
const One = new Uint8Array([]);
function Pne(n) {
    const e = [];
    let t = 0;
    for (let r = 0; r < n.length; r++)
        e.push(One),
        t += 32;
    for (let r = 0; r < n.length; r++) {
        const s = zt(n[r]);
        e[r] = lM(t),
        e.push(lM(s.length)),
        e.push(Rne(s)),
        t += 32 + Math.ceil(s.length / 32) * 32
    }
    return gr(e)
}
const cM = "0x0000000000000000000000000000000000000000000000000000000000000000";
function jne(n) {
    const e = {
        sender: "",
        urls: [],
        calldata: "",
        selector: "",
        extraData: "",
        errorArgs: []
    };
    Ie(Sp(n) >= 160, "insufficient OffchainLookup data", "OFFCHAIN_FAULT", {
        reason: "insufficient OffchainLookup data"
    });
    const t = fr(n, 0, 32);
    Ie(fr(t, 0, 12) === fr(cM, 0, 12), "corrupt OffchainLookup sender", "OFFCHAIN_FAULT", {
        reason: "corrupt OffchainLookup sender"
    }),
    e.sender = fr(t, 12);
    try {
        const r = []
          , s = Bt(fr(n, 32, 64))
          , i = Bt(fr(n, s, s + 32))
          , o = fr(n, s + 32);
        for (let a = 0; a < i; a++) {
            const l = Bne(o, a * 32);
            if (l == null)
                throw new Error("abort");
            r.push(l)
        }
        e.urls = r
    } catch {
        Ie(!1, "corrupt OffchainLookup urls", "OFFCHAIN_FAULT", {
            reason: "corrupt OffchainLookup urls"
        })
    }
    try {
        const r = I4(n, 64);
        if (r == null)
            throw new Error("abort");
        e.calldata = r
    } catch {
        Ie(!1, "corrupt OffchainLookup calldata", "OFFCHAIN_FAULT", {
            reason: "corrupt OffchainLookup calldata"
        })
    }
    Ie(fr(n, 100, 128) === fr(cM, 0, 28), "corrupt OffchainLookup callbaackSelector", "OFFCHAIN_FAULT", {
        reason: "corrupt OffchainLookup callbaackSelector"
    }),
    e.selector = fr(n, 96, 100);
    try {
        const r = I4(n, 128);
        if (r == null)
            throw new Error("abort");
        e.extraData = r
    } catch {
        Ie(!1, "corrupt OffchainLookup extraData", "OFFCHAIN_FAULT", {
            reason: "corrupt OffchainLookup extraData"
        })
    }
    return e.errorArgs = "sender,urls,calldata,selector,extraData".split(/,/).map(r => e[r]),
    e
}
function Td(n, e) {
    if (n.provider)
        return n.provider;
    Ie(!1, "missing provider", "UNSUPPORTED_OPERATION", {
        operation: e
    })
}
async function uM(n, e) {
    let t = y2(e);
    if (t.to != null && (t.to = Xs(t.to, n)),
    t.from != null) {
        const r = t.from;
        t.from = Promise.all([n.getAddress(), Xs(r, n)]).then( ([s,i]) => (he(s.toLowerCase() === i.toLowerCase(), "transaction from mismatch", "tx.from", i),
        s))
    } else
        t.from = n.getAddress();
    return await qs(t)
}
class Lne {
    provider;
    constructor(e) {
        xt(this, {
            provider: e || null
        })
    }
    async getNonce(e) {
        return Td(this, "getTransactionCount").getTransactionCount(await this.getAddress(), e)
    }
    async populateCall(e) {
        return await uM(this, e)
    }
    async populateTransaction(e) {
        const t = Td(this, "populateTransaction")
          , r = await uM(this, e);
        r.nonce == null && (r.nonce = await this.getNonce("pending")),
        r.gasLimit == null && (r.gasLimit = await this.estimateGas(r));
        const s = await this.provider.getNetwork();
        if (r.chainId != null) {
            const o = nt(r.chainId);
            he(o === s.chainId, "transaction chainId mismatch", "tx.chainId", e.chainId)
        } else
            r.chainId = s.chainId;
        const i = r.maxFeePerGas != null || r.maxPriorityFeePerGas != null;
        if (r.gasPrice != null && (r.type === 2 || i) ? he(!1, "eip-1559 transaction do not support gasPrice", "tx", e) : (r.type === 0 || r.type === 1) && i && he(!1, "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "tx", e),
        (r.type === 2 || r.type == null) && r.maxFeePerGas != null && r.maxPriorityFeePerGas != null)
            r.type = 2;
        else if (r.type === 0 || r.type === 1) {
            const o = await t.getFeeData();
            Ie(o.gasPrice != null, "network does not support gasPrice", "UNSUPPORTED_OPERATION", {
                operation: "getGasPrice"
            }),
            r.gasPrice == null && (r.gasPrice = o.gasPrice)
        } else {
            const o = await t.getFeeData();
            if (r.type == null)
                if (o.maxFeePerGas != null && o.maxPriorityFeePerGas != null)
                    if (r.authorizationList && r.authorizationList.length ? r.type = 4 : r.type = 2,
                    r.gasPrice != null) {
                        const a = r.gasPrice;
                        delete r.gasPrice,
                        r.maxFeePerGas = a,
                        r.maxPriorityFeePerGas = a
                    } else
                        r.maxFeePerGas == null && (r.maxFeePerGas = o.maxFeePerGas),
                        r.maxPriorityFeePerGas == null && (r.maxPriorityFeePerGas = o.maxPriorityFeePerGas);
                else
                    o.gasPrice != null ? (Ie(!i, "network does not support EIP-1559", "UNSUPPORTED_OPERATION", {
                        operation: "populateTransaction"
                    }),
                    r.gasPrice == null && (r.gasPrice = o.gasPrice),
                    r.type = 0) : Ie(!1, "failed to get consistent fee data", "UNSUPPORTED_OPERATION", {
                        operation: "signer.getFeeData"
                    });
            else
                (r.type === 2 || r.type === 3 || r.type === 4) && (r.maxFeePerGas == null && (r.maxFeePerGas = o.maxFeePerGas),
                r.maxPriorityFeePerGas == null && (r.maxPriorityFeePerGas = o.maxPriorityFeePerGas))
        }
        return await qs(r)
    }
    async populateAuthorization(e) {
        const t = Object.assign({}, e);
        return t.chainId == null && (t.chainId = (await Td(this, "getNetwork").getNetwork()).chainId),
        t.nonce == null && (t.nonce = await this.getNonce()),
        t
    }
    async estimateGas(e) {
        return Td(this, "estimateGas").estimateGas(await this.populateCall(e))
    }
    async call(e) {
        return Td(this, "call").call(await this.populateCall(e))
    }
    async resolveName(e) {
        return await Td(this, "resolveName").resolveName(e)
    }
    async sendTransaction(e) {
        const t = Td(this, "sendTransaction")
          , r = await this.populateTransaction(e);
        delete r.from;
        const s = hF.from(r);
        return await t.broadcastTransaction(await this.signTransaction(s))
    }
    authorize(e) {
        Ie(!1, "authorization not implemented for this signer", "UNSUPPORTED_OPERATION", {
            operation: "authorize"
        })
    }
}
function Fne(n) {
    return JSON.parse(JSON.stringify(n))
}
class aU {
    #e;
    #t;
    #n;
    #r;
    #s;
    #o;
    constructor(e) {
        this.#e = e,
        this.#t = null,
        this.#n = this.#i.bind(this),
        this.#r = !1,
        this.#s = null,
        this.#o = !1
    }
    _subscribe(e) {
        throw new Error("subclasses must override this")
    }
    _emitResults(e, t) {
        throw new Error("subclasses must override this")
    }
    _recover(e) {
        throw new Error("subclasses must override this")
    }
    async #i(e) {
        try {
            this.#t == null && (this.#t = this._subscribe(this.#e));
            let t = null;
            try {
                t = await this.#t
            } catch (i) {
                if (!xs(i, "UNSUPPORTED_OPERATION") || i.operation !== "eth_newFilter")
                    throw i
            }
            if (t == null) {
                this.#t = null,
                this.#e._recoverSubscriber(this, this._recover(this.#e));
                return
            }
            const r = await this.#e.getNetwork();
            if (this.#s || (this.#s = r),
            this.#s.chainId !== r.chainId)
                throw new Error("chaid changed");
            if (this.#o)
                return;
            const s = await this.#e.send("eth_getFilterChanges", [t]);
            await this._emitResults(this.#e, s)
        } catch (t) {
            console.log("@TODO", t)
        }
        this.#e.once("block", this.#n)
    }
    #a() {
        const e = this.#t;
        e && (this.#t = null,
        e.then(t => {
            this.#e.destroyed || this.#e.send("eth_uninstallFilter", [t])
        }
        ))
    }
    start() {
        this.#r || (this.#r = !0,
        this.#i(-2))
    }
    stop() {
        this.#r && (this.#r = !1,
        this.#o = !0,
        this.#a(),
        this.#e.off("block", this.#n))
    }
    pause(e) {
        e && this.#a(),
        this.#e.off("block", this.#n)
    }
    resume() {
        this.start()
    }
}
class Une extends aU {
    #e;
    constructor(e, t) {
        super(e),
        this.#e = Fne(t)
    }
    _recover(e) {
        return new K8(e,this.#e)
    }
    async _subscribe(e) {
        return await e.send("eth_newFilter", [this.#e])
    }
    async _emitResults(e, t) {
        for (const r of t)
            e.emit(this.#e, e._wrapLog(r, e._network))
    }
}
class zne extends aU {
    async _subscribe(e) {
        return await e.send("eth_newPendingTransactionFilter", [])
    }
    async _emitResults(e, t) {
        for (const r of t)
            e.emit("pending", r)
    }
}
const $ne = "bigint,boolean,function,number,string,symbol".split(/,/g);
function Uw(n) {
    if (n == null || $ne.indexOf(typeof n) >= 0 || typeof n.getAddress == "function")
        return n;
    if (Array.isArray(n))
        return n.map(Uw);
    if (typeof n == "object")
        return Object.keys(n).reduce( (e, t) => (e[t] = n[t],
        e), {});
    throw new Error(`should not happen: ${n} (${typeof n})`)
}
function Hne(n) {
    return new Promise(e => {
        setTimeout(e, n)
    }
    )
}
function Hh(n) {
    return n && n.toLowerCase()
}
function dM(n) {
    return n && typeof n.pollingInterval == "number"
}
const lU = {
    polling: !1,
    staticNetwork: null,
    batchStallTime: 10,
    batchMaxSize: 1 << 20,
    batchMaxCount: 100,
    cacheTimeout: 250,
    pollingInterval: 4e3
};
class PS extends Lne {
    address;
    constructor(e, t) {
        super(e),
        t = yn(t),
        xt(this, {
            address: t
        })
    }
    connect(e) {
        Ie(!1, "cannot reconnect JsonRpcSigner", "UNSUPPORTED_OPERATION", {
            operation: "signer.connect"
        })
    }
    async getAddress() {
        return this.address
    }
    async populateTransaction(e) {
        return await this.populateCall(e)
    }
    async sendUncheckedTransaction(e) {
        const t = Uw(e)
          , r = [];
        if (t.from) {
            const i = t.from;
            r.push((async () => {
                const o = await Xs(i, this.provider);
                he(o != null && o.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", e),
                t.from = o
            }
            )())
        } else
            t.from = this.address;
        if (t.gasLimit == null && r.push((async () => {
            t.gasLimit = await this.provider.estimateGas({
                ...t,
                from: this.address
            })
        }
        )()),
        t.to != null) {
            const i = t.to;
            r.push((async () => {
                t.to = await Xs(i, this.provider)
            }
            )())
        }
        r.length && await Promise.all(r);
        const s = this.provider.getRpcTransaction(t);
        return this.provider.send("eth_sendTransaction", [s])
    }
    async sendTransaction(e) {
        const t = await this.provider.getBlockNumber()
          , r = await this.sendUncheckedTransaction(e);
        return await new Promise( (s, i) => {
            const o = [1e3, 100];
            let a = 0;
            const l = async () => {
                try {
                    const u = await this.provider.getTransaction(r);
                    if (u != null) {
                        s(u.replaceableTransaction(t));
                        return
                    }
                } catch (u) {
                    if (xs(u, "CANCELLED") || xs(u, "BAD_DATA") || xs(u, "NETWORK_ERROR") || xs(u, "UNSUPPORTED_OPERATION")) {
                        u.info == null && (u.info = {}),
                        u.info.sendTransactionHash = r,
                        i(u);
                        return
                    }
                    if (xs(u, "INVALID_ARGUMENT") && (a++,
                    u.info == null && (u.info = {}),
                    u.info.sendTransactionHash = r,
                    a > 10)) {
                        i(u);
                        return
                    }
                    this.provider.emit("error", Zn("failed to fetch transation after sending (will try again)", "UNKNOWN_ERROR", {
                        error: u
                    }))
                }
                this.provider._setTimeout( () => {
                    l()
                }
                , o.pop() || 4e3)
            }
            ;
            l()
        }
        )
    }
    async signTransaction(e) {
        const t = Uw(e);
        if (t.from) {
            const s = await Xs(t.from, this.provider);
            he(s != null && s.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", e),
            t.from = s
        } else
            t.from = this.address;
        const r = this.provider.getRpcTransaction(t);
        return await this.provider.send("eth_signTransaction", [r])
    }
    async signMessage(e) {
        const t = typeof e == "string" ? pc(e) : e;
        return await this.provider.send("personal_sign", [Ke(t), this.address.toLowerCase()])
    }
    async signTypedData(e, t, r) {
        const s = Uw(r)
          , i = await Vi.resolveNames(e, t, s, async o => {
            const a = await Xs(o);
            return he(a != null, "TypedData does not support null address", "value", o),
            a
        }
        );
        return await this.provider.send("eth_signTypedData_v4", [this.address.toLowerCase(), JSON.stringify(Vi.getPayload(i.domain, t, i.value))])
    }
    async unlock(e) {
        return this.provider.send("personal_unlockAccount", [this.address.toLowerCase(), e, null])
    }
    async _legacySignMessage(e) {
        const t = typeof e == "string" ? pc(e) : e;
        return await this.provider.send("eth_sign", [this.address.toLowerCase(), Ke(t)])
    }
}
class Vne extends Mne {
    #e;
    #t;
    #n;
    #r;
    #s;
    #o;
    #i;
    #a() {
        if (this.#r)
            return;
        const e = this._getOption("batchMaxCount") === 1 ? 0 : this._getOption("batchStallTime");
        this.#r = setTimeout( () => {
            this.#r = null;
            const t = this.#n;
            for (this.#n = []; t.length; ) {
                const r = [t.shift()];
                for (; t.length && r.length !== this.#e.batchMaxCount; )
                    if (r.push(t.shift()),
                    JSON.stringify(r.map(i => i.payload)).length > this.#e.batchMaxSize) {
                        t.unshift(r.pop());
                        break
                    }
                (async () => {
                    const s = r.length === 1 ? r[0].payload : r.map(i => i.payload);
                    this.emit("debug", {
                        action: "sendRpcPayload",
                        payload: s
                    });
                    try {
                        const i = await this._send(s);
                        this.emit("debug", {
                            action: "receiveRpcResult",
                            result: i
                        });
                        for (const {resolve: o, reject: a, payload: l} of r) {
                            if (this.destroyed) {
                                a(Zn("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", {
                                    operation: l.method
                                }));
                                continue
                            }
                            const u = i.filter(d => d.id === l.id)[0];
                            if (u == null) {
                                const d = Zn("missing response for request", "BAD_DATA", {
                                    value: i,
                                    info: {
                                        payload: l
                                    }
                                });
                                this.emit("error", d),
                                a(d);
                                continue
                            }
                            if ("error"in u) {
                                a(this.getRpcError(l, u));
                                continue
                            }
                            o(u.result)
                        }
                    } catch (i) {
                        this.emit("debug", {
                            action: "receiveRpcError",
                            error: i
                        });
                        for (const {reject: o} of r)
                            o(i)
                    }
                }
                )()
            }
        }
        , e)
    }
    constructor(e, t) {
        super(e, t),
        this.#t = 1,
        this.#e = Object.assign({}, lU, t || {}),
        this.#n = [],
        this.#r = null,
        this.#o = null,
        this.#i = null;
        {
            let s = null;
            const i = new Promise(o => {
                s = o
            }
            );
            this.#s = {
                promise: i,
                resolve: s
            }
        }
        const r = this._getOption("staticNetwork");
        typeof r == "boolean" ? (he(!r || e !== "any", "staticNetwork cannot be used on special network 'any'", "options", t),
        r && e != null && (this.#o = Qi.from(e))) : r && (he(e == null || r.matches(e), "staticNetwork MUST match network object", "options", t),
        this.#o = r)
    }
    _getOption(e) {
        return this.#e[e]
    }
    get _network() {
        return Ie(this.#o, "network is not available yet", "NETWORK_ERROR"),
        this.#o
    }
    async _perform(e) {
        if (e.method === "call" || e.method === "estimateGas") {
            let r = e.transaction;
            if (r && r.type != null && nt(r.type) && r.maxFeePerGas == null && r.maxPriorityFeePerGas == null) {
                const s = await this.getFeeData();
                s.maxFeePerGas == null && s.maxPriorityFeePerGas == null && (e = Object.assign({}, e, {
                    transaction: Object.assign({}, r, {
                        type: void 0
                    })
                }))
            }
        }
        const t = this.getRpcRequest(e);
        return t != null ? await this.send(t.method, t.args) : super._perform(e)
    }
    async _detectNetwork() {
        const e = this._getOption("staticNetwork");
        if (e)
            if (e === !0) {
                if (this.#o)
                    return this.#o
            } else
                return e;
        return this.#i ? await this.#i : this.ready ? (this.#i = (async () => {
            try {
                const t = Qi.from(nt(await this.send("eth_chainId", [])));
                return this.#i = null,
                t
            } catch (t) {
                throw this.#i = null,
                t
            }
        }
        )(),
        await this.#i) : (this.#i = (async () => {
            const t = {
                id: this.#t++,
                method: "eth_chainId",
                params: [],
                jsonrpc: "2.0"
            };
            this.emit("debug", {
                action: "sendRpcPayload",
                payload: t
            });
            let r;
            try {
                r = (await this._send(t))[0],
                this.#i = null
            } catch (s) {
                throw this.#i = null,
                this.emit("debug", {
                    action: "receiveRpcError",
                    error: s
                }),
                s
            }
            if (this.emit("debug", {
                action: "receiveRpcResult",
                result: r
            }),
            "result"in r)
                return Qi.from(nt(r.result));
            throw this.getRpcError(t, r)
        }
        )(),
        await this.#i)
    }
    _start() {
        this.#s == null || this.#s.resolve == null || (this.#s.resolve(),
        this.#s = null,
        (async () => {
            for (; this.#o == null && !this.destroyed; )
                try {
                    this.#o = await this._detectNetwork()
                } catch (e) {
                    if (this.destroyed)
                        break;
                    console.log("JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)"),
                    this.emit("error", Zn("failed to bootstrap network detection", "NETWORK_ERROR", {
                        event: "initial-network-discovery",
                        info: {
                            error: e
                        }
                    })),
                    await Hne(1e3)
                }
            this.#a()
        }
        )())
    }
    async _waitUntilReady() {
        if (this.#s != null)
            return await this.#s.promise
    }
    _getSubscriber(e) {
        return e.type === "pending" ? new zne(this) : e.type === "event" ? this._getOption("polling") ? new K8(this,e.filter) : new Une(this,e.filter) : e.type === "orphan" && e.filter.orphan === "drop-log" ? new oU("orphan") : super._getSubscriber(e)
    }
    get ready() {
        return this.#s == null
    }
    getRpcTransaction(e) {
        const t = {};
        return ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach(r => {
            if (e[r] == null)
                return;
            let s = r;
            r === "gasLimit" && (s = "gas"),
            t[s] = ea(nt(e[r], `tx.${r}`))
        }
        ),
        ["from", "to", "data"].forEach(r => {
            e[r] != null && (t[r] = Ke(e[r]))
        }
        ),
        e.accessList && (t.accessList = $f(e.accessList)),
        e.blobVersionedHashes && (t.blobVersionedHashes = e.blobVersionedHashes.map(r => r.toLowerCase())),
        e.authorizationList && (t.authorizationList = e.authorizationList.map(r => {
            const s = fF(r);
            return {
                address: s.address,
                nonce: ea(s.nonce),
                chainId: ea(s.chainId),
                yParity: ea(s.signature.yParity),
                r: ea(s.signature.r),
                s: ea(s.signature.s)
            }
        }
        )),
        t
    }
    getRpcRequest(e) {
        switch (e.method) {
        case "chainId":
            return {
                method: "eth_chainId",
                args: []
            };
        case "getBlockNumber":
            return {
                method: "eth_blockNumber",
                args: []
            };
        case "getGasPrice":
            return {
                method: "eth_gasPrice",
                args: []
            };
        case "getPriorityFee":
            return {
                method: "eth_maxPriorityFeePerGas",
                args: []
            };
        case "getBalance":
            return {
                method: "eth_getBalance",
                args: [Hh(e.address), e.blockTag]
            };
        case "getTransactionCount":
            return {
                method: "eth_getTransactionCount",
                args: [Hh(e.address), e.blockTag]
            };
        case "getCode":
            return {
                method: "eth_getCode",
                args: [Hh(e.address), e.blockTag]
            };
        case "getStorage":
            return {
                method: "eth_getStorageAt",
                args: [Hh(e.address), "0x" + e.position.toString(16), e.blockTag]
            };
        case "broadcastTransaction":
            return {
                method: "eth_sendRawTransaction",
                args: [e.signedTransaction]
            };
        case "getBlock":
            if ("blockTag"in e)
                return {
                    method: "eth_getBlockByNumber",
                    args: [e.blockTag, !!e.includeTransactions]
                };
            if ("blockHash"in e)
                return {
                    method: "eth_getBlockByHash",
                    args: [e.blockHash, !!e.includeTransactions]
                };
            break;
        case "getTransaction":
            return {
                method: "eth_getTransactionByHash",
                args: [e.hash]
            };
        case "getTransactionReceipt":
            return {
                method: "eth_getTransactionReceipt",
                args: [e.hash]
            };
        case "call":
            return {
                method: "eth_call",
                args: [this.getRpcTransaction(e.transaction), e.blockTag]
            };
        case "estimateGas":
            return {
                method: "eth_estimateGas",
                args: [this.getRpcTransaction(e.transaction)]
            };
        case "getLogs":
            return e.filter && e.filter.address != null && (Array.isArray(e.filter.address) ? e.filter.address = e.filter.address.map(Hh) : e.filter.address = Hh(e.filter.address)),
            {
                method: "eth_getLogs",
                args: [e.filter]
            }
        }
        return null
    }
    getRpcError(e, t) {
        const {method: r} = e
          , {error: s} = t;
        if (r === "eth_estimateGas" && s.message) {
            const a = s.message;
            if (!a.match(/revert/i) && a.match(/insufficient funds/i))
                return Zn("insufficient funds", "INSUFFICIENT_FUNDS", {
                    transaction: e.params[0],
                    info: {
                        payload: e,
                        error: s
                    }
                });
            if (a.match(/nonce/i) && a.match(/too low/i))
                return Zn("nonce has already been used", "NONCE_EXPIRED", {
                    transaction: e.params[0],
                    info: {
                        payload: e,
                        error: s
                    }
                })
        }
        if (r === "eth_call" || r === "eth_estimateGas") {
            const a = M4(s)
              , l = Qp.getBuiltinCallException(r === "eth_call" ? "call" : "estimateGas", e.params[0], a ? a.data : null);
            return l.info = {
                error: s,
                payload: e
            },
            l
        }
        const i = JSON.stringify(qne(s));
        if (typeof s.message == "string" && s.message.match(/user denied|ethers-user-denied/i))
            return Zn("user rejected action", "ACTION_REJECTED", {
                action: {
                    eth_sign: "signMessage",
                    personal_sign: "signMessage",
                    eth_signTypedData_v4: "signTypedData",
                    eth_signTransaction: "signTransaction",
                    eth_sendTransaction: "sendTransaction",
                    eth_requestAccounts: "requestAccess",
                    wallet_requestAccounts: "requestAccess"
                }[r] || "unknown",
                reason: "rejected",
                info: {
                    payload: e,
                    error: s
                }
            });
        if (r === "eth_sendRawTransaction" || r === "eth_sendTransaction") {
            const a = e.params[0];
            if (i.match(/insufficient funds|base fee exceeds gas limit/i))
                return Zn("insufficient funds for intrinsic transaction cost", "INSUFFICIENT_FUNDS", {
                    transaction: a,
                    info: {
                        error: s
                    }
                });
            if (i.match(/nonce/i) && i.match(/too low/i))
                return Zn("nonce has already been used", "NONCE_EXPIRED", {
                    transaction: a,
                    info: {
                        error: s
                    }
                });
            if (i.match(/replacement transaction/i) && i.match(/underpriced/i))
                return Zn("replacement fee too low", "REPLACEMENT_UNDERPRICED", {
                    transaction: a,
                    info: {
                        error: s
                    }
                });
            if (i.match(/only replay-protected/i))
                return Zn("legacy pre-eip-155 transactions not supported", "UNSUPPORTED_OPERATION", {
                    operation: r,
                    info: {
                        transaction: a,
                        info: {
                            error: s
                        }
                    }
                })
        }
        let o = !!i.match(/the method .* does not exist/i);
        return o || s && s.details && s.details.startsWith("Unauthorized method:") && (o = !0),
        o ? Zn("unsupported operation", "UNSUPPORTED_OPERATION", {
            operation: e.method,
            info: {
                error: s,
                payload: e
            }
        }) : Zn("could not coalesce error", "UNKNOWN_ERROR", {
            error: s,
            payload: e
        })
    }
    send(e, t) {
        if (this.destroyed)
            return Promise.reject(Zn("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", {
                operation: e
            }));
        const r = this.#t++
          , s = new Promise( (i, o) => {
            this.#n.push({
                resolve: i,
                reject: o,
                payload: {
                    method: e,
                    params: t,
                    id: r,
                    jsonrpc: "2.0"
                }
            })
        }
        );
        return this.#a(),
        s
    }
    async getSigner(e) {
        e == null && (e = 0);
        const t = this.send("eth_accounts", []);
        if (typeof e == "number") {
            const s = await t;
            if (e >= s.length)
                throw new Error("no such account");
            return new PS(this,s[e])
        }
        const {accounts: r} = await qs({
            network: this.getNetwork(),
            accounts: t
        });
        e = yn(e);
        for (const s of r)
            if (yn(s) === e)
                return new PS(this,e);
        throw new Error("invalid account")
    }
    async listAccounts() {
        return (await this.send("eth_accounts", [])).map(t => new PS(this,t))
    }
    destroy() {
        this.#r && (clearTimeout(this.#r),
        this.#r = null);
        for (const {payload: e, reject: t} of this.#n)
            t(Zn("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", {
                operation: e.method
            }));
        this.#n = [],
        super.destroy()
    }
}
class cU extends Vne {
    #e;
    constructor(e, t) {
        super(e, t);
        let r = this._getOption("pollingInterval");
        r == null && (r = lU.pollingInterval),
        this.#e = r
    }
    _getSubscriber(e) {
        const t = super._getSubscriber(e);
        return dM(t) && (t.pollingInterval = this.#e),
        t
    }
    get pollingInterval() {
        return this.#e
    }
    set pollingInterval(e) {
        if (!Number.isInteger(e) || e < 0)
            throw new Error("invalid interval");
        this.#e = e,
        this._forEachSubscriber(t => {
            dM(t) && (t.pollingInterval = this.#e)
        }
        )
    }
}
class Ty extends cU {
    #e;
    constructor(e, t, r) {
        e == null && (e = "http://localhost:8545"),
        super(t, r),
        typeof e == "string" ? this.#e = new tl(e) : this.#e = e.clone()
    }
    _getConnection() {
        return this.#e.clone()
    }
    async send(e, t) {
        return await this._start(),
        await super.send(e, t)
    }
    async _send(e) {
        const t = this._getConnection();
        t.body = JSON.stringify(e),
        t.setHeader("content-type", "application/json");
        const r = await t.send();
        r.assertOk();
        let s = r.bodyJson;
        return Array.isArray(s) || (s = [s]),
        s
    }
}
function M4(n) {
    if (n == null)
        return null;
    if (typeof n.message == "string" && n.message.match(/revert/i) && zn(n.data))
        return {
            message: n.message,
            data: n.data
        };
    if (typeof n == "object") {
        for (const e in n) {
            const t = M4(n[e]);
            if (t)
                return t
        }
        return null
    }
    if (typeof n == "string")
        try {
            return M4(JSON.parse(n))
        } catch {}
    return null
}
function B4(n, e) {
    if (n != null) {
        if (typeof n.message == "string" && e.push(n.message),
        typeof n == "object")
            for (const t in n)
                B4(n[t], e);
        if (typeof n == "string")
            try {
                return B4(JSON.parse(n), e)
            } catch {}
    }
}
function qne(n) {
    const e = [];
    return B4(n, e),
    e
}
class Ys extends cU {
    #e;
    #t;
    constructor(e, t, r) {
        const s = Object.assign({}, r ?? {}, {
            batchMaxCount: 1
        });
        he(e && e.request, "invalid EIP-1193 provider", "ethereum", e),
        super(t, s),
        this.#t = null,
        r && r.providerInfo && (this.#t = r.providerInfo),
        this.#e = async (i, o) => {
            const a = {
                method: i,
                params: o
            };
            this.emit("debug", {
                action: "sendEip1193Request",
                payload: a
            });
            try {
                const l = await e.request(a);
                return this.emit("debug", {
                    action: "receiveEip1193Result",
                    result: l
                }),
                l
            } catch (l) {
                const u = new Error(l.message);
                throw u.code = l.code,
                u.data = l.data,
                u.payload = a,
                this.emit("debug", {
                    action: "receiveEip1193Error",
                    error: u
                }),
                u
            }
        }
    }
    get providerInfo() {
        return this.#t
    }
    async send(e, t) {
        return await this._start(),
        await super.send(e, t)
    }
    async _send(e) {
        he(!Array.isArray(e), "EIP-1193 does not support batch request", "payload", e);
        try {
            const t = await this.#e(e.method, e.params || []);
            return [{
                id: e.id,
                result: t
            }]
        } catch (t) {
            return [{
                id: e.id,
                error: {
                    code: t.code,
                    data: t.data,
                    message: t.message
                }
            }]
        }
    }
    getRpcError(e, t) {
        switch (t = JSON.parse(JSON.stringify(t)),
        t.error.code || -1) {
        case 4001:
            t.error.message = `ethers-user-denied: ${t.error.message}`;
            break;
        case 4200:
            t.error.message = `ethers-unsupported: ${t.error.message}`;
            break
        }
        return super.getRpcError(e, t)
    }
    async hasSigner(e) {
        e == null && (e = 0);
        const t = await this.send("eth_accounts", []);
        return typeof e == "number" ? t.length > e : (e = e.toLowerCase(),
        t.filter(r => r.toLowerCase() === e).length !== 0)
    }
    async getSigner(e) {
        if (e == null && (e = 0),
        !await this.hasSigner(e))
            try {
                await this.#e("eth_requestAccounts", [])
            } catch (t) {
                const r = t.payload;
                throw this.getRpcError(r, {
                    id: r.id,
                    error: t
                })
            }
        return await super.getSigner(e)
    }
    static async discover(e) {
        if (e == null && (e = {}),
        e.provider)
            return new Ys(e.provider);
        const t = e.window ? e.window : typeof window < "u" ? window : null;
        if (t == null)
            return null;
        const r = e.anyProvider;
        if (r && t.ethereum)
            return new Ys(t.ethereum);
        if (!("addEventListener"in t && "dispatchEvent"in t && "removeEventListener"in t))
            return null;
        const s = e.timeout ? e.timeout : 300;
        return s === 0 ? null : await new Promise( (i, o) => {
            let a = [];
            const l = h => {
                a.push(h.detail),
                r && u()
            }
              , u = () => {
                if (clearTimeout(d),
                a.length)
                    if (e && e.filter) {
                        const h = e.filter(a.map(p => Object.assign({}, p.info)));
                        if (h == null)
                            i(null);
                        else if (h instanceof Ys)
                            i(h);
                        else {
                            let p = null;
                            if (h.uuid && (p = a.filter(w => h.uuid === w.info.uuid)[0]),
                            p) {
                                const {provider: g, info: w} = p;
                                i(new Ys(g,void 0,{
                                    providerInfo: w
                                }))
                            } else
                                o(Zn("filter returned unknown info", "UNSUPPORTED_OPERATION", {
                                    value: h
                                }))
                        }
                    } else {
                        const {provider: h, info: p} = a[0];
                        i(new Ys(h,void 0,{
                            providerInfo: p
                        }))
                    }
                else
                    i(null);
                t.removeEventListener("eip6963:announceProvider", l)
            }
              , d = setTimeout( () => {
                u()
            }
            , s);
            t.addEventListener("eip6963:announceProvider", l),
            t.dispatchEvent(new Event("eip6963:requestProvider"))
        }
        )
    }
}
function of(n) {
    let e = "Something went wrong. Please try again."
      , t = "UNKNOWN";
    if (!n)
        return {
            code: t,
            message: e,
            raw: n
        };
    const r = i => i ? typeof i == "string" ? i : i.message ? i.message : i.error ? r(i.error) : i.info?.error ? r(i.info.error) : i.cause ? r(i.cause) : "" : ""
      , s = r(n).toLowerCase();
    try {
        const i = n?.code ?? n?.error?.code;
        i === 4001 || i === "ACTION_REJECTED" ? (t = "USER_REJECTED",
        e = "You rejected the request in your wallet.") : i === -32002 ? (t = "PENDING_REQUEST",
        e = "A wallet request is already pending. Please check your wallet popup.") : s.includes("chain") && s.includes("network") ? (t = "WRONG_NETWORK",
        e = "Please switch to the correct network.") : s.includes("insufficient funds") ? (t = "INSUFFICIENT_FUNDS",
        e = "You don't have enough balance to complete this transaction.") : s.includes("underpriced") ? (t = "LOW_GAS_PRICE",
        e = "Gas price too low. Try again with a higher gas fee.") : s.includes("provider not found") ? (t = "NO_PROVIDER",
        e = "No wallet provider found. Please install MetaMask or another wallet.") : e = r(n) || e
    } catch (i) {
        console.error("Error parsing wallet error:", i)
    }
    return {
        code: t,
        message: e,
        raw: n
    }
}
var jS = {}, Pm = {}, fM;
function Gne() {
    if (fM)
        return Pm;
    fM = 1,
    Pm.byteLength = a,
    Pm.toByteArray = u,
    Pm.fromByteArray = p;
    for (var n = [], e = [], t = typeof Uint8Array < "u" ? Uint8Array : Array, r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", s = 0, i = r.length; s < i; ++s)
        n[s] = r[s],
        e[r.charCodeAt(s)] = s;
    e[45] = 62,
    e[95] = 63;
    function o(g) {
        var w = g.length;
        if (w % 4 > 0)
            throw new Error("Invalid string. Length must be a multiple of 4");
        var b = g.indexOf("=");
        b === -1 && (b = w);
        var v = b === w ? 0 : 4 - b % 4;
        return [b, v]
    }
    function a(g) {
        var w = o(g)
          , b = w[0]
          , v = w[1];
        return (b + v) * 3 / 4 - v
    }
    function l(g, w, b) {
        return (w + b) * 3 / 4 - b
    }
    function u(g) {
        var w, b = o(g), v = b[0], S = b[1], N = new t(l(g, v, S)), _ = 0, I = S > 0 ? v - 4 : v, k;
        for (k = 0; k < I; k += 4)
            w = e[g.charCodeAt(k)] << 18 | e[g.charCodeAt(k + 1)] << 12 | e[g.charCodeAt(k + 2)] << 6 | e[g.charCodeAt(k + 3)],
            N[_++] = w >> 16 & 255,
            N[_++] = w >> 8 & 255,
            N[_++] = w & 255;
        return S === 2 && (w = e[g.charCodeAt(k)] << 2 | e[g.charCodeAt(k + 1)] >> 4,
        N[_++] = w & 255),
        S === 1 && (w = e[g.charCodeAt(k)] << 10 | e[g.charCodeAt(k + 1)] << 4 | e[g.charCodeAt(k + 2)] >> 2,
        N[_++] = w >> 8 & 255,
        N[_++] = w & 255),
        N
    }
    function d(g) {
        return n[g >> 18 & 63] + n[g >> 12 & 63] + n[g >> 6 & 63] + n[g & 63]
    }
    function h(g, w, b) {
        for (var v, S = [], N = w; N < b; N += 3)
            v = (g[N] << 16 & 16711680) + (g[N + 1] << 8 & 65280) + (g[N + 2] & 255),
            S.push(d(v));
        return S.join("")
    }
    function p(g) {
        for (var w, b = g.length, v = b % 3, S = [], N = 16383, _ = 0, I = b - v; _ < I; _ += N)
            S.push(h(g, _, _ + N > I ? I : _ + N));
        return v === 1 ? (w = g[b - 1],
        S.push(n[w >> 2] + n[w << 4 & 63] + "==")) : v === 2 && (w = (g[b - 2] << 8) + g[b - 1],
        S.push(n[w >> 10] + n[w >> 4 & 63] + n[w << 2 & 63] + "=")),
        S.join("")
    }
    return Pm
}
var N1 = {};
var hM;
function Wne() {
    return hM || (hM = 1,
    N1.read = function(n, e, t, r, s) {
        var i, o, a = s * 8 - r - 1, l = (1 << a) - 1, u = l >> 1, d = -7, h = t ? s - 1 : 0, p = t ? -1 : 1, g = n[e + h];
        for (h += p,
        i = g & (1 << -d) - 1,
        g >>= -d,
        d += a; d > 0; i = i * 256 + n[e + h],
        h += p,
        d -= 8)
            ;
        for (o = i & (1 << -d) - 1,
        i >>= -d,
        d += r; d > 0; o = o * 256 + n[e + h],
        h += p,
        d -= 8)
            ;
        if (i === 0)
            i = 1 - u;
        else {
            if (i === l)
                return o ? NaN : (g ? -1 : 1) * (1 / 0);
            o = o + Math.pow(2, r),
            i = i - u
        }
        return (g ? -1 : 1) * o * Math.pow(2, i - r)
    }
    ,
    N1.write = function(n, e, t, r, s, i) {
        var o, a, l, u = i * 8 - s - 1, d = (1 << u) - 1, h = d >> 1, p = s === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, g = r ? 0 : i - 1, w = r ? 1 : -1, b = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
        for (e = Math.abs(e),
        isNaN(e) || e === 1 / 0 ? (a = isNaN(e) ? 1 : 0,
        o = d) : (o = Math.floor(Math.log(e) / Math.LN2),
        e * (l = Math.pow(2, -o)) < 1 && (o--,
        l *= 2),
        o + h >= 1 ? e += p / l : e += p * Math.pow(2, 1 - h),
        e * l >= 2 && (o++,
        l /= 2),
        o + h >= d ? (a = 0,
        o = d) : o + h >= 1 ? (a = (e * l - 1) * Math.pow(2, s),
        o = o + h) : (a = e * Math.pow(2, h - 1) * Math.pow(2, s),
        o = 0)); s >= 8; n[t + g] = a & 255,
        g += w,
        a /= 256,
        s -= 8)
            ;
        for (o = o << s | a,
        u += s; u > 0; n[t + g] = o & 255,
        g += w,
        o /= 256,
        u -= 8)
            ;
        n[t + g - w] |= b * 128
    }
    ),
    N1
}
var pM;
function Yv() {
    return pM || (pM = 1,
    (function(n) {
        const e = Gne()
          , t = Wne()
          , r = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
        n.Buffer = a,
        n.SlowBuffer = N,
        n.INSPECT_MAX_BYTES = 50;
        const s = 2147483647;
        n.kMaxLength = s,
        a.TYPED_ARRAY_SUPPORT = i(),
        !a.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
        function i() {
            try {
                const ee = new Uint8Array(1)
                  , K = {
                    foo: function() {
                        return 42
                    }
                };
                return Object.setPrototypeOf(K, Uint8Array.prototype),
                Object.setPrototypeOf(ee, K),
                ee.foo() === 42
            } catch {
                return !1
            }
        }
        Object.defineProperty(a.prototype, "parent", {
            enumerable: !0,
            get: function() {
                if (a.isBuffer(this))
                    return this.buffer
            }
        }),
        Object.defineProperty(a.prototype, "offset", {
            enumerable: !0,
            get: function() {
                if (a.isBuffer(this))
                    return this.byteOffset
            }
        });
        function o(ee) {
            if (ee > s)
                throw new RangeError('The value "' + ee + '" is invalid for option "size"');
            const K = new Uint8Array(ee);
            return Object.setPrototypeOf(K, a.prototype),
            K
        }
        function a(ee, K, X) {
            if (typeof ee == "number") {
                if (typeof K == "string")
                    throw new TypeError('The "string" argument must be of type string. Received type number');
                return h(ee)
            }
            return l(ee, K, X)
        }
        a.poolSize = 8192;
        function l(ee, K, X) {
            if (typeof ee == "string")
                return p(ee, K);
            if (ArrayBuffer.isView(ee))
                return w(ee);
            if (ee == null)
                throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof ee);
            if (Et(ee, ArrayBuffer) || ee && Et(ee.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (Et(ee, SharedArrayBuffer) || ee && Et(ee.buffer, SharedArrayBuffer)))
                return b(ee, K, X);
            if (typeof ee == "number")
                throw new TypeError('The "value" argument must not be of type number. Received type number');
            const re = ee.valueOf && ee.valueOf();
            if (re != null && re !== ee)
                return a.from(re, K, X);
            const se = v(ee);
            if (se)
                return se;
            if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof ee[Symbol.toPrimitive] == "function")
                return a.from(ee[Symbol.toPrimitive]("string"), K, X);
            throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof ee)
        }
        a.from = function(ee, K, X) {
            return l(ee, K, X)
        }
        ,
        Object.setPrototypeOf(a.prototype, Uint8Array.prototype),
        Object.setPrototypeOf(a, Uint8Array);
        function u(ee) {
            if (typeof ee != "number")
                throw new TypeError('"size" argument must be of type number');
            if (ee < 0)
                throw new RangeError('The value "' + ee + '" is invalid for option "size"')
        }
        function d(ee, K, X) {
            return u(ee),
            ee <= 0 ? o(ee) : K !== void 0 ? typeof X == "string" ? o(ee).fill(K, X) : o(ee).fill(K) : o(ee)
        }
        a.alloc = function(ee, K, X) {
            return d(ee, K, X)
        }
        ;
        function h(ee) {
            return u(ee),
            o(ee < 0 ? 0 : S(ee) | 0)
        }
        a.allocUnsafe = function(ee) {
            return h(ee)
        }
        ,
        a.allocUnsafeSlow = function(ee) {
            return h(ee)
        }
        ;
        function p(ee, K) {
            if ((typeof K != "string" || K === "") && (K = "utf8"),
            !a.isEncoding(K))
                throw new TypeError("Unknown encoding: " + K);
            const X = _(ee, K) | 0;
            let re = o(X);
            const se = re.write(ee, K);
            return se !== X && (re = re.slice(0, se)),
            re
        }
        function g(ee) {
            const K = ee.length < 0 ? 0 : S(ee.length) | 0
              , X = o(K);
            for (let re = 0; re < K; re += 1)
                X[re] = ee[re] & 255;
            return X
        }
        function w(ee) {
            if (Et(ee, Uint8Array)) {
                const K = new Uint8Array(ee);
                return b(K.buffer, K.byteOffset, K.byteLength)
            }
            return g(ee)
        }
        function b(ee, K, X) {
            if (K < 0 || ee.byteLength < K)
                throw new RangeError('"offset" is outside of buffer bounds');
            if (ee.byteLength < K + (X || 0))
                throw new RangeError('"length" is outside of buffer bounds');
            let re;
            return K === void 0 && X === void 0 ? re = new Uint8Array(ee) : X === void 0 ? re = new Uint8Array(ee,K) : re = new Uint8Array(ee,K,X),
            Object.setPrototypeOf(re, a.prototype),
            re
        }
        function v(ee) {
            if (a.isBuffer(ee)) {
                const K = S(ee.length) | 0
                  , X = o(K);
                return X.length === 0 || ee.copy(X, 0, 0, K),
                X
            }
            if (ee.length !== void 0)
                return typeof ee.length != "number" || St(ee.length) ? o(0) : g(ee);
            if (ee.type === "Buffer" && Array.isArray(ee.data))
                return g(ee.data)
        }
        function S(ee) {
            if (ee >= s)
                throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + s.toString(16) + " bytes");
            return ee | 0
        }
        function N(ee) {
            return +ee != ee && (ee = 0),
            a.alloc(+ee)
        }
        a.isBuffer = function(K) {
            return K != null && K._isBuffer === !0 && K !== a.prototype
        }
        ,
        a.compare = function(K, X) {
            if (Et(K, Uint8Array) && (K = a.from(K, K.offset, K.byteLength)),
            Et(X, Uint8Array) && (X = a.from(X, X.offset, X.byteLength)),
            !a.isBuffer(K) || !a.isBuffer(X))
                throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
            if (K === X)
                return 0;
            let re = K.length
              , se = X.length;
            for (let fe = 0, ge = Math.min(re, se); fe < ge; ++fe)
                if (K[fe] !== X[fe]) {
                    re = K[fe],
                    se = X[fe];
                    break
                }
            return re < se ? -1 : se < re ? 1 : 0
        }
        ,
        a.isEncoding = function(K) {
            switch (String(K).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return !0;
            default:
                return !1
            }
        }
        ,
        a.concat = function(K, X) {
            if (!Array.isArray(K))
                throw new TypeError('"list" argument must be an Array of Buffers');
            if (K.length === 0)
                return a.alloc(0);
            let re;
            if (X === void 0)
                for (X = 0,
                re = 0; re < K.length; ++re)
                    X += K[re].length;
            const se = a.allocUnsafe(X);
            let fe = 0;
            for (re = 0; re < K.length; ++re) {
                let ge = K[re];
                if (Et(ge, Uint8Array))
                    fe + ge.length > se.length ? (a.isBuffer(ge) || (ge = a.from(ge)),
                    ge.copy(se, fe)) : Uint8Array.prototype.set.call(se, ge, fe);
                else if (a.isBuffer(ge))
                    ge.copy(se, fe);
                else
                    throw new TypeError('"list" argument must be an Array of Buffers');
                fe += ge.length
            }
            return se
        }
        ;
        function _(ee, K) {
            if (a.isBuffer(ee))
                return ee.length;
            if (ArrayBuffer.isView(ee) || Et(ee, ArrayBuffer))
                return ee.byteLength;
            if (typeof ee != "string")
                throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof ee);
            const X = ee.length
              , re = arguments.length > 2 && arguments[2] === !0;
            if (!re && X === 0)
                return 0;
            let se = !1;
            for (; ; )
                switch (K) {
                case "ascii":
                case "latin1":
                case "binary":
                    return X;
                case "utf8":
                case "utf-8":
                    return st(ee).length;
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return X * 2;
                case "hex":
                    return X >>> 1;
                case "base64":
                    return ct(ee).length;
                default:
                    if (se)
                        return re ? -1 : st(ee).length;
                    K = ("" + K).toLowerCase(),
                    se = !0
                }
        }
        a.byteLength = _;
        function I(ee, K, X) {
            let re = !1;
            if ((K === void 0 || K < 0) && (K = 0),
            K > this.length || ((X === void 0 || X > this.length) && (X = this.length),
            X <= 0) || (X >>>= 0,
            K >>>= 0,
            X <= K))
                return "";
            for (ee || (ee = "utf8"); ; )
                switch (ee) {
                case "hex":
                    return G(this, K, X);
                case "utf8":
                case "utf-8":
                    return A(this, K, X);
                case "ascii":
                    return O(this, K, X);
                case "latin1":
                case "binary":
                    return z(this, K, X);
                case "base64":
                    return j(this, K, X);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return Y(this, K, X);
                default:
                    if (re)
                        throw new TypeError("Unknown encoding: " + ee);
                    ee = (ee + "").toLowerCase(),
                    re = !0
                }
        }
        a.prototype._isBuffer = !0;
        function k(ee, K, X) {
            const re = ee[K];
            ee[K] = ee[X],
            ee[X] = re
        }
        a.prototype.swap16 = function() {
            const K = this.length;
            if (K % 2 !== 0)
                throw new RangeError("Buffer size must be a multiple of 16-bits");
            for (let X = 0; X < K; X += 2)
                k(this, X, X + 1);
            return this
        }
        ,
        a.prototype.swap32 = function() {
            const K = this.length;
            if (K % 4 !== 0)
                throw new RangeError("Buffer size must be a multiple of 32-bits");
            for (let X = 0; X < K; X += 4)
                k(this, X, X + 3),
                k(this, X + 1, X + 2);
            return this
        }
        ,
        a.prototype.swap64 = function() {
            const K = this.length;
            if (K % 8 !== 0)
                throw new RangeError("Buffer size must be a multiple of 64-bits");
            for (let X = 0; X < K; X += 8)
                k(this, X, X + 7),
                k(this, X + 1, X + 6),
                k(this, X + 2, X + 5),
                k(this, X + 3, X + 4);
            return this
        }
        ,
        a.prototype.toString = function() {
            const K = this.length;
            return K === 0 ? "" : arguments.length === 0 ? A(this, 0, K) : I.apply(this, arguments)
        }
        ,
        a.prototype.toLocaleString = a.prototype.toString,
        a.prototype.equals = function(K) {
            if (!a.isBuffer(K))
                throw new TypeError("Argument must be a Buffer");
            return this === K ? !0 : a.compare(this, K) === 0
        }
        ,
        a.prototype.inspect = function() {
            let K = "";
            const X = n.INSPECT_MAX_BYTES;
            return K = this.toString("hex", 0, X).replace(/(.{2})/g, "$1 ").trim(),
            this.length > X && (K += " ... "),
            "<Buffer " + K + ">"
        }
        ,
        r && (a.prototype[r] = a.prototype.inspect),
        a.prototype.compare = function(K, X, re, se, fe) {
            if (Et(K, Uint8Array) && (K = a.from(K, K.offset, K.byteLength)),
            !a.isBuffer(K))
                throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof K);
            if (X === void 0 && (X = 0),
            re === void 0 && (re = K ? K.length : 0),
            se === void 0 && (se = 0),
            fe === void 0 && (fe = this.length),
            X < 0 || re > K.length || se < 0 || fe > this.length)
                throw new RangeError("out of range index");
            if (se >= fe && X >= re)
                return 0;
            if (se >= fe)
                return -1;
            if (X >= re)
                return 1;
            if (X >>>= 0,
            re >>>= 0,
            se >>>= 0,
            fe >>>= 0,
            this === K)
                return 0;
            let ge = fe - se
              , _e = re - X;
            const Qe = Math.min(ge, _e)
              , Ve = this.slice(se, fe)
              , jt = K.slice(X, re);
            for (let dt = 0; dt < Qe; ++dt)
                if (Ve[dt] !== jt[dt]) {
                    ge = Ve[dt],
                    _e = jt[dt];
                    break
                }
            return ge < _e ? -1 : _e < ge ? 1 : 0
        }
        ;
        function B(ee, K, X, re, se) {
            if (ee.length === 0)
                return -1;
            if (typeof X == "string" ? (re = X,
            X = 0) : X > 2147483647 ? X = 2147483647 : X < -2147483648 && (X = -2147483648),
            X = +X,
            St(X) && (X = se ? 0 : ee.length - 1),
            X < 0 && (X = ee.length + X),
            X >= ee.length) {
                if (se)
                    return -1;
                X = ee.length - 1
            } else if (X < 0)
                if (se)
                    X = 0;
                else
                    return -1;
            if (typeof K == "string" && (K = a.from(K, re)),
            a.isBuffer(K))
                return K.length === 0 ? -1 : P(ee, K, X, re, se);
            if (typeof K == "number")
                return K = K & 255,
                typeof Uint8Array.prototype.indexOf == "function" ? se ? Uint8Array.prototype.indexOf.call(ee, K, X) : Uint8Array.prototype.lastIndexOf.call(ee, K, X) : P(ee, [K], X, re, se);
            throw new TypeError("val must be string, number or Buffer")
        }
        function P(ee, K, X, re, se) {
            let fe = 1
              , ge = ee.length
              , _e = K.length;
            if (re !== void 0 && (re = String(re).toLowerCase(),
            re === "ucs2" || re === "ucs-2" || re === "utf16le" || re === "utf-16le")) {
                if (ee.length < 2 || K.length < 2)
                    return -1;
                fe = 2,
                ge /= 2,
                _e /= 2,
                X /= 2
            }
            function Qe(jt, dt) {
                return fe === 1 ? jt[dt] : jt.readUInt16BE(dt * fe)
            }
            let Ve;
            if (se) {
                let jt = -1;
                for (Ve = X; Ve < ge; Ve++)
                    if (Qe(ee, Ve) === Qe(K, jt === -1 ? 0 : Ve - jt)) {
                        if (jt === -1 && (jt = Ve),
                        Ve - jt + 1 === _e)
                            return jt * fe
                    } else
                        jt !== -1 && (Ve -= Ve - jt),
                        jt = -1
            } else
                for (X + _e > ge && (X = ge - _e),
                Ve = X; Ve >= 0; Ve--) {
                    let jt = !0;
                    for (let dt = 0; dt < _e; dt++)
                        if (Qe(ee, Ve + dt) !== Qe(K, dt)) {
                            jt = !1;
                            break
                        }
                    if (jt)
                        return Ve
                }
            return -1
        }
        a.prototype.includes = function(K, X, re) {
            return this.indexOf(K, X, re) !== -1
        }
        ,
        a.prototype.indexOf = function(K, X, re) {
            return B(this, K, X, re, !0)
        }
        ,
        a.prototype.lastIndexOf = function(K, X, re) {
            return B(this, K, X, re, !1)
        }
        ;
        function M(ee, K, X, re) {
            X = Number(X) || 0;
            const se = ee.length - X;
            re ? (re = Number(re),
            re > se && (re = se)) : re = se;
            const fe = K.length;
            re > fe / 2 && (re = fe / 2);
            let ge;
            for (ge = 0; ge < re; ++ge) {
                const _e = parseInt(K.substr(ge * 2, 2), 16);
                if (St(_e))
                    return ge;
                ee[X + ge] = _e
            }
            return ge
        }
        function R(ee, K, X, re) {
            return Xe(st(K, ee.length - X), ee, X, re)
        }
        function L(ee, K, X, re) {
            return Xe(ot(K), ee, X, re)
        }
        function q(ee, K, X, re) {
            return Xe(ct(K), ee, X, re)
        }
        function H(ee, K, X, re) {
            return Xe(Ct(K, ee.length - X), ee, X, re)
        }
        a.prototype.write = function(K, X, re, se) {
            if (X === void 0)
                se = "utf8",
                re = this.length,
                X = 0;
            else if (re === void 0 && typeof X == "string")
                se = X,
                re = this.length,
                X = 0;
            else if (isFinite(X))
                X = X >>> 0,
                isFinite(re) ? (re = re >>> 0,
                se === void 0 && (se = "utf8")) : (se = re,
                re = void 0);
            else
                throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
            const fe = this.length - X;
            if ((re === void 0 || re > fe) && (re = fe),
            K.length > 0 && (re < 0 || X < 0) || X > this.length)
                throw new RangeError("Attempt to write outside buffer bounds");
            se || (se = "utf8");
            let ge = !1;
            for (; ; )
                switch (se) {
                case "hex":
                    return M(this, K, X, re);
                case "utf8":
                case "utf-8":
                    return R(this, K, X, re);
                case "ascii":
                case "latin1":
                case "binary":
                    return L(this, K, X, re);
                case "base64":
                    return q(this, K, X, re);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return H(this, K, X, re);
                default:
                    if (ge)
                        throw new TypeError("Unknown encoding: " + se);
                    se = ("" + se).toLowerCase(),
                    ge = !0
                }
        }
        ,
        a.prototype.toJSON = function() {
            return {
                type: "Buffer",
                data: Array.prototype.slice.call(this._arr || this, 0)
            }
        }
        ;
        function j(ee, K, X) {
            return K === 0 && X === ee.length ? e.fromByteArray(ee) : e.fromByteArray(ee.slice(K, X))
        }
        function A(ee, K, X) {
            X = Math.min(ee.length, X);
            const re = [];
            let se = K;
            for (; se < X; ) {
                const fe = ee[se];
                let ge = null
                  , _e = fe > 239 ? 4 : fe > 223 ? 3 : fe > 191 ? 2 : 1;
                if (se + _e <= X) {
                    let Qe, Ve, jt, dt;
                    switch (_e) {
                    case 1:
                        fe < 128 && (ge = fe);
                        break;
                    case 2:
                        Qe = ee[se + 1],
                        (Qe & 192) === 128 && (dt = (fe & 31) << 6 | Qe & 63,
                        dt > 127 && (ge = dt));
                        break;
                    case 3:
                        Qe = ee[se + 1],
                        Ve = ee[se + 2],
                        (Qe & 192) === 128 && (Ve & 192) === 128 && (dt = (fe & 15) << 12 | (Qe & 63) << 6 | Ve & 63,
                        dt > 2047 && (dt < 55296 || dt > 57343) && (ge = dt));
                        break;
                    case 4:
                        Qe = ee[se + 1],
                        Ve = ee[se + 2],
                        jt = ee[se + 3],
                        (Qe & 192) === 128 && (Ve & 192) === 128 && (jt & 192) === 128 && (dt = (fe & 15) << 18 | (Qe & 63) << 12 | (Ve & 63) << 6 | jt & 63,
                        dt > 65535 && dt < 1114112 && (ge = dt))
                    }
                }
                ge === null ? (ge = 65533,
                _e = 1) : ge > 65535 && (ge -= 65536,
                re.push(ge >>> 10 & 1023 | 55296),
                ge = 56320 | ge & 1023),
                re.push(ge),
                se += _e
            }
            return C(re)
        }
        const E = 4096;
        function C(ee) {
            const K = ee.length;
            if (K <= E)
                return String.fromCharCode.apply(String, ee);
            let X = ""
              , re = 0;
            for (; re < K; )
                X += String.fromCharCode.apply(String, ee.slice(re, re += E));
            return X
        }
        function O(ee, K, X) {
            let re = "";
            X = Math.min(ee.length, X);
            for (let se = K; se < X; ++se)
                re += String.fromCharCode(ee[se] & 127);
            return re
        }
        function z(ee, K, X) {
            let re = "";
            X = Math.min(ee.length, X);
            for (let se = K; se < X; ++se)
                re += String.fromCharCode(ee[se]);
            return re
        }
        function G(ee, K, X) {
            const re = ee.length;
            (!K || K < 0) && (K = 0),
            (!X || X < 0 || X > re) && (X = re);
            let se = "";
            for (let fe = K; fe < X; ++fe)
                se += ut[ee[fe]];
            return se
        }
        function Y(ee, K, X) {
            const re = ee.slice(K, X);
            let se = "";
            for (let fe = 0; fe < re.length - 1; fe += 2)
                se += String.fromCharCode(re[fe] + re[fe + 1] * 256);
            return se
        }
        a.prototype.slice = function(K, X) {
            const re = this.length;
            K = ~~K,
            X = X === void 0 ? re : ~~X,
            K < 0 ? (K += re,
            K < 0 && (K = 0)) : K > re && (K = re),
            X < 0 ? (X += re,
            X < 0 && (X = 0)) : X > re && (X = re),
            X < K && (X = K);
            const se = this.subarray(K, X);
            return Object.setPrototypeOf(se, a.prototype),
            se
        }
        ;
        function $(ee, K, X) {
            if (ee % 1 !== 0 || ee < 0)
                throw new RangeError("offset is not uint");
            if (ee + K > X)
                throw new RangeError("Trying to access beyond buffer length")
        }
        a.prototype.readUintLE = a.prototype.readUIntLE = function(K, X, re) {
            K = K >>> 0,
            X = X >>> 0,
            re || $(K, X, this.length);
            let se = this[K]
              , fe = 1
              , ge = 0;
            for (; ++ge < X && (fe *= 256); )
                se += this[K + ge] * fe;
            return se
        }
        ,
        a.prototype.readUintBE = a.prototype.readUIntBE = function(K, X, re) {
            K = K >>> 0,
            X = X >>> 0,
            re || $(K, X, this.length);
            let se = this[K + --X]
              , fe = 1;
            for (; X > 0 && (fe *= 256); )
                se += this[K + --X] * fe;
            return se
        }
        ,
        a.prototype.readUint8 = a.prototype.readUInt8 = function(K, X) {
            return K = K >>> 0,
            X || $(K, 1, this.length),
            this[K]
        }
        ,
        a.prototype.readUint16LE = a.prototype.readUInt16LE = function(K, X) {
            return K = K >>> 0,
            X || $(K, 2, this.length),
            this[K] | this[K + 1] << 8
        }
        ,
        a.prototype.readUint16BE = a.prototype.readUInt16BE = function(K, X) {
            return K = K >>> 0,
            X || $(K, 2, this.length),
            this[K] << 8 | this[K + 1]
        }
        ,
        a.prototype.readUint32LE = a.prototype.readUInt32LE = function(K, X) {
            return K = K >>> 0,
            X || $(K, 4, this.length),
            (this[K] | this[K + 1] << 8 | this[K + 2] << 16) + this[K + 3] * 16777216
        }
        ,
        a.prototype.readUint32BE = a.prototype.readUInt32BE = function(K, X) {
            return K = K >>> 0,
            X || $(K, 4, this.length),
            this[K] * 16777216 + (this[K + 1] << 16 | this[K + 2] << 8 | this[K + 3])
        }
        ,
        a.prototype.readBigUInt64LE = cn(function(K) {
            K = K >>> 0,
            me(K, "offset");
            const X = this[K]
              , re = this[K + 7];
            (X === void 0 || re === void 0) && Ee(K, this.length - 8);
            const se = X + this[++K] * 2 ** 8 + this[++K] * 2 ** 16 + this[++K] * 2 ** 24
              , fe = this[++K] + this[++K] * 2 ** 8 + this[++K] * 2 ** 16 + re * 2 ** 24;
            return BigInt(se) + (BigInt(fe) << BigInt(32))
        }),
        a.prototype.readBigUInt64BE = cn(function(K) {
            K = K >>> 0,
            me(K, "offset");
            const X = this[K]
              , re = this[K + 7];
            (X === void 0 || re === void 0) && Ee(K, this.length - 8);
            const se = X * 2 ** 24 + this[++K] * 2 ** 16 + this[++K] * 2 ** 8 + this[++K]
              , fe = this[++K] * 2 ** 24 + this[++K] * 2 ** 16 + this[++K] * 2 ** 8 + re;
            return (BigInt(se) << BigInt(32)) + BigInt(fe)
        }),
        a.prototype.readIntLE = function(K, X, re) {
            K = K >>> 0,
            X = X >>> 0,
            re || $(K, X, this.length);
            let se = this[K]
              , fe = 1
              , ge = 0;
            for (; ++ge < X && (fe *= 256); )
                se += this[K + ge] * fe;
            return fe *= 128,
            se >= fe && (se -= Math.pow(2, 8 * X)),
            se
        }
        ,
        a.prototype.readIntBE = function(K, X, re) {
            K = K >>> 0,
            X = X >>> 0,
            re || $(K, X, this.length);
            let se = X
              , fe = 1
              , ge = this[K + --se];
            for (; se > 0 && (fe *= 256); )
                ge += this[K + --se] * fe;
            return fe *= 128,
            ge >= fe && (ge -= Math.pow(2, 8 * X)),
            ge
        }
        ,
        a.prototype.readInt8 = function(K, X) {
            return K = K >>> 0,
            X || $(K, 1, this.length),
            this[K] & 128 ? (255 - this[K] + 1) * -1 : this[K]
        }
        ,
        a.prototype.readInt16LE = function(K, X) {
            K = K >>> 0,
            X || $(K, 2, this.length);
            const re = this[K] | this[K + 1] << 8;
            return re & 32768 ? re | 4294901760 : re
        }
        ,
        a.prototype.readInt16BE = function(K, X) {
            K = K >>> 0,
            X || $(K, 2, this.length);
            const re = this[K + 1] | this[K] << 8;
            return re & 32768 ? re | 4294901760 : re
        }
        ,
        a.prototype.readInt32LE = function(K, X) {
            return K = K >>> 0,
            X || $(K, 4, this.length),
            this[K] | this[K + 1] << 8 | this[K + 2] << 16 | this[K + 3] << 24
        }
        ,
        a.prototype.readInt32BE = function(K, X) {
            return K = K >>> 0,
            X || $(K, 4, this.length),
            this[K] << 24 | this[K + 1] << 16 | this[K + 2] << 8 | this[K + 3]
        }
        ,
        a.prototype.readBigInt64LE = cn(function(K) {
            K = K >>> 0,
            me(K, "offset");
            const X = this[K]
              , re = this[K + 7];
            (X === void 0 || re === void 0) && Ee(K, this.length - 8);
            const se = this[K + 4] + this[K + 5] * 2 ** 8 + this[K + 6] * 2 ** 16 + (re << 24);
            return (BigInt(se) << BigInt(32)) + BigInt(X + this[++K] * 2 ** 8 + this[++K] * 2 ** 16 + this[++K] * 2 ** 24)
        }),
        a.prototype.readBigInt64BE = cn(function(K) {
            K = K >>> 0,
            me(K, "offset");
            const X = this[K]
              , re = this[K + 7];
            (X === void 0 || re === void 0) && Ee(K, this.length - 8);
            const se = (X << 24) + this[++K] * 2 ** 16 + this[++K] * 2 ** 8 + this[++K];
            return (BigInt(se) << BigInt(32)) + BigInt(this[++K] * 2 ** 24 + this[++K] * 2 ** 16 + this[++K] * 2 ** 8 + re)
        }),
        a.prototype.readFloatLE = function(K, X) {
            return K = K >>> 0,
            X || $(K, 4, this.length),
            t.read(this, K, !0, 23, 4)
        }
        ,
        a.prototype.readFloatBE = function(K, X) {
            return K = K >>> 0,
            X || $(K, 4, this.length),
            t.read(this, K, !1, 23, 4)
        }
        ,
        a.prototype.readDoubleLE = function(K, X) {
            return K = K >>> 0,
            X || $(K, 8, this.length),
            t.read(this, K, !0, 52, 8)
        }
        ,
        a.prototype.readDoubleBE = function(K, X) {
            return K = K >>> 0,
            X || $(K, 8, this.length),
            t.read(this, K, !1, 52, 8)
        }
        ;
        function D(ee, K, X, re, se, fe) {
            if (!a.isBuffer(ee))
                throw new TypeError('"buffer" argument must be a Buffer instance');
            if (K > se || K < fe)
                throw new RangeError('"value" argument is out of bounds');
            if (X + re > ee.length)
                throw new RangeError("Index out of range")
        }
        a.prototype.writeUintLE = a.prototype.writeUIntLE = function(K, X, re, se) {
            if (K = +K,
            X = X >>> 0,
            re = re >>> 0,
            !se) {
                const _e = Math.pow(2, 8 * re) - 1;
                D(this, K, X, re, _e, 0)
            }
            let fe = 1
              , ge = 0;
            for (this[X] = K & 255; ++ge < re && (fe *= 256); )
                this[X + ge] = K / fe & 255;
            return X + re
        }
        ,
        a.prototype.writeUintBE = a.prototype.writeUIntBE = function(K, X, re, se) {
            if (K = +K,
            X = X >>> 0,
            re = re >>> 0,
            !se) {
                const _e = Math.pow(2, 8 * re) - 1;
                D(this, K, X, re, _e, 0)
            }
            let fe = re - 1
              , ge = 1;
            for (this[X + fe] = K & 255; --fe >= 0 && (ge *= 256); )
                this[X + fe] = K / ge & 255;
            return X + re
        }
        ,
        a.prototype.writeUint8 = a.prototype.writeUInt8 = function(K, X, re) {
            return K = +K,
            X = X >>> 0,
            re || D(this, K, X, 1, 255, 0),
            this[X] = K & 255,
            X + 1
        }
        ,
        a.prototype.writeUint16LE = a.prototype.writeUInt16LE = function(K, X, re) {
            return K = +K,
            X = X >>> 0,
            re || D(this, K, X, 2, 65535, 0),
            this[X] = K & 255,
            this[X + 1] = K >>> 8,
            X + 2
        }
        ,
        a.prototype.writeUint16BE = a.prototype.writeUInt16BE = function(K, X, re) {
            return K = +K,
            X = X >>> 0,
            re || D(this, K, X, 2, 65535, 0),
            this[X] = K >>> 8,
            this[X + 1] = K & 255,
            X + 2
        }
        ,
        a.prototype.writeUint32LE = a.prototype.writeUInt32LE = function(K, X, re) {
            return K = +K,
            X = X >>> 0,
            re || D(this, K, X, 4, 4294967295, 0),
            this[X + 3] = K >>> 24,
            this[X + 2] = K >>> 16,
            this[X + 1] = K >>> 8,
            this[X] = K & 255,
            X + 4
        }
        ,
        a.prototype.writeUint32BE = a.prototype.writeUInt32BE = function(K, X, re) {
            return K = +K,
            X = X >>> 0,
            re || D(this, K, X, 4, 4294967295, 0),
            this[X] = K >>> 24,
            this[X + 1] = K >>> 16,
            this[X + 2] = K >>> 8,
            this[X + 3] = K & 255,
            X + 4
        }
        ;
        function U(ee, K, X, re, se) {
            ce(K, re, se, ee, X, 7);
            let fe = Number(K & BigInt(4294967295));
            ee[X++] = fe,
            fe = fe >> 8,
            ee[X++] = fe,
            fe = fe >> 8,
            ee[X++] = fe,
            fe = fe >> 8,
            ee[X++] = fe;
            let ge = Number(K >> BigInt(32) & BigInt(4294967295));
            return ee[X++] = ge,
            ge = ge >> 8,
            ee[X++] = ge,
            ge = ge >> 8,
            ee[X++] = ge,
            ge = ge >> 8,
            ee[X++] = ge,
            X
        }
        function W(ee, K, X, re, se) {
            ce(K, re, se, ee, X, 7);
            let fe = Number(K & BigInt(4294967295));
            ee[X + 7] = fe,
            fe = fe >> 8,
            ee[X + 6] = fe,
            fe = fe >> 8,
            ee[X + 5] = fe,
            fe = fe >> 8,
            ee[X + 4] = fe;
            let ge = Number(K >> BigInt(32) & BigInt(4294967295));
            return ee[X + 3] = ge,
            ge = ge >> 8,
            ee[X + 2] = ge,
            ge = ge >> 8,
            ee[X + 1] = ge,
            ge = ge >> 8,
            ee[X] = ge,
            X + 8
        }
        a.prototype.writeBigUInt64LE = cn(function(K, X=0) {
            return U(this, K, X, BigInt(0), BigInt("0xffffffffffffffff"))
        }),
        a.prototype.writeBigUInt64BE = cn(function(K, X=0) {
            return W(this, K, X, BigInt(0), BigInt("0xffffffffffffffff"))
        }),
        a.prototype.writeIntLE = function(K, X, re, se) {
            if (K = +K,
            X = X >>> 0,
            !se) {
                const Qe = Math.pow(2, 8 * re - 1);
                D(this, K, X, re, Qe - 1, -Qe)
            }
            let fe = 0
              , ge = 1
              , _e = 0;
            for (this[X] = K & 255; ++fe < re && (ge *= 256); )
                K < 0 && _e === 0 && this[X + fe - 1] !== 0 && (_e = 1),
                this[X + fe] = (K / ge >> 0) - _e & 255;
            return X + re
        }
        ,
        a.prototype.writeIntBE = function(K, X, re, se) {
            if (K = +K,
            X = X >>> 0,
            !se) {
                const Qe = Math.pow(2, 8 * re - 1);
                D(this, K, X, re, Qe - 1, -Qe)
            }
            let fe = re - 1
              , ge = 1
              , _e = 0;
            for (this[X + fe] = K & 255; --fe >= 0 && (ge *= 256); )
                K < 0 && _e === 0 && this[X + fe + 1] !== 0 && (_e = 1),
                this[X + fe] = (K / ge >> 0) - _e & 255;
            return X + re
        }
        ,
        a.prototype.writeInt8 = function(K, X, re) {
            return K = +K,
            X = X >>> 0,
            re || D(this, K, X, 1, 127, -128),
            K < 0 && (K = 255 + K + 1),
            this[X] = K & 255,
            X + 1
        }
        ,
        a.prototype.writeInt16LE = function(K, X, re) {
            return K = +K,
            X = X >>> 0,
            re || D(this, K, X, 2, 32767, -32768),
            this[X] = K & 255,
            this[X + 1] = K >>> 8,
            X + 2
        }
        ,
        a.prototype.writeInt16BE = function(K, X, re) {
            return K = +K,
            X = X >>> 0,
            re || D(this, K, X, 2, 32767, -32768),
            this[X] = K >>> 8,
            this[X + 1] = K & 255,
            X + 2
        }
        ,
        a.prototype.writeInt32LE = function(K, X, re) {
            return K = +K,
            X = X >>> 0,
            re || D(this, K, X, 4, 2147483647, -2147483648),
            this[X] = K & 255,
            this[X + 1] = K >>> 8,
            this[X + 2] = K >>> 16,
            this[X + 3] = K >>> 24,
            X + 4
        }
        ,
        a.prototype.writeInt32BE = function(K, X, re) {
            return K = +K,
            X = X >>> 0,
            re || D(this, K, X, 4, 2147483647, -2147483648),
            K < 0 && (K = 4294967295 + K + 1),
            this[X] = K >>> 24,
            this[X + 1] = K >>> 16,
            this[X + 2] = K >>> 8,
            this[X + 3] = K & 255,
            X + 4
        }
        ,
        a.prototype.writeBigInt64LE = cn(function(K, X=0) {
            return U(this, K, X, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
        }),
        a.prototype.writeBigInt64BE = cn(function(K, X=0) {
            return W(this, K, X, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
        });
        function Q(ee, K, X, re, se, fe) {
            if (X + re > ee.length)
                throw new RangeError("Index out of range");
            if (X < 0)
                throw new RangeError("Index out of range")
        }
        function J(ee, K, X, re, se) {
            return K = +K,
            X = X >>> 0,
            se || Q(ee, K, X, 4),
            t.write(ee, K, X, re, 23, 4),
            X + 4
        }
        a.prototype.writeFloatLE = function(K, X, re) {
            return J(this, K, X, !0, re)
        }
        ,
        a.prototype.writeFloatBE = function(K, X, re) {
            return J(this, K, X, !1, re)
        }
        ;
        function ne(ee, K, X, re, se) {
            return K = +K,
            X = X >>> 0,
            se || Q(ee, K, X, 8),
            t.write(ee, K, X, re, 52, 8),
            X + 8
        }
        a.prototype.writeDoubleLE = function(K, X, re) {
            return ne(this, K, X, !0, re)
        }
        ,
        a.prototype.writeDoubleBE = function(K, X, re) {
            return ne(this, K, X, !1, re)
        }
        ,
        a.prototype.copy = function(K, X, re, se) {
            if (!a.isBuffer(K))
                throw new TypeError("argument should be a Buffer");
            if (re || (re = 0),
            !se && se !== 0 && (se = this.length),
            X >= K.length && (X = K.length),
            X || (X = 0),
            se > 0 && se < re && (se = re),
            se === re || K.length === 0 || this.length === 0)
                return 0;
            if (X < 0)
                throw new RangeError("targetStart out of bounds");
            if (re < 0 || re >= this.length)
                throw new RangeError("Index out of range");
            if (se < 0)
                throw new RangeError("sourceEnd out of bounds");
            se > this.length && (se = this.length),
            K.length - X < se - re && (se = K.length - X + re);
            const fe = se - re;
            return this === K && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(X, re, se) : Uint8Array.prototype.set.call(K, this.subarray(re, se), X),
            fe
        }
        ,
        a.prototype.fill = function(K, X, re, se) {
            if (typeof K == "string") {
                if (typeof X == "string" ? (se = X,
                X = 0,
                re = this.length) : typeof re == "string" && (se = re,
                re = this.length),
                se !== void 0 && typeof se != "string")
                    throw new TypeError("encoding must be a string");
                if (typeof se == "string" && !a.isEncoding(se))
                    throw new TypeError("Unknown encoding: " + se);
                if (K.length === 1) {
                    const ge = K.charCodeAt(0);
                    (se === "utf8" && ge < 128 || se === "latin1") && (K = ge)
                }
            } else
                typeof K == "number" ? K = K & 255 : typeof K == "boolean" && (K = Number(K));
            if (X < 0 || this.length < X || this.length < re)
                throw new RangeError("Out of range index");
            if (re <= X)
                return this;
            X = X >>> 0,
            re = re === void 0 ? this.length : re >>> 0,
            K || (K = 0);
            let fe;
            if (typeof K == "number")
                for (fe = X; fe < re; ++fe)
                    this[fe] = K;
            else {
                const ge = a.isBuffer(K) ? K : a.from(K, se)
                  , _e = ge.length;
                if (_e === 0)
                    throw new TypeError('The value "' + K + '" is invalid for argument "value"');
                for (fe = 0; fe < re - X; ++fe)
                    this[fe + X] = ge[fe % _e]
            }
            return this
        }
        ;
        const ie = {};
        function ae(ee, K, X) {
            ie[ee] = class extends X {
                constructor() {
                    super(),
                    Object.defineProperty(this, "message", {
                        value: K.apply(this, arguments),
                        writable: !0,
                        configurable: !0
                    }),
                    this.name = `${this.name} [${ee}]`,
                    this.stack,
                    delete this.name
                }
                get code() {
                    return ee
                }
                set code(se) {
                    Object.defineProperty(this, "code", {
                        configurable: !0,
                        enumerable: !0,
                        value: se,
                        writable: !0
                    })
                }
                toString() {
                    return `${this.name} [${ee}]: ${this.message}`
                }
            }
        }
        ae("ERR_BUFFER_OUT_OF_BOUNDS", function(ee) {
            return ee ? `${ee} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds"
        }, RangeError),
        ae("ERR_INVALID_ARG_TYPE", function(ee, K) {
            return `The "${ee}" argument must be of type number. Received type ${typeof K}`
        }, TypeError),
        ae("ERR_OUT_OF_RANGE", function(ee, K, X) {
            let re = `The value of "${ee}" is out of range.`
              , se = X;
            return Number.isInteger(X) && Math.abs(X) > 2 ** 32 ? se = xe(String(X)) : typeof X == "bigint" && (se = String(X),
            (X > BigInt(2) ** BigInt(32) || X < -(BigInt(2) ** BigInt(32))) && (se = xe(se)),
            se += "n"),
            re += ` It must be ${K}. Received ${se}`,
            re
        }, RangeError);
        function xe(ee) {
            let K = ""
              , X = ee.length;
            const re = ee[0] === "-" ? 1 : 0;
            for (; X >= re + 4; X -= 3)
                K = `_${ee.slice(X - 3, X)}${K}`;
            return `${ee.slice(0, X)}${K}`
        }
        function ue(ee, K, X) {
            me(K, "offset"),
            (ee[K] === void 0 || ee[K + X] === void 0) && Ee(K, ee.length - (X + 1))
        }
        function ce(ee, K, X, re, se, fe) {
            if (ee > X || ee < K) {
                const ge = typeof K == "bigint" ? "n" : "";
                let _e;
                throw K === 0 || K === BigInt(0) ? _e = `>= 0${ge} and < 2${ge} ** ${(fe + 1) * 8}${ge}` : _e = `>= -(2${ge} ** ${(fe + 1) * 8 - 1}${ge}) and < 2 ** ${(fe + 1) * 8 - 1}${ge}`,
                new ie.ERR_OUT_OF_RANGE("value",_e,ee)
            }
            ue(re, se, fe)
        }
        function me(ee, K) {
            if (typeof ee != "number")
                throw new ie.ERR_INVALID_ARG_TYPE(K,"number",ee)
        }
        function Ee(ee, K, X) {
            throw Math.floor(ee) !== ee ? (me(ee, X),
            new ie.ERR_OUT_OF_RANGE("offset","an integer",ee)) : K < 0 ? new ie.ERR_BUFFER_OUT_OF_BOUNDS : new ie.ERR_OUT_OF_RANGE("offset",`>= 0 and <= ${K}`,ee)
        }
        const Oe = /[^+/0-9A-Za-z-_]/g;
        function mt(ee) {
            if (ee = ee.split("=")[0],
            ee = ee.trim().replace(Oe, ""),
            ee.length < 2)
                return "";
            for (; ee.length % 4 !== 0; )
                ee = ee + "=";
            return ee
        }
        function st(ee, K) {
            K = K || 1 / 0;
            let X;
            const re = ee.length;
            let se = null;
            const fe = [];
            for (let ge = 0; ge < re; ++ge) {
                if (X = ee.charCodeAt(ge),
                X > 55295 && X < 57344) {
                    if (!se) {
                        if (X > 56319) {
                            (K -= 3) > -1 && fe.push(239, 191, 189);
                            continue
                        } else if (ge + 1 === re) {
                            (K -= 3) > -1 && fe.push(239, 191, 189);
                            continue
                        }
                        se = X;
                        continue
                    }
                    if (X < 56320) {
                        (K -= 3) > -1 && fe.push(239, 191, 189),
                        se = X;
                        continue
                    }
                    X = (se - 55296 << 10 | X - 56320) + 65536
                } else
                    se && (K -= 3) > -1 && fe.push(239, 191, 189);
                if (se = null,
                X < 128) {
                    if ((K -= 1) < 0)
                        break;
                    fe.push(X)
                } else if (X < 2048) {
                    if ((K -= 2) < 0)
                        break;
                    fe.push(X >> 6 | 192, X & 63 | 128)
                } else if (X < 65536) {
                    if ((K -= 3) < 0)
                        break;
                    fe.push(X >> 12 | 224, X >> 6 & 63 | 128, X & 63 | 128)
                } else if (X < 1114112) {
                    if ((K -= 4) < 0)
                        break;
                    fe.push(X >> 18 | 240, X >> 12 & 63 | 128, X >> 6 & 63 | 128, X & 63 | 128)
                } else
                    throw new Error("Invalid code point")
            }
            return fe
        }
        function ot(ee) {
            const K = [];
            for (let X = 0; X < ee.length; ++X)
                K.push(ee.charCodeAt(X) & 255);
            return K
        }
        function Ct(ee, K) {
            let X, re, se;
            const fe = [];
            for (let ge = 0; ge < ee.length && !((K -= 2) < 0); ++ge)
                X = ee.charCodeAt(ge),
                re = X >> 8,
                se = X % 256,
                fe.push(se),
                fe.push(re);
            return fe
        }
        function ct(ee) {
            return e.toByteArray(mt(ee))
        }
        function Xe(ee, K, X, re) {
            let se;
            for (se = 0; se < re && !(se + X >= K.length || se >= ee.length); ++se)
                K[se + X] = ee[se];
            return se
        }
        function Et(ee, K) {
            return ee instanceof K || ee != null && ee.constructor != null && ee.constructor.name != null && ee.constructor.name === K.name
        }
        function St(ee) {
            return ee !== ee
        }
        const ut = (function() {
            const ee = "0123456789abcdef"
              , K = new Array(256);
            for (let X = 0; X < 16; ++X) {
                const re = X * 16;
                for (let se = 0; se < 16; ++se)
                    K[re + se] = ee[X] + ee[se]
            }
            return K
        }
        )();
        function cn(ee) {
            return typeof BigInt > "u" ? _t : ee
        }
        function _t() {
            throw new Error("BigInt not supported")
        }
    }
    )(jS)),
    jS
}
var Mt = Yv();
const Vh = typeof globalThis == "object" && "crypto"in globalThis ? globalThis.crypto : void 0;
function Iy(n) {
    return n instanceof Uint8Array || ArrayBuffer.isView(n) && n.constructor.name === "Uint8Array"
}
function Jp(n) {
    if (!Number.isSafeInteger(n) || n < 0)
        throw new Error("positive integer expected, got " + n)
}
function Nc(n, ...e) {
    if (!Iy(n))
        throw new Error("Uint8Array expected");
    if (e.length > 0 && !e.includes(n.length))
        throw new Error("Uint8Array expected of length " + e + ", got length=" + n.length)
}
function uU(n) {
    if (typeof n != "function" || typeof n.create != "function")
        throw new Error("Hash should be wrapped by utils.createHasher");
    Jp(n.outputLen),
    Jp(n.blockLen)
}
function e0(n, e=!0) {
    if (n.destroyed)
        throw new Error("Hash instance has been destroyed");
    if (e && n.finished)
        throw new Error("Hash#digest() has already been called")
}
function dU(n, e) {
    Nc(n);
    const t = e.outputLen;
    if (n.length < t)
        throw new Error("digestInto() expects output buffer of length at least " + t)
}
function Yne(n) {
    return new Uint32Array(n.buffer,n.byteOffset,Math.floor(n.byteLength / 4))
}
function Qu(...n) {
    for (let e = 0; e < n.length; e++)
        n[e].fill(0)
}
function LS(n) {
    return new DataView(n.buffer,n.byteOffset,n.byteLength)
}
function ka(n, e) {
    return n << 32 - e | n >>> e
}
const Kne = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function Xne(n) {
    return n << 24 & 4278190080 | n << 8 & 16711680 | n >>> 8 & 65280 | n >>> 24 & 255
}
function Qne(n) {
    for (let e = 0; e < n.length; e++)
        n[e] = Xne(n[e]);
    return n
}
const mM = Kne ? n => n : Qne
  , fU = typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function"
  , Zne = Array.from({
    length: 256
}, (n, e) => e.toString(16).padStart(2, "0"));
function Ef(n) {
    if (Nc(n),
    fU)
        return n.toHex();
    let e = "";
    for (let t = 0; t < n.length; t++)
        e += Zne[n[t]];
    return e
}
const Dl = {
    _0: 48,
    _9: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102
};
function gM(n) {
    if (n >= Dl._0 && n <= Dl._9)
        return n - Dl._0;
    if (n >= Dl.A && n <= Dl.F)
        return n - (Dl.A - 10);
    if (n >= Dl.a && n <= Dl.f)
        return n - (Dl.a - 10)
}
function w2(n) {
    if (typeof n != "string")
        throw new Error("hex string expected, got " + typeof n);
    if (fU)
        return Uint8Array.fromHex(n);
    const e = n.length
      , t = e / 2;
    if (e % 2)
        throw new Error("hex string expected, got unpadded hex of length " + e);
    const r = new Uint8Array(t);
    for (let s = 0, i = 0; s < t; s++,
    i += 2) {
        const o = gM(n.charCodeAt(i))
          , a = gM(n.charCodeAt(i + 1));
        if (o === void 0 || a === void 0) {
            const l = n[i] + n[i + 1];
            throw new Error('hex string expected, got non-hex character "' + l + '" at index ' + i)
        }
        r[s] = o * 16 + a
    }
    return r
}
function Jne(n) {
    if (typeof n != "string")
        throw new Error("string expected");
    return new Uint8Array(new TextEncoder().encode(n))
}
function Kv(n) {
    return typeof n == "string" && (n = Jne(n)),
    Nc(n),
    n
}
function ra(...n) {
    let e = 0;
    for (let r = 0; r < n.length; r++) {
        const s = n[r];
        Nc(s),
        e += s.length
    }
    const t = new Uint8Array(e);
    for (let r = 0, s = 0; r < n.length; r++) {
        const i = n[r];
        t.set(i, s),
        s += i.length
    }
    return t
}
class X8 {
}
function Q8(n) {
    const e = r => n().update(Kv(r)).digest()
      , t = n();
    return e.outputLen = t.outputLen,
    e.blockLen = t.blockLen,
    e.create = () => n(),
    e
}
function Xv(n=32) {
    if (Vh && typeof Vh.getRandomValues == "function")
        return Vh.getRandomValues(new Uint8Array(n));
    if (Vh && typeof Vh.randomBytes == "function")
        return Uint8Array.from(Vh.randomBytes(n));
    throw new Error("crypto.getRandomValues must be defined")
}
function ere(n, e, t, r) {
    if (typeof n.setBigUint64 == "function")
        return n.setBigUint64(e, t, r);
    const s = BigInt(32)
      , i = BigInt(4294967295)
      , o = Number(t >> s & i)
      , a = Number(t & i)
      , l = r ? 4 : 0
      , u = r ? 0 : 4;
    n.setUint32(e + l, o, r),
    n.setUint32(e + u, a, r)
}
function tre(n, e, t) {
    return n & e ^ ~n & t
}
function nre(n, e, t) {
    return n & e ^ n & t ^ e & t
}
class hU extends X8 {
    constructor(e, t, r, s) {
        super(),
        this.finished = !1,
        this.length = 0,
        this.pos = 0,
        this.destroyed = !1,
        this.blockLen = e,
        this.outputLen = t,
        this.padOffset = r,
        this.isLE = s,
        this.buffer = new Uint8Array(e),
        this.view = LS(this.buffer)
    }
    update(e) {
        e0(this),
        e = Kv(e),
        Nc(e);
        const {view: t, buffer: r, blockLen: s} = this
          , i = e.length;
        for (let o = 0; o < i; ) {
            const a = Math.min(s - this.pos, i - o);
            if (a === s) {
                const l = LS(e);
                for (; s <= i - o; o += s)
                    this.process(l, o);
                continue
            }
            r.set(e.subarray(o, o + a), this.pos),
            this.pos += a,
            o += a,
            this.pos === s && (this.process(t, 0),
            this.pos = 0)
        }
        return this.length += e.length,
        this.roundClean(),
        this
    }
    digestInto(e) {
        e0(this),
        dU(e, this),
        this.finished = !0;
        const {buffer: t, view: r, blockLen: s, isLE: i} = this;
        let {pos: o} = this;
        t[o++] = 128,
        Qu(this.buffer.subarray(o)),
        this.padOffset > s - o && (this.process(r, 0),
        o = 0);
        for (let h = o; h < s; h++)
            t[h] = 0;
        ere(r, s - 8, BigInt(this.length * 8), i),
        this.process(r, 0);
        const a = LS(e)
          , l = this.outputLen;
        if (l % 4)
            throw new Error("_sha2: outputLen should be aligned to 32bit");
        const u = l / 4
          , d = this.get();
        if (u > d.length)
            throw new Error("_sha2: outputLen bigger than state");
        for (let h = 0; h < u; h++)
            a.setUint32(4 * h, d[h], i)
    }
    digest() {
        const {buffer: e, outputLen: t} = this;
        this.digestInto(e);
        const r = e.slice(0, t);
        return this.destroy(),
        r
    }
    _cloneInto(e) {
        e || (e = new this.constructor),
        e.set(...this.get());
        const {blockLen: t, buffer: r, length: s, finished: i, destroyed: o, pos: a} = this;
        return e.destroyed = o,
        e.finished = i,
        e.length = s,
        e.pos = a,
        s % t && e.buffer.set(r),
        e
    }
    clone() {
        return this._cloneInto()
    }
}
const pu = Uint32Array.from([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225])
  , Ns = Uint32Array.from([1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209])
  , D1 = BigInt(2 ** 32 - 1)
  , yM = BigInt(32);
function rre(n, e=!1) {
    return e ? {
        h: Number(n & D1),
        l: Number(n >> yM & D1)
    } : {
        h: Number(n >> yM & D1) | 0,
        l: Number(n & D1) | 0
    }
}
function pU(n, e=!1) {
    const t = n.length;
    let r = new Uint32Array(t)
      , s = new Uint32Array(t);
    for (let i = 0; i < t; i++) {
        const {h: o, l: a} = rre(n[i], e);
        [r[i],s[i]] = [o, a]
    }
    return [r, s]
}
const bM = (n, e, t) => n >>> t
  , wM = (n, e, t) => n << 32 - t | e >>> t
  , qh = (n, e, t) => n >>> t | e << 32 - t
  , Gh = (n, e, t) => n << 32 - t | e >>> t
  , T1 = (n, e, t) => n << 64 - t | e >>> t - 32
  , I1 = (n, e, t) => n >>> t - 32 | e << 64 - t
  , sre = (n, e, t) => n << t | e >>> 32 - t
  , ire = (n, e, t) => e << t | n >>> 32 - t
  , ore = (n, e, t) => e << t - 32 | n >>> 64 - t
  , are = (n, e, t) => n << t - 32 | e >>> 64 - t;
function Tl(n, e, t, r) {
    const s = (e >>> 0) + (r >>> 0);
    return {
        h: n + t + (s / 2 ** 32 | 0) | 0,
        l: s | 0
    }
}
const lre = (n, e, t) => (n >>> 0) + (e >>> 0) + (t >>> 0)
  , cre = (n, e, t, r) => e + t + r + (n / 2 ** 32 | 0) | 0
  , ure = (n, e, t, r) => (n >>> 0) + (e >>> 0) + (t >>> 0) + (r >>> 0)
  , dre = (n, e, t, r, s) => e + t + r + s + (n / 2 ** 32 | 0) | 0
  , fre = (n, e, t, r, s) => (n >>> 0) + (e >>> 0) + (t >>> 0) + (r >>> 0) + (s >>> 0)
  , hre = (n, e, t, r, s, i) => e + t + r + s + i + (n / 2 ** 32 | 0) | 0
  , pre = Uint32Array.from([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298])
  , mu = new Uint32Array(64);
class mre extends hU {
    constructor(e=32) {
        super(64, e, 8, !1),
        this.A = pu[0] | 0,
        this.B = pu[1] | 0,
        this.C = pu[2] | 0,
        this.D = pu[3] | 0,
        this.E = pu[4] | 0,
        this.F = pu[5] | 0,
        this.G = pu[6] | 0,
        this.H = pu[7] | 0
    }
    get() {
        const {A: e, B: t, C: r, D: s, E: i, F: o, G: a, H: l} = this;
        return [e, t, r, s, i, o, a, l]
    }
    set(e, t, r, s, i, o, a, l) {
        this.A = e | 0,
        this.B = t | 0,
        this.C = r | 0,
        this.D = s | 0,
        this.E = i | 0,
        this.F = o | 0,
        this.G = a | 0,
        this.H = l | 0
    }
    process(e, t) {
        for (let h = 0; h < 16; h++,
        t += 4)
            mu[h] = e.getUint32(t, !1);
        for (let h = 16; h < 64; h++) {
            const p = mu[h - 15]
              , g = mu[h - 2]
              , w = ka(p, 7) ^ ka(p, 18) ^ p >>> 3
              , b = ka(g, 17) ^ ka(g, 19) ^ g >>> 10;
            mu[h] = b + mu[h - 7] + w + mu[h - 16] | 0
        }
        let {A: r, B: s, C: i, D: o, E: a, F: l, G: u, H: d} = this;
        for (let h = 0; h < 64; h++) {
            const p = ka(a, 6) ^ ka(a, 11) ^ ka(a, 25)
              , g = d + p + tre(a, l, u) + pre[h] + mu[h] | 0
              , b = (ka(r, 2) ^ ka(r, 13) ^ ka(r, 22)) + nre(r, s, i) | 0;
            d = u,
            u = l,
            l = a,
            a = o + g | 0,
            o = i,
            i = s,
            s = r,
            r = g + b | 0
        }
        r = r + this.A | 0,
        s = s + this.B | 0,
        i = i + this.C | 0,
        o = o + this.D | 0,
        a = a + this.E | 0,
        l = l + this.F | 0,
        u = u + this.G | 0,
        d = d + this.H | 0,
        this.set(r, s, i, o, a, l, u, d)
    }
    roundClean() {
        Qu(mu)
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0),
        Qu(this.buffer)
    }
}
const mU = pU(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map(n => BigInt(n)))
  , gre = mU[0]
  , yre = mU[1]
  , gu = new Uint32Array(80)
  , yu = new Uint32Array(80);
class bre extends hU {
    constructor(e=64) {
        super(128, e, 16, !1),
        this.Ah = Ns[0] | 0,
        this.Al = Ns[1] | 0,
        this.Bh = Ns[2] | 0,
        this.Bl = Ns[3] | 0,
        this.Ch = Ns[4] | 0,
        this.Cl = Ns[5] | 0,
        this.Dh = Ns[6] | 0,
        this.Dl = Ns[7] | 0,
        this.Eh = Ns[8] | 0,
        this.El = Ns[9] | 0,
        this.Fh = Ns[10] | 0,
        this.Fl = Ns[11] | 0,
        this.Gh = Ns[12] | 0,
        this.Gl = Ns[13] | 0,
        this.Hh = Ns[14] | 0,
        this.Hl = Ns[15] | 0
    }
    get() {
        const {Ah: e, Al: t, Bh: r, Bl: s, Ch: i, Cl: o, Dh: a, Dl: l, Eh: u, El: d, Fh: h, Fl: p, Gh: g, Gl: w, Hh: b, Hl: v} = this;
        return [e, t, r, s, i, o, a, l, u, d, h, p, g, w, b, v]
    }
    set(e, t, r, s, i, o, a, l, u, d, h, p, g, w, b, v) {
        this.Ah = e | 0,
        this.Al = t | 0,
        this.Bh = r | 0,
        this.Bl = s | 0,
        this.Ch = i | 0,
        this.Cl = o | 0,
        this.Dh = a | 0,
        this.Dl = l | 0,
        this.Eh = u | 0,
        this.El = d | 0,
        this.Fh = h | 0,
        this.Fl = p | 0,
        this.Gh = g | 0,
        this.Gl = w | 0,
        this.Hh = b | 0,
        this.Hl = v | 0
    }
    process(e, t) {
        for (let _ = 0; _ < 16; _++,
        t += 4)
            gu[_] = e.getUint32(t),
            yu[_] = e.getUint32(t += 4);
        for (let _ = 16; _ < 80; _++) {
            const I = gu[_ - 15] | 0
              , k = yu[_ - 15] | 0
              , B = qh(I, k, 1) ^ qh(I, k, 8) ^ bM(I, k, 7)
              , P = Gh(I, k, 1) ^ Gh(I, k, 8) ^ wM(I, k, 7)
              , M = gu[_ - 2] | 0
              , R = yu[_ - 2] | 0
              , L = qh(M, R, 19) ^ T1(M, R, 61) ^ bM(M, R, 6)
              , q = Gh(M, R, 19) ^ I1(M, R, 61) ^ wM(M, R, 6)
              , H = ure(P, q, yu[_ - 7], yu[_ - 16])
              , j = dre(H, B, L, gu[_ - 7], gu[_ - 16]);
            gu[_] = j | 0,
            yu[_] = H | 0
        }
        let {Ah: r, Al: s, Bh: i, Bl: o, Ch: a, Cl: l, Dh: u, Dl: d, Eh: h, El: p, Fh: g, Fl: w, Gh: b, Gl: v, Hh: S, Hl: N} = this;
        for (let _ = 0; _ < 80; _++) {
            const I = qh(h, p, 14) ^ qh(h, p, 18) ^ T1(h, p, 41)
              , k = Gh(h, p, 14) ^ Gh(h, p, 18) ^ I1(h, p, 41)
              , B = h & g ^ ~h & b
              , P = p & w ^ ~p & v
              , M = fre(N, k, P, yre[_], yu[_])
              , R = hre(M, S, I, B, gre[_], gu[_])
              , L = M | 0
              , q = qh(r, s, 28) ^ T1(r, s, 34) ^ T1(r, s, 39)
              , H = Gh(r, s, 28) ^ I1(r, s, 34) ^ I1(r, s, 39)
              , j = r & i ^ r & a ^ i & a
              , A = s & o ^ s & l ^ o & l;
            S = b | 0,
            N = v | 0,
            b = g | 0,
            v = w | 0,
            g = h | 0,
            w = p | 0,
            {h, l: p} = Tl(u | 0, d | 0, R | 0, L | 0),
            u = a | 0,
            d = l | 0,
            a = i | 0,
            l = o | 0,
            i = r | 0,
            o = s | 0;
            const E = lre(L, H, A);
            r = cre(E, R, q, j),
            s = E | 0
        }
        ({h: r, l: s} = Tl(this.Ah | 0, this.Al | 0, r | 0, s | 0)),
        {h: i, l: o} = Tl(this.Bh | 0, this.Bl | 0, i | 0, o | 0),
        {h: a, l} = Tl(this.Ch | 0, this.Cl | 0, a | 0, l | 0),
        {h: u, l: d} = Tl(this.Dh | 0, this.Dl | 0, u | 0, d | 0),
        {h, l: p} = Tl(this.Eh | 0, this.El | 0, h | 0, p | 0),
        {h: g, l: w} = Tl(this.Fh | 0, this.Fl | 0, g | 0, w | 0),
        {h: b, l: v} = Tl(this.Gh | 0, this.Gl | 0, b | 0, v | 0),
        {h: S, l: N} = Tl(this.Hh | 0, this.Hl | 0, S | 0, N | 0),
        this.set(r, s, i, o, a, l, u, d, h, p, g, w, b, v, S, N)
    }
    roundClean() {
        Qu(gu, yu)
    }
    destroy() {
        Qu(this.buffer),
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
    }
}
const Z8 = Q8( () => new mre)
  , wre = Q8( () => new bre);
const J8 = BigInt(0)
  , R4 = BigInt(1);
function Rf(n, e="") {
    if (typeof n != "boolean") {
        const t = e && `"${e}"`;
        throw new Error(t + "expected boolean, got type=" + typeof n)
    }
    return n
}
function oa(n, e, t="") {
    const r = Iy(n)
      , s = n?.length
      , i = e !== void 0;
    if (!r || i && s !== e) {
        const o = t && `"${t}" `
          , a = i ? ` of length ${e}` : ""
          , l = r ? `length=${s}` : `type=${typeof n}`;
        throw new Error(o + "expected Uint8Array" + a + ", got " + l)
    }
    return n
}
function M1(n) {
    const e = n.toString(16);
    return e.length & 1 ? "0" + e : e
}
function gU(n) {
    if (typeof n != "string")
        throw new Error("hex string expected, got " + typeof n);
    return n === "" ? J8 : BigInt("0x" + n)
}
function Qv(n) {
    return gU(Ef(n))
}
function Qg(n) {
    return Nc(n),
    gU(Ef(Uint8Array.from(n).reverse()))
}
function e_(n, e) {
    return w2(n.toString(16).padStart(e * 2, "0"))
}
function yU(n, e) {
    return e_(n, e).reverse()
}
function hr(n, e, t) {
    let r;
    if (typeof e == "string")
        try {
            r = w2(e)
        } catch (i) {
            throw new Error(n + " must be hex string or Uint8Array, cause: " + i)
        }
    else if (Iy(e))
        r = Uint8Array.from(e);
    else
        throw new Error(n + " must be hex string or Uint8Array");
    const s = r.length;
    if (typeof t == "number" && s !== t)
        throw new Error(n + " of length " + t + " expected, got " + s);
    return r
}
function vM(n) {
    return Uint8Array.from(n)
}
const FS = n => typeof n == "bigint" && J8 <= n;
function vre(n, e, t) {
    return FS(n) && FS(e) && FS(t) && e <= n && n < t
}
function O4(n, e, t, r) {
    if (!vre(e, t, r))
        throw new Error("expected valid " + n + ": " + t + " <= n < " + r + ", got " + e)
}
function bU(n) {
    let e;
    for (e = 0; n > J8; n >>= R4,
    e += 1)
        ;
    return e
}
const My = n => (R4 << BigInt(n)) - R4;
function xre(n, e, t) {
    if (typeof n != "number" || n < 2)
        throw new Error("hashLen must be a number");
    if (typeof e != "number" || e < 2)
        throw new Error("qByteLen must be a number");
    if (typeof t != "function")
        throw new Error("hmacFn must be a function");
    const r = g => new Uint8Array(g)
      , s = g => Uint8Array.of(g);
    let i = r(n)
      , o = r(n)
      , a = 0;
    const l = () => {
        i.fill(1),
        o.fill(0),
        a = 0
    }
      , u = (...g) => t(o, i, ...g)
      , d = (g=r(0)) => {
        o = u(s(0), g),
        i = u(),
        g.length !== 0 && (o = u(s(1), g),
        i = u())
    }
      , h = () => {
        if (a++ >= 1e3)
            throw new Error("drbg: tried 1000 values");
        let g = 0;
        const w = [];
        for (; g < e; ) {
            i = u();
            const b = i.slice();
            w.push(b),
            g += i.length
        }
        return ra(...w)
    }
    ;
    return (g, w) => {
        l(),
        d(g);
        let b;
        for (; !(b = w(h())); )
            d();
        return l(),
        b
    }
}
function By(n, e, t={}) {
    if (!n || typeof n != "object")
        throw new Error("expected valid options object");
    function r(s, i, o) {
        const a = n[s];
        if (o && a === void 0)
            return;
        const l = typeof a;
        if (l !== i || a === null)
            throw new Error(`param "${s}" is invalid: expected ${i}, got ${l}`)
    }
    Object.entries(e).forEach( ([s,i]) => r(s, i, !1)),
    Object.entries(t).forEach( ([s,i]) => r(s, i, !0))
}
function v2(n) {
    const e = new WeakMap;
    return (t, ...r) => {
        const s = e.get(t);
        if (s !== void 0)
            return s;
        const i = n(t, ...r);
        return e.set(t, i),
        i
    }
}
const Ai = BigInt(0)
  , Es = BigInt(1)
  , af = BigInt(2)
  , wU = BigInt(3)
  , vU = BigInt(4)
  , xU = BigInt(5)
  , Ere = BigInt(7)
  , EU = BigInt(8)
  , Sre = BigInt(9)
  , SU = BigInt(16);
function Pr(n, e) {
    const t = n % e;
    return t >= Ai ? t : e + t
}
function dr(n, e, t) {
    let r = n;
    for (; e-- > Ai; )
        r *= r,
        r %= t;
    return r
}
function xM(n, e) {
    if (n === Ai)
        throw new Error("invert: expected non-zero number");
    if (e <= Ai)
        throw new Error("invert: expected positive modulus, got " + e);
    let t = Pr(n, e)
      , r = e
      , s = Ai
      , i = Es;
    for (; t !== Ai; ) {
        const a = r / t
          , l = r % t
          , u = s - i * a;
        r = t,
        t = l,
        s = i,
        i = u
    }
    if (r !== Es)
        throw new Error("invert: does not exist");
    return Pr(s, e)
}
function t_(n, e, t) {
    if (!n.eql(n.sqr(e), t))
        throw new Error("Cannot find square root")
}
function AU(n, e) {
    const t = (n.ORDER + Es) / vU
      , r = n.pow(e, t);
    return t_(n, r, e),
    r
}
function Are(n, e) {
    const t = (n.ORDER - xU) / EU
      , r = n.mul(e, af)
      , s = n.pow(r, t)
      , i = n.mul(e, s)
      , o = n.mul(n.mul(i, af), s)
      , a = n.mul(i, n.sub(o, n.ONE));
    return t_(n, a, e),
    a
}
function Cre(n) {
    const e = Vf(n)
      , t = CU(n)
      , r = t(e, e.neg(e.ONE))
      , s = t(e, r)
      , i = t(e, e.neg(r))
      , o = (n + Ere) / SU;
    return (a, l) => {
        let u = a.pow(l, o)
          , d = a.mul(u, r);
        const h = a.mul(u, s)
          , p = a.mul(u, i)
          , g = a.eql(a.sqr(d), l)
          , w = a.eql(a.sqr(h), l);
        u = a.cmov(u, d, g),
        d = a.cmov(p, h, w);
        const b = a.eql(a.sqr(d), l)
          , v = a.cmov(u, d, b);
        return t_(a, v, l),
        v
    }
}
function CU(n) {
    if (n < wU)
        throw new Error("sqrt is not defined for small field");
    let e = n - Es
      , t = 0;
    for (; e % af === Ai; )
        e /= af,
        t++;
    let r = af;
    const s = Vf(n);
    for (; EM(s, r) === 1; )
        if (r++ > 1e3)
            throw new Error("Cannot find square root: probably non-prime P");
    if (t === 1)
        return AU;
    let i = s.pow(r, e);
    const o = (e + Es) / af;
    return function(l, u) {
        if (l.is0(u))
            return u;
        if (EM(l, u) !== 1)
            throw new Error("Cannot find square root");
        let d = t
          , h = l.mul(l.ONE, i)
          , p = l.pow(u, e)
          , g = l.pow(u, o);
        for (; !l.eql(p, l.ONE); ) {
            if (l.is0(p))
                return l.ZERO;
            let w = 1
              , b = l.sqr(p);
            for (; !l.eql(b, l.ONE); )
                if (w++,
                b = l.sqr(b),
                w === d)
                    throw new Error("Cannot find square root");
            const v = Es << BigInt(d - w - 1)
              , S = l.pow(h, v);
            d = w,
            h = l.sqr(S),
            p = l.mul(p, h),
            g = l.mul(g, S)
        }
        return g
    }
}
function _re(n) {
    return n % vU === wU ? AU : n % EU === xU ? Are : n % SU === Sre ? Cre(n) : CU(n)
}
const kre = (n, e) => (Pr(n, e) & Es) === Es
  , Nre = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];
function Dre(n) {
    const e = {
        ORDER: "bigint",
        MASK: "bigint",
        BYTES: "number",
        BITS: "number"
    }
      , t = Nre.reduce( (r, s) => (r[s] = "function",
    r), e);
    return By(n, t),
    n
}
function Tre(n, e, t) {
    if (t < Ai)
        throw new Error("invalid exponent, negatives unsupported");
    if (t === Ai)
        return n.ONE;
    if (t === Es)
        return e;
    let r = n.ONE
      , s = e;
    for (; t > Ai; )
        t & Es && (r = n.mul(r, s)),
        s = n.sqr(s),
        t >>= Es;
    return r
}
function _U(n, e, t=!1) {
    const r = new Array(e.length).fill(t ? n.ZERO : void 0)
      , s = e.reduce( (o, a, l) => n.is0(a) ? o : (r[l] = o,
    n.mul(o, a)), n.ONE)
      , i = n.inv(s);
    return e.reduceRight( (o, a, l) => n.is0(a) ? o : (r[l] = n.mul(o, r[l]),
    n.mul(o, a)), i),
    r
}
function EM(n, e) {
    const t = (n.ORDER - Es) / af
      , r = n.pow(e, t)
      , s = n.eql(r, n.ONE)
      , i = n.eql(r, n.ZERO)
      , o = n.eql(r, n.neg(n.ONE));
    if (!s && !i && !o)
        throw new Error("invalid Legendre symbol result");
    return s ? 1 : i ? 0 : -1
}
function kU(n, e) {
    e !== void 0 && Jp(e);
    const t = e !== void 0 ? e : n.toString(2).length
      , r = Math.ceil(t / 8);
    return {
        nBitLength: t,
        nByteLength: r
    }
}
function Vf(n, e, t=!1, r={}) {
    if (n <= Ai)
        throw new Error("invalid field: expected ORDER > 0, got " + n);
    let s, i, o = !1, a;
    if (typeof e == "object" && e != null) {
        if (r.sqrt || t)
            throw new Error("cannot specify opts in two arguments");
        const p = e;
        p.BITS && (s = p.BITS),
        p.sqrt && (i = p.sqrt),
        typeof p.isLE == "boolean" && (t = p.isLE),
        typeof p.modFromBytes == "boolean" && (o = p.modFromBytes),
        a = p.allowedLengths
    } else
        typeof e == "number" && (s = e),
        r.sqrt && (i = r.sqrt);
    const {nBitLength: l, nByteLength: u} = kU(n, s);
    if (u > 2048)
        throw new Error("invalid field: expected ORDER of <= 2048 bytes");
    let d;
    const h = Object.freeze({
        ORDER: n,
        isLE: t,
        BITS: l,
        BYTES: u,
        MASK: My(l),
        ZERO: Ai,
        ONE: Es,
        allowedLengths: a,
        create: p => Pr(p, n),
        isValid: p => {
            if (typeof p != "bigint")
                throw new Error("invalid field element: expected bigint, got " + typeof p);
            return Ai <= p && p < n
        }
        ,
        is0: p => p === Ai,
        isValidNot0: p => !h.is0(p) && h.isValid(p),
        isOdd: p => (p & Es) === Es,
        neg: p => Pr(-p, n),
        eql: (p, g) => p === g,
        sqr: p => Pr(p * p, n),
        add: (p, g) => Pr(p + g, n),
        sub: (p, g) => Pr(p - g, n),
        mul: (p, g) => Pr(p * g, n),
        pow: (p, g) => Tre(h, p, g),
        div: (p, g) => Pr(p * xM(g, n), n),
        sqrN: p => p * p,
        addN: (p, g) => p + g,
        subN: (p, g) => p - g,
        mulN: (p, g) => p * g,
        inv: p => xM(p, n),
        sqrt: i || (p => (d || (d = _re(n)),
        d(h, p))),
        toBytes: p => t ? yU(p, u) : e_(p, u),
        fromBytes: (p, g=!0) => {
            if (a) {
                if (!a.includes(p.length) || p.length > u)
                    throw new Error("Field.fromBytes: expected " + a + " bytes, got " + p.length);
                const b = new Uint8Array(u);
                b.set(p, t ? 0 : b.length - p.length),
                p = b
            }
            if (p.length !== u)
                throw new Error("Field.fromBytes: expected " + u + " bytes, got " + p.length);
            let w = t ? Qg(p) : Qv(p);
            if (o && (w = Pr(w, n)),
            !g && !h.isValid(w))
                throw new Error("invalid field element: outside of range 0..ORDER");
            return w
        }
        ,
        invertBatch: p => _U(h, p),
        cmov: (p, g, w) => w ? g : p
    });
    return Object.freeze(h)
}
function NU(n) {
    if (typeof n != "bigint")
        throw new Error("field order must be bigint");
    const e = n.toString(2).length;
    return Math.ceil(e / 8)
}
function DU(n) {
    const e = NU(n);
    return e + Math.ceil(e / 2)
}
function Ire(n, e, t=!1) {
    const r = n.length
      , s = NU(e)
      , i = DU(e);
    if (r < 16 || r < i || r > 1024)
        throw new Error("expected " + i + "-1024 bytes of input, got " + r);
    const o = t ? Qg(n) : Qv(n)
      , a = Pr(o, e - Es) + Es;
    return t ? yU(a, s) : e_(a, s)
}
const t0 = BigInt(0)
  , lf = BigInt(1);
function x2(n, e) {
    const t = e.negate();
    return n ? t : e
}
function cf(n, e) {
    const t = _U(n.Fp, e.map(r => r.Z));
    return e.map( (r, s) => n.fromAffine(r.toAffine(t[s])))
}
function TU(n, e) {
    if (!Number.isSafeInteger(n) || n <= 0 || n > e)
        throw new Error("invalid window size, expected [1.." + e + "], got W=" + n)
}
function US(n, e) {
    TU(n, e);
    const t = Math.ceil(e / n) + 1
      , r = 2 ** (n - 1)
      , s = 2 ** n
      , i = My(n)
      , o = BigInt(n);
    return {
        windows: t,
        windowSize: r,
        mask: i,
        maxNumber: s,
        shiftBy: o
    }
}
function SM(n, e, t) {
    const {windowSize: r, mask: s, maxNumber: i, shiftBy: o} = t;
    let a = Number(n & s)
      , l = n >> o;
    a > r && (a -= i,
    l += lf);
    const u = e * r
      , d = u + Math.abs(a) - 1
      , h = a === 0
      , p = a < 0
      , g = e % 2 !== 0;
    return {
        nextN: l,
        offset: d,
        isZero: h,
        isNeg: p,
        isNegF: g,
        offsetF: u
    }
}
function Mre(n, e) {
    if (!Array.isArray(n))
        throw new Error("array expected");
    n.forEach( (t, r) => {
        if (!(t instanceof e))
            throw new Error("invalid point at index " + r)
    }
    )
}
function Bre(n, e) {
    if (!Array.isArray(n))
        throw new Error("array of scalars expected");
    n.forEach( (t, r) => {
        if (!e.isValid(t))
            throw new Error("invalid scalar at index " + r)
    }
    )
}
const zS = new WeakMap
  , IU = new WeakMap;
function $S(n) {
    return IU.get(n) || 1
}
function AM(n) {
    if (n !== t0)
        throw new Error("invalid wNAF")
}
let MU = class {
    constructor(e, t) {
        this.BASE = e.BASE,
        this.ZERO = e.ZERO,
        this.Fn = e.Fn,
        this.bits = t
    }
    _unsafeLadder(e, t, r=this.ZERO) {
        let s = e;
        for (; t > t0; )
            t & lf && (r = r.add(s)),
            s = s.double(),
            t >>= lf;
        return r
    }
    precomputeWindow(e, t) {
        const {windows: r, windowSize: s} = US(t, this.bits)
          , i = [];
        let o = e
          , a = o;
        for (let l = 0; l < r; l++) {
            a = o,
            i.push(a);
            for (let u = 1; u < s; u++)
                a = a.add(o),
                i.push(a);
            o = a.double()
        }
        return i
    }
    wNAF(e, t, r) {
        if (!this.Fn.isValid(r))
            throw new Error("invalid scalar");
        let s = this.ZERO
          , i = this.BASE;
        const o = US(e, this.bits);
        for (let a = 0; a < o.windows; a++) {
            const {nextN: l, offset: u, isZero: d, isNeg: h, isNegF: p, offsetF: g} = SM(r, a, o);
            r = l,
            d ? i = i.add(x2(p, t[g])) : s = s.add(x2(h, t[u]))
        }
        return AM(r),
        {
            p: s,
            f: i
        }
    }
    wNAFUnsafe(e, t, r, s=this.ZERO) {
        const i = US(e, this.bits);
        for (let o = 0; o < i.windows && r !== t0; o++) {
            const {nextN: a, offset: l, isZero: u, isNeg: d} = SM(r, o, i);
            if (r = a,
            !u) {
                const h = t[l];
                s = s.add(d ? h.negate() : h)
            }
        }
        return AM(r),
        s
    }
    getPrecomputes(e, t, r) {
        let s = zS.get(t);
        return s || (s = this.precomputeWindow(t, e),
        e !== 1 && (typeof r == "function" && (s = r(s)),
        zS.set(t, s))),
        s
    }
    cached(e, t, r) {
        const s = $S(e);
        return this.wNAF(s, this.getPrecomputes(s, e, r), t)
    }
    unsafe(e, t, r, s) {
        const i = $S(e);
        return i === 1 ? this._unsafeLadder(e, t, s) : this.wNAFUnsafe(i, this.getPrecomputes(i, e, r), t, s)
    }
    createCache(e, t) {
        TU(t, this.bits),
        IU.set(e, t),
        zS.delete(e)
    }
    hasCache(e) {
        return $S(e) !== 1
    }
}
;
function Rre(n, e, t, r) {
    let s = e
      , i = n.ZERO
      , o = n.ZERO;
    for (; t > t0 || r > t0; )
        t & lf && (i = i.add(s)),
        r & lf && (o = o.add(s)),
        s = s.double(),
        t >>= lf,
        r >>= lf;
    return {
        p1: i,
        p2: o
    }
}
function BU(n, e, t, r) {
    Mre(t, n),
    Bre(r, e);
    const s = t.length
      , i = r.length;
    if (s !== i)
        throw new Error("arrays of points and scalars must have equal length");
    const o = n.ZERO
      , a = bU(BigInt(s));
    let l = 1;
    a > 12 ? l = a - 3 : a > 4 ? l = a - 2 : a > 0 && (l = 2);
    const u = My(l)
      , d = new Array(Number(u) + 1).fill(o)
      , h = Math.floor((e.BITS - 1) / l) * l;
    let p = o;
    for (let g = h; g >= 0; g -= l) {
        d.fill(o);
        for (let b = 0; b < i; b++) {
            const v = r[b]
              , S = Number(v >> BigInt(g) & u);
            d[S] = d[S].add(t[b])
        }
        let w = o;
        for (let b = d.length - 1, v = o; b > 0; b--)
            v = v.add(d[b]),
            w = w.add(v);
        if (p = p.add(w),
        g !== 0)
            for (let b = 0; b < l; b++)
                p = p.double()
    }
    return p
}
function CM(n, e, t) {
    if (e) {
        if (e.ORDER !== n)
            throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
        return Dre(e),
        e
    } else
        return Vf(n, {
            isLE: t
        })
}
function RU(n, e, t={}, r) {
    if (r === void 0 && (r = n === "edwards"),
    !e || typeof e != "object")
        throw new Error(`expected valid ${n} CURVE object`);
    for (const l of ["p", "n", "h"]) {
        const u = e[l];
        if (!(typeof u == "bigint" && u > t0))
            throw new Error(`CURVE.${l} must be positive bigint`)
    }
    const s = CM(e.p, t.Fp, r)
      , i = CM(e.n, t.Fn, r)
      , a = ["Gx", "Gy", "a", n === "weierstrass" ? "b" : "d"];
    for (const l of a)
        if (!s.isValid(e[l]))
            throw new Error(`CURVE.${l} must be valid field element of CURVE.Fp`);
    return e = Object.freeze(Object.assign({}, e)),
    {
        CURVE: e,
        Fp: s,
        Fn: i
    }
}
const bu = BigInt(0)
  , Zr = BigInt(1)
  , HS = BigInt(2)
  , Ore = BigInt(8);
function Pre(n, e, t, r) {
    const s = n.sqr(t)
      , i = n.sqr(r)
      , o = n.add(n.mul(e.a, s), i)
      , a = n.add(n.ONE, n.mul(e.d, n.mul(s, i)));
    return n.eql(o, a)
}
function jre(n, e={}) {
    const t = RU("edwards", n, e, e.FpFnLE)
      , {Fp: r, Fn: s} = t;
    let i = t.CURVE;
    const {h: o} = i;
    By(e, {}, {
        uvRatio: "function"
    });
    const a = HS << BigInt(s.BYTES * 8) - Zr
      , l = v => r.create(v)
      , u = e.uvRatio || ( (v, S) => {
        try {
            return {
                isValid: !0,
                value: r.sqrt(r.div(v, S))
            }
        } catch {
            return {
                isValid: !1,
                value: bu
            }
        }
    }
    );
    if (!Pre(r, i, i.Gx, i.Gy))
        throw new Error("bad curve params: generator point");
    function d(v, S, N=!1) {
        const _ = N ? Zr : bu;
        return O4("coordinate " + v, S, _, a),
        S
    }
    function h(v) {
        if (!(v instanceof w))
            throw new Error("ExtendedPoint expected")
    }
    const p = v2( (v, S) => {
        const {X: N, Y: _, Z: I} = v
          , k = v.is0();
        S == null && (S = k ? Ore : r.inv(I));
        const B = l(N * S)
          , P = l(_ * S)
          , M = r.mul(I, S);
        if (k)
            return {
                x: bu,
                y: Zr
            };
        if (M !== Zr)
            throw new Error("invZ was invalid");
        return {
            x: B,
            y: P
        }
    }
    )
      , g = v2(v => {
        const {a: S, d: N} = i;
        if (v.is0())
            throw new Error("bad point: ZERO");
        const {X: _, Y: I, Z: k, T: B} = v
          , P = l(_ * _)
          , M = l(I * I)
          , R = l(k * k)
          , L = l(R * R)
          , q = l(P * S)
          , H = l(R * l(q + M))
          , j = l(L + l(N * l(P * M)));
        if (H !== j)
            throw new Error("bad point: equation left != right (1)");
        const A = l(_ * I)
          , E = l(k * B);
        if (A !== E)
            throw new Error("bad point: equation left != right (2)");
        return !0
    }
    );
    class w {
        constructor(S, N, _, I) {
            this.X = d("x", S),
            this.Y = d("y", N),
            this.Z = d("z", _, !0),
            this.T = d("t", I),
            Object.freeze(this)
        }
        static CURVE() {
            return i
        }
        static fromAffine(S) {
            if (S instanceof w)
                throw new Error("extended point not allowed");
            const {x: N, y: _} = S || {};
            return d("x", N),
            d("y", _),
            new w(N,_,Zr,l(N * _))
        }
        static fromBytes(S, N=!1) {
            const _ = r.BYTES
              , {a: I, d: k} = i;
            S = vM(oa(S, _, "point")),
            Rf(N, "zip215");
            const B = vM(S)
              , P = S[_ - 1];
            B[_ - 1] = P & -129;
            const M = Qg(B)
              , R = N ? a : r.ORDER;
            O4("point.y", M, bu, R);
            const L = l(M * M)
              , q = l(L - Zr)
              , H = l(k * L - I);
            let {isValid: j, value: A} = u(q, H);
            if (!j)
                throw new Error("bad point: invalid y coordinate");
            const E = (A & Zr) === Zr
              , C = (P & 128) !== 0;
            if (!N && A === bu && C)
                throw new Error("bad point: x=0 and x_0=1");
            return C !== E && (A = l(-A)),
            w.fromAffine({
                x: A,
                y: M
            })
        }
        static fromHex(S, N=!1) {
            return w.fromBytes(hr("point", S), N)
        }
        get x() {
            return this.toAffine().x
        }
        get y() {
            return this.toAffine().y
        }
        precompute(S=8, N=!0) {
            return b.createCache(this, S),
            N || this.multiply(HS),
            this
        }
        assertValidity() {
            g(this)
        }
        equals(S) {
            h(S);
            const {X: N, Y: _, Z: I} = this
              , {X: k, Y: B, Z: P} = S
              , M = l(N * P)
              , R = l(k * I)
              , L = l(_ * P)
              , q = l(B * I);
            return M === R && L === q
        }
        is0() {
            return this.equals(w.ZERO)
        }
        negate() {
            return new w(l(-this.X),this.Y,this.Z,l(-this.T))
        }
        double() {
            const {a: S} = i
              , {X: N, Y: _, Z: I} = this
              , k = l(N * N)
              , B = l(_ * _)
              , P = l(HS * l(I * I))
              , M = l(S * k)
              , R = N + _
              , L = l(l(R * R) - k - B)
              , q = M + B
              , H = q - P
              , j = M - B
              , A = l(L * H)
              , E = l(q * j)
              , C = l(L * j)
              , O = l(H * q);
            return new w(A,E,O,C)
        }
        add(S) {
            h(S);
            const {a: N, d: _} = i
              , {X: I, Y: k, Z: B, T: P} = this
              , {X: M, Y: R, Z: L, T: q} = S
              , H = l(I * M)
              , j = l(k * R)
              , A = l(P * _ * q)
              , E = l(B * L)
              , C = l((I + k) * (M + R) - H - j)
              , O = E - A
              , z = E + A
              , G = l(j - N * H)
              , Y = l(C * O)
              , $ = l(z * G)
              , D = l(C * G)
              , U = l(O * z);
            return new w(Y,$,U,D)
        }
        subtract(S) {
            return this.add(S.negate())
        }
        multiply(S) {
            if (!s.isValidNot0(S))
                throw new Error("invalid scalar: expected 1 <= sc < curve.n");
            const {p: N, f: _} = b.cached(this, S, I => cf(w, I));
            return cf(w, [N, _])[0]
        }
        multiplyUnsafe(S, N=w.ZERO) {
            if (!s.isValid(S))
                throw new Error("invalid scalar: expected 0 <= sc < curve.n");
            return S === bu ? w.ZERO : this.is0() || S === Zr ? this : b.unsafe(this, S, _ => cf(w, _), N)
        }
        isSmallOrder() {
            return this.multiplyUnsafe(o).is0()
        }
        isTorsionFree() {
            return b.unsafe(this, i.n).is0()
        }
        toAffine(S) {
            return p(this, S)
        }
        clearCofactor() {
            return o === Zr ? this : this.multiplyUnsafe(o)
        }
        toBytes() {
            const {x: S, y: N} = this.toAffine()
              , _ = r.toBytes(N);
            return _[_.length - 1] |= S & Zr ? 128 : 0,
            _
        }
        toHex() {
            return Ef(this.toBytes())
        }
        toString() {
            return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`
        }
        get ex() {
            return this.X
        }
        get ey() {
            return this.Y
        }
        get ez() {
            return this.Z
        }
        get et() {
            return this.T
        }
        static normalizeZ(S) {
            return cf(w, S)
        }
        static msm(S, N) {
            return BU(w, s, S, N)
        }
        _setWindowSize(S) {
            this.precompute(S)
        }
        toRawBytes() {
            return this.toBytes()
        }
    }
    w.BASE = new w(i.Gx,i.Gy,Zr,l(i.Gx * i.Gy)),
    w.ZERO = new w(bu,Zr,Zr,bu),
    w.Fp = r,
    w.Fn = s;
    const b = new MU(w,s.BITS);
    return w.BASE.precompute(8),
    w
}
function Lre(n, e, t={}) {
    if (typeof e != "function")
        throw new Error('"hash" function param is required');
    By(t, {}, {
        adjustScalarBytes: "function",
        randomBytes: "function",
        domain: "function",
        prehash: "function",
        mapToCurve: "function"
    });
    const {prehash: r} = t
      , {BASE: s, Fp: i, Fn: o} = n
      , a = t.randomBytes || Xv
      , l = t.adjustScalarBytes || (R => R)
      , u = t.domain || ( (R, L, q) => {
        if (Rf(q, "phflag"),
        L.length || q)
            throw new Error("Contexts/pre-hash are not supported");
        return R
    }
    );
    function d(R) {
        return o.create(Qg(R))
    }
    function h(R) {
        const L = _.secretKey;
        R = hr("private key", R, L);
        const q = hr("hashed private key", e(R), 2 * L)
          , H = l(q.slice(0, L))
          , j = q.slice(L, 2 * L)
          , A = d(H);
        return {
            head: H,
            prefix: j,
            scalar: A
        }
    }
    function p(R) {
        const {head: L, prefix: q, scalar: H} = h(R)
          , j = s.multiply(H)
          , A = j.toBytes();
        return {
            head: L,
            prefix: q,
            scalar: H,
            point: j,
            pointBytes: A
        }
    }
    function g(R) {
        return p(R).pointBytes
    }
    function w(R=Uint8Array.of(), ...L) {
        const q = ra(...L);
        return d(e(u(q, hr("context", R), !!r)))
    }
    function b(R, L, q={}) {
        R = hr("message", R),
        r && (R = r(R));
        const {prefix: H, scalar: j, pointBytes: A} = p(L)
          , E = w(q.context, H, R)
          , C = s.multiply(E).toBytes()
          , O = w(q.context, C, A, R)
          , z = o.create(E + O * j);
        if (!o.isValid(z))
            throw new Error("sign failed: invalid s");
        const G = ra(C, o.toBytes(z));
        return oa(G, _.signature, "result")
    }
    const v = {
        zip215: !0
    };
    function S(R, L, q, H=v) {
        const {context: j, zip215: A} = H
          , E = _.signature;
        R = hr("signature", R, E),
        L = hr("message", L),
        q = hr("publicKey", q, _.publicKey),
        A !== void 0 && Rf(A, "zip215"),
        r && (L = r(L));
        const C = E / 2
          , O = R.subarray(0, C)
          , z = Qg(R.subarray(C, E));
        let G, Y, $;
        try {
            G = n.fromBytes(q, A),
            Y = n.fromBytes(O, A),
            $ = s.multiplyUnsafe(z)
        } catch {
            return !1
        }
        if (!A && G.isSmallOrder())
            return !1;
        const D = w(j, Y.toBytes(), G.toBytes(), L);
        return Y.add(G.multiplyUnsafe(D)).subtract($).clearCofactor().is0()
    }
    const N = i.BYTES
      , _ = {
        secretKey: N,
        publicKey: N,
        signature: 2 * N,
        seed: N
    };
    function I(R=a(_.seed)) {
        return oa(R, _.seed, "seed")
    }
    function k(R) {
        const L = M.randomSecretKey(R);
        return {
            secretKey: L,
            publicKey: g(L)
        }
    }
    function B(R) {
        return Iy(R) && R.length === o.BYTES
    }
    function P(R, L) {
        try {
            return !!n.fromBytes(R, L)
        } catch {
            return !1
        }
    }
    const M = {
        getExtendedPublicKey: p,
        randomSecretKey: I,
        isValidSecretKey: B,
        isValidPublicKey: P,
        toMontgomery(R) {
            const {y: L} = n.fromBytes(R)
              , q = _.publicKey
              , H = q === 32;
            if (!H && q !== 57)
                throw new Error("only defined for 25519 and 448");
            const j = H ? i.div(Zr + L, Zr - L) : i.div(L - Zr, L + Zr);
            return i.toBytes(j)
        },
        toMontgomerySecret(R) {
            const L = _.secretKey;
            oa(R, L);
            const q = e(R.subarray(0, L));
            return l(q).subarray(0, L)
        },
        randomPrivateKey: I,
        precompute(R=8, L=n.BASE) {
            return L.precompute(R, !1)
        }
    };
    return Object.freeze({
        keygen: k,
        getPublicKey: g,
        sign: b,
        verify: S,
        utils: M,
        Point: n,
        lengths: _
    })
}
function Fre(n) {
    const e = {
        a: n.a,
        d: n.d,
        p: n.Fp.ORDER,
        n: n.n,
        h: n.h,
        Gx: n.Gx,
        Gy: n.Gy
    }
      , t = n.Fp
      , r = Vf(e.n, n.nBitLength, !0)
      , s = {
        Fp: t,
        Fn: r,
        uvRatio: n.uvRatio
    }
      , i = {
        randomBytes: n.randomBytes,
        adjustScalarBytes: n.adjustScalarBytes,
        domain: n.domain,
        prehash: n.prehash,
        mapToCurve: n.mapToCurve
    };
    return {
        CURVE: e,
        curveOpts: s,
        hash: n.hash,
        eddsaOpts: i
    }
}
function Ure(n, e) {
    const t = e.Point;
    return Object.assign({}, e, {
        ExtendedPoint: t,
        CURVE: n,
        nBitLength: t.Fn.BITS,
        nByteLength: t.Fn.BYTES
    })
}
function zre(n) {
    const {CURVE: e, curveOpts: t, hash: r, eddsaOpts: s} = Fre(n)
      , i = jre(e, t)
      , o = Lre(i, r, s);
    return Ure(n, o)
}
const $re = BigInt(1)
  , _M = BigInt(2);
BigInt(3);
const Hre = BigInt(5)
  , Vre = BigInt(8)
  , n_ = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed")
  , OU = {
    p: n_,
    n: BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),
    h: Vre,
    a: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),
    d: BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),
    Gx: BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),
    Gy: BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")
};
function qre(n) {
    const e = BigInt(10)
      , t = BigInt(20)
      , r = BigInt(40)
      , s = BigInt(80)
      , i = n_
      , a = n * n % i * n % i
      , l = dr(a, _M, i) * a % i
      , u = dr(l, $re, i) * n % i
      , d = dr(u, Hre, i) * u % i
      , h = dr(d, e, i) * d % i
      , p = dr(h, t, i) * h % i
      , g = dr(p, r, i) * p % i
      , w = dr(g, s, i) * g % i
      , b = dr(w, s, i) * g % i
      , v = dr(b, e, i) * d % i;
    return {
        pow_p_5_8: dr(v, _M, i) * n % i,
        b2: a
    }
}
function Gre(n) {
    return n[0] &= 248,
    n[31] &= 127,
    n[31] |= 64,
    n
}
const kM = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
function Wre(n, e) {
    const t = n_
      , r = Pr(e * e * e, t)
      , s = Pr(r * r * e, t)
      , i = qre(n * s).pow_p_5_8;
    let o = Pr(n * r * i, t);
    const a = Pr(e * o * o, t)
      , l = o
      , u = Pr(o * kM, t)
      , d = a === n
      , h = a === Pr(-n, t)
      , p = a === Pr(-n * kM, t);
    return d && (o = l),
    (h || p) && (o = u),
    kre(o, t) && (o = Pr(-o, t)),
    {
        isValid: d || h,
        value: o
    }
}
const Yre = Vf(OU.p, {
    isLE: !0
})
  , Kre = {
    ...OU,
    Fp: Yre,
    hash: wre,
    adjustScalarBytes: Gre,
    uvRatio: Wre
}
  , Ry = zre(Kre);
var zw = {
    exports: {}
}, Xre = zw.exports, NM;
function PU() {
    return NM || (NM = 1,
    (function(n) {
        (function(e, t) {
            function r(j, A) {
                if (!j)
                    throw new Error(A || "Assertion failed")
            }
            function s(j, A) {
                j.super_ = A;
                var E = function() {};
                E.prototype = A.prototype,
                j.prototype = new E,
                j.prototype.constructor = j
            }
            function i(j, A, E) {
                if (i.isBN(j))
                    return j;
                this.negative = 0,
                this.words = null,
                this.length = 0,
                this.red = null,
                j !== null && ((A === "le" || A === "be") && (E = A,
                A = 10),
                this._init(j || 0, A || 10, E || "be"))
            }
            typeof e == "object" ? e.exports = i : t.BN = i,
            i.BN = i,
            i.wordSize = 26;
            var o;
            try {
                typeof window < "u" && typeof window.Buffer < "u" ? o = window.Buffer : o = Yv().Buffer
            } catch {}
            i.isBN = function(A) {
                return A instanceof i ? !0 : A !== null && typeof A == "object" && A.constructor.wordSize === i.wordSize && Array.isArray(A.words)
            }
            ,
            i.max = function(A, E) {
                return A.cmp(E) > 0 ? A : E
            }
            ,
            i.min = function(A, E) {
                return A.cmp(E) < 0 ? A : E
            }
            ,
            i.prototype._init = function(A, E, C) {
                if (typeof A == "number")
                    return this._initNumber(A, E, C);
                if (typeof A == "object")
                    return this._initArray(A, E, C);
                E === "hex" && (E = 16),
                r(E === (E | 0) && E >= 2 && E <= 36),
                A = A.toString().replace(/\s+/g, "");
                var O = 0;
                A[0] === "-" && (O++,
                this.negative = 1),
                O < A.length && (E === 16 ? this._parseHex(A, O, C) : (this._parseBase(A, E, O),
                C === "le" && this._initArray(this.toArray(), E, C)))
            }
            ,
            i.prototype._initNumber = function(A, E, C) {
                A < 0 && (this.negative = 1,
                A = -A),
                A < 67108864 ? (this.words = [A & 67108863],
                this.length = 1) : A < 4503599627370496 ? (this.words = [A & 67108863, A / 67108864 & 67108863],
                this.length = 2) : (r(A < 9007199254740992),
                this.words = [A & 67108863, A / 67108864 & 67108863, 1],
                this.length = 3),
                C === "le" && this._initArray(this.toArray(), E, C)
            }
            ,
            i.prototype._initArray = function(A, E, C) {
                if (r(typeof A.length == "number"),
                A.length <= 0)
                    return this.words = [0],
                    this.length = 1,
                    this;
                this.length = Math.ceil(A.length / 3),
                this.words = new Array(this.length);
                for (var O = 0; O < this.length; O++)
                    this.words[O] = 0;
                var z, G, Y = 0;
                if (C === "be")
                    for (O = A.length - 1,
                    z = 0; O >= 0; O -= 3)
                        G = A[O] | A[O - 1] << 8 | A[O - 2] << 16,
                        this.words[z] |= G << Y & 67108863,
                        this.words[z + 1] = G >>> 26 - Y & 67108863,
                        Y += 24,
                        Y >= 26 && (Y -= 26,
                        z++);
                else if (C === "le")
                    for (O = 0,
                    z = 0; O < A.length; O += 3)
                        G = A[O] | A[O + 1] << 8 | A[O + 2] << 16,
                        this.words[z] |= G << Y & 67108863,
                        this.words[z + 1] = G >>> 26 - Y & 67108863,
                        Y += 24,
                        Y >= 26 && (Y -= 26,
                        z++);
                return this._strip()
            }
            ;
            function a(j, A) {
                var E = j.charCodeAt(A);
                if (E >= 48 && E <= 57)
                    return E - 48;
                if (E >= 65 && E <= 70)
                    return E - 55;
                if (E >= 97 && E <= 102)
                    return E - 87;
                r(!1, "Invalid character in " + j)
            }
            function l(j, A, E) {
                var C = a(j, E);
                return E - 1 >= A && (C |= a(j, E - 1) << 4),
                C
            }
            i.prototype._parseHex = function(A, E, C) {
                this.length = Math.ceil((A.length - E) / 6),
                this.words = new Array(this.length);
                for (var O = 0; O < this.length; O++)
                    this.words[O] = 0;
                var z = 0, G = 0, Y;
                if (C === "be")
                    for (O = A.length - 1; O >= E; O -= 2)
                        Y = l(A, E, O) << z,
                        this.words[G] |= Y & 67108863,
                        z >= 18 ? (z -= 18,
                        G += 1,
                        this.words[G] |= Y >>> 26) : z += 8;
                else {
                    var $ = A.length - E;
                    for (O = $ % 2 === 0 ? E + 1 : E; O < A.length; O += 2)
                        Y = l(A, E, O) << z,
                        this.words[G] |= Y & 67108863,
                        z >= 18 ? (z -= 18,
                        G += 1,
                        this.words[G] |= Y >>> 26) : z += 8
                }
                this._strip()
            }
            ;
            function u(j, A, E, C) {
                for (var O = 0, z = 0, G = Math.min(j.length, E), Y = A; Y < G; Y++) {
                    var $ = j.charCodeAt(Y) - 48;
                    O *= C,
                    $ >= 49 ? z = $ - 49 + 10 : $ >= 17 ? z = $ - 17 + 10 : z = $,
                    r($ >= 0 && z < C, "Invalid character"),
                    O += z
                }
                return O
            }
            i.prototype._parseBase = function(A, E, C) {
                this.words = [0],
                this.length = 1;
                for (var O = 0, z = 1; z <= 67108863; z *= E)
                    O++;
                O--,
                z = z / E | 0;
                for (var G = A.length - C, Y = G % O, $ = Math.min(G, G - Y) + C, D = 0, U = C; U < $; U += O)
                    D = u(A, U, U + O, E),
                    this.imuln(z),
                    this.words[0] + D < 67108864 ? this.words[0] += D : this._iaddn(D);
                if (Y !== 0) {
                    var W = 1;
                    for (D = u(A, U, A.length, E),
                    U = 0; U < Y; U++)
                        W *= E;
                    this.imuln(W),
                    this.words[0] + D < 67108864 ? this.words[0] += D : this._iaddn(D)
                }
                this._strip()
            }
            ,
            i.prototype.copy = function(A) {
                A.words = new Array(this.length);
                for (var E = 0; E < this.length; E++)
                    A.words[E] = this.words[E];
                A.length = this.length,
                A.negative = this.negative,
                A.red = this.red
            }
            ;
            function d(j, A) {
                j.words = A.words,
                j.length = A.length,
                j.negative = A.negative,
                j.red = A.red
            }
            if (i.prototype._move = function(A) {
                d(A, this)
            }
            ,
            i.prototype.clone = function() {
                var A = new i(null);
                return this.copy(A),
                A
            }
            ,
            i.prototype._expand = function(A) {
                for (; this.length < A; )
                    this.words[this.length++] = 0;
                return this
            }
            ,
            i.prototype._strip = function() {
                for (; this.length > 1 && this.words[this.length - 1] === 0; )
                    this.length--;
                return this._normSign()
            }
            ,
            i.prototype._normSign = function() {
                return this.length === 1 && this.words[0] === 0 && (this.negative = 0),
                this
            }
            ,
            typeof Symbol < "u" && typeof Symbol.for == "function")
                try {
                    i.prototype[Symbol.for("nodejs.util.inspect.custom")] = h
                } catch {
                    i.prototype.inspect = h
                }
            else
                i.prototype.inspect = h;
            function h() {
                return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
            }
            var p = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"]
              , g = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
              , w = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
            i.prototype.toString = function(A, E) {
                A = A || 10,
                E = E | 0 || 1;
                var C;
                if (A === 16 || A === "hex") {
                    C = "";
                    for (var O = 0, z = 0, G = 0; G < this.length; G++) {
                        var Y = this.words[G]
                          , $ = ((Y << O | z) & 16777215).toString(16);
                        z = Y >>> 24 - O & 16777215,
                        O += 2,
                        O >= 26 && (O -= 26,
                        G--),
                        z !== 0 || G !== this.length - 1 ? C = p[6 - $.length] + $ + C : C = $ + C
                    }
                    for (z !== 0 && (C = z.toString(16) + C); C.length % E !== 0; )
                        C = "0" + C;
                    return this.negative !== 0 && (C = "-" + C),
                    C
                }
                if (A === (A | 0) && A >= 2 && A <= 36) {
                    var D = g[A]
                      , U = w[A];
                    C = "";
                    var W = this.clone();
                    for (W.negative = 0; !W.isZero(); ) {
                        var Q = W.modrn(U).toString(A);
                        W = W.idivn(U),
                        W.isZero() ? C = Q + C : C = p[D - Q.length] + Q + C
                    }
                    for (this.isZero() && (C = "0" + C); C.length % E !== 0; )
                        C = "0" + C;
                    return this.negative !== 0 && (C = "-" + C),
                    C
                }
                r(!1, "Base should be between 2 and 36")
            }
            ,
            i.prototype.toNumber = function() {
                var A = this.words[0];
                return this.length === 2 ? A += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? A += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(!1, "Number can only safely store up to 53 bits"),
                this.negative !== 0 ? -A : A
            }
            ,
            i.prototype.toJSON = function() {
                return this.toString(16, 2)
            }
            ,
            o && (i.prototype.toBuffer = function(A, E) {
                return this.toArrayLike(o, A, E)
            }
            ),
            i.prototype.toArray = function(A, E) {
                return this.toArrayLike(Array, A, E)
            }
            ;
            var b = function(A, E) {
                return A.allocUnsafe ? A.allocUnsafe(E) : new A(E)
            };
            i.prototype.toArrayLike = function(A, E, C) {
                this._strip();
                var O = this.byteLength()
                  , z = C || Math.max(1, O);
                r(O <= z, "byte array longer than desired length"),
                r(z > 0, "Requested array length <= 0");
                var G = b(A, z)
                  , Y = E === "le" ? "LE" : "BE";
                return this["_toArrayLike" + Y](G, O),
                G
            }
            ,
            i.prototype._toArrayLikeLE = function(A, E) {
                for (var C = 0, O = 0, z = 0, G = 0; z < this.length; z++) {
                    var Y = this.words[z] << G | O;
                    A[C++] = Y & 255,
                    C < A.length && (A[C++] = Y >> 8 & 255),
                    C < A.length && (A[C++] = Y >> 16 & 255),
                    G === 6 ? (C < A.length && (A[C++] = Y >> 24 & 255),
                    O = 0,
                    G = 0) : (O = Y >>> 24,
                    G += 2)
                }
                if (C < A.length)
                    for (A[C++] = O; C < A.length; )
                        A[C++] = 0
            }
            ,
            i.prototype._toArrayLikeBE = function(A, E) {
                for (var C = A.length - 1, O = 0, z = 0, G = 0; z < this.length; z++) {
                    var Y = this.words[z] << G | O;
                    A[C--] = Y & 255,
                    C >= 0 && (A[C--] = Y >> 8 & 255),
                    C >= 0 && (A[C--] = Y >> 16 & 255),
                    G === 6 ? (C >= 0 && (A[C--] = Y >> 24 & 255),
                    O = 0,
                    G = 0) : (O = Y >>> 24,
                    G += 2)
                }
                if (C >= 0)
                    for (A[C--] = O; C >= 0; )
                        A[C--] = 0
            }
            ,
            Math.clz32 ? i.prototype._countBits = function(A) {
                return 32 - Math.clz32(A)
            }
            : i.prototype._countBits = function(A) {
                var E = A
                  , C = 0;
                return E >= 4096 && (C += 13,
                E >>>= 13),
                E >= 64 && (C += 7,
                E >>>= 7),
                E >= 8 && (C += 4,
                E >>>= 4),
                E >= 2 && (C += 2,
                E >>>= 2),
                C + E
            }
            ,
            i.prototype._zeroBits = function(A) {
                if (A === 0)
                    return 26;
                var E = A
                  , C = 0;
                return (E & 8191) === 0 && (C += 13,
                E >>>= 13),
                (E & 127) === 0 && (C += 7,
                E >>>= 7),
                (E & 15) === 0 && (C += 4,
                E >>>= 4),
                (E & 3) === 0 && (C += 2,
                E >>>= 2),
                (E & 1) === 0 && C++,
                C
            }
            ,
            i.prototype.bitLength = function() {
                var A = this.words[this.length - 1]
                  , E = this._countBits(A);
                return (this.length - 1) * 26 + E
            }
            ;
            function v(j) {
                for (var A = new Array(j.bitLength()), E = 0; E < A.length; E++) {
                    var C = E / 26 | 0
                      , O = E % 26;
                    A[E] = j.words[C] >>> O & 1
                }
                return A
            }
            i.prototype.zeroBits = function() {
                if (this.isZero())
                    return 0;
                for (var A = 0, E = 0; E < this.length; E++) {
                    var C = this._zeroBits(this.words[E]);
                    if (A += C,
                    C !== 26)
                        break
                }
                return A
            }
            ,
            i.prototype.byteLength = function() {
                return Math.ceil(this.bitLength() / 8)
            }
            ,
            i.prototype.toTwos = function(A) {
                return this.negative !== 0 ? this.abs().inotn(A).iaddn(1) : this.clone()
            }
            ,
            i.prototype.fromTwos = function(A) {
                return this.testn(A - 1) ? this.notn(A).iaddn(1).ineg() : this.clone()
            }
            ,
            i.prototype.isNeg = function() {
                return this.negative !== 0
            }
            ,
            i.prototype.neg = function() {
                return this.clone().ineg()
            }
            ,
            i.prototype.ineg = function() {
                return this.isZero() || (this.negative ^= 1),
                this
            }
            ,
            i.prototype.iuor = function(A) {
                for (; this.length < A.length; )
                    this.words[this.length++] = 0;
                for (var E = 0; E < A.length; E++)
                    this.words[E] = this.words[E] | A.words[E];
                return this._strip()
            }
            ,
            i.prototype.ior = function(A) {
                return r((this.negative | A.negative) === 0),
                this.iuor(A)
            }
            ,
            i.prototype.or = function(A) {
                return this.length > A.length ? this.clone().ior(A) : A.clone().ior(this)
            }
            ,
            i.prototype.uor = function(A) {
                return this.length > A.length ? this.clone().iuor(A) : A.clone().iuor(this)
            }
            ,
            i.prototype.iuand = function(A) {
                var E;
                this.length > A.length ? E = A : E = this;
                for (var C = 0; C < E.length; C++)
                    this.words[C] = this.words[C] & A.words[C];
                return this.length = E.length,
                this._strip()
            }
            ,
            i.prototype.iand = function(A) {
                return r((this.negative | A.negative) === 0),
                this.iuand(A)
            }
            ,
            i.prototype.and = function(A) {
                return this.length > A.length ? this.clone().iand(A) : A.clone().iand(this)
            }
            ,
            i.prototype.uand = function(A) {
                return this.length > A.length ? this.clone().iuand(A) : A.clone().iuand(this)
            }
            ,
            i.prototype.iuxor = function(A) {
                var E, C;
                this.length > A.length ? (E = this,
                C = A) : (E = A,
                C = this);
                for (var O = 0; O < C.length; O++)
                    this.words[O] = E.words[O] ^ C.words[O];
                if (this !== E)
                    for (; O < E.length; O++)
                        this.words[O] = E.words[O];
                return this.length = E.length,
                this._strip()
            }
            ,
            i.prototype.ixor = function(A) {
                return r((this.negative | A.negative) === 0),
                this.iuxor(A)
            }
            ,
            i.prototype.xor = function(A) {
                return this.length > A.length ? this.clone().ixor(A) : A.clone().ixor(this)
            }
            ,
            i.prototype.uxor = function(A) {
                return this.length > A.length ? this.clone().iuxor(A) : A.clone().iuxor(this)
            }
            ,
            i.prototype.inotn = function(A) {
                r(typeof A == "number" && A >= 0);
                var E = Math.ceil(A / 26) | 0
                  , C = A % 26;
                this._expand(E),
                C > 0 && E--;
                for (var O = 0; O < E; O++)
                    this.words[O] = ~this.words[O] & 67108863;
                return C > 0 && (this.words[O] = ~this.words[O] & 67108863 >> 26 - C),
                this._strip()
            }
            ,
            i.prototype.notn = function(A) {
                return this.clone().inotn(A)
            }
            ,
            i.prototype.setn = function(A, E) {
                r(typeof A == "number" && A >= 0);
                var C = A / 26 | 0
                  , O = A % 26;
                return this._expand(C + 1),
                E ? this.words[C] = this.words[C] | 1 << O : this.words[C] = this.words[C] & ~(1 << O),
                this._strip()
            }
            ,
            i.prototype.iadd = function(A) {
                var E;
                if (this.negative !== 0 && A.negative === 0)
                    return this.negative = 0,
                    E = this.isub(A),
                    this.negative ^= 1,
                    this._normSign();
                if (this.negative === 0 && A.negative !== 0)
                    return A.negative = 0,
                    E = this.isub(A),
                    A.negative = 1,
                    E._normSign();
                var C, O;
                this.length > A.length ? (C = this,
                O = A) : (C = A,
                O = this);
                for (var z = 0, G = 0; G < O.length; G++)
                    E = (C.words[G] | 0) + (O.words[G] | 0) + z,
                    this.words[G] = E & 67108863,
                    z = E >>> 26;
                for (; z !== 0 && G < C.length; G++)
                    E = (C.words[G] | 0) + z,
                    this.words[G] = E & 67108863,
                    z = E >>> 26;
                if (this.length = C.length,
                z !== 0)
                    this.words[this.length] = z,
                    this.length++;
                else if (C !== this)
                    for (; G < C.length; G++)
                        this.words[G] = C.words[G];
                return this
            }
            ,
            i.prototype.add = function(A) {
                var E;
                return A.negative !== 0 && this.negative === 0 ? (A.negative = 0,
                E = this.sub(A),
                A.negative ^= 1,
                E) : A.negative === 0 && this.negative !== 0 ? (this.negative = 0,
                E = A.sub(this),
                this.negative = 1,
                E) : this.length > A.length ? this.clone().iadd(A) : A.clone().iadd(this)
            }
            ,
            i.prototype.isub = function(A) {
                if (A.negative !== 0) {
                    A.negative = 0;
                    var E = this.iadd(A);
                    return A.negative = 1,
                    E._normSign()
                } else if (this.negative !== 0)
                    return this.negative = 0,
                    this.iadd(A),
                    this.negative = 1,
                    this._normSign();
                var C = this.cmp(A);
                if (C === 0)
                    return this.negative = 0,
                    this.length = 1,
                    this.words[0] = 0,
                    this;
                var O, z;
                C > 0 ? (O = this,
                z = A) : (O = A,
                z = this);
                for (var G = 0, Y = 0; Y < z.length; Y++)
                    E = (O.words[Y] | 0) - (z.words[Y] | 0) + G,
                    G = E >> 26,
                    this.words[Y] = E & 67108863;
                for (; G !== 0 && Y < O.length; Y++)
                    E = (O.words[Y] | 0) + G,
                    G = E >> 26,
                    this.words[Y] = E & 67108863;
                if (G === 0 && Y < O.length && O !== this)
                    for (; Y < O.length; Y++)
                        this.words[Y] = O.words[Y];
                return this.length = Math.max(this.length, Y),
                O !== this && (this.negative = 1),
                this._strip()
            }
            ,
            i.prototype.sub = function(A) {
                return this.clone().isub(A)
            }
            ;
            function S(j, A, E) {
                E.negative = A.negative ^ j.negative;
                var C = j.length + A.length | 0;
                E.length = C,
                C = C - 1 | 0;
                var O = j.words[0] | 0
                  , z = A.words[0] | 0
                  , G = O * z
                  , Y = G & 67108863
                  , $ = G / 67108864 | 0;
                E.words[0] = Y;
                for (var D = 1; D < C; D++) {
                    for (var U = $ >>> 26, W = $ & 67108863, Q = Math.min(D, A.length - 1), J = Math.max(0, D - j.length + 1); J <= Q; J++) {
                        var ne = D - J | 0;
                        O = j.words[ne] | 0,
                        z = A.words[J] | 0,
                        G = O * z + W,
                        U += G / 67108864 | 0,
                        W = G & 67108863
                    }
                    E.words[D] = W | 0,
                    $ = U | 0
                }
                return $ !== 0 ? E.words[D] = $ | 0 : E.length--,
                E._strip()
            }
            var N = function(A, E, C) {
                var O = A.words, z = E.words, G = C.words, Y = 0, $, D, U, W = O[0] | 0, Q = W & 8191, J = W >>> 13, ne = O[1] | 0, ie = ne & 8191, ae = ne >>> 13, xe = O[2] | 0, ue = xe & 8191, ce = xe >>> 13, me = O[3] | 0, Ee = me & 8191, Oe = me >>> 13, mt = O[4] | 0, st = mt & 8191, ot = mt >>> 13, Ct = O[5] | 0, ct = Ct & 8191, Xe = Ct >>> 13, Et = O[6] | 0, St = Et & 8191, ut = Et >>> 13, cn = O[7] | 0, _t = cn & 8191, ee = cn >>> 13, K = O[8] | 0, X = K & 8191, re = K >>> 13, se = O[9] | 0, fe = se & 8191, ge = se >>> 13, _e = z[0] | 0, Qe = _e & 8191, Ve = _e >>> 13, jt = z[1] | 0, dt = jt & 8191, Qt = jt >>> 13, Nn = z[2] | 0, ln = Nn & 8191, $t = Nn >>> 13, $e = z[3] | 0, Ue = $e & 8191, qe = $e >>> 13, At = z[4] | 0, De = At & 8191, Me = At >>> 13, Je = z[5] | 0, Pe = Je & 8191, et = Je >>> 13, Nt = z[6] | 0, pt = Nt & 8191, wt = Nt >>> 13, Rn = z[7] | 0, Zt = Rn & 8191, Jt = Rn >>> 13, oi = z[8] | 0, Dt = oi & 8191, Ht = oi >>> 13, ll = z[9] | 0, Xn = ll & 8191, ar = ll >>> 13;
                C.negative = A.negative ^ E.negative,
                C.length = 19,
                $ = Math.imul(Q, Qe),
                D = Math.imul(Q, Ve),
                D = D + Math.imul(J, Qe) | 0,
                U = Math.imul(J, Ve);
                var F0 = (Y + $ | 0) + ((D & 8191) << 13) | 0;
                Y = (U + (D >>> 13) | 0) + (F0 >>> 26) | 0,
                F0 &= 67108863,
                $ = Math.imul(ie, Qe),
                D = Math.imul(ie, Ve),
                D = D + Math.imul(ae, Qe) | 0,
                U = Math.imul(ae, Ve),
                $ = $ + Math.imul(Q, dt) | 0,
                D = D + Math.imul(Q, Qt) | 0,
                D = D + Math.imul(J, dt) | 0,
                U = U + Math.imul(J, Qt) | 0;
                var rh = (Y + $ | 0) + ((D & 8191) << 13) | 0;
                Y = (U + (D >>> 13) | 0) + (rh >>> 26) | 0,
                rh &= 67108863,
                $ = Math.imul(ue, Qe),
                D = Math.imul(ue, Ve),
                D = D + Math.imul(ce, Qe) | 0,
                U = Math.imul(ce, Ve),
                $ = $ + Math.imul(ie, dt) | 0,
                D = D + Math.imul(ie, Qt) | 0,
                D = D + Math.imul(ae, dt) | 0,
                U = U + Math.imul(ae, Qt) | 0,
                $ = $ + Math.imul(Q, ln) | 0,
                D = D + Math.imul(Q, $t) | 0,
                D = D + Math.imul(J, ln) | 0,
                U = U + Math.imul(J, $t) | 0;
                var cl = (Y + $ | 0) + ((D & 8191) << 13) | 0;
                Y = (U + (D >>> 13) | 0) + (cl >>> 26) | 0,
                cl &= 67108863,
                $ = Math.imul(Ee, Qe),
                D = Math.imul(Ee, Ve),
                D = D + Math.imul(Oe, Qe) | 0,
                U = Math.imul(Oe, Ve),
                $ = $ + Math.imul(ue, dt) | 0,
                D = D + Math.imul(ue, Qt) | 0,
                D = D + Math.imul(ce, dt) | 0,
                U = U + Math.imul(ce, Qt) | 0,
                $ = $ + Math.imul(ie, ln) | 0,
                D = D + Math.imul(ie, $t) | 0,
                D = D + Math.imul(ae, ln) | 0,
                U = U + Math.imul(ae, $t) | 0,
                $ = $ + Math.imul(Q, Ue) | 0,
                D = D + Math.imul(Q, qe) | 0,
                D = D + Math.imul(J, Ue) | 0,
                U = U + Math.imul(J, qe) | 0;
                var fd = (Y + $ | 0) + ((D & 8191) << 13) | 0;
                Y = (U + (D >>> 13) | 0) + (fd >>> 26) | 0,
                fd &= 67108863,
                $ = Math.imul(st, Qe),
                D = Math.imul(st, Ve),
                D = D + Math.imul(ot, Qe) | 0,
                U = Math.imul(ot, Ve),
                $ = $ + Math.imul(Ee, dt) | 0,
                D = D + Math.imul(Ee, Qt) | 0,
                D = D + Math.imul(Oe, dt) | 0,
                U = U + Math.imul(Oe, Qt) | 0,
                $ = $ + Math.imul(ue, ln) | 0,
                D = D + Math.imul(ue, $t) | 0,
                D = D + Math.imul(ce, ln) | 0,
                U = U + Math.imul(ce, $t) | 0,
                $ = $ + Math.imul(ie, Ue) | 0,
                D = D + Math.imul(ie, qe) | 0,
                D = D + Math.imul(ae, Ue) | 0,
                U = U + Math.imul(ae, qe) | 0,
                $ = $ + Math.imul(Q, De) | 0,
                D = D + Math.imul(Q, Me) | 0,
                D = D + Math.imul(J, De) | 0,
                U = U + Math.imul(J, Me) | 0;
                var ba = (Y + $ | 0) + ((D & 8191) << 13) | 0;
                Y = (U + (D >>> 13) | 0) + (ba >>> 26) | 0,
                ba &= 67108863,
                $ = Math.imul(ct, Qe),
                D = Math.imul(ct, Ve),
                D = D + Math.imul(Xe, Qe) | 0,
                U = Math.imul(Xe, Ve),
                $ = $ + Math.imul(st, dt) | 0,
                D = D + Math.imul(st, Qt) | 0,
                D = D + Math.imul(ot, dt) | 0,
                U = U + Math.imul(ot, Qt) | 0,
                $ = $ + Math.imul(Ee, ln) | 0,
                D = D + Math.imul(Ee, $t) | 0,
                D = D + Math.imul(Oe, ln) | 0,
                U = U + Math.imul(Oe, $t) | 0,
                $ = $ + Math.imul(ue, Ue) | 0,
                D = D + Math.imul(ue, qe) | 0,
                D = D + Math.imul(ce, Ue) | 0,
                U = U + Math.imul(ce, qe) | 0,
                $ = $ + Math.imul(ie, De) | 0,
                D = D + Math.imul(ie, Me) | 0,
                D = D + Math.imul(ae, De) | 0,
                U = U + Math.imul(ae, Me) | 0,
                $ = $ + Math.imul(Q, Pe) | 0,
                D = D + Math.imul(Q, et) | 0,
                D = D + Math.imul(J, Pe) | 0,
                U = U + Math.imul(J, et) | 0;
                var wa = (Y + $ | 0) + ((D & 8191) << 13) | 0;
                Y = (U + (D >>> 13) | 0) + (wa >>> 26) | 0,
                wa &= 67108863,
                $ = Math.imul(St, Qe),
                D = Math.imul(St, Ve),
                D = D + Math.imul(ut, Qe) | 0,
                U = Math.imul(ut, Ve),
                $ = $ + Math.imul(ct, dt) | 0,
                D = D + Math.imul(ct, Qt) | 0,
                D = D + Math.imul(Xe, dt) | 0,
                U = U + Math.imul(Xe, Qt) | 0,
                $ = $ + Math.imul(st, ln) | 0,
                D = D + Math.imul(st, $t) | 0,
                D = D + Math.imul(ot, ln) | 0,
                U = U + Math.imul(ot, $t) | 0,
                $ = $ + Math.imul(Ee, Ue) | 0,
                D = D + Math.imul(Ee, qe) | 0,
                D = D + Math.imul(Oe, Ue) | 0,
                U = U + Math.imul(Oe, qe) | 0,
                $ = $ + Math.imul(ue, De) | 0,
                D = D + Math.imul(ue, Me) | 0,
                D = D + Math.imul(ce, De) | 0,
                U = U + Math.imul(ce, Me) | 0,
                $ = $ + Math.imul(ie, Pe) | 0,
                D = D + Math.imul(ie, et) | 0,
                D = D + Math.imul(ae, Pe) | 0,
                U = U + Math.imul(ae, et) | 0,
                $ = $ + Math.imul(Q, pt) | 0,
                D = D + Math.imul(Q, wt) | 0,
                D = D + Math.imul(J, pt) | 0,
                U = U + Math.imul(J, wt) | 0;
                var ul = (Y + $ | 0) + ((D & 8191) << 13) | 0;
                Y = (U + (D >>> 13) | 0) + (ul >>> 26) | 0,
                ul &= 67108863,
                $ = Math.imul(_t, Qe),
                D = Math.imul(_t, Ve),
                D = D + Math.imul(ee, Qe) | 0,
                U = Math.imul(ee, Ve),
                $ = $ + Math.imul(St, dt) | 0,
                D = D + Math.imul(St, Qt) | 0,
                D = D + Math.imul(ut, dt) | 0,
                U = U + Math.imul(ut, Qt) | 0,
                $ = $ + Math.imul(ct, ln) | 0,
                D = D + Math.imul(ct, $t) | 0,
                D = D + Math.imul(Xe, ln) | 0,
                U = U + Math.imul(Xe, $t) | 0,
                $ = $ + Math.imul(st, Ue) | 0,
                D = D + Math.imul(st, qe) | 0,
                D = D + Math.imul(ot, Ue) | 0,
                U = U + Math.imul(ot, qe) | 0,
                $ = $ + Math.imul(Ee, De) | 0,
                D = D + Math.imul(Ee, Me) | 0,
                D = D + Math.imul(Oe, De) | 0,
                U = U + Math.imul(Oe, Me) | 0,
                $ = $ + Math.imul(ue, Pe) | 0,
                D = D + Math.imul(ue, et) | 0,
                D = D + Math.imul(ce, Pe) | 0,
                U = U + Math.imul(ce, et) | 0,
                $ = $ + Math.imul(ie, pt) | 0,
                D = D + Math.imul(ie, wt) | 0,
                D = D + Math.imul(ae, pt) | 0,
                U = U + Math.imul(ae, wt) | 0,
                $ = $ + Math.imul(Q, Zt) | 0,
                D = D + Math.imul(Q, Jt) | 0,
                D = D + Math.imul(J, Zt) | 0,
                U = U + Math.imul(J, Jt) | 0;
                var va = (Y + $ | 0) + ((D & 8191) << 13) | 0;
                Y = (U + (D >>> 13) | 0) + (va >>> 26) | 0,
                va &= 67108863,
                $ = Math.imul(X, Qe),
                D = Math.imul(X, Ve),
                D = D + Math.imul(re, Qe) | 0,
                U = Math.imul(re, Ve),
                $ = $ + Math.imul(_t, dt) | 0,
                D = D + Math.imul(_t, Qt) | 0,
                D = D + Math.imul(ee, dt) | 0,
                U = U + Math.imul(ee, Qt) | 0,
                $ = $ + Math.imul(St, ln) | 0,
                D = D + Math.imul(St, $t) | 0,
                D = D + Math.imul(ut, ln) | 0,
                U = U + Math.imul(ut, $t) | 0,
                $ = $ + Math.imul(ct, Ue) | 0,
                D = D + Math.imul(ct, qe) | 0,
                D = D + Math.imul(Xe, Ue) | 0,
                U = U + Math.imul(Xe, qe) | 0,
                $ = $ + Math.imul(st, De) | 0,
                D = D + Math.imul(st, Me) | 0,
                D = D + Math.imul(ot, De) | 0,
                U = U + Math.imul(ot, Me) | 0,
                $ = $ + Math.imul(Ee, Pe) | 0,
                D = D + Math.imul(Ee, et) | 0,
                D = D + Math.imul(Oe, Pe) | 0,
                U = U + Math.imul(Oe, et) | 0,
                $ = $ + Math.imul(ue, pt) | 0,
                D = D + Math.imul(ue, wt) | 0,
                D = D + Math.imul(ce, pt) | 0,
                U = U + Math.imul(ce, wt) | 0,
                $ = $ + Math.imul(ie, Zt) | 0,
                D = D + Math.imul(ie, Jt) | 0,
                D = D + Math.imul(ae, Zt) | 0,
                U = U + Math.imul(ae, Jt) | 0,
                $ = $ + Math.imul(Q, Dt) | 0,
                D = D + Math.imul(Q, Ht) | 0,
                D = D + Math.imul(J, Dt) | 0,
                U = U + Math.imul(J, Ht) | 0;
                var lr = (Y + $ | 0) + ((D & 8191) << 13) | 0;
                Y = (U + (D >>> 13) | 0) + (lr >>> 26) | 0,
                lr &= 67108863,
                $ = Math.imul(fe, Qe),
                D = Math.imul(fe, Ve),
                D = D + Math.imul(ge, Qe) | 0,
                U = Math.imul(ge, Ve),
                $ = $ + Math.imul(X, dt) | 0,
                D = D + Math.imul(X, Qt) | 0,
                D = D + Math.imul(re, dt) | 0,
                U = U + Math.imul(re, Qt) | 0,
                $ = $ + Math.imul(_t, ln) | 0,
                D = D + Math.imul(_t, $t) | 0,
                D = D + Math.imul(ee, ln) | 0,
                U = U + Math.imul(ee, $t) | 0,
                $ = $ + Math.imul(St, Ue) | 0,
                D = D + Math.imul(St, qe) | 0,
                D = D + Math.imul(ut, Ue) | 0,
                U = U + Math.imul(ut, qe) | 0,
                $ = $ + Math.imul(ct, De) | 0,
                D = D + Math.imul(ct, Me) | 0,
                D = D + Math.imul(Xe, De) | 0,
                U = U + Math.imul(Xe, Me) | 0,
                $ = $ + Math.imul(st, Pe) | 0,
                D = D + Math.imul(st, et) | 0,
                D = D + Math.imul(ot, Pe) | 0,
                U = U + Math.imul(ot, et) | 0,
                $ = $ + Math.imul(Ee, pt) | 0,
                D = D + Math.imul(Ee, wt) | 0,
                D = D + Math.imul(Oe, pt) | 0,
                U = U + Math.imul(Oe, wt) | 0,
                $ = $ + Math.imul(ue, Zt) | 0,
                D = D + Math.imul(ue, Jt) | 0,
                D = D + Math.imul(ce, Zt) | 0,
                U = U + Math.imul(ce, Jt) | 0,
                $ = $ + Math.imul(ie, Dt) | 0,
                D = D + Math.imul(ie, Ht) | 0,
                D = D + Math.imul(ae, Dt) | 0,
                U = U + Math.imul(ae, Ht) | 0,
                $ = $ + Math.imul(Q, Xn) | 0,
                D = D + Math.imul(Q, ar) | 0,
                D = D + Math.imul(J, Xn) | 0,
                U = U + Math.imul(J, ar) | 0;
                var sh = (Y + $ | 0) + ((D & 8191) << 13) | 0;
                Y = (U + (D >>> 13) | 0) + (sh >>> 26) | 0,
                sh &= 67108863,
                $ = Math.imul(fe, dt),
                D = Math.imul(fe, Qt),
                D = D + Math.imul(ge, dt) | 0,
                U = Math.imul(ge, Qt),
                $ = $ + Math.imul(X, ln) | 0,
                D = D + Math.imul(X, $t) | 0,
                D = D + Math.imul(re, ln) | 0,
                U = U + Math.imul(re, $t) | 0,
                $ = $ + Math.imul(_t, Ue) | 0,
                D = D + Math.imul(_t, qe) | 0,
                D = D + Math.imul(ee, Ue) | 0,
                U = U + Math.imul(ee, qe) | 0,
                $ = $ + Math.imul(St, De) | 0,
                D = D + Math.imul(St, Me) | 0,
                D = D + Math.imul(ut, De) | 0,
                U = U + Math.imul(ut, Me) | 0,
                $ = $ + Math.imul(ct, Pe) | 0,
                D = D + Math.imul(ct, et) | 0,
                D = D + Math.imul(Xe, Pe) | 0,
                U = U + Math.imul(Xe, et) | 0,
                $ = $ + Math.imul(st, pt) | 0,
                D = D + Math.imul(st, wt) | 0,
                D = D + Math.imul(ot, pt) | 0,
                U = U + Math.imul(ot, wt) | 0,
                $ = $ + Math.imul(Ee, Zt) | 0,
                D = D + Math.imul(Ee, Jt) | 0,
                D = D + Math.imul(Oe, Zt) | 0,
                U = U + Math.imul(Oe, Jt) | 0,
                $ = $ + Math.imul(ue, Dt) | 0,
                D = D + Math.imul(ue, Ht) | 0,
                D = D + Math.imul(ce, Dt) | 0,
                U = U + Math.imul(ce, Ht) | 0,
                $ = $ + Math.imul(ie, Xn) | 0,
                D = D + Math.imul(ie, ar) | 0,
                D = D + Math.imul(ae, Xn) | 0,
                U = U + Math.imul(ae, ar) | 0;
                var ih = (Y + $ | 0) + ((D & 8191) << 13) | 0;
                Y = (U + (D >>> 13) | 0) + (ih >>> 26) | 0,
                ih &= 67108863,
                $ = Math.imul(fe, ln),
                D = Math.imul(fe, $t),
                D = D + Math.imul(ge, ln) | 0,
                U = Math.imul(ge, $t),
                $ = $ + Math.imul(X, Ue) | 0,
                D = D + Math.imul(X, qe) | 0,
                D = D + Math.imul(re, Ue) | 0,
                U = U + Math.imul(re, qe) | 0,
                $ = $ + Math.imul(_t, De) | 0,
                D = D + Math.imul(_t, Me) | 0,
                D = D + Math.imul(ee, De) | 0,
                U = U + Math.imul(ee, Me) | 0,
                $ = $ + Math.imul(St, Pe) | 0,
                D = D + Math.imul(St, et) | 0,
                D = D + Math.imul(ut, Pe) | 0,
                U = U + Math.imul(ut, et) | 0,
                $ = $ + Math.imul(ct, pt) | 0,
                D = D + Math.imul(ct, wt) | 0,
                D = D + Math.imul(Xe, pt) | 0,
                U = U + Math.imul(Xe, wt) | 0,
                $ = $ + Math.imul(st, Zt) | 0,
                D = D + Math.imul(st, Jt) | 0,
                D = D + Math.imul(ot, Zt) | 0,
                U = U + Math.imul(ot, Jt) | 0,
                $ = $ + Math.imul(Ee, Dt) | 0,
                D = D + Math.imul(Ee, Ht) | 0,
                D = D + Math.imul(Oe, Dt) | 0,
                U = U + Math.imul(Oe, Ht) | 0,
                $ = $ + Math.imul(ue, Xn) | 0,
                D = D + Math.imul(ue, ar) | 0,
                D = D + Math.imul(ce, Xn) | 0,
                U = U + Math.imul(ce, ar) | 0;
                var $o = (Y + $ | 0) + ((D & 8191) << 13) | 0;
                Y = (U + (D >>> 13) | 0) + ($o >>> 26) | 0,
                $o &= 67108863,
                $ = Math.imul(fe, Ue),
                D = Math.imul(fe, qe),
                D = D + Math.imul(ge, Ue) | 0,
                U = Math.imul(ge, qe),
                $ = $ + Math.imul(X, De) | 0,
                D = D + Math.imul(X, Me) | 0,
                D = D + Math.imul(re, De) | 0,
                U = U + Math.imul(re, Me) | 0,
                $ = $ + Math.imul(_t, Pe) | 0,
                D = D + Math.imul(_t, et) | 0,
                D = D + Math.imul(ee, Pe) | 0,
                U = U + Math.imul(ee, et) | 0,
                $ = $ + Math.imul(St, pt) | 0,
                D = D + Math.imul(St, wt) | 0,
                D = D + Math.imul(ut, pt) | 0,
                U = U + Math.imul(ut, wt) | 0,
                $ = $ + Math.imul(ct, Zt) | 0,
                D = D + Math.imul(ct, Jt) | 0,
                D = D + Math.imul(Xe, Zt) | 0,
                U = U + Math.imul(Xe, Jt) | 0,
                $ = $ + Math.imul(st, Dt) | 0,
                D = D + Math.imul(st, Ht) | 0,
                D = D + Math.imul(ot, Dt) | 0,
                U = U + Math.imul(ot, Ht) | 0,
                $ = $ + Math.imul(Ee, Xn) | 0,
                D = D + Math.imul(Ee, ar) | 0,
                D = D + Math.imul(Oe, Xn) | 0,
                U = U + Math.imul(Oe, ar) | 0;
                var xa = (Y + $ | 0) + ((D & 8191) << 13) | 0;
                Y = (U + (D >>> 13) | 0) + (xa >>> 26) | 0,
                xa &= 67108863,
                $ = Math.imul(fe, De),
                D = Math.imul(fe, Me),
                D = D + Math.imul(ge, De) | 0,
                U = Math.imul(ge, Me),
                $ = $ + Math.imul(X, Pe) | 0,
                D = D + Math.imul(X, et) | 0,
                D = D + Math.imul(re, Pe) | 0,
                U = U + Math.imul(re, et) | 0,
                $ = $ + Math.imul(_t, pt) | 0,
                D = D + Math.imul(_t, wt) | 0,
                D = D + Math.imul(ee, pt) | 0,
                U = U + Math.imul(ee, wt) | 0,
                $ = $ + Math.imul(St, Zt) | 0,
                D = D + Math.imul(St, Jt) | 0,
                D = D + Math.imul(ut, Zt) | 0,
                U = U + Math.imul(ut, Jt) | 0,
                $ = $ + Math.imul(ct, Dt) | 0,
                D = D + Math.imul(ct, Ht) | 0,
                D = D + Math.imul(Xe, Dt) | 0,
                U = U + Math.imul(Xe, Ht) | 0,
                $ = $ + Math.imul(st, Xn) | 0,
                D = D + Math.imul(st, ar) | 0,
                D = D + Math.imul(ot, Xn) | 0,
                U = U + Math.imul(ot, ar) | 0;
                var U0 = (Y + $ | 0) + ((D & 8191) << 13) | 0;
                Y = (U + (D >>> 13) | 0) + (U0 >>> 26) | 0,
                U0 &= 67108863,
                $ = Math.imul(fe, Pe),
                D = Math.imul(fe, et),
                D = D + Math.imul(ge, Pe) | 0,
                U = Math.imul(ge, et),
                $ = $ + Math.imul(X, pt) | 0,
                D = D + Math.imul(X, wt) | 0,
                D = D + Math.imul(re, pt) | 0,
                U = U + Math.imul(re, wt) | 0,
                $ = $ + Math.imul(_t, Zt) | 0,
                D = D + Math.imul(_t, Jt) | 0,
                D = D + Math.imul(ee, Zt) | 0,
                U = U + Math.imul(ee, Jt) | 0,
                $ = $ + Math.imul(St, Dt) | 0,
                D = D + Math.imul(St, Ht) | 0,
                D = D + Math.imul(ut, Dt) | 0,
                U = U + Math.imul(ut, Ht) | 0,
                $ = $ + Math.imul(ct, Xn) | 0,
                D = D + Math.imul(ct, ar) | 0,
                D = D + Math.imul(Xe, Xn) | 0,
                U = U + Math.imul(Xe, ar) | 0;
                var oh = (Y + $ | 0) + ((D & 8191) << 13) | 0;
                Y = (U + (D >>> 13) | 0) + (oh >>> 26) | 0,
                oh &= 67108863,
                $ = Math.imul(fe, pt),
                D = Math.imul(fe, wt),
                D = D + Math.imul(ge, pt) | 0,
                U = Math.imul(ge, wt),
                $ = $ + Math.imul(X, Zt) | 0,
                D = D + Math.imul(X, Jt) | 0,
                D = D + Math.imul(re, Zt) | 0,
                U = U + Math.imul(re, Jt) | 0,
                $ = $ + Math.imul(_t, Dt) | 0,
                D = D + Math.imul(_t, Ht) | 0,
                D = D + Math.imul(ee, Dt) | 0,
                U = U + Math.imul(ee, Ht) | 0,
                $ = $ + Math.imul(St, Xn) | 0,
                D = D + Math.imul(St, ar) | 0,
                D = D + Math.imul(ut, Xn) | 0,
                U = U + Math.imul(ut, ar) | 0;
                var ah = (Y + $ | 0) + ((D & 8191) << 13) | 0;
                Y = (U + (D >>> 13) | 0) + (ah >>> 26) | 0,
                ah &= 67108863,
                $ = Math.imul(fe, Zt),
                D = Math.imul(fe, Jt),
                D = D + Math.imul(ge, Zt) | 0,
                U = Math.imul(ge, Jt),
                $ = $ + Math.imul(X, Dt) | 0,
                D = D + Math.imul(X, Ht) | 0,
                D = D + Math.imul(re, Dt) | 0,
                U = U + Math.imul(re, Ht) | 0,
                $ = $ + Math.imul(_t, Xn) | 0,
                D = D + Math.imul(_t, ar) | 0,
                D = D + Math.imul(ee, Xn) | 0,
                U = U + Math.imul(ee, ar) | 0;
                var z0 = (Y + $ | 0) + ((D & 8191) << 13) | 0;
                Y = (U + (D >>> 13) | 0) + (z0 >>> 26) | 0,
                z0 &= 67108863,
                $ = Math.imul(fe, Dt),
                D = Math.imul(fe, Ht),
                D = D + Math.imul(ge, Dt) | 0,
                U = Math.imul(ge, Ht),
                $ = $ + Math.imul(X, Xn) | 0,
                D = D + Math.imul(X, ar) | 0,
                D = D + Math.imul(re, Xn) | 0,
                U = U + Math.imul(re, ar) | 0;
                var Fc = (Y + $ | 0) + ((D & 8191) << 13) | 0;
                Y = (U + (D >>> 13) | 0) + (Fc >>> 26) | 0,
                Fc &= 67108863,
                $ = Math.imul(fe, Xn),
                D = Math.imul(fe, ar),
                D = D + Math.imul(ge, Xn) | 0,
                U = Math.imul(ge, ar);
                var Uc = (Y + $ | 0) + ((D & 8191) << 13) | 0;
                return Y = (U + (D >>> 13) | 0) + (Uc >>> 26) | 0,
                Uc &= 67108863,
                G[0] = F0,
                G[1] = rh,
                G[2] = cl,
                G[3] = fd,
                G[4] = ba,
                G[5] = wa,
                G[6] = ul,
                G[7] = va,
                G[8] = lr,
                G[9] = sh,
                G[10] = ih,
                G[11] = $o,
                G[12] = xa,
                G[13] = U0,
                G[14] = oh,
                G[15] = ah,
                G[16] = z0,
                G[17] = Fc,
                G[18] = Uc,
                Y !== 0 && (G[19] = Y,
                C.length++),
                C
            };
            Math.imul || (N = S);
            function _(j, A, E) {
                E.negative = A.negative ^ j.negative,
                E.length = j.length + A.length;
                for (var C = 0, O = 0, z = 0; z < E.length - 1; z++) {
                    var G = O;
                    O = 0;
                    for (var Y = C & 67108863, $ = Math.min(z, A.length - 1), D = Math.max(0, z - j.length + 1); D <= $; D++) {
                        var U = z - D
                          , W = j.words[U] | 0
                          , Q = A.words[D] | 0
                          , J = W * Q
                          , ne = J & 67108863;
                        G = G + (J / 67108864 | 0) | 0,
                        ne = ne + Y | 0,
                        Y = ne & 67108863,
                        G = G + (ne >>> 26) | 0,
                        O += G >>> 26,
                        G &= 67108863
                    }
                    E.words[z] = Y,
                    C = G,
                    G = O
                }
                return C !== 0 ? E.words[z] = C : E.length--,
                E._strip()
            }
            function I(j, A, E) {
                return _(j, A, E)
            }
            i.prototype.mulTo = function(A, E) {
                var C, O = this.length + A.length;
                return this.length === 10 && A.length === 10 ? C = N(this, A, E) : O < 63 ? C = S(this, A, E) : O < 1024 ? C = _(this, A, E) : C = I(this, A, E),
                C
            }
            ,
            i.prototype.mul = function(A) {
                var E = new i(null);
                return E.words = new Array(this.length + A.length),
                this.mulTo(A, E)
            }
            ,
            i.prototype.mulf = function(A) {
                var E = new i(null);
                return E.words = new Array(this.length + A.length),
                I(this, A, E)
            }
            ,
            i.prototype.imul = function(A) {
                return this.clone().mulTo(A, this)
            }
            ,
            i.prototype.imuln = function(A) {
                var E = A < 0;
                E && (A = -A),
                r(typeof A == "number"),
                r(A < 67108864);
                for (var C = 0, O = 0; O < this.length; O++) {
                    var z = (this.words[O] | 0) * A
                      , G = (z & 67108863) + (C & 67108863);
                    C >>= 26,
                    C += z / 67108864 | 0,
                    C += G >>> 26,
                    this.words[O] = G & 67108863
                }
                return C !== 0 && (this.words[O] = C,
                this.length++),
                this.length = A === 0 ? 1 : this.length,
                E ? this.ineg() : this
            }
            ,
            i.prototype.muln = function(A) {
                return this.clone().imuln(A)
            }
            ,
            i.prototype.sqr = function() {
                return this.mul(this)
            }
            ,
            i.prototype.isqr = function() {
                return this.imul(this.clone())
            }
            ,
            i.prototype.pow = function(A) {
                var E = v(A);
                if (E.length === 0)
                    return new i(1);
                for (var C = this, O = 0; O < E.length && E[O] === 0; O++,
                C = C.sqr())
                    ;
                if (++O < E.length)
                    for (var z = C.sqr(); O < E.length; O++,
                    z = z.sqr())
                        E[O] !== 0 && (C = C.mul(z));
                return C
            }
            ,
            i.prototype.iushln = function(A) {
                r(typeof A == "number" && A >= 0);
                var E = A % 26, C = (A - E) / 26, O = 67108863 >>> 26 - E << 26 - E, z;
                if (E !== 0) {
                    var G = 0;
                    for (z = 0; z < this.length; z++) {
                        var Y = this.words[z] & O
                          , $ = (this.words[z] | 0) - Y << E;
                        this.words[z] = $ | G,
                        G = Y >>> 26 - E
                    }
                    G && (this.words[z] = G,
                    this.length++)
                }
                if (C !== 0) {
                    for (z = this.length - 1; z >= 0; z--)
                        this.words[z + C] = this.words[z];
                    for (z = 0; z < C; z++)
                        this.words[z] = 0;
                    this.length += C
                }
                return this._strip()
            }
            ,
            i.prototype.ishln = function(A) {
                return r(this.negative === 0),
                this.iushln(A)
            }
            ,
            i.prototype.iushrn = function(A, E, C) {
                r(typeof A == "number" && A >= 0);
                var O;
                E ? O = (E - E % 26) / 26 : O = 0;
                var z = A % 26
                  , G = Math.min((A - z) / 26, this.length)
                  , Y = 67108863 ^ 67108863 >>> z << z
                  , $ = C;
                if (O -= G,
                O = Math.max(0, O),
                $) {
                    for (var D = 0; D < G; D++)
                        $.words[D] = this.words[D];
                    $.length = G
                }
                if (G !== 0)
                    if (this.length > G)
                        for (this.length -= G,
                        D = 0; D < this.length; D++)
                            this.words[D] = this.words[D + G];
                    else
                        this.words[0] = 0,
                        this.length = 1;
                var U = 0;
                for (D = this.length - 1; D >= 0 && (U !== 0 || D >= O); D--) {
                    var W = this.words[D] | 0;
                    this.words[D] = U << 26 - z | W >>> z,
                    U = W & Y
                }
                return $ && U !== 0 && ($.words[$.length++] = U),
                this.length === 0 && (this.words[0] = 0,
                this.length = 1),
                this._strip()
            }
            ,
            i.prototype.ishrn = function(A, E, C) {
                return r(this.negative === 0),
                this.iushrn(A, E, C)
            }
            ,
            i.prototype.shln = function(A) {
                return this.clone().ishln(A)
            }
            ,
            i.prototype.ushln = function(A) {
                return this.clone().iushln(A)
            }
            ,
            i.prototype.shrn = function(A) {
                return this.clone().ishrn(A)
            }
            ,
            i.prototype.ushrn = function(A) {
                return this.clone().iushrn(A)
            }
            ,
            i.prototype.testn = function(A) {
                r(typeof A == "number" && A >= 0);
                var E = A % 26
                  , C = (A - E) / 26
                  , O = 1 << E;
                if (this.length <= C)
                    return !1;
                var z = this.words[C];
                return !!(z & O)
            }
            ,
            i.prototype.imaskn = function(A) {
                r(typeof A == "number" && A >= 0);
                var E = A % 26
                  , C = (A - E) / 26;
                if (r(this.negative === 0, "imaskn works only with positive numbers"),
                this.length <= C)
                    return this;
                if (E !== 0 && C++,
                this.length = Math.min(C, this.length),
                E !== 0) {
                    var O = 67108863 ^ 67108863 >>> E << E;
                    this.words[this.length - 1] &= O
                }
                return this._strip()
            }
            ,
            i.prototype.maskn = function(A) {
                return this.clone().imaskn(A)
            }
            ,
            i.prototype.iaddn = function(A) {
                return r(typeof A == "number"),
                r(A < 67108864),
                A < 0 ? this.isubn(-A) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= A ? (this.words[0] = A - (this.words[0] | 0),
                this.negative = 0,
                this) : (this.negative = 0,
                this.isubn(A),
                this.negative = 1,
                this) : this._iaddn(A)
            }
            ,
            i.prototype._iaddn = function(A) {
                this.words[0] += A;
                for (var E = 0; E < this.length && this.words[E] >= 67108864; E++)
                    this.words[E] -= 67108864,
                    E === this.length - 1 ? this.words[E + 1] = 1 : this.words[E + 1]++;
                return this.length = Math.max(this.length, E + 1),
                this
            }
            ,
            i.prototype.isubn = function(A) {
                if (r(typeof A == "number"),
                r(A < 67108864),
                A < 0)
                    return this.iaddn(-A);
                if (this.negative !== 0)
                    return this.negative = 0,
                    this.iaddn(A),
                    this.negative = 1,
                    this;
                if (this.words[0] -= A,
                this.length === 1 && this.words[0] < 0)
                    this.words[0] = -this.words[0],
                    this.negative = 1;
                else
                    for (var E = 0; E < this.length && this.words[E] < 0; E++)
                        this.words[E] += 67108864,
                        this.words[E + 1] -= 1;
                return this._strip()
            }
            ,
            i.prototype.addn = function(A) {
                return this.clone().iaddn(A)
            }
            ,
            i.prototype.subn = function(A) {
                return this.clone().isubn(A)
            }
            ,
            i.prototype.iabs = function() {
                return this.negative = 0,
                this
            }
            ,
            i.prototype.abs = function() {
                return this.clone().iabs()
            }
            ,
            i.prototype._ishlnsubmul = function(A, E, C) {
                var O = A.length + C, z;
                this._expand(O);
                var G, Y = 0;
                for (z = 0; z < A.length; z++) {
                    G = (this.words[z + C] | 0) + Y;
                    var $ = (A.words[z] | 0) * E;
                    G -= $ & 67108863,
                    Y = (G >> 26) - ($ / 67108864 | 0),
                    this.words[z + C] = G & 67108863
                }
                for (; z < this.length - C; z++)
                    G = (this.words[z + C] | 0) + Y,
                    Y = G >> 26,
                    this.words[z + C] = G & 67108863;
                if (Y === 0)
                    return this._strip();
                for (r(Y === -1),
                Y = 0,
                z = 0; z < this.length; z++)
                    G = -(this.words[z] | 0) + Y,
                    Y = G >> 26,
                    this.words[z] = G & 67108863;
                return this.negative = 1,
                this._strip()
            }
            ,
            i.prototype._wordDiv = function(A, E) {
                var C = this.length - A.length
                  , O = this.clone()
                  , z = A
                  , G = z.words[z.length - 1] | 0
                  , Y = this._countBits(G);
                C = 26 - Y,
                C !== 0 && (z = z.ushln(C),
                O.iushln(C),
                G = z.words[z.length - 1] | 0);
                var $ = O.length - z.length, D;
                if (E !== "mod") {
                    D = new i(null),
                    D.length = $ + 1,
                    D.words = new Array(D.length);
                    for (var U = 0; U < D.length; U++)
                        D.words[U] = 0
                }
                var W = O.clone()._ishlnsubmul(z, 1, $);
                W.negative === 0 && (O = W,
                D && (D.words[$] = 1));
                for (var Q = $ - 1; Q >= 0; Q--) {
                    var J = (O.words[z.length + Q] | 0) * 67108864 + (O.words[z.length + Q - 1] | 0);
                    for (J = Math.min(J / G | 0, 67108863),
                    O._ishlnsubmul(z, J, Q); O.negative !== 0; )
                        J--,
                        O.negative = 0,
                        O._ishlnsubmul(z, 1, Q),
                        O.isZero() || (O.negative ^= 1);
                    D && (D.words[Q] = J)
                }
                return D && D._strip(),
                O._strip(),
                E !== "div" && C !== 0 && O.iushrn(C),
                {
                    div: D || null,
                    mod: O
                }
            }
            ,
            i.prototype.divmod = function(A, E, C) {
                if (r(!A.isZero()),
                this.isZero())
                    return {
                        div: new i(0),
                        mod: new i(0)
                    };
                var O, z, G;
                return this.negative !== 0 && A.negative === 0 ? (G = this.neg().divmod(A, E),
                E !== "mod" && (O = G.div.neg()),
                E !== "div" && (z = G.mod.neg(),
                C && z.negative !== 0 && z.iadd(A)),
                {
                    div: O,
                    mod: z
                }) : this.negative === 0 && A.negative !== 0 ? (G = this.divmod(A.neg(), E),
                E !== "mod" && (O = G.div.neg()),
                {
                    div: O,
                    mod: G.mod
                }) : (this.negative & A.negative) !== 0 ? (G = this.neg().divmod(A.neg(), E),
                E !== "div" && (z = G.mod.neg(),
                C && z.negative !== 0 && z.isub(A)),
                {
                    div: G.div,
                    mod: z
                }) : A.length > this.length || this.cmp(A) < 0 ? {
                    div: new i(0),
                    mod: this
                } : A.length === 1 ? E === "div" ? {
                    div: this.divn(A.words[0]),
                    mod: null
                } : E === "mod" ? {
                    div: null,
                    mod: new i(this.modrn(A.words[0]))
                } : {
                    div: this.divn(A.words[0]),
                    mod: new i(this.modrn(A.words[0]))
                } : this._wordDiv(A, E)
            }
            ,
            i.prototype.div = function(A) {
                return this.divmod(A, "div", !1).div
            }
            ,
            i.prototype.mod = function(A) {
                return this.divmod(A, "mod", !1).mod
            }
            ,
            i.prototype.umod = function(A) {
                return this.divmod(A, "mod", !0).mod
            }
            ,
            i.prototype.divRound = function(A) {
                var E = this.divmod(A);
                if (E.mod.isZero())
                    return E.div;
                var C = E.div.negative !== 0 ? E.mod.isub(A) : E.mod
                  , O = A.ushrn(1)
                  , z = A.andln(1)
                  , G = C.cmp(O);
                return G < 0 || z === 1 && G === 0 ? E.div : E.div.negative !== 0 ? E.div.isubn(1) : E.div.iaddn(1)
            }
            ,
            i.prototype.modrn = function(A) {
                var E = A < 0;
                E && (A = -A),
                r(A <= 67108863);
                for (var C = (1 << 26) % A, O = 0, z = this.length - 1; z >= 0; z--)
                    O = (C * O + (this.words[z] | 0)) % A;
                return E ? -O : O
            }
            ,
            i.prototype.modn = function(A) {
                return this.modrn(A)
            }
            ,
            i.prototype.idivn = function(A) {
                var E = A < 0;
                E && (A = -A),
                r(A <= 67108863);
                for (var C = 0, O = this.length - 1; O >= 0; O--) {
                    var z = (this.words[O] | 0) + C * 67108864;
                    this.words[O] = z / A | 0,
                    C = z % A
                }
                return this._strip(),
                E ? this.ineg() : this
            }
            ,
            i.prototype.divn = function(A) {
                return this.clone().idivn(A)
            }
            ,
            i.prototype.egcd = function(A) {
                r(A.negative === 0),
                r(!A.isZero());
                var E = this
                  , C = A.clone();
                E.negative !== 0 ? E = E.umod(A) : E = E.clone();
                for (var O = new i(1), z = new i(0), G = new i(0), Y = new i(1), $ = 0; E.isEven() && C.isEven(); )
                    E.iushrn(1),
                    C.iushrn(1),
                    ++$;
                for (var D = C.clone(), U = E.clone(); !E.isZero(); ) {
                    for (var W = 0, Q = 1; (E.words[0] & Q) === 0 && W < 26; ++W,
                    Q <<= 1)
                        ;
                    if (W > 0)
                        for (E.iushrn(W); W-- > 0; )
                            (O.isOdd() || z.isOdd()) && (O.iadd(D),
                            z.isub(U)),
                            O.iushrn(1),
                            z.iushrn(1);
                    for (var J = 0, ne = 1; (C.words[0] & ne) === 0 && J < 26; ++J,
                    ne <<= 1)
                        ;
                    if (J > 0)
                        for (C.iushrn(J); J-- > 0; )
                            (G.isOdd() || Y.isOdd()) && (G.iadd(D),
                            Y.isub(U)),
                            G.iushrn(1),
                            Y.iushrn(1);
                    E.cmp(C) >= 0 ? (E.isub(C),
                    O.isub(G),
                    z.isub(Y)) : (C.isub(E),
                    G.isub(O),
                    Y.isub(z))
                }
                return {
                    a: G,
                    b: Y,
                    gcd: C.iushln($)
                }
            }
            ,
            i.prototype._invmp = function(A) {
                r(A.negative === 0),
                r(!A.isZero());
                var E = this
                  , C = A.clone();
                E.negative !== 0 ? E = E.umod(A) : E = E.clone();
                for (var O = new i(1), z = new i(0), G = C.clone(); E.cmpn(1) > 0 && C.cmpn(1) > 0; ) {
                    for (var Y = 0, $ = 1; (E.words[0] & $) === 0 && Y < 26; ++Y,
                    $ <<= 1)
                        ;
                    if (Y > 0)
                        for (E.iushrn(Y); Y-- > 0; )
                            O.isOdd() && O.iadd(G),
                            O.iushrn(1);
                    for (var D = 0, U = 1; (C.words[0] & U) === 0 && D < 26; ++D,
                    U <<= 1)
                        ;
                    if (D > 0)
                        for (C.iushrn(D); D-- > 0; )
                            z.isOdd() && z.iadd(G),
                            z.iushrn(1);
                    E.cmp(C) >= 0 ? (E.isub(C),
                    O.isub(z)) : (C.isub(E),
                    z.isub(O))
                }
                var W;
                return E.cmpn(1) === 0 ? W = O : W = z,
                W.cmpn(0) < 0 && W.iadd(A),
                W
            }
            ,
            i.prototype.gcd = function(A) {
                if (this.isZero())
                    return A.abs();
                if (A.isZero())
                    return this.abs();
                var E = this.clone()
                  , C = A.clone();
                E.negative = 0,
                C.negative = 0;
                for (var O = 0; E.isEven() && C.isEven(); O++)
                    E.iushrn(1),
                    C.iushrn(1);
                do {
                    for (; E.isEven(); )
                        E.iushrn(1);
                    for (; C.isEven(); )
                        C.iushrn(1);
                    var z = E.cmp(C);
                    if (z < 0) {
                        var G = E;
                        E = C,
                        C = G
                    } else if (z === 0 || C.cmpn(1) === 0)
                        break;
                    E.isub(C)
                } while (!0);
                return C.iushln(O)
            }
            ,
            i.prototype.invm = function(A) {
                return this.egcd(A).a.umod(A)
            }
            ,
            i.prototype.isEven = function() {
                return (this.words[0] & 1) === 0
            }
            ,
            i.prototype.isOdd = function() {
                return (this.words[0] & 1) === 1
            }
            ,
            i.prototype.andln = function(A) {
                return this.words[0] & A
            }
            ,
            i.prototype.bincn = function(A) {
                r(typeof A == "number");
                var E = A % 26
                  , C = (A - E) / 26
                  , O = 1 << E;
                if (this.length <= C)
                    return this._expand(C + 1),
                    this.words[C] |= O,
                    this;
                for (var z = O, G = C; z !== 0 && G < this.length; G++) {
                    var Y = this.words[G] | 0;
                    Y += z,
                    z = Y >>> 26,
                    Y &= 67108863,
                    this.words[G] = Y
                }
                return z !== 0 && (this.words[G] = z,
                this.length++),
                this
            }
            ,
            i.prototype.isZero = function() {
                return this.length === 1 && this.words[0] === 0
            }
            ,
            i.prototype.cmpn = function(A) {
                var E = A < 0;
                if (this.negative !== 0 && !E)
                    return -1;
                if (this.negative === 0 && E)
                    return 1;
                this._strip();
                var C;
                if (this.length > 1)
                    C = 1;
                else {
                    E && (A = -A),
                    r(A <= 67108863, "Number is too big");
                    var O = this.words[0] | 0;
                    C = O === A ? 0 : O < A ? -1 : 1
                }
                return this.negative !== 0 ? -C | 0 : C
            }
            ,
            i.prototype.cmp = function(A) {
                if (this.negative !== 0 && A.negative === 0)
                    return -1;
                if (this.negative === 0 && A.negative !== 0)
                    return 1;
                var E = this.ucmp(A);
                return this.negative !== 0 ? -E | 0 : E
            }
            ,
            i.prototype.ucmp = function(A) {
                if (this.length > A.length)
                    return 1;
                if (this.length < A.length)
                    return -1;
                for (var E = 0, C = this.length - 1; C >= 0; C--) {
                    var O = this.words[C] | 0
                      , z = A.words[C] | 0;
                    if (O !== z) {
                        O < z ? E = -1 : O > z && (E = 1);
                        break
                    }
                }
                return E
            }
            ,
            i.prototype.gtn = function(A) {
                return this.cmpn(A) === 1
            }
            ,
            i.prototype.gt = function(A) {
                return this.cmp(A) === 1
            }
            ,
            i.prototype.gten = function(A) {
                return this.cmpn(A) >= 0
            }
            ,
            i.prototype.gte = function(A) {
                return this.cmp(A) >= 0
            }
            ,
            i.prototype.ltn = function(A) {
                return this.cmpn(A) === -1
            }
            ,
            i.prototype.lt = function(A) {
                return this.cmp(A) === -1
            }
            ,
            i.prototype.lten = function(A) {
                return this.cmpn(A) <= 0
            }
            ,
            i.prototype.lte = function(A) {
                return this.cmp(A) <= 0
            }
            ,
            i.prototype.eqn = function(A) {
                return this.cmpn(A) === 0
            }
            ,
            i.prototype.eq = function(A) {
                return this.cmp(A) === 0
            }
            ,
            i.red = function(A) {
                return new q(A)
            }
            ,
            i.prototype.toRed = function(A) {
                return r(!this.red, "Already a number in reduction context"),
                r(this.negative === 0, "red works only with positives"),
                A.convertTo(this)._forceRed(A)
            }
            ,
            i.prototype.fromRed = function() {
                return r(this.red, "fromRed works only with numbers in reduction context"),
                this.red.convertFrom(this)
            }
            ,
            i.prototype._forceRed = function(A) {
                return this.red = A,
                this
            }
            ,
            i.prototype.forceRed = function(A) {
                return r(!this.red, "Already a number in reduction context"),
                this._forceRed(A)
            }
            ,
            i.prototype.redAdd = function(A) {
                return r(this.red, "redAdd works only with red numbers"),
                this.red.add(this, A)
            }
            ,
            i.prototype.redIAdd = function(A) {
                return r(this.red, "redIAdd works only with red numbers"),
                this.red.iadd(this, A)
            }
            ,
            i.prototype.redSub = function(A) {
                return r(this.red, "redSub works only with red numbers"),
                this.red.sub(this, A)
            }
            ,
            i.prototype.redISub = function(A) {
                return r(this.red, "redISub works only with red numbers"),
                this.red.isub(this, A)
            }
            ,
            i.prototype.redShl = function(A) {
                return r(this.red, "redShl works only with red numbers"),
                this.red.shl(this, A)
            }
            ,
            i.prototype.redMul = function(A) {
                return r(this.red, "redMul works only with red numbers"),
                this.red._verify2(this, A),
                this.red.mul(this, A)
            }
            ,
            i.prototype.redIMul = function(A) {
                return r(this.red, "redMul works only with red numbers"),
                this.red._verify2(this, A),
                this.red.imul(this, A)
            }
            ,
            i.prototype.redSqr = function() {
                return r(this.red, "redSqr works only with red numbers"),
                this.red._verify1(this),
                this.red.sqr(this)
            }
            ,
            i.prototype.redISqr = function() {
                return r(this.red, "redISqr works only with red numbers"),
                this.red._verify1(this),
                this.red.isqr(this)
            }
            ,
            i.prototype.redSqrt = function() {
                return r(this.red, "redSqrt works only with red numbers"),
                this.red._verify1(this),
                this.red.sqrt(this)
            }
            ,
            i.prototype.redInvm = function() {
                return r(this.red, "redInvm works only with red numbers"),
                this.red._verify1(this),
                this.red.invm(this)
            }
            ,
            i.prototype.redNeg = function() {
                return r(this.red, "redNeg works only with red numbers"),
                this.red._verify1(this),
                this.red.neg(this)
            }
            ,
            i.prototype.redPow = function(A) {
                return r(this.red && !A.red, "redPow(normalNum)"),
                this.red._verify1(this),
                this.red.pow(this, A)
            }
            ;
            var k = {
                k256: null,
                p224: null,
                p192: null,
                p25519: null
            };
            function B(j, A) {
                this.name = j,
                this.p = new i(A,16),
                this.n = this.p.bitLength(),
                this.k = new i(1).iushln(this.n).isub(this.p),
                this.tmp = this._tmp()
            }
            B.prototype._tmp = function() {
                var A = new i(null);
                return A.words = new Array(Math.ceil(this.n / 13)),
                A
            }
            ,
            B.prototype.ireduce = function(A) {
                var E = A, C;
                do
                    this.split(E, this.tmp),
                    E = this.imulK(E),
                    E = E.iadd(this.tmp),
                    C = E.bitLength();
                while (C > this.n);
                var O = C < this.n ? -1 : E.ucmp(this.p);
                return O === 0 ? (E.words[0] = 0,
                E.length = 1) : O > 0 ? E.isub(this.p) : E.strip !== void 0 ? E.strip() : E._strip(),
                E
            }
            ,
            B.prototype.split = function(A, E) {
                A.iushrn(this.n, 0, E)
            }
            ,
            B.prototype.imulK = function(A) {
                return A.imul(this.k)
            }
            ;
            function P() {
                B.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
            }
            s(P, B),
            P.prototype.split = function(A, E) {
                for (var C = 4194303, O = Math.min(A.length, 9), z = 0; z < O; z++)
                    E.words[z] = A.words[z];
                if (E.length = O,
                A.length <= 9) {
                    A.words[0] = 0,
                    A.length = 1;
                    return
                }
                var G = A.words[9];
                for (E.words[E.length++] = G & C,
                z = 10; z < A.length; z++) {
                    var Y = A.words[z] | 0;
                    A.words[z - 10] = (Y & C) << 4 | G >>> 22,
                    G = Y
                }
                G >>>= 22,
                A.words[z - 10] = G,
                G === 0 && A.length > 10 ? A.length -= 10 : A.length -= 9
            }
            ,
            P.prototype.imulK = function(A) {
                A.words[A.length] = 0,
                A.words[A.length + 1] = 0,
                A.length += 2;
                for (var E = 0, C = 0; C < A.length; C++) {
                    var O = A.words[C] | 0;
                    E += O * 977,
                    A.words[C] = E & 67108863,
                    E = O * 64 + (E / 67108864 | 0)
                }
                return A.words[A.length - 1] === 0 && (A.length--,
                A.words[A.length - 1] === 0 && A.length--),
                A
            }
            ;
            function M() {
                B.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
            }
            s(M, B);
            function R() {
                B.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
            }
            s(R, B);
            function L() {
                B.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
            }
            s(L, B),
            L.prototype.imulK = function(A) {
                for (var E = 0, C = 0; C < A.length; C++) {
                    var O = (A.words[C] | 0) * 19 + E
                      , z = O & 67108863;
                    O >>>= 26,
                    A.words[C] = z,
                    E = O
                }
                return E !== 0 && (A.words[A.length++] = E),
                A
            }
            ,
            i._prime = function(A) {
                if (k[A])
                    return k[A];
                var E;
                if (A === "k256")
                    E = new P;
                else if (A === "p224")
                    E = new M;
                else if (A === "p192")
                    E = new R;
                else if (A === "p25519")
                    E = new L;
                else
                    throw new Error("Unknown prime " + A);
                return k[A] = E,
                E
            }
            ;
            function q(j) {
                if (typeof j == "string") {
                    var A = i._prime(j);
                    this.m = A.p,
                    this.prime = A
                } else
                    r(j.gtn(1), "modulus must be greater than 1"),
                    this.m = j,
                    this.prime = null
            }
            q.prototype._verify1 = function(A) {
                r(A.negative === 0, "red works only with positives"),
                r(A.red, "red works only with red numbers")
            }
            ,
            q.prototype._verify2 = function(A, E) {
                r((A.negative | E.negative) === 0, "red works only with positives"),
                r(A.red && A.red === E.red, "red works only with red numbers")
            }
            ,
            q.prototype.imod = function(A) {
                return this.prime ? this.prime.ireduce(A)._forceRed(this) : (d(A, A.umod(this.m)._forceRed(this)),
                A)
            }
            ,
            q.prototype.neg = function(A) {
                return A.isZero() ? A.clone() : this.m.sub(A)._forceRed(this)
            }
            ,
            q.prototype.add = function(A, E) {
                this._verify2(A, E);
                var C = A.add(E);
                return C.cmp(this.m) >= 0 && C.isub(this.m),
                C._forceRed(this)
            }
            ,
            q.prototype.iadd = function(A, E) {
                this._verify2(A, E);
                var C = A.iadd(E);
                return C.cmp(this.m) >= 0 && C.isub(this.m),
                C
            }
            ,
            q.prototype.sub = function(A, E) {
                this._verify2(A, E);
                var C = A.sub(E);
                return C.cmpn(0) < 0 && C.iadd(this.m),
                C._forceRed(this)
            }
            ,
            q.prototype.isub = function(A, E) {
                this._verify2(A, E);
                var C = A.isub(E);
                return C.cmpn(0) < 0 && C.iadd(this.m),
                C
            }
            ,
            q.prototype.shl = function(A, E) {
                return this._verify1(A),
                this.imod(A.ushln(E))
            }
            ,
            q.prototype.imul = function(A, E) {
                return this._verify2(A, E),
                this.imod(A.imul(E))
            }
            ,
            q.prototype.mul = function(A, E) {
                return this._verify2(A, E),
                this.imod(A.mul(E))
            }
            ,
            q.prototype.isqr = function(A) {
                return this.imul(A, A.clone())
            }
            ,
            q.prototype.sqr = function(A) {
                return this.mul(A, A)
            }
            ,
            q.prototype.sqrt = function(A) {
                if (A.isZero())
                    return A.clone();
                var E = this.m.andln(3);
                if (r(E % 2 === 1),
                E === 3) {
                    var C = this.m.add(new i(1)).iushrn(2);
                    return this.pow(A, C)
                }
                for (var O = this.m.subn(1), z = 0; !O.isZero() && O.andln(1) === 0; )
                    z++,
                    O.iushrn(1);
                r(!O.isZero());
                var G = new i(1).toRed(this)
                  , Y = G.redNeg()
                  , $ = this.m.subn(1).iushrn(1)
                  , D = this.m.bitLength();
                for (D = new i(2 * D * D).toRed(this); this.pow(D, $).cmp(Y) !== 0; )
                    D.redIAdd(Y);
                for (var U = this.pow(D, O), W = this.pow(A, O.addn(1).iushrn(1)), Q = this.pow(A, O), J = z; Q.cmp(G) !== 0; ) {
                    for (var ne = Q, ie = 0; ne.cmp(G) !== 0; ie++)
                        ne = ne.redSqr();
                    r(ie < J);
                    var ae = this.pow(U, new i(1).iushln(J - ie - 1));
                    W = W.redMul(ae),
                    U = ae.redSqr(),
                    Q = Q.redMul(U),
                    J = ie
                }
                return W
            }
            ,
            q.prototype.invm = function(A) {
                var E = A._invmp(this.m);
                return E.negative !== 0 ? (E.negative = 0,
                this.imod(E).redNeg()) : this.imod(E)
            }
            ,
            q.prototype.pow = function(A, E) {
                if (E.isZero())
                    return new i(1).toRed(this);
                if (E.cmpn(1) === 0)
                    return A.clone();
                var C = 4
                  , O = new Array(1 << C);
                O[0] = new i(1).toRed(this),
                O[1] = A;
                for (var z = 2; z < O.length; z++)
                    O[z] = this.mul(O[z - 1], A);
                var G = O[0]
                  , Y = 0
                  , $ = 0
                  , D = E.bitLength() % 26;
                for (D === 0 && (D = 26),
                z = E.length - 1; z >= 0; z--) {
                    for (var U = E.words[z], W = D - 1; W >= 0; W--) {
                        var Q = U >> W & 1;
                        if (G !== O[0] && (G = this.sqr(G)),
                        Q === 0 && Y === 0) {
                            $ = 0;
                            continue
                        }
                        Y <<= 1,
                        Y |= Q,
                        $++,
                        !($ !== C && (z !== 0 || W !== 0)) && (G = this.mul(G, O[Y]),
                        $ = 0,
                        Y = 0)
                    }
                    D = 26
                }
                return G
            }
            ,
            q.prototype.convertTo = function(A) {
                var E = A.umod(this.m);
                return E === A ? E.clone() : E
            }
            ,
            q.prototype.convertFrom = function(A) {
                var E = A.clone();
                return E.red = null,
                E
            }
            ,
            i.mont = function(A) {
                return new H(A)
            }
            ;
            function H(j) {
                q.call(this, j),
                this.shift = this.m.bitLength(),
                this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26),
                this.r = new i(1).iushln(this.shift),
                this.r2 = this.imod(this.r.sqr()),
                this.rinv = this.r._invmp(this.m),
                this.minv = this.rinv.mul(this.r).isubn(1).div(this.m),
                this.minv = this.minv.umod(this.r),
                this.minv = this.r.sub(this.minv)
            }
            s(H, q),
            H.prototype.convertTo = function(A) {
                return this.imod(A.ushln(this.shift))
            }
            ,
            H.prototype.convertFrom = function(A) {
                var E = this.imod(A.mul(this.rinv));
                return E.red = null,
                E
            }
            ,
            H.prototype.imul = function(A, E) {
                if (A.isZero() || E.isZero())
                    return A.words[0] = 0,
                    A.length = 1,
                    A;
                var C = A.imul(E)
                  , O = C.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m)
                  , z = C.isub(O).iushrn(this.shift)
                  , G = z;
                return z.cmp(this.m) >= 0 ? G = z.isub(this.m) : z.cmpn(0) < 0 && (G = z.iadd(this.m)),
                G._forceRed(this)
            }
            ,
            H.prototype.mul = function(A, E) {
                if (A.isZero() || E.isZero())
                    return new i(0)._forceRed(this);
                var C = A.mul(E)
                  , O = C.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m)
                  , z = C.isub(O).iushrn(this.shift)
                  , G = z;
                return z.cmp(this.m) >= 0 ? G = z.isub(this.m) : z.cmpn(0) < 0 && (G = z.iadd(this.m)),
                G._forceRed(this)
            }
            ,
            H.prototype.invm = function(A) {
                var E = this.imod(A._invmp(this.m).mul(this.r2));
                return E._forceRed(this)
            }
        }
        )(n, Xre)
    }
    )(zw)),
    zw.exports
}
var Qre = PU();
const DM = Fo(Qre);
var B1 = {
    exports: {}
};
var TM;
function jU() {
    return TM || (TM = 1,
    (function(n, e) {
        var t = Yv()
          , r = t.Buffer;
        function s(o, a) {
            for (var l in o)
                a[l] = o[l]
        }
        r.from && r.alloc && r.allocUnsafe && r.allocUnsafeSlow ? n.exports = t : (s(t, e),
        e.Buffer = i);
        function i(o, a, l) {
            return r(o, a, l)
        }
        i.prototype = Object.create(r.prototype),
        s(r, i),
        i.from = function(o, a, l) {
            if (typeof o == "number")
                throw new TypeError("Argument must not be a number");
            return r(o, a, l)
        }
        ,
        i.alloc = function(o, a, l) {
            if (typeof o != "number")
                throw new TypeError("Argument must be a number");
            var u = r(o);
            return a !== void 0 ? typeof l == "string" ? u.fill(a, l) : u.fill(a) : u.fill(0),
            u
        }
        ,
        i.allocUnsafe = function(o) {
            if (typeof o != "number")
                throw new TypeError("Argument must be a number");
            return r(o)
        }
        ,
        i.allocUnsafeSlow = function(o) {
            if (typeof o != "number")
                throw new TypeError("Argument must be a number");
            return t.SlowBuffer(o)
        }
    }
    )(B1, B1.exports)),
    B1.exports
}
var VS, IM;
function Zre() {
    if (IM)
        return VS;
    IM = 1;
    var n = jU().Buffer;
    function e(t) {
        if (t.length >= 255)
            throw new TypeError("Alphabet too long");
        for (var r = new Uint8Array(256), s = 0; s < r.length; s++)
            r[s] = 255;
        for (var i = 0; i < t.length; i++) {
            var o = t.charAt(i)
              , a = o.charCodeAt(0);
            if (r[a] !== 255)
                throw new TypeError(o + " is ambiguous");
            r[a] = i
        }
        var l = t.length
          , u = t.charAt(0)
          , d = Math.log(l) / Math.log(256)
          , h = Math.log(256) / Math.log(l);
        function p(b) {
            if ((Array.isArray(b) || b instanceof Uint8Array) && (b = n.from(b)),
            !n.isBuffer(b))
                throw new TypeError("Expected Buffer");
            if (b.length === 0)
                return "";
            for (var v = 0, S = 0, N = 0, _ = b.length; N !== _ && b[N] === 0; )
                N++,
                v++;
            for (var I = (_ - N) * h + 1 >>> 0, k = new Uint8Array(I); N !== _; ) {
                for (var B = b[N], P = 0, M = I - 1; (B !== 0 || P < S) && M !== -1; M--,
                P++)
                    B += 256 * k[M] >>> 0,
                    k[M] = B % l >>> 0,
                    B = B / l >>> 0;
                if (B !== 0)
                    throw new Error("Non-zero carry");
                S = P,
                N++
            }
            for (var R = I - S; R !== I && k[R] === 0; )
                R++;
            for (var L = u.repeat(v); R < I; ++R)
                L += t.charAt(k[R]);
            return L
        }
        function g(b) {
            if (typeof b != "string")
                throw new TypeError("Expected String");
            if (b.length === 0)
                return n.alloc(0);
            for (var v = 0, S = 0, N = 0; b[v] === u; )
                S++,
                v++;
            for (var _ = (b.length - v) * d + 1 >>> 0, I = new Uint8Array(_); v < b.length; ) {
                var k = b.charCodeAt(v);
                if (k > 255)
                    return;
                var B = r[k];
                if (B === 255)
                    return;
                for (var P = 0, M = _ - 1; (B !== 0 || P < N) && M !== -1; M--,
                P++)
                    B += l * I[M] >>> 0,
                    I[M] = B % 256 >>> 0,
                    B = B / 256 >>> 0;
                if (B !== 0)
                    throw new Error("Non-zero carry");
                N = P,
                v++
            }
            for (var R = _ - N; R !== _ && I[R] === 0; )
                R++;
            var L = n.allocUnsafe(S + (_ - R));
            L.fill(0, 0, S);
            for (var q = S; R !== _; )
                L[q++] = I[R++];
            return L
        }
        function w(b) {
            var v = g(b);
            if (v)
                return v;
            throw new Error("Non-base" + l + " character")
        }
        return {
            encode: p,
            decodeUnsafe: g,
            decode: w
        }
    }
    return VS = e,
    VS
}
var qS, MM;
function Jre() {
    if (MM)
        return qS;
    MM = 1;
    var n = Zre()
      , e = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    return qS = n(e),
    qS
}
var ese = Jre();
const ws = Fo(ese)
  , BM = Z8;
var Sn = {}, GS, RM;
function tse() {
    if (RM)
        return GS;
    RM = 1;
    var n = jU().Buffer;
    function e(t) {
        if (t.length >= 255)
            throw new TypeError("Alphabet too long");
        for (var r = new Uint8Array(256), s = 0; s < r.length; s++)
            r[s] = 255;
        for (var i = 0; i < t.length; i++) {
            var o = t.charAt(i)
              , a = o.charCodeAt(0);
            if (r[a] !== 255)
                throw new TypeError(o + " is ambiguous");
            r[a] = i
        }
        var l = t.length
          , u = t.charAt(0)
          , d = Math.log(l) / Math.log(256)
          , h = Math.log(256) / Math.log(l);
        function p(b) {
            if ((Array.isArray(b) || b instanceof Uint8Array) && (b = n.from(b)),
            !n.isBuffer(b))
                throw new TypeError("Expected Buffer");
            if (b.length === 0)
                return "";
            for (var v = 0, S = 0, N = 0, _ = b.length; N !== _ && b[N] === 0; )
                N++,
                v++;
            for (var I = (_ - N) * h + 1 >>> 0, k = new Uint8Array(I); N !== _; ) {
                for (var B = b[N], P = 0, M = I - 1; (B !== 0 || P < S) && M !== -1; M--,
                P++)
                    B += 256 * k[M] >>> 0,
                    k[M] = B % l >>> 0,
                    B = B / l >>> 0;
                if (B !== 0)
                    throw new Error("Non-zero carry");
                S = P,
                N++
            }
            for (var R = I - S; R !== I && k[R] === 0; )
                R++;
            for (var L = u.repeat(v); R < I; ++R)
                L += t.charAt(k[R]);
            return L
        }
        function g(b) {
            if (typeof b != "string")
                throw new TypeError("Expected String");
            if (b.length === 0)
                return n.alloc(0);
            for (var v = 0, S = 0, N = 0; b[v] === u; )
                S++,
                v++;
            for (var _ = (b.length - v) * d + 1 >>> 0, I = new Uint8Array(_); v < b.length; ) {
                var k = b.charCodeAt(v);
                if (k > 255)
                    return;
                var B = r[k];
                if (B === 255)
                    return;
                for (var P = 0, M = _ - 1; (B !== 0 || P < N) && M !== -1; M--,
                P++)
                    B += l * I[M] >>> 0,
                    I[M] = B % 256 >>> 0,
                    B = B / 256 >>> 0;
                if (B !== 0)
                    throw new Error("Non-zero carry");
                N = P,
                v++
            }
            for (var R = _ - N; R !== _ && I[R] === 0; )
                R++;
            var L = n.allocUnsafe(S + (_ - R));
            L.fill(0, 0, S);
            for (var q = S; R !== _; )
                L[q++] = I[R++];
            return L
        }
        function w(b) {
            var v = g(b);
            if (v)
                return v;
            throw new Error("Non-base" + l + " character")
        }
        return {
            encode: p,
            decodeUnsafe: g,
            decode: w
        }
    }
    return GS = e,
    GS
}
var WS, OM;
function nse() {
    if (OM)
        return WS;
    OM = 1;
    var n = tse()
      , e = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    return WS = n(e),
    WS
}
function ic(n, e, t) {
    return e <= n && n <= t
}
function Zv(n) {
    if (n === void 0)
        return {};
    if (n === Object(n))
        return n;
    throw TypeError("Could not convert argument to dictionary")
}
function rse(n) {
    for (var e = String(n), t = e.length, r = 0, s = []; r < t; ) {
        var i = e.charCodeAt(r);
        if (i < 55296 || i > 57343)
            s.push(i);
        else if (56320 <= i && i <= 57343)
            s.push(65533);
        else if (55296 <= i && i <= 56319)
            if (r === t - 1)
                s.push(65533);
            else {
                var o = n.charCodeAt(r + 1);
                if (56320 <= o && o <= 57343) {
                    var a = i & 1023
                      , l = o & 1023;
                    s.push(65536 + (a << 10) + l),
                    r += 1
                } else
                    s.push(65533)
            }
        r += 1
    }
    return s
}
function sse(n) {
    for (var e = "", t = 0; t < n.length; ++t) {
        var r = n[t];
        r <= 65535 ? e += String.fromCharCode(r) : (r -= 65536,
        e += String.fromCharCode((r >> 10) + 55296, (r & 1023) + 56320))
    }
    return e
}
var E2 = -1;
function r_(n) {
    this.tokens = [].slice.call(n)
}
r_.prototype = {
    endOfStream: function() {
        return !this.tokens.length
    },
    read: function() {
        return this.tokens.length ? this.tokens.shift() : E2
    },
    prepend: function(n) {
        if (Array.isArray(n))
            for (var e = n; e.length; )
                this.tokens.unshift(e.pop());
        else
            this.tokens.unshift(n)
    },
    push: function(n) {
        if (Array.isArray(n))
            for (var e = n; e.length; )
                this.tokens.push(e.shift());
        else
            this.tokens.push(n)
    }
};
var n0 = -1;
function YS(n, e) {
    if (n)
        throw TypeError("Decoder error");
    return e || 65533
}
var S2 = "utf-8";
function A2(n, e) {
    if (!(this instanceof A2))
        return new A2(n,e);
    if (n = n !== void 0 ? String(n).toLowerCase() : S2,
    n !== S2)
        throw new Error("Encoding not supported. Only utf-8 is supported");
    e = Zv(e),
    this._streaming = !1,
    this._BOMseen = !1,
    this._decoder = null,
    this._fatal = !!e.fatal,
    this._ignoreBOM = !!e.ignoreBOM,
    Object.defineProperty(this, "encoding", {
        value: "utf-8"
    }),
    Object.defineProperty(this, "fatal", {
        value: this._fatal
    }),
    Object.defineProperty(this, "ignoreBOM", {
        value: this._ignoreBOM
    })
}
A2.prototype = {
    decode: function(e, t) {
        var r;
        typeof e == "object" && e instanceof ArrayBuffer ? r = new Uint8Array(e) : typeof e == "object" && "buffer"in e && e.buffer instanceof ArrayBuffer ? r = new Uint8Array(e.buffer,e.byteOffset,e.byteLength) : r = new Uint8Array(0),
        t = Zv(t),
        this._streaming || (this._decoder = new ise({
            fatal: this._fatal
        }),
        this._BOMseen = !1),
        this._streaming = !!t.stream;
        for (var s = new r_(r), i = [], o; !s.endOfStream() && (o = this._decoder.handler(s, s.read()),
        o !== n0); )
            o !== null && (Array.isArray(o) ? i.push.apply(i, o) : i.push(o));
        if (!this._streaming) {
            do {
                if (o = this._decoder.handler(s, s.read()),
                o === n0)
                    break;
                o !== null && (Array.isArray(o) ? i.push.apply(i, o) : i.push(o))
            } while (!s.endOfStream());
            this._decoder = null
        }
        return i.length && ["utf-8"].indexOf(this.encoding) !== -1 && !this._ignoreBOM && !this._BOMseen && (i[0] === 65279 ? (this._BOMseen = !0,
        i.shift()) : this._BOMseen = !0),
        sse(i)
    }
};
function C2(n, e) {
    if (!(this instanceof C2))
        return new C2(n,e);
    if (n = n !== void 0 ? String(n).toLowerCase() : S2,
    n !== S2)
        throw new Error("Encoding not supported. Only utf-8 is supported");
    e = Zv(e),
    this._streaming = !1,
    this._encoder = null,
    this._options = {
        fatal: !!e.fatal
    },
    Object.defineProperty(this, "encoding", {
        value: "utf-8"
    })
}
C2.prototype = {
    encode: function(e, t) {
        e = e ? String(e) : "",
        t = Zv(t),
        this._streaming || (this._encoder = new ose(this._options)),
        this._streaming = !!t.stream;
        for (var r = [], s = new r_(rse(e)), i; !s.endOfStream() && (i = this._encoder.handler(s, s.read()),
        i !== n0); )
            Array.isArray(i) ? r.push.apply(r, i) : r.push(i);
        if (!this._streaming) {
            for (; i = this._encoder.handler(s, s.read()),
            i !== n0; )
                Array.isArray(i) ? r.push.apply(r, i) : r.push(i);
            this._encoder = null
        }
        return new Uint8Array(r)
    }
};
function ise(n) {
    var e = n.fatal
      , t = 0
      , r = 0
      , s = 0
      , i = 128
      , o = 191;
    this.handler = function(a, l) {
        if (l === E2 && s !== 0)
            return s = 0,
            YS(e);
        if (l === E2)
            return n0;
        if (s === 0) {
            if (ic(l, 0, 127))
                return l;
            if (ic(l, 194, 223))
                s = 1,
                t = l - 192;
            else if (ic(l, 224, 239))
                l === 224 && (i = 160),
                l === 237 && (o = 159),
                s = 2,
                t = l - 224;
            else if (ic(l, 240, 244))
                l === 240 && (i = 144),
                l === 244 && (o = 143),
                s = 3,
                t = l - 240;
            else
                return YS(e);
            return t = t << 6 * s,
            null
        }
        if (!ic(l, i, o))
            return t = s = r = 0,
            i = 128,
            o = 191,
            a.prepend(l),
            YS(e);
        if (i = 128,
        o = 191,
        r += 1,
        t += l - 128 << 6 * (s - r),
        r !== s)
            return null;
        var u = t;
        return t = s = r = 0,
        u
    }
}
function ose(n) {
    n.fatal,
    this.handler = function(e, t) {
        if (t === E2)
            return n0;
        if (ic(t, 0, 127))
            return t;
        var r, s;
        ic(t, 128, 2047) ? (r = 1,
        s = 192) : ic(t, 2048, 65535) ? (r = 2,
        s = 224) : ic(t, 65536, 1114111) && (r = 3,
        s = 240);
        for (var i = [(t >> 6 * r) + s]; r > 0; ) {
            var o = t >> 6 * (r - 1);
            i.push(128 | o & 63),
            r -= 1
        }
        return i
    }
}
const ase = Object.freeze(Object.defineProperty({
    __proto__: null,
    TextDecoder: A2,
    TextEncoder: C2
}, Symbol.toStringTag, {
    value: "Module"
}))
  , lse = S8(ase);
var PM;
function cse() {
    if (PM)
        return Sn;
    PM = 1;
    var n = Sn && Sn.__createBinding || (Object.create ? (function(R, L, q, H) {
        H === void 0 && (H = q),
        Object.defineProperty(R, H, {
            enumerable: !0,
            get: function() {
                return L[q]
            }
        })
    }
    ) : (function(R, L, q, H) {
        H === void 0 && (H = q),
        R[H] = L[q]
    }
    ))
      , e = Sn && Sn.__setModuleDefault || (Object.create ? (function(R, L) {
        Object.defineProperty(R, "default", {
            enumerable: !0,
            value: L
        })
    }
    ) : function(R, L) {
        R.default = L
    }
    )
      , t = Sn && Sn.__decorate || function(R, L, q, H) {
        var j = arguments.length, A = j < 3 ? L : H === null ? H = Object.getOwnPropertyDescriptor(L, q) : H, E;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
            A = Reflect.decorate(R, L, q, H);
        else
            for (var C = R.length - 1; C >= 0; C--)
                (E = R[C]) && (A = (j < 3 ? E(A) : j > 3 ? E(L, q, A) : E(L, q)) || A);
        return j > 3 && A && Object.defineProperty(L, q, A),
        A
    }
      , r = Sn && Sn.__importStar || function(R) {
        if (R && R.__esModule)
            return R;
        var L = {};
        if (R != null)
            for (var q in R)
                q !== "default" && Object.hasOwnProperty.call(R, q) && n(L, R, q);
        return e(L, R),
        L
    }
      , s = Sn && Sn.__importDefault || function(R) {
        return R && R.__esModule ? R : {
            default: R
        }
    }
    ;
    Object.defineProperty(Sn, "__esModule", {
        value: !0
    }),
    Sn.deserializeUnchecked = Sn.deserialize = Sn.serialize = Sn.BinaryReader = Sn.BinaryWriter = Sn.BorshError = Sn.baseDecode = Sn.baseEncode = void 0;
    const i = s(PU())
      , o = s(nse())
      , a = r(lse)
      , l = typeof TextDecoder != "function" ? a.TextDecoder : TextDecoder
      , u = new l("utf-8",{
        fatal: !0
    });
    function d(R) {
        return typeof R == "string" && (R = Buffer.from(R, "utf8")),
        o.default.encode(Buffer.from(R))
    }
    Sn.baseEncode = d;
    function h(R) {
        return Buffer.from(o.default.decode(R))
    }
    Sn.baseDecode = h;
    const p = 1024;
    class g extends Error {
        constructor(L) {
            super(L),
            this.fieldPath = [],
            this.originalMessage = L
        }
        addToFieldPath(L) {
            this.fieldPath.splice(0, 0, L),
            this.message = this.originalMessage + ": " + this.fieldPath.join(".")
        }
    }
    Sn.BorshError = g;
    class w {
        constructor() {
            this.buf = Buffer.alloc(p),
            this.length = 0
        }
        maybeResize() {
            this.buf.length < 16 + this.length && (this.buf = Buffer.concat([this.buf, Buffer.alloc(p)]))
        }
        writeU8(L) {
            this.maybeResize(),
            this.buf.writeUInt8(L, this.length),
            this.length += 1
        }
        writeU16(L) {
            this.maybeResize(),
            this.buf.writeUInt16LE(L, this.length),
            this.length += 2
        }
        writeU32(L) {
            this.maybeResize(),
            this.buf.writeUInt32LE(L, this.length),
            this.length += 4
        }
        writeU64(L) {
            this.maybeResize(),
            this.writeBuffer(Buffer.from(new i.default(L).toArray("le", 8)))
        }
        writeU128(L) {
            this.maybeResize(),
            this.writeBuffer(Buffer.from(new i.default(L).toArray("le", 16)))
        }
        writeU256(L) {
            this.maybeResize(),
            this.writeBuffer(Buffer.from(new i.default(L).toArray("le", 32)))
        }
        writeU512(L) {
            this.maybeResize(),
            this.writeBuffer(Buffer.from(new i.default(L).toArray("le", 64)))
        }
        writeBuffer(L) {
            this.buf = Buffer.concat([Buffer.from(this.buf.subarray(0, this.length)), L, Buffer.alloc(p)]),
            this.length += L.length
        }
        writeString(L) {
            this.maybeResize();
            const q = Buffer.from(L, "utf8");
            this.writeU32(q.length),
            this.writeBuffer(q)
        }
        writeFixedArray(L) {
            this.writeBuffer(Buffer.from(L))
        }
        writeArray(L, q) {
            this.maybeResize(),
            this.writeU32(L.length);
            for (const H of L)
                this.maybeResize(),
                q(H)
        }
        toArray() {
            return this.buf.subarray(0, this.length)
        }
    }
    Sn.BinaryWriter = w;
    function b(R, L, q) {
        const H = q.value;
        q.value = function(...j) {
            try {
                return H.apply(this, j)
            } catch (A) {
                if (A instanceof RangeError) {
                    const E = A.code;
                    if (["ERR_BUFFER_OUT_OF_BOUNDS", "ERR_OUT_OF_RANGE"].indexOf(E) >= 0)
                        throw new g("Reached the end of buffer when deserializing")
                }
                throw A
            }
        }
    }
    class v {
        constructor(L) {
            this.buf = L,
            this.offset = 0
        }
        readU8() {
            const L = this.buf.readUInt8(this.offset);
            return this.offset += 1,
            L
        }
        readU16() {
            const L = this.buf.readUInt16LE(this.offset);
            return this.offset += 2,
            L
        }
        readU32() {
            const L = this.buf.readUInt32LE(this.offset);
            return this.offset += 4,
            L
        }
        readU64() {
            const L = this.readBuffer(8);
            return new i.default(L,"le")
        }
        readU128() {
            const L = this.readBuffer(16);
            return new i.default(L,"le")
        }
        readU256() {
            const L = this.readBuffer(32);
            return new i.default(L,"le")
        }
        readU512() {
            const L = this.readBuffer(64);
            return new i.default(L,"le")
        }
        readBuffer(L) {
            if (this.offset + L > this.buf.length)
                throw new g(`Expected buffer length ${L} isn't within bounds`);
            const q = this.buf.slice(this.offset, this.offset + L);
            return this.offset += L,
            q
        }
        readString() {
            const L = this.readU32()
              , q = this.readBuffer(L);
            try {
                return u.decode(q)
            } catch (H) {
                throw new g(`Error decoding UTF-8 string: ${H}`)
            }
        }
        readFixedArray(L) {
            return new Uint8Array(this.readBuffer(L))
        }
        readArray(L) {
            const q = this.readU32()
              , H = Array();
            for (let j = 0; j < q; ++j)
                H.push(L());
            return H
        }
    }
    t([b], v.prototype, "readU8", null),
    t([b], v.prototype, "readU16", null),
    t([b], v.prototype, "readU32", null),
    t([b], v.prototype, "readU64", null),
    t([b], v.prototype, "readU128", null),
    t([b], v.prototype, "readU256", null),
    t([b], v.prototype, "readU512", null),
    t([b], v.prototype, "readString", null),
    t([b], v.prototype, "readFixedArray", null),
    t([b], v.prototype, "readArray", null),
    Sn.BinaryReader = v;
    function S(R) {
        return R.charAt(0).toUpperCase() + R.slice(1)
    }
    function N(R, L, q, H, j) {
        try {
            if (typeof H == "string")
                j[`write${S(H)}`](q);
            else if (H instanceof Array)
                if (typeof H[0] == "number") {
                    if (q.length !== H[0])
                        throw new g(`Expecting byte array of length ${H[0]}, but got ${q.length} bytes`);
                    j.writeFixedArray(q)
                } else if (H.length === 2 && typeof H[1] == "number") {
                    if (q.length !== H[1])
                        throw new g(`Expecting byte array of length ${H[1]}, but got ${q.length} bytes`);
                    for (let A = 0; A < H[1]; A++)
                        N(R, null, q[A], H[0], j)
                } else
                    j.writeArray(q, A => {
                        N(R, L, A, H[0], j)
                    }
                    );
            else if (H.kind !== void 0)
                switch (H.kind) {
                case "option":
                    {
                        q == null ? j.writeU8(0) : (j.writeU8(1),
                        N(R, L, q, H.type, j));
                        break
                    }
                case "map":
                    {
                        j.writeU32(q.size),
                        q.forEach( (A, E) => {
                            N(R, L, E, H.key, j),
                            N(R, L, A, H.value, j)
                        }
                        );
                        break
                    }
                default:
                    throw new g(`FieldType ${H} unrecognized`)
                }
            else
                _(R, q, j)
        } catch (A) {
            throw A instanceof g && A.addToFieldPath(L),
            A
        }
    }
    function _(R, L, q) {
        if (typeof L.borshSerialize == "function") {
            L.borshSerialize(q);
            return
        }
        const H = R.get(L.constructor);
        if (!H)
            throw new g(`Class ${L.constructor.name} is missing in schema`);
        if (H.kind === "struct")
            H.fields.map( ([j,A]) => {
                N(R, j, L[j], A, q)
            }
            );
        else if (H.kind === "enum") {
            const j = L[H.field];
            for (let A = 0; A < H.values.length; ++A) {
                const [E,C] = H.values[A];
                if (E === j) {
                    q.writeU8(A),
                    N(R, E, L[E], C, q);
                    break
                }
            }
        } else
            throw new g(`Unexpected schema kind: ${H.kind} for ${L.constructor.name}`)
    }
    function I(R, L, q=w) {
        const H = new q;
        return _(R, L, H),
        H.toArray()
    }
    Sn.serialize = I;
    function k(R, L, q, H) {
        try {
            if (typeof q == "string")
                return H[`read${S(q)}`]();
            if (q instanceof Array) {
                if (typeof q[0] == "number")
                    return H.readFixedArray(q[0]);
                if (typeof q[1] == "number") {
                    const j = [];
                    for (let A = 0; A < q[1]; A++)
                        j.push(k(R, null, q[0], H));
                    return j
                } else
                    return H.readArray( () => k(R, L, q[0], H))
            }
            if (q.kind === "option")
                return H.readU8() ? k(R, L, q.type, H) : void 0;
            if (q.kind === "map") {
                let j = new Map;
                const A = H.readU32();
                for (let E = 0; E < A; E++) {
                    const C = k(R, L, q.key, H)
                      , O = k(R, L, q.value, H);
                    j.set(C, O)
                }
                return j
            }
            return B(R, q, H)
        } catch (j) {
            throw j instanceof g && j.addToFieldPath(L),
            j
        }
    }
    function B(R, L, q) {
        if (typeof L.borshDeserialize == "function")
            return L.borshDeserialize(q);
        const H = R.get(L);
        if (!H)
            throw new g(`Class ${L.name} is missing in schema`);
        if (H.kind === "struct") {
            const j = {};
            for (const [A,E] of R.get(L).fields)
                j[A] = k(R, A, E, q);
            return new L(j)
        }
        if (H.kind === "enum") {
            const j = q.readU8();
            if (j >= H.values.length)
                throw new g(`Enum index: ${j} is out of range`);
            const [A,E] = H.values[j]
              , C = k(R, A, E, q);
            return new L({
                [A]: C
            })
        }
        throw new g(`Unexpected schema kind: ${H.kind} for ${L.constructor.name}`)
    }
    function P(R, L, q, H=v) {
        const j = new H(q)
          , A = B(R, L, j);
        if (j.offset < q.length)
            throw new g(`Unexpected ${q.length - j.offset} bytes after deserialized data`);
        return A
    }
    Sn.deserialize = P;
    function M(R, L, q, H=v) {
        const j = new H(q);
        return B(R, L, j)
    }
    return Sn.deserializeUnchecked = M,
    Sn
}
var KS = cse(), Ae = {}, jM;
function use() {
    if (jM)
        return Ae;
    jM = 1,
    Object.defineProperty(Ae, "__esModule", {
        value: !0
    }),
    Ae.s16 = Ae.s8 = Ae.nu64be = Ae.u48be = Ae.u40be = Ae.u32be = Ae.u24be = Ae.u16be = Ae.nu64 = Ae.u48 = Ae.u40 = Ae.u32 = Ae.u24 = Ae.u16 = Ae.u8 = Ae.offset = Ae.greedy = Ae.Constant = Ae.UTF8 = Ae.CString = Ae.Blob = Ae.Boolean = Ae.BitField = Ae.BitStructure = Ae.VariantLayout = Ae.Union = Ae.UnionLayoutDiscriminator = Ae.UnionDiscriminator = Ae.Structure = Ae.Sequence = Ae.DoubleBE = Ae.Double = Ae.FloatBE = Ae.Float = Ae.NearInt64BE = Ae.NearInt64 = Ae.NearUInt64BE = Ae.NearUInt64 = Ae.IntBE = Ae.Int = Ae.UIntBE = Ae.UInt = Ae.OffsetLayout = Ae.GreedyCount = Ae.ExternalLayout = Ae.bindConstructorLayout = Ae.nameWithProperty = Ae.Layout = Ae.uint8ArrayToBuffer = Ae.checkUint8Array = void 0,
    Ae.constant = Ae.utf8 = Ae.cstr = Ae.blob = Ae.unionLayoutDiscriminator = Ae.union = Ae.seq = Ae.bits = Ae.struct = Ae.f64be = Ae.f64 = Ae.f32be = Ae.f32 = Ae.ns64be = Ae.s48be = Ae.s40be = Ae.s32be = Ae.s24be = Ae.s16be = Ae.ns64 = Ae.s48 = Ae.s40 = Ae.s32 = Ae.s24 = void 0;
    const n = Yv();
    function e(D) {
        if (!(D instanceof Uint8Array))
            throw new TypeError("b must be a Uint8Array")
    }
    Ae.checkUint8Array = e;
    function t(D) {
        return e(D),
        n.Buffer.from(D.buffer, D.byteOffset, D.length)
    }
    Ae.uint8ArrayToBuffer = t;
    class r {
        constructor(U, W) {
            if (!Number.isInteger(U))
                throw new TypeError("span must be an integer");
            this.span = U,
            this.property = W
        }
        makeDestinationObject() {
            return {}
        }
        getSpan(U, W) {
            if (0 > this.span)
                throw new RangeError("indeterminate span");
            return this.span
        }
        replicate(U) {
            const W = Object.create(this.constructor.prototype);
            return Object.assign(W, this),
            W.property = U,
            W
        }
        fromArray(U) {}
    }
    Ae.Layout = r;
    function s(D, U) {
        return U.property ? D + "[" + U.property + "]" : D
    }
    Ae.nameWithProperty = s;
    function i(D, U) {
        if (typeof D != "function")
            throw new TypeError("Class must be constructor");
        if (Object.prototype.hasOwnProperty.call(D, "layout_"))
            throw new Error("Class is already bound to a layout");
        if (!(U && U instanceof r))
            throw new TypeError("layout must be a Layout");
        if (Object.prototype.hasOwnProperty.call(U, "boundConstructor_"))
            throw new Error("layout is already bound to a constructor");
        D.layout_ = U,
        U.boundConstructor_ = D,
        U.makeDestinationObject = ( () => new D),
        Object.defineProperty(D.prototype, "encode", {
            value(W, Q) {
                return U.encode(this, W, Q)
            },
            writable: !0
        }),
        Object.defineProperty(D, "decode", {
            value(W, Q) {
                return U.decode(W, Q)
            },
            writable: !0
        })
    }
    Ae.bindConstructorLayout = i;
    class o extends r {
        isCount() {
            throw new Error("ExternalLayout is abstract")
        }
    }
    Ae.ExternalLayout = o;
    class a extends o {
        constructor(U=1, W) {
            if (!Number.isInteger(U) || 0 >= U)
                throw new TypeError("elementSpan must be a (positive) integer");
            super(-1, W),
            this.elementSpan = U
        }
        isCount() {
            return !0
        }
        decode(U, W=0) {
            e(U);
            const Q = U.length - W;
            return Math.floor(Q / this.elementSpan)
        }
        encode(U, W, Q) {
            return 0
        }
    }
    Ae.GreedyCount = a;
    class l extends o {
        constructor(U, W=0, Q) {
            if (!(U instanceof r))
                throw new TypeError("layout must be a Layout");
            if (!Number.isInteger(W))
                throw new TypeError("offset must be integer or undefined");
            super(U.span, Q || U.property),
            this.layout = U,
            this.offset = W
        }
        isCount() {
            return this.layout instanceof u || this.layout instanceof d
        }
        decode(U, W=0) {
            return this.layout.decode(U, W + this.offset)
        }
        encode(U, W, Q=0) {
            return this.layout.encode(U, W, Q + this.offset)
        }
    }
    Ae.OffsetLayout = l;
    class u extends r {
        constructor(U, W) {
            if (super(U, W),
            6 < this.span)
                throw new RangeError("span must not exceed 6 bytes")
        }
        decode(U, W=0) {
            return t(U).readUIntLE(W, this.span)
        }
        encode(U, W, Q=0) {
            return t(W).writeUIntLE(U, Q, this.span),
            this.span
        }
    }
    Ae.UInt = u;
    class d extends r {
        constructor(U, W) {
            if (super(U, W),
            6 < this.span)
                throw new RangeError("span must not exceed 6 bytes")
        }
        decode(U, W=0) {
            return t(U).readUIntBE(W, this.span)
        }
        encode(U, W, Q=0) {
            return t(W).writeUIntBE(U, Q, this.span),
            this.span
        }
    }
    Ae.UIntBE = d;
    class h extends r {
        constructor(U, W) {
            if (super(U, W),
            6 < this.span)
                throw new RangeError("span must not exceed 6 bytes")
        }
        decode(U, W=0) {
            return t(U).readIntLE(W, this.span)
        }
        encode(U, W, Q=0) {
            return t(W).writeIntLE(U, Q, this.span),
            this.span
        }
    }
    Ae.Int = h;
    class p extends r {
        constructor(U, W) {
            if (super(U, W),
            6 < this.span)
                throw new RangeError("span must not exceed 6 bytes")
        }
        decode(U, W=0) {
            return t(U).readIntBE(W, this.span)
        }
        encode(U, W, Q=0) {
            return t(W).writeIntBE(U, Q, this.span),
            this.span
        }
    }
    Ae.IntBE = p;
    const g = Math.pow(2, 32);
    function w(D) {
        const U = Math.floor(D / g)
          , W = D - U * g;
        return {
            hi32: U,
            lo32: W
        }
    }
    function b(D, U) {
        return D * g + U
    }
    class v extends r {
        constructor(U) {
            super(8, U)
        }
        decode(U, W=0) {
            const Q = t(U)
              , J = Q.readUInt32LE(W)
              , ne = Q.readUInt32LE(W + 4);
            return b(ne, J)
        }
        encode(U, W, Q=0) {
            const J = w(U)
              , ne = t(W);
            return ne.writeUInt32LE(J.lo32, Q),
            ne.writeUInt32LE(J.hi32, Q + 4),
            8
        }
    }
    Ae.NearUInt64 = v;
    class S extends r {
        constructor(U) {
            super(8, U)
        }
        decode(U, W=0) {
            const Q = t(U)
              , J = Q.readUInt32BE(W)
              , ne = Q.readUInt32BE(W + 4);
            return b(J, ne)
        }
        encode(U, W, Q=0) {
            const J = w(U)
              , ne = t(W);
            return ne.writeUInt32BE(J.hi32, Q),
            ne.writeUInt32BE(J.lo32, Q + 4),
            8
        }
    }
    Ae.NearUInt64BE = S;
    class N extends r {
        constructor(U) {
            super(8, U)
        }
        decode(U, W=0) {
            const Q = t(U)
              , J = Q.readUInt32LE(W)
              , ne = Q.readInt32LE(W + 4);
            return b(ne, J)
        }
        encode(U, W, Q=0) {
            const J = w(U)
              , ne = t(W);
            return ne.writeUInt32LE(J.lo32, Q),
            ne.writeInt32LE(J.hi32, Q + 4),
            8
        }
    }
    Ae.NearInt64 = N;
    class _ extends r {
        constructor(U) {
            super(8, U)
        }
        decode(U, W=0) {
            const Q = t(U)
              , J = Q.readInt32BE(W)
              , ne = Q.readUInt32BE(W + 4);
            return b(J, ne)
        }
        encode(U, W, Q=0) {
            const J = w(U)
              , ne = t(W);
            return ne.writeInt32BE(J.hi32, Q),
            ne.writeUInt32BE(J.lo32, Q + 4),
            8
        }
    }
    Ae.NearInt64BE = _;
    class I extends r {
        constructor(U) {
            super(4, U)
        }
        decode(U, W=0) {
            return t(U).readFloatLE(W)
        }
        encode(U, W, Q=0) {
            return t(W).writeFloatLE(U, Q),
            4
        }
    }
    Ae.Float = I;
    class k extends r {
        constructor(U) {
            super(4, U)
        }
        decode(U, W=0) {
            return t(U).readFloatBE(W)
        }
        encode(U, W, Q=0) {
            return t(W).writeFloatBE(U, Q),
            4
        }
    }
    Ae.FloatBE = k;
    class B extends r {
        constructor(U) {
            super(8, U)
        }
        decode(U, W=0) {
            return t(U).readDoubleLE(W)
        }
        encode(U, W, Q=0) {
            return t(W).writeDoubleLE(U, Q),
            8
        }
    }
    Ae.Double = B;
    class P extends r {
        constructor(U) {
            super(8, U)
        }
        decode(U, W=0) {
            return t(U).readDoubleBE(W)
        }
        encode(U, W, Q=0) {
            return t(W).writeDoubleBE(U, Q),
            8
        }
    }
    Ae.DoubleBE = P;
    class M extends r {
        constructor(U, W, Q) {
            if (!(U instanceof r))
                throw new TypeError("elementLayout must be a Layout");
            if (!(W instanceof o && W.isCount() || Number.isInteger(W) && 0 <= W))
                throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
            let J = -1;
            !(W instanceof o) && 0 < U.span && (J = W * U.span),
            super(J, Q),
            this.elementLayout = U,
            this.count = W
        }
        getSpan(U, W=0) {
            if (0 <= this.span)
                return this.span;
            let Q = 0
              , J = this.count;
            if (J instanceof o && (J = J.decode(U, W)),
            0 < this.elementLayout.span)
                Q = J * this.elementLayout.span;
            else {
                let ne = 0;
                for (; ne < J; )
                    Q += this.elementLayout.getSpan(U, W + Q),
                    ++ne
            }
            return Q
        }
        decode(U, W=0) {
            const Q = [];
            let J = 0
              , ne = this.count;
            for (ne instanceof o && (ne = ne.decode(U, W)); J < ne; )
                Q.push(this.elementLayout.decode(U, W)),
                W += this.elementLayout.getSpan(U, W),
                J += 1;
            return Q
        }
        encode(U, W, Q=0) {
            const J = this.elementLayout
              , ne = U.reduce( (ie, ae) => ie + J.encode(ae, W, Q + ie), 0);
            return this.count instanceof o && this.count.encode(U.length, W, Q),
            ne
        }
    }
    Ae.Sequence = M;
    class R extends r {
        constructor(U, W, Q) {
            if (!(Array.isArray(U) && U.reduce( (ne, ie) => ne && ie instanceof r, !0)))
                throw new TypeError("fields must be array of Layout instances");
            typeof W == "boolean" && Q === void 0 && (Q = W,
            W = void 0);
            for (const ne of U)
                if (0 > ne.span && ne.property === void 0)
                    throw new Error("fields cannot contain unnamed variable-length layout");
            let J = -1;
            try {
                J = U.reduce( (ne, ie) => ne + ie.getSpan(), 0)
            } catch {}
            super(J, W),
            this.fields = U,
            this.decodePrefixes = !!Q
        }
        getSpan(U, W=0) {
            if (0 <= this.span)
                return this.span;
            let Q = 0;
            try {
                Q = this.fields.reduce( (J, ne) => {
                    const ie = ne.getSpan(U, W);
                    return W += ie,
                    J + ie
                }
                , 0)
            } catch {
                throw new RangeError("indeterminate span")
            }
            return Q
        }
        decode(U, W=0) {
            e(U);
            const Q = this.makeDestinationObject();
            for (const J of this.fields)
                if (J.property !== void 0 && (Q[J.property] = J.decode(U, W)),
                W += J.getSpan(U, W),
                this.decodePrefixes && U.length === W)
                    break;
            return Q
        }
        encode(U, W, Q=0) {
            const J = Q;
            let ne = 0
              , ie = 0;
            for (const ae of this.fields) {
                let xe = ae.span;
                if (ie = 0 < xe ? xe : 0,
                ae.property !== void 0) {
                    const ue = U[ae.property];
                    ue !== void 0 && (ie = ae.encode(ue, W, Q),
                    0 > xe && (xe = ae.getSpan(W, Q)))
                }
                ne = Q,
                Q += xe
            }
            return ne + ie - J
        }
        fromArray(U) {
            const W = this.makeDestinationObject();
            for (const Q of this.fields)
                Q.property !== void 0 && 0 < U.length && (W[Q.property] = U.shift());
            return W
        }
        layoutFor(U) {
            if (typeof U != "string")
                throw new TypeError("property must be string");
            for (const W of this.fields)
                if (W.property === U)
                    return W
        }
        offsetOf(U) {
            if (typeof U != "string")
                throw new TypeError("property must be string");
            let W = 0;
            for (const Q of this.fields) {
                if (Q.property === U)
                    return W;
                0 > Q.span ? W = -1 : 0 <= W && (W += Q.span)
            }
        }
    }
    Ae.Structure = R;
    class L {
        constructor(U) {
            this.property = U
        }
        decode(U, W) {
            throw new Error("UnionDiscriminator is abstract")
        }
        encode(U, W, Q) {
            throw new Error("UnionDiscriminator is abstract")
        }
    }
    Ae.UnionDiscriminator = L;
    class q extends L {
        constructor(U, W) {
            if (!(U instanceof o && U.isCount()))
                throw new TypeError("layout must be an unsigned integer ExternalLayout");
            super(W || U.property || "variant"),
            this.layout = U
        }
        decode(U, W) {
            return this.layout.decode(U, W)
        }
        encode(U, W, Q) {
            return this.layout.encode(U, W, Q)
        }
    }
    Ae.UnionLayoutDiscriminator = q;
    class H extends r {
        constructor(U, W, Q) {
            let J;
            if (U instanceof u || U instanceof d)
                J = new q(new l(U));
            else if (U instanceof o && U.isCount())
                J = new q(U);
            else if (U instanceof L)
                J = U;
            else
                throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
            if (W === void 0 && (W = null),
            !(W === null || W instanceof r))
                throw new TypeError("defaultLayout must be null or a Layout");
            if (W !== null) {
                if (0 > W.span)
                    throw new Error("defaultLayout must have constant span");
                W.property === void 0 && (W = W.replicate("content"))
            }
            let ne = -1;
            W && (ne = W.span,
            0 <= ne && (U instanceof u || U instanceof d) && (ne += J.layout.span)),
            super(ne, Q),
            this.discriminator = J,
            this.usesPrefixDiscriminator = U instanceof u || U instanceof d,
            this.defaultLayout = W,
            this.registry = {};
            let ie = this.defaultGetSourceVariant.bind(this);
            this.getSourceVariant = function(ae) {
                return ie(ae)
            }
            ,
            this.configGetSourceVariant = function(ae) {
                ie = ae.bind(this)
            }
        }
        getSpan(U, W=0) {
            if (0 <= this.span)
                return this.span;
            const Q = this.getVariant(U, W);
            if (!Q)
                throw new Error("unable to determine span for unrecognized variant");
            return Q.getSpan(U, W)
        }
        defaultGetSourceVariant(U) {
            if (Object.prototype.hasOwnProperty.call(U, this.discriminator.property)) {
                if (this.defaultLayout && this.defaultLayout.property && Object.prototype.hasOwnProperty.call(U, this.defaultLayout.property))
                    return;
                const W = this.registry[U[this.discriminator.property]];
                if (W && (!W.layout || W.property && Object.prototype.hasOwnProperty.call(U, W.property)))
                    return W
            } else
                for (const W in this.registry) {
                    const Q = this.registry[W];
                    if (Q.property && Object.prototype.hasOwnProperty.call(U, Q.property))
                        return Q
                }
            throw new Error("unable to infer src variant")
        }
        decode(U, W=0) {
            let Q;
            const J = this.discriminator
              , ne = J.decode(U, W)
              , ie = this.registry[ne];
            if (ie === void 0) {
                const ae = this.defaultLayout;
                let xe = 0;
                this.usesPrefixDiscriminator && (xe = J.layout.span),
                Q = this.makeDestinationObject(),
                Q[J.property] = ne,
                Q[ae.property] = ae.decode(U, W + xe)
            } else
                Q = ie.decode(U, W);
            return Q
        }
        encode(U, W, Q=0) {
            const J = this.getSourceVariant(U);
            if (J === void 0) {
                const ne = this.discriminator
                  , ie = this.defaultLayout;
                let ae = 0;
                return this.usesPrefixDiscriminator && (ae = ne.layout.span),
                ne.encode(U[ne.property], W, Q),
                ae + ie.encode(U[ie.property], W, Q + ae)
            }
            return J.encode(U, W, Q)
        }
        addVariant(U, W, Q) {
            const J = new j(this,U,W,Q);
            return this.registry[U] = J,
            J
        }
        getVariant(U, W=0) {
            let Q;
            return U instanceof Uint8Array ? Q = this.discriminator.decode(U, W) : Q = U,
            this.registry[Q]
        }
    }
    Ae.Union = H;
    class j extends r {
        constructor(U, W, Q, J) {
            if (!(U instanceof H))
                throw new TypeError("union must be a Union");
            if (!Number.isInteger(W) || 0 > W)
                throw new TypeError("variant must be a (non-negative) integer");
            if (typeof Q == "string" && J === void 0 && (J = Q,
            Q = null),
            Q) {
                if (!(Q instanceof r))
                    throw new TypeError("layout must be a Layout");
                if (U.defaultLayout !== null && 0 <= Q.span && Q.span > U.defaultLayout.span)
                    throw new Error("variant span exceeds span of containing union");
                if (typeof J != "string")
                    throw new TypeError("variant must have a String property")
            }
            let ne = U.span;
            0 > U.span && (ne = Q ? Q.span : 0,
            0 <= ne && U.usesPrefixDiscriminator && (ne += U.discriminator.layout.span)),
            super(ne, J),
            this.union = U,
            this.variant = W,
            this.layout = Q || null
        }
        getSpan(U, W=0) {
            if (0 <= this.span)
                return this.span;
            let Q = 0;
            this.union.usesPrefixDiscriminator && (Q = this.union.discriminator.layout.span);
            let J = 0;
            return this.layout && (J = this.layout.getSpan(U, W + Q)),
            Q + J
        }
        decode(U, W=0) {
            const Q = this.makeDestinationObject();
            if (this !== this.union.getVariant(U, W))
                throw new Error("variant mismatch");
            let J = 0;
            return this.union.usesPrefixDiscriminator && (J = this.union.discriminator.layout.span),
            this.layout ? Q[this.property] = this.layout.decode(U, W + J) : this.property ? Q[this.property] = !0 : this.union.usesPrefixDiscriminator && (Q[this.union.discriminator.property] = this.variant),
            Q
        }
        encode(U, W, Q=0) {
            let J = 0;
            if (this.union.usesPrefixDiscriminator && (J = this.union.discriminator.layout.span),
            this.layout && !Object.prototype.hasOwnProperty.call(U, this.property))
                throw new TypeError("variant lacks property " + this.property);
            this.union.discriminator.encode(this.variant, W, Q);
            let ne = J;
            if (this.layout && (this.layout.encode(U[this.property], W, Q + J),
            ne += this.layout.getSpan(W, Q + J),
            0 <= this.union.span && ne > this.union.span))
                throw new Error("encoded variant overruns containing union");
            return ne
        }
        fromArray(U) {
            if (this.layout)
                return this.layout.fromArray(U)
        }
    }
    Ae.VariantLayout = j;
    function A(D) {
        return 0 > D && (D += 4294967296),
        D
    }
    class E extends r {
        constructor(U, W, Q) {
            if (!(U instanceof u || U instanceof d))
                throw new TypeError("word must be a UInt or UIntBE layout");
            if (typeof W == "string" && Q === void 0 && (Q = W,
            W = !1),
            4 < U.span)
                throw new RangeError("word cannot exceed 32 bits");
            super(U.span, Q),
            this.word = U,
            this.msb = !!W,
            this.fields = [];
            let J = 0;
            this._packedSetValue = function(ne) {
                return J = A(ne),
                this
            }
            ,
            this._packedGetValue = function() {
                return J
            }
        }
        decode(U, W=0) {
            const Q = this.makeDestinationObject()
              , J = this.word.decode(U, W);
            this._packedSetValue(J);
            for (const ne of this.fields)
                ne.property !== void 0 && (Q[ne.property] = ne.decode(U));
            return Q
        }
        encode(U, W, Q=0) {
            const J = this.word.decode(W, Q);
            this._packedSetValue(J);
            for (const ne of this.fields)
                if (ne.property !== void 0) {
                    const ie = U[ne.property];
                    ie !== void 0 && ne.encode(ie)
                }
            return this.word.encode(this._packedGetValue(), W, Q)
        }
        addField(U, W) {
            const Q = new C(this,U,W);
            return this.fields.push(Q),
            Q
        }
        addBoolean(U) {
            const W = new O(this,U);
            return this.fields.push(W),
            W
        }
        fieldFor(U) {
            if (typeof U != "string")
                throw new TypeError("property must be string");
            for (const W of this.fields)
                if (W.property === U)
                    return W
        }
    }
    Ae.BitStructure = E;
    class C {
        constructor(U, W, Q) {
            if (!(U instanceof E))
                throw new TypeError("container must be a BitStructure");
            if (!Number.isInteger(W) || 0 >= W)
                throw new TypeError("bits must be positive integer");
            const J = 8 * U.span
              , ne = U.fields.reduce( (ie, ae) => ie + ae.bits, 0);
            if (W + ne > J)
                throw new Error("bits too long for span remainder (" + (J - ne) + " of " + J + " remain)");
            this.container = U,
            this.bits = W,
            this.valueMask = (1 << W) - 1,
            W === 32 && (this.valueMask = 4294967295),
            this.start = ne,
            this.container.msb && (this.start = J - ne - W),
            this.wordMask = A(this.valueMask << this.start),
            this.property = Q
        }
        decode(U, W) {
            const Q = this.container._packedGetValue();
            return A(Q & this.wordMask) >>> this.start
        }
        encode(U) {
            if (typeof U != "number" || !Number.isInteger(U) || U !== A(U & this.valueMask))
                throw new TypeError(s("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
            const W = this.container._packedGetValue()
              , Q = A(U << this.start);
            this.container._packedSetValue(A(W & ~this.wordMask) | Q)
        }
    }
    Ae.BitField = C;
    class O extends C {
        constructor(U, W) {
            super(U, 1, W)
        }
        decode(U, W) {
            return !!super.decode(U, W)
        }
        encode(U) {
            typeof U == "boolean" && (U = +U),
            super.encode(U)
        }
    }
    Ae.Boolean = O;
    class z extends r {
        constructor(U, W) {
            if (!(U instanceof o && U.isCount() || Number.isInteger(U) && 0 <= U))
                throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
            let Q = -1;
            U instanceof o || (Q = U),
            super(Q, W),
            this.length = U
        }
        getSpan(U, W) {
            let Q = this.span;
            return 0 > Q && (Q = this.length.decode(U, W)),
            Q
        }
        decode(U, W=0) {
            let Q = this.span;
            return 0 > Q && (Q = this.length.decode(U, W)),
            t(U).slice(W, W + Q)
        }
        encode(U, W, Q) {
            let J = this.length;
            if (this.length instanceof o && (J = U.length),
            !(U instanceof Uint8Array && J === U.length))
                throw new TypeError(s("Blob.encode", this) + " requires (length " + J + ") Uint8Array as src");
            if (Q + J > W.length)
                throw new RangeError("encoding overruns Uint8Array");
            const ne = t(U);
            return t(W).write(ne.toString("hex"), Q, J, "hex"),
            this.length instanceof o && this.length.encode(J, W, Q),
            J
        }
    }
    Ae.Blob = z;
    class G extends r {
        constructor(U) {
            super(-1, U)
        }
        getSpan(U, W=0) {
            e(U);
            let Q = W;
            for (; Q < U.length && U[Q] !== 0; )
                Q += 1;
            return 1 + Q - W
        }
        decode(U, W=0) {
            const Q = this.getSpan(U, W);
            return t(U).slice(W, W + Q - 1).toString("utf-8")
        }
        encode(U, W, Q=0) {
            typeof U != "string" && (U = String(U));
            const J = n.Buffer.from(U, "utf8")
              , ne = J.length;
            if (Q + ne > W.length)
                throw new RangeError("encoding overruns Buffer");
            const ie = t(W);
            return J.copy(ie, Q),
            ie[Q + ne] = 0,
            ne + 1
        }
    }
    Ae.CString = G;
    class Y extends r {
        constructor(U, W) {
            if (typeof U == "string" && W === void 0 && (W = U,
            U = void 0),
            U === void 0)
                U = -1;
            else if (!Number.isInteger(U))
                throw new TypeError("maxSpan must be an integer");
            super(-1, W),
            this.maxSpan = U
        }
        getSpan(U, W=0) {
            return e(U),
            U.length - W
        }
        decode(U, W=0) {
            const Q = this.getSpan(U, W);
            if (0 <= this.maxSpan && this.maxSpan < Q)
                throw new RangeError("text length exceeds maxSpan");
            return t(U).slice(W, W + Q).toString("utf-8")
        }
        encode(U, W, Q=0) {
            typeof U != "string" && (U = String(U));
            const J = n.Buffer.from(U, "utf8")
              , ne = J.length;
            if (0 <= this.maxSpan && this.maxSpan < ne)
                throw new RangeError("text length exceeds maxSpan");
            if (Q + ne > W.length)
                throw new RangeError("encoding overruns Buffer");
            return J.copy(t(W), Q),
            ne
        }
    }
    Ae.UTF8 = Y;
    class $ extends r {
        constructor(U, W) {
            super(0, W),
            this.value = U
        }
        decode(U, W) {
            return this.value
        }
        encode(U, W, Q) {
            return 0
        }
    }
    return Ae.Constant = $,
    Ae.greedy = ( (D, U) => new a(D,U)),
    Ae.offset = ( (D, U, W) => new l(D,U,W)),
    Ae.u8 = (D => new u(1,D)),
    Ae.u16 = (D => new u(2,D)),
    Ae.u24 = (D => new u(3,D)),
    Ae.u32 = (D => new u(4,D)),
    Ae.u40 = (D => new u(5,D)),
    Ae.u48 = (D => new u(6,D)),
    Ae.nu64 = (D => new v(D)),
    Ae.u16be = (D => new d(2,D)),
    Ae.u24be = (D => new d(3,D)),
    Ae.u32be = (D => new d(4,D)),
    Ae.u40be = (D => new d(5,D)),
    Ae.u48be = (D => new d(6,D)),
    Ae.nu64be = (D => new S(D)),
    Ae.s8 = (D => new h(1,D)),
    Ae.s16 = (D => new h(2,D)),
    Ae.s24 = (D => new h(3,D)),
    Ae.s32 = (D => new h(4,D)),
    Ae.s40 = (D => new h(5,D)),
    Ae.s48 = (D => new h(6,D)),
    Ae.ns64 = (D => new N(D)),
    Ae.s16be = (D => new p(2,D)),
    Ae.s24be = (D => new p(3,D)),
    Ae.s32be = (D => new p(4,D)),
    Ae.s40be = (D => new p(5,D)),
    Ae.s48be = (D => new p(6,D)),
    Ae.ns64be = (D => new _(D)),
    Ae.f32 = (D => new I(D)),
    Ae.f32be = (D => new k(D)),
    Ae.f64 = (D => new B(D)),
    Ae.f64be = (D => new P(D)),
    Ae.struct = ( (D, U, W) => new R(D,U,W)),
    Ae.bits = ( (D, U, W) => new E(D,U,W)),
    Ae.seq = ( (D, U, W) => new M(D,U,W)),
    Ae.union = ( (D, U, W) => new H(D,U,W)),
    Ae.unionLayoutDiscriminator = ( (D, U) => new q(D,U)),
    Ae.blob = ( (D, U) => new z(D,U)),
    Ae.cstr = (D => new G(D)),
    Ae.utf8 = ( (D, U) => new Y(D,U)),
    Ae.constant = ( (D, U) => new $(D,U)),
    Ae
}
var oe = use()
  , dse = 8078e3
  , fse = 8078001
  , hse = 8078004
  , pse = 8078005
  , mse = 8078006
  , gse = 8078011;
function LU(n) {
    return Array.isArray(n) ? "%5B" + n.map(LU).join("%2C%20") + "%5D" : typeof n == "bigint" ? `${n}n` : encodeURIComponent(String(n != null && Object.getPrototypeOf(n) === null ? {
        ...n
    } : n))
}
function yse([n,e]) {
    return `${n}=${LU(e)}`
}
function bse(n) {
    const e = Object.entries(n).map(yse).join("&");
    return btoa(e)
}
function wse(n, e={}) {
    {
        let t = `Solana error #${n}; Decode this error by running \`npx @solana/errors decode -- ${n}`;
        return Object.keys(e).length && (t += ` '${bse(e)}'`),
        `${t}\``
    }
}
var Np = class extends Error {
    cause = this.cause;
    context;
    constructor(...[n,e]) {
        let t, r;
        if (e) {
            const {cause: i, ...o} = e;
            i && (r = {
                cause: i
            }),
            Object.keys(o).length > 0 && (t = o)
        }
        const s = wse(n, t);
        super(s, r),
        this.context = {
            __code: n,
            ...t
        },
        this.name = "SolanaError"
    }
}
;
function vse(n, e) {
    return "fixedSize"in e ? e.fixedSize : e.getSizeFromValue(n)
}
function xse(n) {
    return Object.freeze({
        ...n,
        encode: e => {
            const t = new Uint8Array(vse(e, n));
            return n.write(e, t, 0),
            t
        }
    })
}
function Ese(n) {
    return Object.freeze({
        ...n,
        decode: (e, t=0) => n.read(e, t)[0]
    })
}
function Wh(n) {
    return "fixedSize"in n && typeof n.fixedSize == "number"
}
function Sse(n, e) {
    if (Wh(n) !== Wh(e))
        throw new Np(hse);
    if (Wh(n) && Wh(e) && n.fixedSize !== e.fixedSize)
        throw new Np(pse,{
            decoderFixedSize: e.fixedSize,
            encoderFixedSize: n.fixedSize
        });
    if (!Wh(n) && !Wh(e) && n.maxSize !== e.maxSize)
        throw new Np(mse,{
            decoderMaxSize: e.maxSize,
            encoderMaxSize: n.maxSize
        });
    return {
        ...e,
        ...n,
        decode: e.decode,
        encode: n.encode,
        read: e.read,
        write: n.write
    }
}
function Ase(n, e, t=0) {
    if (e.length - t <= 0)
        throw new Np(dse,{
            codecDescription: n
        })
}
function Cse(n, e, t, r=0) {
    const s = t.length - r;
    if (s < e)
        throw new Np(fse,{
            bytesLength: s,
            codecDescription: n,
            expected: e
        })
}
function _se(n, e, t, r) {
    if (r < e || r > t)
        throw new Np(gse,{
            codecDescription: n,
            max: t,
            min: e,
            value: r
        })
}
function FU(n) {
    return n?.endian !== 1
}
function kse(n) {
    return xse({
        fixedSize: n.size,
        write(e, t, r) {
            n.range && _se(n.name, n.range[0], n.range[1], e);
            const s = new ArrayBuffer(n.size);
            return n.set(new DataView(s), e, FU(n.config)),
            t.set(new Uint8Array(s), r),
            r + n.size
        }
    })
}
function Nse(n) {
    return Ese({
        fixedSize: n.size,
        read(e, t=0) {
            Ase(n.name, e, t),
            Cse(n.name, n.size, e, t);
            const r = new DataView(Dse(e, t, n.size));
            return [n.get(r, FU(n.config)), t + n.size]
        }
    })
}
function Dse(n, e, t) {
    const r = n.byteOffset + (e ?? 0)
      , s = t ?? n.byteLength;
    return n.buffer.slice(r, r + s)
}
var Tse = (n={}) => kse({
    config: n,
    name: "u64",
    range: [0n, BigInt("0xffffffffffffffff")],
    set: (e, t, r) => e.setBigUint64(0, BigInt(t), r),
    size: 8
})
  , Ise = (n={}) => Nse({
    config: n,
    get: (e, t) => e.getBigUint64(0, t),
    name: "u64",
    size: 8
})
  , Mse = (n={}) => Sse(Tse(n), Ise(n));
class Bse extends TypeError {
    constructor(e, t) {
        let r;
        const {message: s, explanation: i, ...o} = e
          , {path: a} = e
          , l = a.length === 0 ? s : `At path: ${a.join(".")} -- ${s}`;
        super(i ?? l),
        i != null && (this.cause = l),
        Object.assign(this, o),
        this.name = this.constructor.name,
        this.failures = () => r ?? (r = [e, ...t()])
    }
}
function Rse(n) {
    return Oy(n) && typeof n[Symbol.iterator] == "function"
}
function Oy(n) {
    return typeof n == "object" && n != null
}
function _2(n) {
    return Oy(n) && !Array.isArray(n)
}
function da(n) {
    return typeof n == "symbol" ? n.toString() : typeof n == "string" ? JSON.stringify(n) : `${n}`
}
function Ose(n) {
    const {done: e, value: t} = n.next();
    return e ? void 0 : t
}
function Pse(n, e, t, r) {
    if (n === !0)
        return;
    n === !1 ? n = {} : typeof n == "string" && (n = {
        message: n
    });
    const {path: s, branch: i} = e
      , {type: o} = t
      , {refinement: a, message: l=`Expected a value of type \`${o}\`${a ? ` with refinement \`${a}\`` : ""}, but received: \`${da(r)}\``} = n;
    return {
        value: r,
        type: o,
        refinement: a,
        key: s[s.length - 1],
        path: s,
        branch: i,
        ...n,
        message: l
    }
}
function *LM(n, e, t, r) {
    Rse(n) || (n = [n]);
    for (const s of n) {
        const i = Pse(s, e, t, r);
        i && (yield i)
    }
}
function *s_(n, e, t={}) {
    const {path: r=[], branch: s=[n], coerce: i=!1, mask: o=!1} = t
      , a = {
        path: r,
        branch: s,
        mask: o
    };
    i && (n = e.coercer(n, a));
    let l = "valid";
    for (const u of e.validator(n, a))
        u.explanation = t.message,
        l = "not_valid",
        yield[u, void 0];
    for (let[u,d,h] of e.entries(n, a)) {
        const p = s_(d, h, {
            path: u === void 0 ? r : [...r, u],
            branch: u === void 0 ? s : [...s, d],
            coerce: i,
            mask: o,
            message: t.message
        });
        for (const g of p)
            g[0] ? (l = g[0].refinement != null ? "not_refined" : "not_valid",
            yield[g[0], void 0]) : i && (d = g[1],
            u === void 0 ? n = d : n instanceof Map ? n.set(u, d) : n instanceof Set ? n.add(d) : Oy(n) && (d !== void 0 || u in n) && (n[u] = d))
    }
    if (l !== "not_valid")
        for (const u of e.refiner(n, a))
            u.explanation = t.message,
            l = "not_refined",
            yield[u, void 0];
    l === "valid" && (yield[void 0, n])
}
let ol = class {
    constructor(e) {
        const {type: t, schema: r, validator: s, refiner: i, coercer: o=l => l, entries: a=function*() {}
        } = e;
        this.type = t,
        this.schema = r,
        this.entries = a,
        this.coercer = o,
        s ? this.validator = (l, u) => {
            const d = s(l, u);
            return LM(d, u, this, l)
        }
        : this.validator = () => [],
        i ? this.refiner = (l, u) => {
            const d = i(l, u);
            return LM(d, u, this, l)
        }
        : this.refiner = () => []
    }
    assert(e, t) {
        return jse(e, this, t)
    }
    create(e, t) {
        return ze(e, this, t)
    }
    is(e) {
        return UU(e, this)
    }
    mask(e, t) {
        return Lse(e, this, t)
    }
    validate(e, t={}) {
        return Py(e, this, t)
    }
}
;
function jse(n, e, t) {
    const r = Py(n, e, {
        message: t
    });
    if (r[0])
        throw r[0]
}
function ze(n, e, t) {
    const r = Py(n, e, {
        coerce: !0,
        message: t
    });
    if (r[0])
        throw r[0];
    return r[1]
}
function Lse(n, e, t) {
    const r = Py(n, e, {
        coerce: !0,
        mask: !0,
        message: t
    });
    if (r[0])
        throw r[0];
    return r[1]
}
function UU(n, e) {
    return !Py(n, e)[0]
}
function Py(n, e, t={}) {
    const r = s_(n, e, t)
      , s = Ose(r);
    return s[0] ? [new Bse(s[0],function*() {
        for (const o of r)
            o[0] && (yield o[0])
    }
    ), void 0] : [void 0, s[1]]
}
function qf(n, e) {
    return new ol({
        type: n,
        schema: null,
        validator: e
    })
}
function Fse() {
    return qf("any", () => !0)
}
function He(n) {
    return new ol({
        type: "array",
        schema: n,
        *entries(e) {
            if (n && Array.isArray(e))
                for (const [t,r] of e.entries())
                    yield[t, r, n]
        },
        coercer(e) {
            return Array.isArray(e) ? e.slice() : e
        },
        validator(e) {
            return Array.isArray(e) || `Expected an array value, but received: ${da(e)}`
        }
    })
}
function nl() {
    return qf("boolean", n => typeof n == "boolean")
}
function i_(n) {
    return qf("instance", e => e instanceof n || `Expected a \`${n.name}\` instance, but received: ${da(e)}`)
}
function tr(n) {
    const e = da(n)
      , t = typeof n;
    return new ol({
        type: "literal",
        schema: t === "string" || t === "number" || t === "boolean" ? n : null,
        validator(r) {
            return r === n || `Expected the literal \`${e}\`, but received: ${da(r)}`
        }
    })
}
function Use() {
    return qf("never", () => !1)
}
function Ge(n) {
    return new ol({
        ...n,
        validator: (e, t) => e === null || n.validator(e, t),
        refiner: (e, t) => e === null || n.refiner(e, t)
    })
}
function be() {
    return qf("number", n => typeof n == "number" && !isNaN(n) || `Expected a number, but received: ${da(n)}`)
}
function bt(n) {
    return new ol({
        ...n,
        validator: (e, t) => e === void 0 || n.validator(e, t),
        refiner: (e, t) => e === void 0 || n.refiner(e, t)
    })
}
function zU(n, e) {
    return new ol({
        type: "record",
        schema: null,
        *entries(t) {
            if (Oy(t))
                for (const r in t) {
                    const s = t[r];
                    yield[r, r, n],
                    yield[r, s, e]
                }
        },
        validator(t) {
            return _2(t) || `Expected an object, but received: ${da(t)}`
        },
        coercer(t) {
            return _2(t) ? {
                ...t
            } : t
        }
    })
}
function Le() {
    return qf("string", n => typeof n == "string" || `Expected a string, but received: ${da(n)}`)
}
function o_(n) {
    const e = Use();
    return new ol({
        type: "tuple",
        schema: null,
        *entries(t) {
            if (Array.isArray(t)) {
                const r = Math.max(n.length, t.length);
                for (let s = 0; s < r; s++)
                    yield[s, t[s], n[s] || e]
            }
        },
        validator(t) {
            return Array.isArray(t) || `Expected an array, but received: ${da(t)}`
        },
        coercer(t) {
            return Array.isArray(t) ? t.slice() : t
        }
    })
}
function Re(n) {
    const e = Object.keys(n);
    return new ol({
        type: "type",
        schema: n,
        *entries(t) {
            if (Oy(t))
                for (const r of e)
                    yield[r, t[r], n[r]]
        },
        validator(t) {
            return _2(t) || `Expected an object, but received: ${da(t)}`
        },
        coercer(t) {
            return _2(t) ? {
                ...t
            } : t
        }
    })
}
function si(n) {
    const e = n.map(t => t.type).join(" | ");
    return new ol({
        type: "union",
        schema: null,
        coercer(t, r) {
            for (const s of n) {
                const [i,o] = s.validate(t, {
                    coerce: !0,
                    mask: r.mask
                });
                if (!i)
                    return o
            }
            return t
        },
        validator(t, r) {
            const s = [];
            for (const i of n) {
                const [...o] = s_(t, i, r)
                  , [a] = o;
                if (a[0])
                    for (const [l] of o)
                        l && s.push(l);
                else
                    return []
            }
            return [`Expected the value to satisfy a union of \`${e}\`, but received: ${da(t)}`, ...s]
        }
    })
}
function k0() {
    return qf("unknown", () => !0)
}
function jy(n, e, t) {
    return new ol({
        ...n,
        coercer: (r, s) => UU(r, e) ? n.coercer(t(r, s), s) : n.coercer(r, s)
    })
}
var R1, zse = new Uint8Array(16);
function $U() {
    if (!R1 && (R1 = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto < "u" && typeof msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto),
    !R1))
        throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    return R1(zse)
}
const $se = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function Jv(n) {
    return typeof n == "string" && $se.test(n)
}
var hs = [];
for (var XS = 0; XS < 256; ++XS)
    hs.push((XS + 256).toString(16).substr(1));
function ex(n) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0
      , t = (hs[n[e + 0]] + hs[n[e + 1]] + hs[n[e + 2]] + hs[n[e + 3]] + "-" + hs[n[e + 4]] + hs[n[e + 5]] + "-" + hs[n[e + 6]] + hs[n[e + 7]] + "-" + hs[n[e + 8]] + hs[n[e + 9]] + "-" + hs[n[e + 10]] + hs[n[e + 11]] + hs[n[e + 12]] + hs[n[e + 13]] + hs[n[e + 14]] + hs[n[e + 15]]).toLowerCase();
    if (!Jv(t))
        throw TypeError("Stringified UUID is invalid");
    return t
}
var FM, QS, ZS = 0, JS = 0;
function Hse(n, e, t) {
    var r = e && t || 0
      , s = e || new Array(16);
    n = n || {};
    var i = n.node || FM
      , o = n.clockseq !== void 0 ? n.clockseq : QS;
    if (i == null || o == null) {
        var a = n.random || (n.rng || $U)();
        i == null && (i = FM = [a[0] | 1, a[1], a[2], a[3], a[4], a[5]]),
        o == null && (o = QS = (a[6] << 8 | a[7]) & 16383)
    }
    var l = n.msecs !== void 0 ? n.msecs : Date.now()
      , u = n.nsecs !== void 0 ? n.nsecs : JS + 1
      , d = l - ZS + (u - JS) / 1e4;
    if (d < 0 && n.clockseq === void 0 && (o = o + 1 & 16383),
    (d < 0 || l > ZS) && n.nsecs === void 0 && (u = 0),
    u >= 1e4)
        throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    ZS = l,
    JS = u,
    QS = o,
    l += 122192928e5;
    var h = ((l & 268435455) * 1e4 + u) % 4294967296;
    s[r++] = h >>> 24 & 255,
    s[r++] = h >>> 16 & 255,
    s[r++] = h >>> 8 & 255,
    s[r++] = h & 255;
    var p = l / 4294967296 * 1e4 & 268435455;
    s[r++] = p >>> 8 & 255,
    s[r++] = p & 255,
    s[r++] = p >>> 24 & 15 | 16,
    s[r++] = p >>> 16 & 255,
    s[r++] = o >>> 8 | 128,
    s[r++] = o & 255;
    for (var g = 0; g < 6; ++g)
        s[r + g] = i[g];
    return e || ex(s)
}
function HU(n) {
    if (!Jv(n))
        throw TypeError("Invalid UUID");
    var e, t = new Uint8Array(16);
    return t[0] = (e = parseInt(n.slice(0, 8), 16)) >>> 24,
    t[1] = e >>> 16 & 255,
    t[2] = e >>> 8 & 255,
    t[3] = e & 255,
    t[4] = (e = parseInt(n.slice(9, 13), 16)) >>> 8,
    t[5] = e & 255,
    t[6] = (e = parseInt(n.slice(14, 18), 16)) >>> 8,
    t[7] = e & 255,
    t[8] = (e = parseInt(n.slice(19, 23), 16)) >>> 8,
    t[9] = e & 255,
    t[10] = (e = parseInt(n.slice(24, 36), 16)) / 1099511627776 & 255,
    t[11] = e / 4294967296 & 255,
    t[12] = e >>> 24 & 255,
    t[13] = e >>> 16 & 255,
    t[14] = e >>> 8 & 255,
    t[15] = e & 255,
    t
}
function Vse(n) {
    n = unescape(encodeURIComponent(n));
    for (var e = [], t = 0; t < n.length; ++t)
        e.push(n.charCodeAt(t));
    return e
}
var qse = "6ba7b810-9dad-11d1-80b4-00c04fd430c8"
  , Gse = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function VU(n, e, t) {
    function r(s, i, o, a) {
        if (typeof s == "string" && (s = Vse(s)),
        typeof i == "string" && (i = HU(i)),
        i.length !== 16)
            throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
        var l = new Uint8Array(16 + s.length);
        if (l.set(i),
        l.set(s, i.length),
        l = t(l),
        l[6] = l[6] & 15 | e,
        l[8] = l[8] & 63 | 128,
        o) {
            a = a || 0;
            for (var u = 0; u < 16; ++u)
                o[a + u] = l[u];
            return o
        }
        return ex(l)
    }
    try {
        r.name = n
    } catch {}
    return r.DNS = qse,
    r.URL = Gse,
    r
}
function Wse(n) {
    if (typeof n == "string") {
        var e = unescape(encodeURIComponent(n));
        n = new Uint8Array(e.length);
        for (var t = 0; t < e.length; ++t)
            n[t] = e.charCodeAt(t)
    }
    return Yse(Kse(Xse(n), n.length * 8))
}
function Yse(n) {
    for (var e = [], t = n.length * 32, r = "0123456789abcdef", s = 0; s < t; s += 8) {
        var i = n[s >> 5] >>> s % 32 & 255
          , o = parseInt(r.charAt(i >>> 4 & 15) + r.charAt(i & 15), 16);
        e.push(o)
    }
    return e
}
function qU(n) {
    return (n + 64 >>> 9 << 4) + 14 + 1
}
function Kse(n, e) {
    n[e >> 5] |= 128 << e % 32,
    n[qU(e) - 1] = e;
    for (var t = 1732584193, r = -271733879, s = -1732584194, i = 271733878, o = 0; o < n.length; o += 16) {
        var a = t
          , l = r
          , u = s
          , d = i;
        t = Ds(t, r, s, i, n[o], 7, -680876936),
        i = Ds(i, t, r, s, n[o + 1], 12, -389564586),
        s = Ds(s, i, t, r, n[o + 2], 17, 606105819),
        r = Ds(r, s, i, t, n[o + 3], 22, -1044525330),
        t = Ds(t, r, s, i, n[o + 4], 7, -176418897),
        i = Ds(i, t, r, s, n[o + 5], 12, 1200080426),
        s = Ds(s, i, t, r, n[o + 6], 17, -1473231341),
        r = Ds(r, s, i, t, n[o + 7], 22, -45705983),
        t = Ds(t, r, s, i, n[o + 8], 7, 1770035416),
        i = Ds(i, t, r, s, n[o + 9], 12, -1958414417),
        s = Ds(s, i, t, r, n[o + 10], 17, -42063),
        r = Ds(r, s, i, t, n[o + 11], 22, -1990404162),
        t = Ds(t, r, s, i, n[o + 12], 7, 1804603682),
        i = Ds(i, t, r, s, n[o + 13], 12, -40341101),
        s = Ds(s, i, t, r, n[o + 14], 17, -1502002290),
        r = Ds(r, s, i, t, n[o + 15], 22, 1236535329),
        t = Ts(t, r, s, i, n[o + 1], 5, -165796510),
        i = Ts(i, t, r, s, n[o + 6], 9, -1069501632),
        s = Ts(s, i, t, r, n[o + 11], 14, 643717713),
        r = Ts(r, s, i, t, n[o], 20, -373897302),
        t = Ts(t, r, s, i, n[o + 5], 5, -701558691),
        i = Ts(i, t, r, s, n[o + 10], 9, 38016083),
        s = Ts(s, i, t, r, n[o + 15], 14, -660478335),
        r = Ts(r, s, i, t, n[o + 4], 20, -405537848),
        t = Ts(t, r, s, i, n[o + 9], 5, 568446438),
        i = Ts(i, t, r, s, n[o + 14], 9, -1019803690),
        s = Ts(s, i, t, r, n[o + 3], 14, -187363961),
        r = Ts(r, s, i, t, n[o + 8], 20, 1163531501),
        t = Ts(t, r, s, i, n[o + 13], 5, -1444681467),
        i = Ts(i, t, r, s, n[o + 2], 9, -51403784),
        s = Ts(s, i, t, r, n[o + 7], 14, 1735328473),
        r = Ts(r, s, i, t, n[o + 12], 20, -1926607734),
        t = Is(t, r, s, i, n[o + 5], 4, -378558),
        i = Is(i, t, r, s, n[o + 8], 11, -2022574463),
        s = Is(s, i, t, r, n[o + 11], 16, 1839030562),
        r = Is(r, s, i, t, n[o + 14], 23, -35309556),
        t = Is(t, r, s, i, n[o + 1], 4, -1530992060),
        i = Is(i, t, r, s, n[o + 4], 11, 1272893353),
        s = Is(s, i, t, r, n[o + 7], 16, -155497632),
        r = Is(r, s, i, t, n[o + 10], 23, -1094730640),
        t = Is(t, r, s, i, n[o + 13], 4, 681279174),
        i = Is(i, t, r, s, n[o], 11, -358537222),
        s = Is(s, i, t, r, n[o + 3], 16, -722521979),
        r = Is(r, s, i, t, n[o + 6], 23, 76029189),
        t = Is(t, r, s, i, n[o + 9], 4, -640364487),
        i = Is(i, t, r, s, n[o + 12], 11, -421815835),
        s = Is(s, i, t, r, n[o + 15], 16, 530742520),
        r = Is(r, s, i, t, n[o + 2], 23, -995338651),
        t = Ms(t, r, s, i, n[o], 6, -198630844),
        i = Ms(i, t, r, s, n[o + 7], 10, 1126891415),
        s = Ms(s, i, t, r, n[o + 14], 15, -1416354905),
        r = Ms(r, s, i, t, n[o + 5], 21, -57434055),
        t = Ms(t, r, s, i, n[o + 12], 6, 1700485571),
        i = Ms(i, t, r, s, n[o + 3], 10, -1894986606),
        s = Ms(s, i, t, r, n[o + 10], 15, -1051523),
        r = Ms(r, s, i, t, n[o + 1], 21, -2054922799),
        t = Ms(t, r, s, i, n[o + 8], 6, 1873313359),
        i = Ms(i, t, r, s, n[o + 15], 10, -30611744),
        s = Ms(s, i, t, r, n[o + 6], 15, -1560198380),
        r = Ms(r, s, i, t, n[o + 13], 21, 1309151649),
        t = Ms(t, r, s, i, n[o + 4], 6, -145523070),
        i = Ms(i, t, r, s, n[o + 11], 10, -1120210379),
        s = Ms(s, i, t, r, n[o + 2], 15, 718787259),
        r = Ms(r, s, i, t, n[o + 9], 21, -343485551),
        t = Lu(t, a),
        r = Lu(r, l),
        s = Lu(s, u),
        i = Lu(i, d)
    }
    return [t, r, s, i]
}
function Xse(n) {
    if (n.length === 0)
        return [];
    for (var e = n.length * 8, t = new Uint32Array(qU(e)), r = 0; r < e; r += 8)
        t[r >> 5] |= (n[r / 8] & 255) << r % 32;
    return t
}
function Lu(n, e) {
    var t = (n & 65535) + (e & 65535)
      , r = (n >> 16) + (e >> 16) + (t >> 16);
    return r << 16 | t & 65535
}
function Qse(n, e) {
    return n << e | n >>> 32 - e
}
function tx(n, e, t, r, s, i) {
    return Lu(Qse(Lu(Lu(e, n), Lu(r, i)), s), t)
}
function Ds(n, e, t, r, s, i, o) {
    return tx(e & t | ~e & r, n, e, s, i, o)
}
function Ts(n, e, t, r, s, i, o) {
    return tx(e & r | t & ~r, n, e, s, i, o)
}
function Is(n, e, t, r, s, i, o) {
    return tx(e ^ t ^ r, n, e, s, i, o)
}
function Ms(n, e, t, r, s, i, o) {
    return tx(t ^ (e | ~r), n, e, s, i, o)
}
var Zse = VU("v3", 48, Wse);
function Jse(n, e, t) {
    n = n || {};
    var r = n.random || (n.rng || $U)();
    if (r[6] = r[6] & 15 | 64,
    r[8] = r[8] & 63 | 128,
    e) {
        t = t || 0;
        for (var s = 0; s < 16; ++s)
            e[t + s] = r[s];
        return e
    }
    return ex(r)
}
function eie(n, e, t, r) {
    switch (n) {
    case 0:
        return e & t ^ ~e & r;
    case 1:
        return e ^ t ^ r;
    case 2:
        return e & t ^ e & r ^ t & r;
    case 3:
        return e ^ t ^ r
    }
}
function e5(n, e) {
    return n << e | n >>> 32 - e
}
function tie(n) {
    var e = [1518500249, 1859775393, 2400959708, 3395469782]
      , t = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    if (typeof n == "string") {
        var r = unescape(encodeURIComponent(n));
        n = [];
        for (var s = 0; s < r.length; ++s)
            n.push(r.charCodeAt(s))
    } else
        Array.isArray(n) || (n = Array.prototype.slice.call(n));
    n.push(128);
    for (var i = n.length / 4 + 2, o = Math.ceil(i / 16), a = new Array(o), l = 0; l < o; ++l) {
        for (var u = new Uint32Array(16), d = 0; d < 16; ++d)
            u[d] = n[l * 64 + d * 4] << 24 | n[l * 64 + d * 4 + 1] << 16 | n[l * 64 + d * 4 + 2] << 8 | n[l * 64 + d * 4 + 3];
        a[l] = u
    }
    a[o - 1][14] = (n.length - 1) * 8 / Math.pow(2, 32),
    a[o - 1][14] = Math.floor(a[o - 1][14]),
    a[o - 1][15] = (n.length - 1) * 8 & 4294967295;
    for (var h = 0; h < o; ++h) {
        for (var p = new Uint32Array(80), g = 0; g < 16; ++g)
            p[g] = a[h][g];
        for (var w = 16; w < 80; ++w)
            p[w] = e5(p[w - 3] ^ p[w - 8] ^ p[w - 14] ^ p[w - 16], 1);
        for (var b = t[0], v = t[1], S = t[2], N = t[3], _ = t[4], I = 0; I < 80; ++I) {
            var k = Math.floor(I / 20)
              , B = e5(b, 5) + eie(k, v, S, N) + _ + e[k] + p[I] >>> 0;
            _ = N,
            N = S,
            S = e5(v, 30) >>> 0,
            v = b,
            b = B
        }
        t[0] = t[0] + b >>> 0,
        t[1] = t[1] + v >>> 0,
        t[2] = t[2] + S >>> 0,
        t[3] = t[3] + N >>> 0,
        t[4] = t[4] + _ >>> 0
    }
    return [t[0] >> 24 & 255, t[0] >> 16 & 255, t[0] >> 8 & 255, t[0] & 255, t[1] >> 24 & 255, t[1] >> 16 & 255, t[1] >> 8 & 255, t[1] & 255, t[2] >> 24 & 255, t[2] >> 16 & 255, t[2] >> 8 & 255, t[2] & 255, t[3] >> 24 & 255, t[3] >> 16 & 255, t[3] >> 8 & 255, t[3] & 255, t[4] >> 24 & 255, t[4] >> 16 & 255, t[4] >> 8 & 255, t[4] & 255]
}
var nie = VU("v5", 80, tie);
const rie = "00000000-0000-0000-0000-000000000000";
function sie(n) {
    if (!Jv(n))
        throw TypeError("Invalid UUID");
    return parseInt(n.substr(14, 1), 16)
}
const iie = Object.freeze(Object.defineProperty({
    __proto__: null,
    NIL: rie,
    parse: HU,
    stringify: ex,
    v1: Hse,
    v3: Zse,
    v4: Jse,
    v5: nie,
    validate: Jv,
    version: sie
}, Symbol.toStringTag, {
    value: "Module"
}))
  , GU = S8(iie);
var t5, UM;
function oie() {
    if (UM)
        return t5;
    UM = 1;
    const n = GU.v4;
    return t5 = function(t, r, s, i) {
        if (typeof t != "string")
            throw new TypeError(t + " must be a string");
        i = i || {};
        const o = typeof i.version == "number" ? i.version : 2;
        if (o !== 1 && o !== 2)
            throw new TypeError(o + " must be 1 or 2");
        const a = {
            method: t
        };
        if (o === 2 && (a.jsonrpc = "2.0"),
        r) {
            if (typeof r != "object" && !Array.isArray(r))
                throw new TypeError(r + " must be an object, array or omitted");
            a.params = r
        }
        if (typeof s > "u") {
            const l = typeof i.generator == "function" ? i.generator : function() {
                return n()
            }
            ;
            a.id = l(a, i)
        } else
            o === 2 && s === null ? i.notificationIdNull && (a.id = null) : a.id = s;
        return a
    }
    ,
    t5
}
var n5, zM;
function aie() {
    if (zM)
        return n5;
    zM = 1;
    const n = GU.v4
      , e = oie()
      , t = function(r, s) {
        if (!(this instanceof t))
            return new t(r,s);
        s || (s = {}),
        this.options = {
            reviver: typeof s.reviver < "u" ? s.reviver : null,
            replacer: typeof s.replacer < "u" ? s.replacer : null,
            generator: typeof s.generator < "u" ? s.generator : function() {
                return n()
            }
            ,
            version: typeof s.version < "u" ? s.version : 2,
            notificationIdNull: typeof s.notificationIdNull == "boolean" ? s.notificationIdNull : !1
        },
        this.callServer = r
    };
    return n5 = t,
    t.prototype.request = function(r, s, i, o) {
        const a = this;
        let l = null;
        const u = Array.isArray(r) && typeof s == "function";
        if (this.options.version === 1 && u)
            throw new TypeError("JSON-RPC 1.0 does not support batching");
        if (u || !u && r && typeof r == "object" && typeof s == "function")
            o = s,
            l = r;
        else {
            typeof i == "function" && (o = i,
            i = void 0);
            const p = typeof o == "function";
            try {
                l = e(r, s, i, {
                    generator: this.options.generator,
                    version: this.options.version,
                    notificationIdNull: this.options.notificationIdNull
                })
            } catch (g) {
                if (p)
                    return o(g);
                throw g
            }
            if (!p)
                return l
        }
        let h;
        try {
            h = JSON.stringify(l, this.options.replacer)
        } catch (p) {
            return o(p)
        }
        return this.callServer(h, function(p, g) {
            a._parseResponse(p, g, o)
        }),
        l
    }
    ,
    t.prototype._parseResponse = function(r, s, i) {
        if (r) {
            i(r);
            return
        }
        if (!s)
            return i();
        let o;
        try {
            o = JSON.parse(s, this.options.reviver)
        } catch (a) {
            return i(a)
        }
        if (i.length === 3)
            if (Array.isArray(o)) {
                const a = function(u) {
                    return typeof u.error < "u"
                }
                  , l = function(u) {
                    return !a(u)
                };
                return i(null, o.filter(a), o.filter(l))
            } else
                return i(null, o.error, o.result);
        i(null, o)
    }
    ,
    n5
}
var lie = aie();
const cie = Fo(lie);
var r5 = {
    exports: {}
}, $M;
function uie() {
    return $M || ($M = 1,
    (function(n) {
        var e = Object.prototype.hasOwnProperty
          , t = "~";
        function r() {}
        Object.create && (r.prototype = Object.create(null),
        new r().__proto__ || (t = !1));
        function s(l, u, d) {
            this.fn = l,
            this.context = u,
            this.once = d || !1
        }
        function i(l, u, d, h, p) {
            if (typeof d != "function")
                throw new TypeError("The listener must be a function");
            var g = new s(d,h || l,p)
              , w = t ? t + u : u;
            return l._events[w] ? l._events[w].fn ? l._events[w] = [l._events[w], g] : l._events[w].push(g) : (l._events[w] = g,
            l._eventsCount++),
            l
        }
        function o(l, u) {
            --l._eventsCount === 0 ? l._events = new r : delete l._events[u]
        }
        function a() {
            this._events = new r,
            this._eventsCount = 0
        }
        a.prototype.eventNames = function() {
            var u = [], d, h;
            if (this._eventsCount === 0)
                return u;
            for (h in d = this._events)
                e.call(d, h) && u.push(t ? h.slice(1) : h);
            return Object.getOwnPropertySymbols ? u.concat(Object.getOwnPropertySymbols(d)) : u
        }
        ,
        a.prototype.listeners = function(u) {
            var d = t ? t + u : u
              , h = this._events[d];
            if (!h)
                return [];
            if (h.fn)
                return [h.fn];
            for (var p = 0, g = h.length, w = new Array(g); p < g; p++)
                w[p] = h[p].fn;
            return w
        }
        ,
        a.prototype.listenerCount = function(u) {
            var d = t ? t + u : u
              , h = this._events[d];
            return h ? h.fn ? 1 : h.length : 0
        }
        ,
        a.prototype.emit = function(u, d, h, p, g, w) {
            var b = t ? t + u : u;
            if (!this._events[b])
                return !1;
            var v = this._events[b], S = arguments.length, N, _;
            if (v.fn) {
                switch (v.once && this.removeListener(u, v.fn, void 0, !0),
                S) {
                case 1:
                    return v.fn.call(v.context),
                    !0;
                case 2:
                    return v.fn.call(v.context, d),
                    !0;
                case 3:
                    return v.fn.call(v.context, d, h),
                    !0;
                case 4:
                    return v.fn.call(v.context, d, h, p),
                    !0;
                case 5:
                    return v.fn.call(v.context, d, h, p, g),
                    !0;
                case 6:
                    return v.fn.call(v.context, d, h, p, g, w),
                    !0
                }
                for (_ = 1,
                N = new Array(S - 1); _ < S; _++)
                    N[_ - 1] = arguments[_];
                v.fn.apply(v.context, N)
            } else {
                var I = v.length, k;
                for (_ = 0; _ < I; _++)
                    switch (v[_].once && this.removeListener(u, v[_].fn, void 0, !0),
                    S) {
                    case 1:
                        v[_].fn.call(v[_].context);
                        break;
                    case 2:
                        v[_].fn.call(v[_].context, d);
                        break;
                    case 3:
                        v[_].fn.call(v[_].context, d, h);
                        break;
                    case 4:
                        v[_].fn.call(v[_].context, d, h, p);
                        break;
                    default:
                        if (!N)
                            for (k = 1,
                            N = new Array(S - 1); k < S; k++)
                                N[k - 1] = arguments[k];
                        v[_].fn.apply(v[_].context, N)
                    }
            }
            return !0
        }
        ,
        a.prototype.on = function(u, d, h) {
            return i(this, u, d, h, !1)
        }
        ,
        a.prototype.once = function(u, d, h) {
            return i(this, u, d, h, !0)
        }
        ,
        a.prototype.removeListener = function(u, d, h, p) {
            var g = t ? t + u : u;
            if (!this._events[g])
                return this;
            if (!d)
                return o(this, g),
                this;
            var w = this._events[g];
            if (w.fn)
                w.fn === d && (!p || w.once) && (!h || w.context === h) && o(this, g);
            else {
                for (var b = 0, v = [], S = w.length; b < S; b++)
                    (w[b].fn !== d || p && !w[b].once || h && w[b].context !== h) && v.push(w[b]);
                v.length ? this._events[g] = v.length === 1 ? v[0] : v : o(this, g)
            }
            return this
        }
        ,
        a.prototype.removeAllListeners = function(u) {
            var d;
            return u ? (d = t ? t + u : u,
            this._events[d] && o(this, d)) : (this._events = new r,
            this._eventsCount = 0),
            this
        }
        ,
        a.prototype.off = a.prototype.removeListener,
        a.prototype.addListener = a.prototype.on,
        a.prefixed = t,
        a.EventEmitter = a,
        n.exports = a
    }
    )(r5)),
    r5.exports
}
var die = uie();
const WU = Fo(die);
var fie = class extends WU {
    socket;
    constructor(n, e) {
        super(),
        this.socket = new window.WebSocket(n,e.protocols),
        this.socket.onopen = () => this.emit("open"),
        this.socket.onmessage = t => this.emit("message", t.data),
        this.socket.onerror = t => this.emit("error", t),
        this.socket.onclose = t => {
            this.emit("close", t.code, t.reason)
        }
    }
    send(n, e, t) {
        const r = t || e;
        try {
            this.socket.send(n),
            r()
        } catch (s) {
            r(s)
        }
    }
    close(n, e) {
        this.socket.close(n, e)
    }
    addEventListener(n, e, t) {
        this.socket.addEventListener(n, e, t)
    }
}
;
function hie(n, e) {
    return new fie(n,e)
}
var pie = class {
    encode(n) {
        return JSON.stringify(n)
    }
    decode(n) {
        return JSON.parse(n)
    }
}
  , mie = class extends WU {
    address;
    rpc_id;
    queue;
    options;
    autoconnect;
    ready;
    reconnect;
    reconnect_timer_id;
    reconnect_interval;
    max_reconnects;
    rest_options;
    current_reconnects;
    generate_request_id;
    socket;
    webSocketFactory;
    dataPack;
    constructor(n, e="ws://localhost:8080", {autoconnect: t=!0, reconnect: r=!0, reconnect_interval: s=1e3, max_reconnects: i=5, ...o}={}, a, l) {
        super(),
        this.webSocketFactory = n,
        this.queue = {},
        this.rpc_id = 0,
        this.address = e,
        this.autoconnect = t,
        this.ready = !1,
        this.reconnect = r,
        this.reconnect_timer_id = void 0,
        this.reconnect_interval = s,
        this.max_reconnects = i,
        this.rest_options = o,
        this.current_reconnects = 0,
        this.generate_request_id = a || ( () => typeof this.rpc_id == "number" ? ++this.rpc_id : Number(this.rpc_id) + 1),
        l ? this.dataPack = l : this.dataPack = new pie,
        this.autoconnect && this._connect(this.address, {
            autoconnect: this.autoconnect,
            reconnect: this.reconnect,
            reconnect_interval: this.reconnect_interval,
            max_reconnects: this.max_reconnects,
            ...this.rest_options
        })
    }
    connect() {
        this.socket || this._connect(this.address, {
            autoconnect: this.autoconnect,
            reconnect: this.reconnect,
            reconnect_interval: this.reconnect_interval,
            max_reconnects: this.max_reconnects,
            ...this.rest_options
        })
    }
    call(n, e, t, r) {
        return !r && typeof t == "object" && (r = t,
        t = null),
        new Promise( (s, i) => {
            if (!this.ready)
                return i(new Error("socket not ready"));
            const o = this.generate_request_id(n, e)
              , a = {
                jsonrpc: "2.0",
                method: n,
                params: e || void 0,
                id: o
            };
            this.socket.send(this.dataPack.encode(a), r, l => {
                if (l)
                    return i(l);
                this.queue[o] = {
                    promise: [s, i]
                },
                t && (this.queue[o].timeout = setTimeout( () => {
                    delete this.queue[o],
                    i(new Error("reply timeout"))
                }
                , t))
            }
            )
        }
        )
    }
    async login(n) {
        const e = await this.call("rpc.login", n);
        if (!e)
            throw new Error("authentication failed");
        return e
    }
    async listMethods() {
        return await this.call("__listMethods")
    }
    notify(n, e) {
        return new Promise( (t, r) => {
            if (!this.ready)
                return r(new Error("socket not ready"));
            const s = {
                jsonrpc: "2.0",
                method: n,
                params: e
            };
            this.socket.send(this.dataPack.encode(s), i => {
                if (i)
                    return r(i);
                t()
            }
            )
        }
        )
    }
    async subscribe(n) {
        typeof n == "string" && (n = [n]);
        const e = await this.call("rpc.on", n);
        if (typeof n == "string" && e[n] !== "ok")
            throw new Error("Failed subscribing to an event '" + n + "' with: " + e[n]);
        return e
    }
    async unsubscribe(n) {
        typeof n == "string" && (n = [n]);
        const e = await this.call("rpc.off", n);
        if (typeof n == "string" && e[n] !== "ok")
            throw new Error("Failed unsubscribing from an event with: " + e);
        return e
    }
    close(n, e) {
        this.socket && this.socket.close(n || 1e3, e)
    }
    setAutoReconnect(n) {
        this.reconnect = n
    }
    setReconnectInterval(n) {
        this.reconnect_interval = n
    }
    setMaxReconnects(n) {
        this.max_reconnects = n
    }
    getCurrentReconnects() {
        return this.current_reconnects
    }
    getMaxReconnects() {
        return this.max_reconnects
    }
    isReconnecting() {
        return this.reconnect_timer_id !== void 0
    }
    willReconnect() {
        return this.reconnect && (this.max_reconnects === 0 || this.current_reconnects < this.max_reconnects)
    }
    _connect(n, e) {
        clearTimeout(this.reconnect_timer_id),
        this.socket = this.webSocketFactory(n, e),
        this.socket.addEventListener("open", () => {
            this.ready = !0,
            this.emit("open"),
            this.current_reconnects = 0
        }
        ),
        this.socket.addEventListener("message", ({data: t}) => {
            t instanceof ArrayBuffer && (t = Mt.Buffer.from(t).toString());
            try {
                t = this.dataPack.decode(t)
            } catch {
                return
            }
            if (t.notification && this.listeners(t.notification).length) {
                if (!Object.keys(t.params).length)
                    return this.emit(t.notification);
                const r = [t.notification];
                if (t.params.constructor === Object)
                    r.push(t.params);
                else
                    for (let s = 0; s < t.params.length; s++)
                        r.push(t.params[s]);
                return Promise.resolve().then( () => {
                    this.emit.apply(this, r)
                }
                )
            }
            if (!this.queue[t.id])
                return t.method ? Promise.resolve().then( () => {
                    this.emit(t.method, t?.params)
                }
                ) : void 0;
            "error"in t == "result"in t && this.queue[t.id].promise[1](new Error('Server response malformed. Response must include either "result" or "error", but not both.')),
            this.queue[t.id].timeout && clearTimeout(this.queue[t.id].timeout),
            t.error ? this.queue[t.id].promise[1](t.error) : this.queue[t.id].promise[0](t.result),
            delete this.queue[t.id]
        }
        ),
        this.socket.addEventListener("error", t => this.emit("error", t)),
        this.socket.addEventListener("close", ({code: t, reason: r}) => {
            this.ready && setTimeout( () => this.emit("close", t, r), 0),
            this.ready = !1,
            this.socket = void 0,
            t !== 1e3 && (this.current_reconnects++,
            this.reconnect && (this.max_reconnects > this.current_reconnects || this.max_reconnects === 0) ? this.reconnect_timer_id = setTimeout( () => this._connect(n, e), this.reconnect_interval) : this.reconnect && this.max_reconnects > 0 && this.current_reconnects >= this.max_reconnects && setTimeout( () => this.emit("max_reconnects_reached", t, r), 1))
        }
        )
    }
}
;
const gie = BigInt(0)
  , jm = BigInt(1)
  , yie = BigInt(2)
  , bie = BigInt(7)
  , wie = BigInt(256)
  , vie = BigInt(113)
  , YU = []
  , KU = []
  , XU = [];
for (let n = 0, e = jm, t = 1, r = 0; n < 24; n++) {
    [t,r] = [r, (2 * t + 3 * r) % 5],
    YU.push(2 * (5 * r + t)),
    KU.push((n + 1) * (n + 2) / 2 % 64);
    let s = gie;
    for (let i = 0; i < 7; i++)
        e = (e << jm ^ (e >> bie) * vie) % wie,
        e & yie && (s ^= jm << (jm << BigInt(i)) - jm);
    XU.push(s)
}
const QU = pU(XU, !0)
  , xie = QU[0]
  , Eie = QU[1]
  , HM = (n, e, t) => t > 32 ? ore(n, e, t) : sre(n, e, t)
  , VM = (n, e, t) => t > 32 ? are(n, e, t) : ire(n, e, t);
function Sie(n, e=24) {
    const t = new Uint32Array(10);
    for (let r = 24 - e; r < 24; r++) {
        for (let o = 0; o < 10; o++)
            t[o] = n[o] ^ n[o + 10] ^ n[o + 20] ^ n[o + 30] ^ n[o + 40];
        for (let o = 0; o < 10; o += 2) {
            const a = (o + 8) % 10
              , l = (o + 2) % 10
              , u = t[l]
              , d = t[l + 1]
              , h = HM(u, d, 1) ^ t[a]
              , p = VM(u, d, 1) ^ t[a + 1];
            for (let g = 0; g < 50; g += 10)
                n[o + g] ^= h,
                n[o + g + 1] ^= p
        }
        let s = n[2]
          , i = n[3];
        for (let o = 0; o < 24; o++) {
            const a = KU[o]
              , l = HM(s, i, a)
              , u = VM(s, i, a)
              , d = YU[o];
            s = n[d],
            i = n[d + 1],
            n[d] = l,
            n[d + 1] = u
        }
        for (let o = 0; o < 50; o += 10) {
            for (let a = 0; a < 10; a++)
                t[a] = n[o + a];
            for (let a = 0; a < 10; a++)
                n[o + a] ^= ~t[(a + 2) % 10] & t[(a + 4) % 10]
        }
        n[0] ^= xie[r],
        n[1] ^= Eie[r]
    }
    Qu(t)
}
class a_ extends X8 {
    constructor(e, t, r, s=!1, i=24) {
        if (super(),
        this.pos = 0,
        this.posOut = 0,
        this.finished = !1,
        this.destroyed = !1,
        this.enableXOF = !1,
        this.blockLen = e,
        this.suffix = t,
        this.outputLen = r,
        this.enableXOF = s,
        this.rounds = i,
        Jp(r),
        !(0 < e && e < 200))
            throw new Error("only keccak-f1600 function is supported");
        this.state = new Uint8Array(200),
        this.state32 = Yne(this.state)
    }
    clone() {
        return this._cloneInto()
    }
    keccak() {
        mM(this.state32),
        Sie(this.state32, this.rounds),
        mM(this.state32),
        this.posOut = 0,
        this.pos = 0
    }
    update(e) {
        e0(this),
        e = Kv(e),
        Nc(e);
        const {blockLen: t, state: r} = this
          , s = e.length;
        for (let i = 0; i < s; ) {
            const o = Math.min(t - this.pos, s - i);
            for (let a = 0; a < o; a++)
                r[this.pos++] ^= e[i++];
            this.pos === t && this.keccak()
        }
        return this
    }
    finish() {
        if (this.finished)
            return;
        this.finished = !0;
        const {state: e, suffix: t, pos: r, blockLen: s} = this;
        e[r] ^= t,
        (t & 128) !== 0 && r === s - 1 && this.keccak(),
        e[s - 1] ^= 128,
        this.keccak()
    }
    writeInto(e) {
        e0(this, !1),
        Nc(e),
        this.finish();
        const t = this.state
          , {blockLen: r} = this;
        for (let s = 0, i = e.length; s < i; ) {
            this.posOut >= r && this.keccak();
            const o = Math.min(r - this.posOut, i - s);
            e.set(t.subarray(this.posOut, this.posOut + o), s),
            this.posOut += o,
            s += o
        }
        return e
    }
    xofInto(e) {
        if (!this.enableXOF)
            throw new Error("XOF is not possible for this instance");
        return this.writeInto(e)
    }
    xof(e) {
        return Jp(e),
        this.xofInto(new Uint8Array(e))
    }
    digestInto(e) {
        if (dU(e, this),
        this.finished)
            throw new Error("digest() was already called");
        return this.writeInto(e),
        this.destroy(),
        e
    }
    digest() {
        return this.digestInto(new Uint8Array(this.outputLen))
    }
    destroy() {
        this.destroyed = !0,
        Qu(this.state)
    }
    _cloneInto(e) {
        const {blockLen: t, suffix: r, outputLen: s, rounds: i, enableXOF: o} = this;
        return e || (e = new a_(t,r,s,o,i)),
        e.state32.set(this.state32),
        e.pos = this.pos,
        e.posOut = this.posOut,
        e.finished = this.finished,
        e.rounds = i,
        e.suffix = r,
        e.outputLen = s,
        e.enableXOF = o,
        e.destroyed = this.destroyed,
        e
    }
}
const Aie = (n, e, t) => Q8( () => new a_(e,n,t))
  , Cie = Aie(1, 136, 256 / 8);
class ZU extends X8 {
    constructor(e, t) {
        super(),
        this.finished = !1,
        this.destroyed = !1,
        uU(e);
        const r = Kv(t);
        if (this.iHash = e.create(),
        typeof this.iHash.update != "function")
            throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen,
        this.outputLen = this.iHash.outputLen;
        const s = this.blockLen
          , i = new Uint8Array(s);
        i.set(r.length > s ? e.create().update(r).digest() : r);
        for (let o = 0; o < i.length; o++)
            i[o] ^= 54;
        this.iHash.update(i),
        this.oHash = e.create();
        for (let o = 0; o < i.length; o++)
            i[o] ^= 106;
        this.oHash.update(i),
        Qu(i)
    }
    update(e) {
        return e0(this),
        this.iHash.update(e),
        this
    }
    digestInto(e) {
        e0(this),
        Nc(e, this.outputLen),
        this.finished = !0,
        this.iHash.digestInto(e),
        this.oHash.update(e),
        this.oHash.digestInto(e),
        this.destroy()
    }
    digest() {
        const e = new Uint8Array(this.oHash.outputLen);
        return this.digestInto(e),
        e
    }
    _cloneInto(e) {
        e || (e = Object.create(Object.getPrototypeOf(this), {}));
        const {oHash: t, iHash: r, finished: s, destroyed: i, blockLen: o, outputLen: a} = this;
        return e = e,
        e.finished = s,
        e.destroyed = i,
        e.blockLen = o,
        e.outputLen = a,
        e.oHash = t._cloneInto(e.oHash),
        e.iHash = r._cloneInto(e.iHash),
        e
    }
    clone() {
        return this._cloneInto()
    }
    destroy() {
        this.destroyed = !0,
        this.oHash.destroy(),
        this.iHash.destroy()
    }
}
const l_ = (n, e, t) => new ZU(n,e).update(t).digest();
l_.create = (n, e) => new ZU(n,e);
const qM = (n, e) => (n + (n >= 0 ? e : -e) / JU) / e;
function _ie(n, e, t) {
    const [[r,s],[i,o]] = e
      , a = qM(o * n, t)
      , l = qM(-s * n, t);
    let u = n - a * r - l * i
      , d = -a * s - l * o;
    const h = u < uc
      , p = d < uc;
    h && (u = -u),
    p && (d = -d);
    const g = My(Math.ceil(bU(t) / 2)) + Dp;
    if (u < uc || u >= g || d < uc || d >= g)
        throw new Error("splitScalar (endomorphism): failed, k=" + n);
    return {
        k1neg: h,
        k1: u,
        k2neg: p,
        k2: d
    }
}
function P4(n) {
    if (!["compact", "recovered", "der"].includes(n))
        throw new Error('Signature format must be "compact", "recovered", or "der"');
    return n
}
function s5(n, e) {
    const t = {};
    for (let r of Object.keys(e))
        t[r] = n[r] === void 0 ? e[r] : n[r];
    return Rf(t.lowS, "lowS"),
    Rf(t.prehash, "prehash"),
    t.format !== void 0 && P4(t.format),
    t
}
let kie = class extends Error {
    constructor(e="") {
        super(e)
    }
}
;
const Ql = {
    Err: kie,
    _tlv: {
        encode: (n, e) => {
            const {Err: t} = Ql;
            if (n < 0 || n > 256)
                throw new t("tlv.encode: wrong tag");
            if (e.length & 1)
                throw new t("tlv.encode: unpadded data");
            const r = e.length / 2
              , s = M1(r);
            if (s.length / 2 & 128)
                throw new t("tlv.encode: long form length too big");
            const i = r > 127 ? M1(s.length / 2 | 128) : "";
            return M1(n) + i + s + e
        }
        ,
        decode(n, e) {
            const {Err: t} = Ql;
            let r = 0;
            if (n < 0 || n > 256)
                throw new t("tlv.encode: wrong tag");
            if (e.length < 2 || e[r++] !== n)
                throw new t("tlv.decode: wrong tlv");
            const s = e[r++]
              , i = !!(s & 128);
            let o = 0;
            if (!i)
                o = s;
            else {
                const l = s & 127;
                if (!l)
                    throw new t("tlv.decode(long): indefinite length not supported");
                if (l > 4)
                    throw new t("tlv.decode(long): byte length is too big");
                const u = e.subarray(r, r + l);
                if (u.length !== l)
                    throw new t("tlv.decode: length bytes not complete");
                if (u[0] === 0)
                    throw new t("tlv.decode(long): zero leftmost byte");
                for (const d of u)
                    o = o << 8 | d;
                if (r += l,
                o < 128)
                    throw new t("tlv.decode(long): not minimal encoding")
            }
            const a = e.subarray(r, r + o);
            if (a.length !== o)
                throw new t("tlv.decode: wrong value length");
            return {
                v: a,
                l: e.subarray(r + o)
            }
        }
    },
    _int: {
        encode(n) {
            const {Err: e} = Ql;
            if (n < uc)
                throw new e("integer: negative integers are not allowed");
            let t = M1(n);
            if (Number.parseInt(t[0], 16) & 8 && (t = "00" + t),
            t.length & 1)
                throw new e("unexpected DER parsing assertion: unpadded hex");
            return t
        },
        decode(n) {
            const {Err: e} = Ql;
            if (n[0] & 128)
                throw new e("invalid signature integer: negative");
            if (n[0] === 0 && !(n[1] & 128))
                throw new e("invalid signature integer: unnecessary leading zero");
            return Qv(n)
        }
    },
    toSig(n) {
        const {Err: e, _int: t, _tlv: r} = Ql
          , s = hr("signature", n)
          , {v: i, l: o} = r.decode(48, s);
        if (o.length)
            throw new e("invalid signature: left bytes after parsing");
        const {v: a, l} = r.decode(2, i)
          , {v: u, l: d} = r.decode(2, l);
        if (d.length)
            throw new e("invalid signature: left bytes after parsing");
        return {
            r: t.decode(a),
            s: t.decode(u)
        }
    },
    hexFromSig(n) {
        const {_tlv: e, _int: t} = Ql
          , r = e.encode(2, t.encode(n.r))
          , s = e.encode(2, t.encode(n.s))
          , i = r + s;
        return e.encode(48, i)
    }
}
  , uc = BigInt(0)
  , Dp = BigInt(1)
  , JU = BigInt(2)
  , O1 = BigInt(3)
  , Nie = BigInt(4);
function gp(n, e) {
    const {BYTES: t} = n;
    let r;
    if (typeof e == "bigint")
        r = e;
    else {
        let s = hr("private key", e);
        try {
            r = n.fromBytes(s)
        } catch {
            throw new Error(`invalid private key: expected ui8a of size ${t}, got ${typeof e}`)
        }
    }
    if (!n.isValidNot0(r))
        throw new Error("invalid private key: out of range [1..N-1]");
    return r
}
function Die(n, e={}) {
    const t = RU("weierstrass", n, e)
      , {Fp: r, Fn: s} = t;
    let i = t.CURVE;
    const {h: o, n: a} = i;
    By(e, {}, {
        allowInfinityPoint: "boolean",
        clearCofactor: "function",
        isTorsionFree: "function",
        fromBytes: "function",
        toBytes: "function",
        endo: "object",
        wrapPrivateKey: "boolean"
    });
    const {endo: l} = e;
    if (l && (!r.is0(i.a) || typeof l.beta != "bigint" || !Array.isArray(l.basises)))
        throw new Error('invalid endo: expected "beta": bigint and "basises": array');
    const u = tz(r, s);
    function d() {
        if (!r.isOdd)
            throw new Error("compression is not supported: Field does not have .isOdd()")
    }
    function h(H, j, A) {
        const {x: E, y: C} = j.toAffine()
          , O = r.toBytes(E);
        if (Rf(A, "isCompressed"),
        A) {
            d();
            const z = !r.isOdd(C);
            return ra(ez(z), O)
        } else
            return ra(Uint8Array.of(4), O, r.toBytes(C))
    }
    function p(H) {
        oa(H, void 0, "Point");
        const {publicKey: j, publicKeyUncompressed: A} = u
          , E = H.length
          , C = H[0]
          , O = H.subarray(1);
        if (E === j && (C === 2 || C === 3)) {
            const z = r.fromBytes(O);
            if (!r.isValid(z))
                throw new Error("bad point: is not on curve, wrong x");
            const G = b(z);
            let Y;
            try {
                Y = r.sqrt(G)
            } catch (U) {
                const W = U instanceof Error ? ": " + U.message : "";
                throw new Error("bad point: is not on curve, sqrt error" + W)
            }
            d();
            const $ = r.isOdd(Y);
            return (C & 1) === 1 !== $ && (Y = r.neg(Y)),
            {
                x: z,
                y: Y
            }
        } else if (E === A && C === 4) {
            const z = r.BYTES
              , G = r.fromBytes(O.subarray(0, z))
              , Y = r.fromBytes(O.subarray(z, z * 2));
            if (!v(G, Y))
                throw new Error("bad point: is not on curve");
            return {
                x: G,
                y: Y
            }
        } else
            throw new Error(`bad point: got length ${E}, expected compressed=${j} or uncompressed=${A}`)
    }
    const g = e.toBytes || h
      , w = e.fromBytes || p;
    function b(H) {
        const j = r.sqr(H)
          , A = r.mul(j, H);
        return r.add(r.add(A, r.mul(H, i.a)), i.b)
    }
    function v(H, j) {
        const A = r.sqr(j)
          , E = b(H);
        return r.eql(A, E)
    }
    if (!v(i.Gx, i.Gy))
        throw new Error("bad curve params: generator point");
    const S = r.mul(r.pow(i.a, O1), Nie)
      , N = r.mul(r.sqr(i.b), BigInt(27));
    if (r.is0(r.add(S, N)))
        throw new Error("bad curve params: a or b");
    function _(H, j, A=!1) {
        if (!r.isValid(j) || A && r.is0(j))
            throw new Error(`bad point coordinate ${H}`);
        return j
    }
    function I(H) {
        if (!(H instanceof R))
            throw new Error("ProjectivePoint expected")
    }
    function k(H) {
        if (!l || !l.basises)
            throw new Error("no endo");
        return _ie(H, l.basises, s.ORDER)
    }
    const B = v2( (H, j) => {
        const {X: A, Y: E, Z: C} = H;
        if (r.eql(C, r.ONE))
            return {
                x: A,
                y: E
            };
        const O = H.is0();
        j == null && (j = O ? r.ONE : r.inv(C));
        const z = r.mul(A, j)
          , G = r.mul(E, j)
          , Y = r.mul(C, j);
        if (O)
            return {
                x: r.ZERO,
                y: r.ZERO
            };
        if (!r.eql(Y, r.ONE))
            throw new Error("invZ was invalid");
        return {
            x: z,
            y: G
        }
    }
    )
      , P = v2(H => {
        if (H.is0()) {
            if (e.allowInfinityPoint && !r.is0(H.Y))
                return;
            throw new Error("bad point: ZERO")
        }
        const {x: j, y: A} = H.toAffine();
        if (!r.isValid(j) || !r.isValid(A))
            throw new Error("bad point: x or y not field elements");
        if (!v(j, A))
            throw new Error("bad point: equation left != right");
        if (!H.isTorsionFree())
            throw new Error("bad point: not in prime-order subgroup");
        return !0
    }
    );
    function M(H, j, A, E, C) {
        return A = new R(r.mul(A.X, H),A.Y,A.Z),
        j = x2(E, j),
        A = x2(C, A),
        j.add(A)
    }
    class R {
        constructor(j, A, E) {
            this.X = _("x", j),
            this.Y = _("y", A, !0),
            this.Z = _("z", E),
            Object.freeze(this)
        }
        static CURVE() {
            return i
        }
        static fromAffine(j) {
            const {x: A, y: E} = j || {};
            if (!j || !r.isValid(A) || !r.isValid(E))
                throw new Error("invalid affine point");
            if (j instanceof R)
                throw new Error("projective point not allowed");
            return r.is0(A) && r.is0(E) ? R.ZERO : new R(A,E,r.ONE)
        }
        static fromBytes(j) {
            const A = R.fromAffine(w(oa(j, void 0, "point")));
            return A.assertValidity(),
            A
        }
        static fromHex(j) {
            return R.fromBytes(hr("pointHex", j))
        }
        get x() {
            return this.toAffine().x
        }
        get y() {
            return this.toAffine().y
        }
        precompute(j=8, A=!0) {
            return q.createCache(this, j),
            A || this.multiply(O1),
            this
        }
        assertValidity() {
            P(this)
        }
        hasEvenY() {
            const {y: j} = this.toAffine();
            if (!r.isOdd)
                throw new Error("Field doesn't support isOdd");
            return !r.isOdd(j)
        }
        equals(j) {
            I(j);
            const {X: A, Y: E, Z: C} = this
              , {X: O, Y: z, Z: G} = j
              , Y = r.eql(r.mul(A, G), r.mul(O, C))
              , $ = r.eql(r.mul(E, G), r.mul(z, C));
            return Y && $
        }
        negate() {
            return new R(this.X,r.neg(this.Y),this.Z)
        }
        double() {
            const {a: j, b: A} = i
              , E = r.mul(A, O1)
              , {X: C, Y: O, Z: z} = this;
            let G = r.ZERO
              , Y = r.ZERO
              , $ = r.ZERO
              , D = r.mul(C, C)
              , U = r.mul(O, O)
              , W = r.mul(z, z)
              , Q = r.mul(C, O);
            return Q = r.add(Q, Q),
            $ = r.mul(C, z),
            $ = r.add($, $),
            G = r.mul(j, $),
            Y = r.mul(E, W),
            Y = r.add(G, Y),
            G = r.sub(U, Y),
            Y = r.add(U, Y),
            Y = r.mul(G, Y),
            G = r.mul(Q, G),
            $ = r.mul(E, $),
            W = r.mul(j, W),
            Q = r.sub(D, W),
            Q = r.mul(j, Q),
            Q = r.add(Q, $),
            $ = r.add(D, D),
            D = r.add($, D),
            D = r.add(D, W),
            D = r.mul(D, Q),
            Y = r.add(Y, D),
            W = r.mul(O, z),
            W = r.add(W, W),
            D = r.mul(W, Q),
            G = r.sub(G, D),
            $ = r.mul(W, U),
            $ = r.add($, $),
            $ = r.add($, $),
            new R(G,Y,$)
        }
        add(j) {
            I(j);
            const {X: A, Y: E, Z: C} = this
              , {X: O, Y: z, Z: G} = j;
            let Y = r.ZERO
              , $ = r.ZERO
              , D = r.ZERO;
            const U = i.a
              , W = r.mul(i.b, O1);
            let Q = r.mul(A, O)
              , J = r.mul(E, z)
              , ne = r.mul(C, G)
              , ie = r.add(A, E)
              , ae = r.add(O, z);
            ie = r.mul(ie, ae),
            ae = r.add(Q, J),
            ie = r.sub(ie, ae),
            ae = r.add(A, C);
            let xe = r.add(O, G);
            return ae = r.mul(ae, xe),
            xe = r.add(Q, ne),
            ae = r.sub(ae, xe),
            xe = r.add(E, C),
            Y = r.add(z, G),
            xe = r.mul(xe, Y),
            Y = r.add(J, ne),
            xe = r.sub(xe, Y),
            D = r.mul(U, ae),
            Y = r.mul(W, ne),
            D = r.add(Y, D),
            Y = r.sub(J, D),
            D = r.add(J, D),
            $ = r.mul(Y, D),
            J = r.add(Q, Q),
            J = r.add(J, Q),
            ne = r.mul(U, ne),
            ae = r.mul(W, ae),
            J = r.add(J, ne),
            ne = r.sub(Q, ne),
            ne = r.mul(U, ne),
            ae = r.add(ae, ne),
            Q = r.mul(J, ae),
            $ = r.add($, Q),
            Q = r.mul(xe, ae),
            Y = r.mul(ie, Y),
            Y = r.sub(Y, Q),
            Q = r.mul(ie, J),
            D = r.mul(xe, D),
            D = r.add(D, Q),
            new R(Y,$,D)
        }
        subtract(j) {
            return this.add(j.negate())
        }
        is0() {
            return this.equals(R.ZERO)
        }
        multiply(j) {
            const {endo: A} = e;
            if (!s.isValidNot0(j))
                throw new Error("invalid scalar: out of range");
            let E, C;
            const O = z => q.cached(this, z, G => cf(R, G));
            if (A) {
                const {k1neg: z, k1: G, k2neg: Y, k2: $} = k(j)
                  , {p: D, f: U} = O(G)
                  , {p: W, f: Q} = O($);
                C = U.add(Q),
                E = M(A.beta, D, W, z, Y)
            } else {
                const {p: z, f: G} = O(j);
                E = z,
                C = G
            }
            return cf(R, [E, C])[0]
        }
        multiplyUnsafe(j) {
            const {endo: A} = e
              , E = this;
            if (!s.isValid(j))
                throw new Error("invalid scalar: out of range");
            if (j === uc || E.is0())
                return R.ZERO;
            if (j === Dp)
                return E;
            if (q.hasCache(this))
                return this.multiply(j);
            if (A) {
                const {k1neg: C, k1: O, k2neg: z, k2: G} = k(j)
                  , {p1: Y, p2: $} = Rre(R, E, O, G);
                return M(A.beta, Y, $, C, z)
            } else
                return q.unsafe(E, j)
        }
        multiplyAndAddUnsafe(j, A, E) {
            const C = this.multiplyUnsafe(A).add(j.multiplyUnsafe(E));
            return C.is0() ? void 0 : C
        }
        toAffine(j) {
            return B(this, j)
        }
        isTorsionFree() {
            const {isTorsionFree: j} = e;
            return o === Dp ? !0 : j ? j(R, this) : q.unsafe(this, a).is0()
        }
        clearCofactor() {
            const {clearCofactor: j} = e;
            return o === Dp ? this : j ? j(R, this) : this.multiplyUnsafe(o)
        }
        isSmallOrder() {
            return this.multiplyUnsafe(o).is0()
        }
        toBytes(j=!0) {
            return Rf(j, "isCompressed"),
            this.assertValidity(),
            g(R, this, j)
        }
        toHex(j=!0) {
            return Ef(this.toBytes(j))
        }
        toString() {
            return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`
        }
        get px() {
            return this.X
        }
        get py() {
            return this.X
        }
        get pz() {
            return this.Z
        }
        toRawBytes(j=!0) {
            return this.toBytes(j)
        }
        _setWindowSize(j) {
            this.precompute(j)
        }
        static normalizeZ(j) {
            return cf(R, j)
        }
        static msm(j, A) {
            return BU(R, s, j, A)
        }
        static fromPrivateKey(j) {
            return R.BASE.multiply(gp(s, j))
        }
    }
    R.BASE = new R(i.Gx,i.Gy,r.ONE),
    R.ZERO = new R(r.ZERO,r.ONE,r.ZERO),
    R.Fp = r,
    R.Fn = s;
    const L = s.BITS
      , q = new MU(R,e.endo ? Math.ceil(L / 2) : L);
    return R.BASE.precompute(8),
    R
}
function ez(n) {
    return Uint8Array.of(n ? 2 : 3)
}
function tz(n, e) {
    return {
        secretKey: e.BYTES,
        publicKey: 1 + n.BYTES,
        publicKeyUncompressed: 1 + 2 * n.BYTES,
        publicKeyHasPrefix: !0,
        signature: 2 * e.BYTES
    }
}
function Tie(n, e={}) {
    const {Fn: t} = n
      , r = e.randomBytes || Xv
      , s = Object.assign(tz(n.Fp, t), {
        seed: DU(t.ORDER)
    });
    function i(g) {
        try {
            return !!gp(t, g)
        } catch {
            return !1
        }
    }
    function o(g, w) {
        const {publicKey: b, publicKeyUncompressed: v} = s;
        try {
            const S = g.length;
            return w === !0 && S !== b || w === !1 && S !== v ? !1 : !!n.fromBytes(g)
        } catch {
            return !1
        }
    }
    function a(g=r(s.seed)) {
        return Ire(oa(g, s.seed, "seed"), t.ORDER)
    }
    function l(g, w=!0) {
        return n.BASE.multiply(gp(t, g)).toBytes(w)
    }
    function u(g) {
        const w = a(g);
        return {
            secretKey: w,
            publicKey: l(w)
        }
    }
    function d(g) {
        if (typeof g == "bigint")
            return !1;
        if (g instanceof n)
            return !0;
        const {secretKey: w, publicKey: b, publicKeyUncompressed: v} = s;
        if (t.allowedLengths || w === b)
            return;
        const S = hr("key", g).length;
        return S === b || S === v
    }
    function h(g, w, b=!0) {
        if (d(g) === !0)
            throw new Error("first arg must be private key");
        if (d(w) === !1)
            throw new Error("second arg must be public key");
        const v = gp(t, g);
        return n.fromHex(w).multiply(v).toBytes(b)
    }
    return Object.freeze({
        getPublicKey: l,
        getSharedSecret: h,
        keygen: u,
        Point: n,
        utils: {
            isValidSecretKey: i,
            isValidPublicKey: o,
            randomSecretKey: a,
            isValidPrivateKey: i,
            randomPrivateKey: a,
            normPrivateKeyToScalar: g => gp(t, g),
            precompute(g=8, w=n.BASE) {
                return w.precompute(g, !1)
            }
        },
        lengths: s
    })
}
function Iie(n, e, t={}) {
    uU(e),
    By(t, {}, {
        hmac: "function",
        lowS: "boolean",
        randomBytes: "function",
        bits2int: "function",
        bits2int_modN: "function"
    });
    const r = t.randomBytes || Xv
      , s = t.hmac || ( (A, ...E) => l_(e, A, ra(...E)))
      , {Fp: i, Fn: o} = n
      , {ORDER: a, BITS: l} = o
      , {keygen: u, getPublicKey: d, getSharedSecret: h, utils: p, lengths: g} = Tie(n, t)
      , w = {
        prehash: !1,
        lowS: typeof t.lowS == "boolean" ? t.lowS : !1,
        format: void 0,
        extraEntropy: !1
    }
      , b = "compact";
    function v(A) {
        const E = a >> Dp;
        return A > E
    }
    function S(A, E) {
        if (!o.isValidNot0(E))
            throw new Error(`invalid signature ${A}: out of range 1..Point.Fn.ORDER`);
        return E
    }
    function N(A, E) {
        P4(E);
        const C = g.signature
          , O = E === "compact" ? C : E === "recovered" ? C + 1 : void 0;
        return oa(A, O, `${E} signature`)
    }
    class _ {
        constructor(E, C, O) {
            this.r = S("r", E),
            this.s = S("s", C),
            O != null && (this.recovery = O),
            Object.freeze(this)
        }
        static fromBytes(E, C=b) {
            N(E, C);
            let O;
            if (C === "der") {
                const {r: $, s: D} = Ql.toSig(oa(E));
                return new _($,D)
            }
            C === "recovered" && (O = E[0],
            C = "compact",
            E = E.subarray(1));
            const z = o.BYTES
              , G = E.subarray(0, z)
              , Y = E.subarray(z, z * 2);
            return new _(o.fromBytes(G),o.fromBytes(Y),O)
        }
        static fromHex(E, C) {
            return this.fromBytes(w2(E), C)
        }
        addRecoveryBit(E) {
            return new _(this.r,this.s,E)
        }
        recoverPublicKey(E) {
            const C = i.ORDER
              , {r: O, s: z, recovery: G} = this;
            if (G == null || ![0, 1, 2, 3].includes(G))
                throw new Error("recovery id invalid");
            if (a * JU < C && G > 1)
                throw new Error("recovery id is ambiguous for h>1 curve");
            const $ = G === 2 || G === 3 ? O + a : O;
            if (!i.isValid($))
                throw new Error("recovery id 2 or 3 invalid");
            const D = i.toBytes($)
              , U = n.fromBytes(ra(ez((G & 1) === 0), D))
              , W = o.inv($)
              , Q = k(hr("msgHash", E))
              , J = o.create(-Q * W)
              , ne = o.create(z * W)
              , ie = n.BASE.multiplyUnsafe(J).add(U.multiplyUnsafe(ne));
            if (ie.is0())
                throw new Error("point at infinify");
            return ie.assertValidity(),
            ie
        }
        hasHighS() {
            return v(this.s)
        }
        toBytes(E=b) {
            if (P4(E),
            E === "der")
                return w2(Ql.hexFromSig(this));
            const C = o.toBytes(this.r)
              , O = o.toBytes(this.s);
            if (E === "recovered") {
                if (this.recovery == null)
                    throw new Error("recovery bit must be present");
                return ra(Uint8Array.of(this.recovery), C, O)
            }
            return ra(C, O)
        }
        toHex(E) {
            return Ef(this.toBytes(E))
        }
        assertValidity() {}
        static fromCompact(E) {
            return _.fromBytes(hr("sig", E), "compact")
        }
        static fromDER(E) {
            return _.fromBytes(hr("sig", E), "der")
        }
        normalizeS() {
            return this.hasHighS() ? new _(this.r,o.neg(this.s),this.recovery) : this
        }
        toDERRawBytes() {
            return this.toBytes("der")
        }
        toDERHex() {
            return Ef(this.toBytes("der"))
        }
        toCompactRawBytes() {
            return this.toBytes("compact")
        }
        toCompactHex() {
            return Ef(this.toBytes("compact"))
        }
    }
    const I = t.bits2int || function(E) {
        if (E.length > 8192)
            throw new Error("input is too large");
        const C = Qv(E)
          , O = E.length * 8 - l;
        return O > 0 ? C >> BigInt(O) : C
    }
      , k = t.bits2int_modN || function(E) {
        return o.create(I(E))
    }
      , B = My(l);
    function P(A) {
        return O4("num < 2^" + l, A, uc, B),
        o.toBytes(A)
    }
    function M(A, E) {
        return oa(A, void 0, "message"),
        E ? oa(e(A), void 0, "prehashed message") : A
    }
    function R(A, E, C) {
        if (["recovered", "canonical"].some(J => J in C))
            throw new Error("sign() legacy options not supported");
        const {lowS: O, prehash: z, extraEntropy: G} = s5(C, w);
        A = M(A, z);
        const Y = k(A)
          , $ = gp(o, E)
          , D = [P($), P(Y)];
        if (G != null && G !== !1) {
            const J = G === !0 ? r(g.secretKey) : G;
            D.push(hr("extraEntropy", J))
        }
        const U = ra(...D)
          , W = Y;
        function Q(J) {
            const ne = I(J);
            if (!o.isValidNot0(ne))
                return;
            const ie = o.inv(ne)
              , ae = n.BASE.multiply(ne).toAffine()
              , xe = o.create(ae.x);
            if (xe === uc)
                return;
            const ue = o.create(ie * o.create(W + xe * $));
            if (ue === uc)
                return;
            let ce = (ae.x === xe ? 0 : 2) | Number(ae.y & Dp)
              , me = ue;
            return O && v(ue) && (me = o.neg(ue),
            ce ^= 1),
            new _(xe,me,ce)
        }
        return {
            seed: U,
            k2sig: Q
        }
    }
    function L(A, E, C={}) {
        A = hr("message", A);
        const {seed: O, k2sig: z} = R(A, E, C);
        return xre(e.outputLen, o.BYTES, s)(O, z)
    }
    function q(A) {
        let E;
        const C = typeof A == "string" || Iy(A)
          , O = !C && A !== null && typeof A == "object" && typeof A.r == "bigint" && typeof A.s == "bigint";
        if (!C && !O)
            throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
        if (O)
            E = new _(A.r,A.s);
        else if (C) {
            try {
                E = _.fromBytes(hr("sig", A), "der")
            } catch (z) {
                if (!(z instanceof Ql.Err))
                    throw z
            }
            if (!E)
                try {
                    E = _.fromBytes(hr("sig", A), "compact")
                } catch {
                    return !1
                }
        }
        return E || !1
    }
    function H(A, E, C, O={}) {
        const {lowS: z, prehash: G, format: Y} = s5(O, w);
        if (C = hr("publicKey", C),
        E = M(hr("message", E), G),
        "strict"in O)
            throw new Error("options.strict was renamed to lowS");
        const $ = Y === void 0 ? q(A) : _.fromBytes(hr("sig", A), Y);
        if ($ === !1)
            return !1;
        try {
            const D = n.fromBytes(C);
            if (z && $.hasHighS())
                return !1;
            const {r: U, s: W} = $
              , Q = k(E)
              , J = o.inv(W)
              , ne = o.create(Q * J)
              , ie = o.create(U * J)
              , ae = n.BASE.multiplyUnsafe(ne).add(D.multiplyUnsafe(ie));
            return ae.is0() ? !1 : o.create(ae.x) === U
        } catch {
            return !1
        }
    }
    function j(A, E, C={}) {
        const {prehash: O} = s5(C, w);
        return E = M(E, O),
        _.fromBytes(A, "recovered").recoverPublicKey(E).toBytes()
    }
    return Object.freeze({
        keygen: u,
        getPublicKey: d,
        getSharedSecret: h,
        utils: p,
        lengths: g,
        Point: n,
        sign: L,
        verify: H,
        recoverPublicKey: j,
        Signature: _,
        hash: e
    })
}
function Mie(n) {
    const e = {
        a: n.a,
        b: n.b,
        p: n.Fp.ORDER,
        n: n.n,
        h: n.h,
        Gx: n.Gx,
        Gy: n.Gy
    }
      , t = n.Fp;
    let r = n.allowedPrivateKeyLengths ? Array.from(new Set(n.allowedPrivateKeyLengths.map(o => Math.ceil(o / 2)))) : void 0;
    const s = Vf(e.n, {
        BITS: n.nBitLength,
        allowedLengths: r,
        modFromBytes: n.wrapPrivateKey
    })
      , i = {
        Fp: t,
        Fn: s,
        allowInfinityPoint: n.allowInfinityPoint,
        endo: n.endo,
        isTorsionFree: n.isTorsionFree,
        clearCofactor: n.clearCofactor,
        fromBytes: n.fromBytes,
        toBytes: n.toBytes
    };
    return {
        CURVE: e,
        curveOpts: i
    }
}
function Bie(n) {
    const {CURVE: e, curveOpts: t} = Mie(n)
      , r = {
        hmac: n.hmac,
        randomBytes: n.randomBytes,
        lowS: n.lowS,
        bits2int: n.bits2int,
        bits2int_modN: n.bits2int_modN
    };
    return {
        CURVE: e,
        curveOpts: t,
        hash: n.hash,
        ecdsaOpts: r
    }
}
function Rie(n, e) {
    const t = e.Point;
    return Object.assign({}, e, {
        ProjectivePoint: t,
        CURVE: Object.assign({}, n, kU(t.Fn.ORDER, t.Fn.BITS))
    })
}
function Oie(n) {
    const {CURVE: e, curveOpts: t, hash: r, ecdsaOpts: s} = Bie(n)
      , i = Die(e, t)
      , o = Iie(i, r, s);
    return Rie(n, o)
}
function Pie(n, e) {
    const t = r => Oie({
        ...n,
        hash: r
    });
    return {
        ...t(e),
        create: t
    }
}
const c_ = {
    p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
    n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
    h: BigInt(1),
    a: BigInt(0),
    b: BigInt(7),
    Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
    Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
}
  , jie = {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    basises: [[BigInt("0x3086d221a7d46bcde86c90e49284eb15"), -BigInt("0xe4437ed6010e88286f547fa90abfe4c3")], [BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]
}
  , GM = BigInt(2);
function Lie(n) {
    const e = c_.p
      , t = BigInt(3)
      , r = BigInt(6)
      , s = BigInt(11)
      , i = BigInt(22)
      , o = BigInt(23)
      , a = BigInt(44)
      , l = BigInt(88)
      , u = n * n * n % e
      , d = u * u * n % e
      , h = dr(d, t, e) * d % e
      , p = dr(h, t, e) * d % e
      , g = dr(p, GM, e) * u % e
      , w = dr(g, s, e) * g % e
      , b = dr(w, i, e) * w % e
      , v = dr(b, a, e) * b % e
      , S = dr(v, l, e) * v % e
      , N = dr(S, a, e) * b % e
      , _ = dr(N, t, e) * d % e
      , I = dr(_, o, e) * w % e
      , k = dr(I, r, e) * u % e
      , B = dr(k, GM, e);
    if (!j4.eql(j4.sqr(B), n))
        throw new Error("Cannot find square root");
    return B
}
const j4 = Vf(c_.p, {
    sqrt: Lie
})
  , Fie = Pie({
    ...c_,
    Fp: j4,
    lowS: !0,
    endo: jie
}, Z8);
Ry.utils.randomPrivateKey;
Ry.getPublicKey;
function WM(n) {
    try {
        return Ry.ExtendedPoint.fromHex(n),
        !0
    } catch {
        return !1
    }
}
const Uie = (n, e) => Ry.sign(n, e.slice(0, 32))
  , zie = Ry.verify
  , gs = n => Mt.Buffer.isBuffer(n) ? n : n instanceof Uint8Array ? Mt.Buffer.from(n.buffer, n.byteOffset, n.byteLength) : Mt.Buffer.from(n);
class $ie {
    constructor(e) {
        Object.assign(this, e)
    }
    encode() {
        return Mt.Buffer.from(KS.serialize($w, this))
    }
    static decode(e) {
        return KS.deserialize($w, this, e)
    }
    static decodeUnchecked(e) {
        return KS.deserializeUnchecked($w, this, e)
    }
}
const $w = new Map;
var nz;
const Hie = 32
  , Vu = 32;
function Vie(n) {
    return n._bn !== void 0
}
let YM = 1;
class rt extends $ie {
    constructor(e) {
        if (super({}),
        this._bn = void 0,
        Vie(e))
            this._bn = e._bn;
        else {
            if (typeof e == "string") {
                const t = ws.decode(e);
                if (t.length != Vu)
                    throw new Error("Invalid public key input");
                this._bn = new DM(t)
            } else
                this._bn = new DM(e);
            if (this._bn.byteLength() > Vu)
                throw new Error("Invalid public key input")
        }
    }
    static unique() {
        const e = new rt(YM);
        return YM += 1,
        new rt(e.toBuffer())
    }
    equals(e) {
        return this._bn.eq(e._bn)
    }
    toBase58() {
        return ws.encode(this.toBytes())
    }
    toJSON() {
        return this.toBase58()
    }
    toBytes() {
        const e = this.toBuffer();
        return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)
    }
    toBuffer() {
        const e = this._bn.toArrayLike(Mt.Buffer);
        if (e.length === Vu)
            return e;
        const t = Mt.Buffer.alloc(32);
        return e.copy(t, 32 - e.length),
        t
    }
    get[Symbol.toStringTag]() {
        return `PublicKey(${this.toString()})`
    }
    toString() {
        return this.toBase58()
    }
    static async createWithSeed(e, t, r) {
        const s = Mt.Buffer.concat([e.toBuffer(), Mt.Buffer.from(t), r.toBuffer()])
          , i = BM(s);
        return new rt(i)
    }
    static createProgramAddressSync(e, t) {
        let r = Mt.Buffer.alloc(0);
        e.forEach(function(i) {
            if (i.length > Hie)
                throw new TypeError("Max seed length exceeded");
            r = Mt.Buffer.concat([r, gs(i)])
        }),
        r = Mt.Buffer.concat([r, t.toBuffer(), Mt.Buffer.from("ProgramDerivedAddress")]);
        const s = BM(r);
        if (WM(s))
            throw new Error("Invalid seeds, address must fall off the curve");
        return new rt(s)
    }
    static async createProgramAddress(e, t) {
        return this.createProgramAddressSync(e, t)
    }
    static findProgramAddressSync(e, t) {
        let r = 255, s;
        for (; r != 0; ) {
            try {
                const i = e.concat(Mt.Buffer.from([r]));
                s = this.createProgramAddressSync(i, t)
            } catch (i) {
                if (i instanceof TypeError)
                    throw i;
                r--;
                continue
            }
            return [s, r]
        }
        throw new Error("Unable to find a viable program address nonce")
    }
    static async findProgramAddress(e, t) {
        return this.findProgramAddressSync(e, t)
    }
    static isOnCurve(e) {
        const t = new rt(e);
        return WM(t.toBytes())
    }
}
nz = rt;
rt.default = new nz("11111111111111111111111111111111");
$w.set(rt, {
    kind: "struct",
    fields: [["_bn", "u256"]]
});
new rt("BPFLoader1111111111111111111111111111111111");
const Tp = 1232
  , rz = 127
  , sz = 64;
class iz extends Error {
    constructor(e) {
        super(`Signature ${e} has expired: block height exceeded.`),
        this.signature = void 0,
        this.signature = e
    }
}
Object.defineProperty(iz.prototype, "name", {
    value: "TransactionExpiredBlockheightExceededError"
});
class oz extends Error {
    constructor(e, t) {
        super(`Transaction was not confirmed in ${t.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${e} using the Solana Explorer or CLI tools.`),
        this.signature = void 0,
        this.signature = e
    }
}
Object.defineProperty(oz.prototype, "name", {
    value: "TransactionExpiredTimeoutError"
});
class yg extends Error {
    constructor(e) {
        super(`Signature ${e} has expired: the nonce is no longer valid.`),
        this.signature = void 0,
        this.signature = e
    }
}
Object.defineProperty(yg.prototype, "name", {
    value: "TransactionExpiredNonceInvalidError"
});
class k2 {
    constructor(e, t) {
        this.staticAccountKeys = void 0,
        this.accountKeysFromLookups = void 0,
        this.staticAccountKeys = e,
        this.accountKeysFromLookups = t
    }
    keySegments() {
        const e = [this.staticAccountKeys];
        return this.accountKeysFromLookups && (e.push(this.accountKeysFromLookups.writable),
        e.push(this.accountKeysFromLookups.readonly)),
        e
    }
    get(e) {
        for (const t of this.keySegments()) {
            if (e < t.length)
                return t[e];
            e -= t.length
        }
    }
    get length() {
        return this.keySegments().flat().length
    }
    compileInstructions(e) {
        if (this.length > 256)
            throw new Error("Account index overflow encountered during compilation");
        const r = new Map;
        this.keySegments().flat().forEach( (i, o) => {
            r.set(i.toBase58(), o)
        }
        );
        const s = i => {
            const o = r.get(i.toBase58());
            if (o === void 0)
                throw new Error("Encountered an unknown instruction account key during compilation");
            return o
        }
        ;
        return e.map(i => ({
            programIdIndex: s(i.programId),
            accountKeyIndexes: i.keys.map(o => s(o.pubkey)),
            data: i.data
        }))
    }
}
const Gt = (n="publicKey") => oe.blob(32, n)
  , yp = (n="string") => {
    const e = oe.struct([oe.u32("length"), oe.u32("lengthPadding"), oe.blob(oe.offset(oe.u32(), -8), "chars")], n)
      , t = e.decode.bind(e)
      , r = e.encode.bind(e)
      , s = e;
    return s.decode = (i, o) => t(i, o).chars.toString(),
    s.encode = (i, o, a) => {
        const l = {
            chars: Mt.Buffer.from(i, "utf8")
        };
        return r(l, o, a)
    }
    ,
    s.alloc = i => oe.u32().span + oe.u32().span + Mt.Buffer.from(i, "utf8").length,
    s
}
  , qie = (n="authorized") => oe.struct([Gt("staker"), Gt("withdrawer")], n)
  , Gie = (n="lockup") => oe.struct([oe.ns64("unixTimestamp"), oe.ns64("epoch"), Gt("custodian")], n)
  , Wie = (n="voteInit") => oe.struct([Gt("nodePubkey"), Gt("authorizedVoter"), Gt("authorizedWithdrawer"), oe.u8("commission")], n)
  , Yie = (n="voteAuthorizeWithSeedArgs") => oe.struct([oe.u32("voteAuthorizationType"), Gt("currentAuthorityDerivedKeyOwnerPubkey"), yp("currentAuthorityDerivedKeySeed"), Gt("newAuthorized")], n);
function az(n, e) {
    const t = s => {
        if (s.span >= 0)
            return s.span;
        if (typeof s.alloc == "function")
            return s.alloc(e[s.property]);
        if ("count"in s && "elementLayout"in s) {
            const i = e[s.property];
            if (Array.isArray(i))
                return i.length * t(s.elementLayout)
        } else if ("fields"in s)
            return az({
                layout: s
            }, e[s.property]);
        return 0
    }
    ;
    let r = 0;
    return n.layout.fields.forEach(s => {
        r += t(s)
    }
    ),
    r
}
function ko(n) {
    let e = 0
      , t = 0;
    for (; ; ) {
        let r = n.shift();
        if (e |= (r & 127) << t * 7,
        t += 1,
        (r & 128) === 0)
            break
    }
    return e
}
function No(n, e) {
    let t = e;
    for (; ; ) {
        let r = t & 127;
        if (t >>= 7,
        t == 0) {
            n.push(r);
            break
        } else
            r |= 128,
            n.push(r)
    }
}
function Rr(n, e) {
    if (!n)
        throw new Error(e || "Assertion failed")
}
class nx {
    constructor(e, t) {
        this.payer = void 0,
        this.keyMetaMap = void 0,
        this.payer = e,
        this.keyMetaMap = t
    }
    static compile(e, t) {
        const r = new Map
          , s = o => {
            const a = o.toBase58();
            let l = r.get(a);
            return l === void 0 && (l = {
                isSigner: !1,
                isWritable: !1,
                isInvoked: !1
            },
            r.set(a, l)),
            l
        }
          , i = s(t);
        i.isSigner = !0,
        i.isWritable = !0;
        for (const o of e) {
            s(o.programId).isInvoked = !0;
            for (const a of o.keys) {
                const l = s(a.pubkey);
                l.isSigner ||= a.isSigner,
                l.isWritable ||= a.isWritable
            }
        }
        return new nx(t,r)
    }
    getMessageComponents() {
        const e = [...this.keyMetaMap.entries()];
        Rr(e.length <= 256, "Max static account keys length exceeded");
        const t = e.filter( ([,l]) => l.isSigner && l.isWritable)
          , r = e.filter( ([,l]) => l.isSigner && !l.isWritable)
          , s = e.filter( ([,l]) => !l.isSigner && l.isWritable)
          , i = e.filter( ([,l]) => !l.isSigner && !l.isWritable)
          , o = {
            numRequiredSignatures: t.length + r.length,
            numReadonlySignedAccounts: r.length,
            numReadonlyUnsignedAccounts: i.length
        };
        {
            Rr(t.length > 0, "Expected at least one writable signer key");
            const [l] = t[0];
            Rr(l === this.payer.toBase58(), "Expected first writable signer key to be the fee payer")
        }
        const a = [...t.map( ([l]) => new rt(l)), ...r.map( ([l]) => new rt(l)), ...s.map( ([l]) => new rt(l)), ...i.map( ([l]) => new rt(l))];
        return [o, a]
    }
    extractTableLookup(e) {
        const [t,r] = this.drainKeysFoundInLookupTable(e.state.addresses, o => !o.isSigner && !o.isInvoked && o.isWritable)
          , [s,i] = this.drainKeysFoundInLookupTable(e.state.addresses, o => !o.isSigner && !o.isInvoked && !o.isWritable);
        if (!(t.length === 0 && s.length === 0))
            return [{
                accountKey: e.key,
                writableIndexes: t,
                readonlyIndexes: s
            }, {
                writable: r,
                readonly: i
            }]
    }
    drainKeysFoundInLookupTable(e, t) {
        const r = new Array
          , s = new Array;
        for (const [i,o] of this.keyMetaMap.entries())
            if (t(o)) {
                const a = new rt(i)
                  , l = e.findIndex(u => u.equals(a));
                l >= 0 && (Rr(l < 256, "Max lookup table index exceeded"),
                r.push(l),
                s.push(a),
                this.keyMetaMap.delete(i))
            }
        return [r, s]
    }
}
const lz = "Reached end of buffer unexpectedly";
function oc(n) {
    if (n.length === 0)
        throw new Error(lz);
    return n.shift()
}
function Do(n, ...e) {
    const [t] = e;
    if (e.length === 2 ? t + (e[1] ?? 0) > n.length : t >= n.length)
        throw new Error(lz);
    return n.splice(...e)
}
class Zu {
    constructor(e) {
        this.header = void 0,
        this.accountKeys = void 0,
        this.recentBlockhash = void 0,
        this.instructions = void 0,
        this.indexToProgramIds = new Map,
        this.header = e.header,
        this.accountKeys = e.accountKeys.map(t => new rt(t)),
        this.recentBlockhash = e.recentBlockhash,
        this.instructions = e.instructions,
        this.instructions.forEach(t => this.indexToProgramIds.set(t.programIdIndex, this.accountKeys[t.programIdIndex]))
    }
    get version() {
        return "legacy"
    }
    get staticAccountKeys() {
        return this.accountKeys
    }
    get compiledInstructions() {
        return this.instructions.map(e => ({
            programIdIndex: e.programIdIndex,
            accountKeyIndexes: e.accounts,
            data: ws.decode(e.data)
        }))
    }
    get addressTableLookups() {
        return []
    }
    getAccountKeys() {
        return new k2(this.staticAccountKeys)
    }
    static compile(e) {
        const t = nx.compile(e.instructions, e.payerKey)
          , [r,s] = t.getMessageComponents()
          , o = new k2(s).compileInstructions(e.instructions).map(a => ({
            programIdIndex: a.programIdIndex,
            accounts: a.accountKeyIndexes,
            data: ws.encode(a.data)
        }));
        return new Zu({
            header: r,
            accountKeys: s,
            recentBlockhash: e.recentBlockhash,
            instructions: o
        })
    }
    isAccountSigner(e) {
        return e < this.header.numRequiredSignatures
    }
    isAccountWritable(e) {
        const t = this.header.numRequiredSignatures;
        if (e >= this.header.numRequiredSignatures) {
            const r = e - t
              , i = this.accountKeys.length - t - this.header.numReadonlyUnsignedAccounts;
            return r < i
        } else {
            const r = t - this.header.numReadonlySignedAccounts;
            return e < r
        }
    }
    isProgramId(e) {
        return this.indexToProgramIds.has(e)
    }
    programIds() {
        return [...this.indexToProgramIds.values()]
    }
    nonProgramIds() {
        return this.accountKeys.filter( (e, t) => !this.isProgramId(t))
    }
    serialize() {
        const e = this.accountKeys.length;
        let t = [];
        No(t, e);
        const r = this.instructions.map(h => {
            const {accounts: p, programIdIndex: g} = h
              , w = Array.from(ws.decode(h.data));
            let b = [];
            No(b, p.length);
            let v = [];
            return No(v, w.length),
            {
                programIdIndex: g,
                keyIndicesCount: Mt.Buffer.from(b),
                keyIndices: p,
                dataLength: Mt.Buffer.from(v),
                data: w
            }
        }
        );
        let s = [];
        No(s, r.length);
        let i = Mt.Buffer.alloc(Tp);
        Mt.Buffer.from(s).copy(i);
        let o = s.length;
        r.forEach(h => {
            const g = oe.struct([oe.u8("programIdIndex"), oe.blob(h.keyIndicesCount.length, "keyIndicesCount"), oe.seq(oe.u8("keyIndex"), h.keyIndices.length, "keyIndices"), oe.blob(h.dataLength.length, "dataLength"), oe.seq(oe.u8("userdatum"), h.data.length, "data")]).encode(h, i, o);
            o += g
        }
        ),
        i = i.slice(0, o);
        const a = oe.struct([oe.blob(1, "numRequiredSignatures"), oe.blob(1, "numReadonlySignedAccounts"), oe.blob(1, "numReadonlyUnsignedAccounts"), oe.blob(t.length, "keyCount"), oe.seq(Gt("key"), e, "keys"), Gt("recentBlockhash")])
          , l = {
            numRequiredSignatures: Mt.Buffer.from([this.header.numRequiredSignatures]),
            numReadonlySignedAccounts: Mt.Buffer.from([this.header.numReadonlySignedAccounts]),
            numReadonlyUnsignedAccounts: Mt.Buffer.from([this.header.numReadonlyUnsignedAccounts]),
            keyCount: Mt.Buffer.from(t),
            keys: this.accountKeys.map(h => gs(h.toBytes())),
            recentBlockhash: ws.decode(this.recentBlockhash)
        };
        let u = Mt.Buffer.alloc(2048);
        const d = a.encode(l, u);
        return i.copy(u, d),
        u.slice(0, d + i.length)
    }
    static from(e) {
        let t = [...e];
        const r = oc(t);
        if (r !== (r & rz))
            throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");
        const s = oc(t)
          , i = oc(t)
          , o = ko(t);
        let a = [];
        for (let p = 0; p < o; p++) {
            const g = Do(t, 0, Vu);
            a.push(new rt(Mt.Buffer.from(g)))
        }
        const l = Do(t, 0, Vu)
          , u = ko(t);
        let d = [];
        for (let p = 0; p < u; p++) {
            const g = oc(t)
              , w = ko(t)
              , b = Do(t, 0, w)
              , v = ko(t)
              , S = Do(t, 0, v)
              , N = ws.encode(Mt.Buffer.from(S));
            d.push({
                programIdIndex: g,
                accounts: b,
                data: N
            })
        }
        const h = {
            header: {
                numRequiredSignatures: r,
                numReadonlySignedAccounts: s,
                numReadonlyUnsignedAccounts: i
            },
            recentBlockhash: ws.encode(Mt.Buffer.from(l)),
            accountKeys: a,
            instructions: d
        };
        return new Zu(h)
    }
}
class N2 {
    constructor(e) {
        this.header = void 0,
        this.staticAccountKeys = void 0,
        this.recentBlockhash = void 0,
        this.compiledInstructions = void 0,
        this.addressTableLookups = void 0,
        this.header = e.header,
        this.staticAccountKeys = e.staticAccountKeys,
        this.recentBlockhash = e.recentBlockhash,
        this.compiledInstructions = e.compiledInstructions,
        this.addressTableLookups = e.addressTableLookups
    }
    get version() {
        return 0
    }
    get numAccountKeysFromLookups() {
        let e = 0;
        for (const t of this.addressTableLookups)
            e += t.readonlyIndexes.length + t.writableIndexes.length;
        return e
    }
    getAccountKeys(e) {
        let t;
        if (e && "accountKeysFromLookups"in e && e.accountKeysFromLookups) {
            if (this.numAccountKeysFromLookups != e.accountKeysFromLookups.writable.length + e.accountKeysFromLookups.readonly.length)
                throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");
            t = e.accountKeysFromLookups
        } else if (e && "addressLookupTableAccounts"in e && e.addressLookupTableAccounts)
            t = this.resolveAddressTableLookups(e.addressLookupTableAccounts);
        else if (this.addressTableLookups.length > 0)
            throw new Error("Failed to get account keys because address table lookups were not resolved");
        return new k2(this.staticAccountKeys,t)
    }
    isAccountSigner(e) {
        return e < this.header.numRequiredSignatures
    }
    isAccountWritable(e) {
        const t = this.header.numRequiredSignatures
          , r = this.staticAccountKeys.length;
        if (e >= r) {
            const s = e - r
              , i = this.addressTableLookups.reduce( (o, a) => o + a.writableIndexes.length, 0);
            return s < i
        } else if (e >= this.header.numRequiredSignatures) {
            const s = e - t
              , o = r - t - this.header.numReadonlyUnsignedAccounts;
            return s < o
        } else {
            const s = t - this.header.numReadonlySignedAccounts;
            return e < s
        }
    }
    resolveAddressTableLookups(e) {
        const t = {
            writable: [],
            readonly: []
        };
        for (const r of this.addressTableLookups) {
            const s = e.find(i => i.key.equals(r.accountKey));
            if (!s)
                throw new Error(`Failed to find address lookup table account for table key ${r.accountKey.toBase58()}`);
            for (const i of r.writableIndexes)
                if (i < s.state.addresses.length)
                    t.writable.push(s.state.addresses[i]);
                else
                    throw new Error(`Failed to find address for index ${i} in address lookup table ${r.accountKey.toBase58()}`);
            for (const i of r.readonlyIndexes)
                if (i < s.state.addresses.length)
                    t.readonly.push(s.state.addresses[i]);
                else
                    throw new Error(`Failed to find address for index ${i} in address lookup table ${r.accountKey.toBase58()}`)
        }
        return t
    }
    static compile(e) {
        const t = nx.compile(e.instructions, e.payerKey)
          , r = new Array
          , s = {
            writable: new Array,
            readonly: new Array
        }
          , i = e.addressLookupTableAccounts || [];
        for (const d of i) {
            const h = t.extractTableLookup(d);
            if (h !== void 0) {
                const [p,{writable: g, readonly: w}] = h;
                r.push(p),
                s.writable.push(...g),
                s.readonly.push(...w)
            }
        }
        const [o,a] = t.getMessageComponents()
          , u = new k2(a,s).compileInstructions(e.instructions);
        return new N2({
            header: o,
            staticAccountKeys: a,
            recentBlockhash: e.recentBlockhash,
            compiledInstructions: u,
            addressTableLookups: r
        })
    }
    serialize() {
        const e = Array();
        No(e, this.staticAccountKeys.length);
        const t = this.serializeInstructions()
          , r = Array();
        No(r, this.compiledInstructions.length);
        const s = this.serializeAddressTableLookups()
          , i = Array();
        No(i, this.addressTableLookups.length);
        const o = oe.struct([oe.u8("prefix"), oe.struct([oe.u8("numRequiredSignatures"), oe.u8("numReadonlySignedAccounts"), oe.u8("numReadonlyUnsignedAccounts")], "header"), oe.blob(e.length, "staticAccountKeysLength"), oe.seq(Gt(), this.staticAccountKeys.length, "staticAccountKeys"), Gt("recentBlockhash"), oe.blob(r.length, "instructionsLength"), oe.blob(t.length, "serializedInstructions"), oe.blob(i.length, "addressTableLookupsLength"), oe.blob(s.length, "serializedAddressTableLookups")])
          , a = new Uint8Array(Tp)
          , u = o.encode({
            prefix: 128,
            header: this.header,
            staticAccountKeysLength: new Uint8Array(e),
            staticAccountKeys: this.staticAccountKeys.map(d => d.toBytes()),
            recentBlockhash: ws.decode(this.recentBlockhash),
            instructionsLength: new Uint8Array(r),
            serializedInstructions: t,
            addressTableLookupsLength: new Uint8Array(i),
            serializedAddressTableLookups: s
        }, a);
        return a.slice(0, u)
    }
    serializeInstructions() {
        let e = 0;
        const t = new Uint8Array(Tp);
        for (const r of this.compiledInstructions) {
            const s = Array();
            No(s, r.accountKeyIndexes.length);
            const i = Array();
            No(i, r.data.length);
            const o = oe.struct([oe.u8("programIdIndex"), oe.blob(s.length, "encodedAccountKeyIndexesLength"), oe.seq(oe.u8(), r.accountKeyIndexes.length, "accountKeyIndexes"), oe.blob(i.length, "encodedDataLength"), oe.blob(r.data.length, "data")]);
            e += o.encode({
                programIdIndex: r.programIdIndex,
                encodedAccountKeyIndexesLength: new Uint8Array(s),
                accountKeyIndexes: r.accountKeyIndexes,
                encodedDataLength: new Uint8Array(i),
                data: r.data
            }, t, e)
        }
        return t.slice(0, e)
    }
    serializeAddressTableLookups() {
        let e = 0;
        const t = new Uint8Array(Tp);
        for (const r of this.addressTableLookups) {
            const s = Array();
            No(s, r.writableIndexes.length);
            const i = Array();
            No(i, r.readonlyIndexes.length);
            const o = oe.struct([Gt("accountKey"), oe.blob(s.length, "encodedWritableIndexesLength"), oe.seq(oe.u8(), r.writableIndexes.length, "writableIndexes"), oe.blob(i.length, "encodedReadonlyIndexesLength"), oe.seq(oe.u8(), r.readonlyIndexes.length, "readonlyIndexes")]);
            e += o.encode({
                accountKey: r.accountKey.toBytes(),
                encodedWritableIndexesLength: new Uint8Array(s),
                writableIndexes: r.writableIndexes,
                encodedReadonlyIndexesLength: new Uint8Array(i),
                readonlyIndexes: r.readonlyIndexes
            }, t, e)
        }
        return t.slice(0, e)
    }
    static deserialize(e) {
        let t = [...e];
        const r = oc(t)
          , s = r & rz;
        Rr(r !== s, "Expected versioned message but received legacy message");
        const i = s;
        Rr(i === 0, `Expected versioned message with version 0 but found version ${i}`);
        const o = {
            numRequiredSignatures: oc(t),
            numReadonlySignedAccounts: oc(t),
            numReadonlyUnsignedAccounts: oc(t)
        }
          , a = []
          , l = ko(t);
        for (let w = 0; w < l; w++)
            a.push(new rt(Do(t, 0, Vu)));
        const u = ws.encode(Do(t, 0, Vu))
          , d = ko(t)
          , h = [];
        for (let w = 0; w < d; w++) {
            const b = oc(t)
              , v = ko(t)
              , S = Do(t, 0, v)
              , N = ko(t)
              , _ = new Uint8Array(Do(t, 0, N));
            h.push({
                programIdIndex: b,
                accountKeyIndexes: S,
                data: _
            })
        }
        const p = ko(t)
          , g = [];
        for (let w = 0; w < p; w++) {
            const b = new rt(Do(t, 0, Vu))
              , v = ko(t)
              , S = Do(t, 0, v)
              , N = ko(t)
              , _ = Do(t, 0, N);
            g.push({
                accountKey: b,
                writableIndexes: S,
                readonlyIndexes: _
            })
        }
        return new N2({
            header: o,
            staticAccountKeys: a,
            recentBlockhash: u,
            compiledInstructions: h,
            addressTableLookups: g
        })
    }
}
let wu = (function(n) {
    return n[n.BLOCKHEIGHT_EXCEEDED = 0] = "BLOCKHEIGHT_EXCEEDED",
    n[n.PROCESSED = 1] = "PROCESSED",
    n[n.TIMED_OUT = 2] = "TIMED_OUT",
    n[n.NONCE_INVALID = 3] = "NONCE_INVALID",
    n
}
)({});
const Kie = Mt.Buffer.alloc(sz).fill(0);
class Gi {
    constructor(e) {
        this.keys = void 0,
        this.programId = void 0,
        this.data = Mt.Buffer.alloc(0),
        this.programId = e.programId,
        this.keys = e.keys,
        e.data && (this.data = e.data)
    }
    toJSON() {
        return {
            keys: this.keys.map( ({pubkey: e, isSigner: t, isWritable: r}) => ({
                pubkey: e.toJSON(),
                isSigner: t,
                isWritable: r
            })),
            programId: this.programId.toJSON(),
            data: [...this.data]
        }
    }
}
class sa {
    get signature() {
        return this.signatures.length > 0 ? this.signatures[0].signature : null
    }
    constructor(e) {
        if (this.signatures = [],
        this.feePayer = void 0,
        this.instructions = [],
        this.recentBlockhash = void 0,
        this.lastValidBlockHeight = void 0,
        this.nonceInfo = void 0,
        this.minNonceContextSlot = void 0,
        this._message = void 0,
        this._json = void 0,
        !!e)
            if (e.feePayer && (this.feePayer = e.feePayer),
            e.signatures && (this.signatures = e.signatures),
            Object.prototype.hasOwnProperty.call(e, "nonceInfo")) {
                const {minContextSlot: t, nonceInfo: r} = e;
                this.minNonceContextSlot = t,
                this.nonceInfo = r
            } else if (Object.prototype.hasOwnProperty.call(e, "lastValidBlockHeight")) {
                const {blockhash: t, lastValidBlockHeight: r} = e;
                this.recentBlockhash = t,
                this.lastValidBlockHeight = r
            } else {
                const {recentBlockhash: t, nonceInfo: r} = e;
                r && (this.nonceInfo = r),
                this.recentBlockhash = t
            }
    }
    toJSON() {
        return {
            recentBlockhash: this.recentBlockhash || null,
            feePayer: this.feePayer ? this.feePayer.toJSON() : null,
            nonceInfo: this.nonceInfo ? {
                nonce: this.nonceInfo.nonce,
                nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()
            } : null,
            instructions: this.instructions.map(e => e.toJSON()),
            signers: this.signatures.map( ({publicKey: e}) => e.toJSON())
        }
    }
    add(...e) {
        if (e.length === 0)
            throw new Error("No instructions");
        return e.forEach(t => {
            "instructions"in t ? this.instructions = this.instructions.concat(t.instructions) : "data"in t && "programId"in t && "keys"in t ? this.instructions.push(t) : this.instructions.push(new Gi(t))
        }
        ),
        this
    }
    compileMessage() {
        if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json))
            return this._message;
        let e, t;
        if (this.nonceInfo ? (e = this.nonceInfo.nonce,
        this.instructions[0] != this.nonceInfo.nonceInstruction ? t = [this.nonceInfo.nonceInstruction, ...this.instructions] : t = this.instructions) : (e = this.recentBlockhash,
        t = this.instructions),
        !e)
            throw new Error("Transaction recentBlockhash required");
        t.length < 1 && console.warn("No instructions provided");
        let r;
        if (this.feePayer)
            r = this.feePayer;
        else if (this.signatures.length > 0 && this.signatures[0].publicKey)
            r = this.signatures[0].publicKey;
        else
            throw new Error("Transaction fee payer required");
        for (let b = 0; b < t.length; b++)
            if (t[b].programId === void 0)
                throw new Error(`Transaction instruction index ${b} has undefined program id`);
        const s = []
          , i = [];
        t.forEach(b => {
            b.keys.forEach(S => {
                i.push({
                    ...S
                })
            }
            );
            const v = b.programId.toString();
            s.includes(v) || s.push(v)
        }
        ),
        s.forEach(b => {
            i.push({
                pubkey: new rt(b),
                isSigner: !1,
                isWritable: !1
            })
        }
        );
        const o = [];
        i.forEach(b => {
            const v = b.pubkey.toString()
              , S = o.findIndex(N => N.pubkey.toString() === v);
            S > -1 ? (o[S].isWritable = o[S].isWritable || b.isWritable,
            o[S].isSigner = o[S].isSigner || b.isSigner) : o.push(b)
        }
        ),
        o.sort(function(b, v) {
            if (b.isSigner !== v.isSigner)
                return b.isSigner ? -1 : 1;
            if (b.isWritable !== v.isWritable)
                return b.isWritable ? -1 : 1;
            const S = {
                localeMatcher: "best fit",
                usage: "sort",
                sensitivity: "variant",
                ignorePunctuation: !1,
                numeric: !1,
                caseFirst: "lower"
            };
            return b.pubkey.toBase58().localeCompare(v.pubkey.toBase58(), "en", S)
        });
        const a = o.findIndex(b => b.pubkey.equals(r));
        if (a > -1) {
            const [b] = o.splice(a, 1);
            b.isSigner = !0,
            b.isWritable = !0,
            o.unshift(b)
        } else
            o.unshift({
                pubkey: r,
                isSigner: !0,
                isWritable: !0
            });
        for (const b of this.signatures) {
            const v = o.findIndex(S => S.pubkey.equals(b.publicKey));
            if (v > -1)
                o[v].isSigner || (o[v].isSigner = !0,
                console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."));
            else
                throw new Error(`unknown signer: ${b.publicKey.toString()}`)
        }
        let l = 0
          , u = 0
          , d = 0;
        const h = []
          , p = [];
        o.forEach( ({pubkey: b, isSigner: v, isWritable: S}) => {
            v ? (h.push(b.toString()),
            l += 1,
            S || (u += 1)) : (p.push(b.toString()),
            S || (d += 1))
        }
        );
        const g = h.concat(p)
          , w = t.map(b => {
            const {data: v, programId: S} = b;
            return {
                programIdIndex: g.indexOf(S.toString()),
                accounts: b.keys.map(N => g.indexOf(N.pubkey.toString())),
                data: ws.encode(v)
            }
        }
        );
        return w.forEach(b => {
            Rr(b.programIdIndex >= 0),
            b.accounts.forEach(v => Rr(v >= 0))
        }
        ),
        new Zu({
            header: {
                numRequiredSignatures: l,
                numReadonlySignedAccounts: u,
                numReadonlyUnsignedAccounts: d
            },
            accountKeys: g,
            recentBlockhash: e,
            instructions: w
        })
    }
    _compile() {
        const e = this.compileMessage()
          , t = e.accountKeys.slice(0, e.header.numRequiredSignatures);
        return this.signatures.length === t.length && this.signatures.every( (s, i) => t[i].equals(s.publicKey)) || (this.signatures = t.map(r => ({
            signature: null,
            publicKey: r
        }))),
        e
    }
    serializeMessage() {
        return this._compile().serialize()
    }
    async getEstimatedFee(e) {
        return (await e.getFeeForMessage(this.compileMessage())).value
    }
    setSigners(...e) {
        if (e.length === 0)
            throw new Error("No signers");
        const t = new Set;
        this.signatures = e.filter(r => {
            const s = r.toString();
            return t.has(s) ? !1 : (t.add(s),
            !0)
        }
        ).map(r => ({
            signature: null,
            publicKey: r
        }))
    }
    sign(...e) {
        if (e.length === 0)
            throw new Error("No signers");
        const t = new Set
          , r = [];
        for (const i of e) {
            const o = i.publicKey.toString();
            t.has(o) || (t.add(o),
            r.push(i))
        }
        this.signatures = r.map(i => ({
            signature: null,
            publicKey: i.publicKey
        }));
        const s = this._compile();
        this._partialSign(s, ...r)
    }
    partialSign(...e) {
        if (e.length === 0)
            throw new Error("No signers");
        const t = new Set
          , r = [];
        for (const i of e) {
            const o = i.publicKey.toString();
            t.has(o) || (t.add(o),
            r.push(i))
        }
        const s = this._compile();
        this._partialSign(s, ...r)
    }
    _partialSign(e, ...t) {
        const r = e.serialize();
        t.forEach(s => {
            const i = Uie(r, s.secretKey);
            this._addSignature(s.publicKey, gs(i))
        }
        )
    }
    addSignature(e, t) {
        this._compile(),
        this._addSignature(e, t)
    }
    _addSignature(e, t) {
        Rr(t.length === 64);
        const r = this.signatures.findIndex(s => e.equals(s.publicKey));
        if (r < 0)
            throw new Error(`unknown signer: ${e.toString()}`);
        this.signatures[r].signature = Mt.Buffer.from(t)
    }
    verifySignatures(e=!0) {
        return !this._getMessageSignednessErrors(this.serializeMessage(), e)
    }
    _getMessageSignednessErrors(e, t) {
        const r = {};
        for (const {signature: s, publicKey: i} of this.signatures)
            s === null ? t && (r.missing ||= []).push(i) : zie(s, e, i.toBytes()) || (r.invalid ||= []).push(i);
        return r.invalid || r.missing ? r : void 0
    }
    serialize(e) {
        const {requireAllSignatures: t, verifySignatures: r} = Object.assign({
            requireAllSignatures: !0,
            verifySignatures: !0
        }, e)
          , s = this.serializeMessage();
        if (r) {
            const i = this._getMessageSignednessErrors(s, t);
            if (i) {
                let o = "Signature verification failed.";
                throw i.invalid && (o += `
Invalid signature for public key${i.invalid.length === 1 ? "" : "(s)"} [\`${i.invalid.map(a => a.toBase58()).join("`, `")}\`].`),
                i.missing && (o += `
Missing signature for public key${i.missing.length === 1 ? "" : "(s)"} [\`${i.missing.map(a => a.toBase58()).join("`, `")}\`].`),
                new Error(o)
            }
        }
        return this._serialize(s)
    }
    _serialize(e) {
        const {signatures: t} = this
          , r = [];
        No(r, t.length);
        const s = r.length + t.length * 64 + e.length
          , i = Mt.Buffer.alloc(s);
        return Rr(t.length < 256),
        Mt.Buffer.from(r).copy(i, 0),
        t.forEach( ({signature: o}, a) => {
            o !== null && (Rr(o.length === 64, "signature has invalid length"),
            Mt.Buffer.from(o).copy(i, r.length + a * 64))
        }
        ),
        e.copy(i, r.length + t.length * 64),
        Rr(i.length <= Tp, `Transaction too large: ${i.length} > ${Tp}`),
        i
    }
    get keys() {
        return Rr(this.instructions.length === 1),
        this.instructions[0].keys.map(e => e.pubkey)
    }
    get programId() {
        return Rr(this.instructions.length === 1),
        this.instructions[0].programId
    }
    get data() {
        return Rr(this.instructions.length === 1),
        this.instructions[0].data
    }
    static from(e) {
        let t = [...e];
        const r = ko(t);
        let s = [];
        for (let i = 0; i < r; i++) {
            const o = Do(t, 0, sz);
            s.push(ws.encode(Mt.Buffer.from(o)))
        }
        return sa.populate(Zu.from(t), s)
    }
    static populate(e, t=[]) {
        const r = new sa;
        return r.recentBlockhash = e.recentBlockhash,
        e.header.numRequiredSignatures > 0 && (r.feePayer = e.accountKeys[0]),
        t.forEach( (s, i) => {
            const o = {
                signature: s == ws.encode(Kie) ? null : ws.decode(s),
                publicKey: e.accountKeys[i]
            };
            r.signatures.push(o)
        }
        ),
        e.instructions.forEach(s => {
            const i = s.accounts.map(o => {
                const a = e.accountKeys[o];
                return {
                    pubkey: a,
                    isSigner: r.signatures.some(l => l.publicKey.toString() === a.toString()) || e.isAccountSigner(o),
                    isWritable: e.isAccountWritable(o)
                }
            }
            );
            r.instructions.push(new Gi({
                keys: i,
                programId: e.accountKeys[s.programIdIndex],
                data: ws.decode(s.data)
            }))
        }
        ),
        r._message = e,
        r._json = r.toJSON(),
        r
    }
}
const Xie = 160
  , Qie = 64
  , Zie = Xie / Qie
  , Jie = 1e3 / Zie;
new rt("SysvarC1ock11111111111111111111111111111111");
new rt("SysvarEpochSchedu1e111111111111111111111111");
new rt("Sysvar1nstructions1111111111111111111111111");
const i5 = new rt("SysvarRecentB1ockHashes11111111111111111111")
  , KM = new rt("SysvarRent111111111111111111111111111111111");
new rt("SysvarRewards111111111111111111111111111111");
new rt("SysvarS1otHashes111111111111111111111111111");
new rt("SysvarS1otHistory11111111111111111111111111");
new rt("SysvarStakeHistory1111111111111111111111111");
class XM extends Error {
    constructor({action: e, signature: t, transactionMessage: r, logs: s}) {
        const i = s ? `Logs: 
${JSON.stringify(s.slice(-10), null, 2)}. ` : ""
          , o = "\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.";
        let a;
        switch (e) {
        case "send":
            a = `Transaction ${t} resulted in an error. 
${r}. ` + i + o;
            break;
        case "simulate":
            a = `Simulation failed. 
Message: ${r}. 
` + i + o;
            break;
        default:
            a = `Unknown action '${(l => l)(e)}'`
        }
        super(a),
        this.signature = void 0,
        this.transactionMessage = void 0,
        this.transactionLogs = void 0,
        this.signature = t,
        this.transactionMessage = r,
        this.transactionLogs = s || void 0
    }
    get transactionError() {
        return {
            message: this.transactionMessage,
            logs: Array.isArray(this.transactionLogs) ? this.transactionLogs : void 0
        }
    }
    get logs() {
        const e = this.transactionLogs;
        if (!(e != null && typeof e == "object" && "then"in e))
            return e
    }
    async getLogs(e) {
        return Array.isArray(this.transactionLogs) || (this.transactionLogs = new Promise( (t, r) => {
            e.getTransaction(this.signature).then(s => {
                if (s && s.meta && s.meta.logMessages) {
                    const i = s.meta.logMessages;
                    this.transactionLogs = i,
                    t(i)
                } else
                    r(new Error("Log messages not found"))
            }
            ).catch(r)
        }
        )),
        await this.transactionLogs
    }
}
class gt extends Error {
    constructor({code: e, message: t, data: r}, s) {
        super(s != null ? `${s}: ${t}` : t),
        this.code = void 0,
        this.data = void 0,
        this.code = e,
        this.data = r,
        this.name = "SolanaJSONRPCError"
    }
}
function lp(n) {
    return new Promise(e => setTimeout(e, n))
}
function go(n, e) {
    const t = n.layout.span >= 0 ? n.layout.span : az(n, e)
      , r = Mt.Buffer.alloc(t)
      , s = Object.assign({
        instruction: n.index
    }, e);
    return n.layout.encode(s, r),
    r
}
const eoe = oe.nu64("lamportsPerSignature")
  , cz = oe.struct([oe.u32("version"), oe.u32("state"), Gt("authorizedPubkey"), Gt("nonce"), oe.struct([eoe], "feeCalculator")])
  , QM = cz.span;
class u_ {
    constructor(e) {
        this.authorizedPubkey = void 0,
        this.nonce = void 0,
        this.feeCalculator = void 0,
        this.authorizedPubkey = e.authorizedPubkey,
        this.nonce = e.nonce,
        this.feeCalculator = e.feeCalculator
    }
    static fromAccountData(e) {
        const t = cz.decode(gs(e), 0);
        return new u_({
            authorizedPubkey: new rt(t.authorizedPubkey),
            nonce: new rt(t.nonce).toString(),
            feeCalculator: t.feeCalculator
        })
    }
}
function r0(n) {
    const e = oe.blob(8, n)
      , t = e.decode.bind(e)
      , r = e.encode.bind(e)
      , s = e
      , i = Mse();
    return s.decode = (o, a) => {
        const l = t(o, a);
        return i.decode(l)
    }
    ,
    s.encode = (o, a, l) => {
        const u = i.encode(o);
        return r(u, a, l)
    }
    ,
    s
}
const yo = Object.freeze({
    Create: {
        index: 0,
        layout: oe.struct([oe.u32("instruction"), oe.ns64("lamports"), oe.ns64("space"), Gt("programId")])
    },
    Assign: {
        index: 1,
        layout: oe.struct([oe.u32("instruction"), Gt("programId")])
    },
    Transfer: {
        index: 2,
        layout: oe.struct([oe.u32("instruction"), r0("lamports")])
    },
    CreateWithSeed: {
        index: 3,
        layout: oe.struct([oe.u32("instruction"), Gt("base"), yp("seed"), oe.ns64("lamports"), oe.ns64("space"), Gt("programId")])
    },
    AdvanceNonceAccount: {
        index: 4,
        layout: oe.struct([oe.u32("instruction")])
    },
    WithdrawNonceAccount: {
        index: 5,
        layout: oe.struct([oe.u32("instruction"), oe.ns64("lamports")])
    },
    InitializeNonceAccount: {
        index: 6,
        layout: oe.struct([oe.u32("instruction"), Gt("authorized")])
    },
    AuthorizeNonceAccount: {
        index: 7,
        layout: oe.struct([oe.u32("instruction"), Gt("authorized")])
    },
    Allocate: {
        index: 8,
        layout: oe.struct([oe.u32("instruction"), oe.ns64("space")])
    },
    AllocateWithSeed: {
        index: 9,
        layout: oe.struct([oe.u32("instruction"), Gt("base"), yp("seed"), oe.ns64("space"), Gt("programId")])
    },
    AssignWithSeed: {
        index: 10,
        layout: oe.struct([oe.u32("instruction"), Gt("base"), yp("seed"), Gt("programId")])
    },
    TransferWithSeed: {
        index: 11,
        layout: oe.struct([oe.u32("instruction"), r0("lamports"), yp("seed"), Gt("programId")])
    },
    UpgradeNonceAccount: {
        index: 12,
        layout: oe.struct([oe.u32("instruction")])
    }
});
class s0 {
    constructor() {}
    static createAccount(e) {
        const t = yo.Create
          , r = go(t, {
            lamports: e.lamports,
            space: e.space,
            programId: gs(e.programId.toBuffer())
        });
        return new Gi({
            keys: [{
                pubkey: e.fromPubkey,
                isSigner: !0,
                isWritable: !0
            }, {
                pubkey: e.newAccountPubkey,
                isSigner: !0,
                isWritable: !0
            }],
            programId: this.programId,
            data: r
        })
    }
    static transfer(e) {
        let t, r;
        if ("basePubkey"in e) {
            const s = yo.TransferWithSeed;
            t = go(s, {
                lamports: BigInt(e.lamports),
                seed: e.seed,
                programId: gs(e.programId.toBuffer())
            }),
            r = [{
                pubkey: e.fromPubkey,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: e.basePubkey,
                isSigner: !0,
                isWritable: !1
            }, {
                pubkey: e.toPubkey,
                isSigner: !1,
                isWritable: !0
            }]
        } else {
            const s = yo.Transfer;
            t = go(s, {
                lamports: BigInt(e.lamports)
            }),
            r = [{
                pubkey: e.fromPubkey,
                isSigner: !0,
                isWritable: !0
            }, {
                pubkey: e.toPubkey,
                isSigner: !1,
                isWritable: !0
            }]
        }
        return new Gi({
            keys: r,
            programId: this.programId,
            data: t
        })
    }
    static assign(e) {
        let t, r;
        if ("basePubkey"in e) {
            const s = yo.AssignWithSeed;
            t = go(s, {
                base: gs(e.basePubkey.toBuffer()),
                seed: e.seed,
                programId: gs(e.programId.toBuffer())
            }),
            r = [{
                pubkey: e.accountPubkey,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: e.basePubkey,
                isSigner: !0,
                isWritable: !1
            }]
        } else {
            const s = yo.Assign;
            t = go(s, {
                programId: gs(e.programId.toBuffer())
            }),
            r = [{
                pubkey: e.accountPubkey,
                isSigner: !0,
                isWritable: !0
            }]
        }
        return new Gi({
            keys: r,
            programId: this.programId,
            data: t
        })
    }
    static createAccountWithSeed(e) {
        const t = yo.CreateWithSeed
          , r = go(t, {
            base: gs(e.basePubkey.toBuffer()),
            seed: e.seed,
            lamports: e.lamports,
            space: e.space,
            programId: gs(e.programId.toBuffer())
        });
        let s = [{
            pubkey: e.fromPubkey,
            isSigner: !0,
            isWritable: !0
        }, {
            pubkey: e.newAccountPubkey,
            isSigner: !1,
            isWritable: !0
        }];
        return e.basePubkey.equals(e.fromPubkey) || s.push({
            pubkey: e.basePubkey,
            isSigner: !0,
            isWritable: !1
        }),
        new Gi({
            keys: s,
            programId: this.programId,
            data: r
        })
    }
    static createNonceAccount(e) {
        const t = new sa;
        "basePubkey"in e && "seed"in e ? t.add(s0.createAccountWithSeed({
            fromPubkey: e.fromPubkey,
            newAccountPubkey: e.noncePubkey,
            basePubkey: e.basePubkey,
            seed: e.seed,
            lamports: e.lamports,
            space: QM,
            programId: this.programId
        })) : t.add(s0.createAccount({
            fromPubkey: e.fromPubkey,
            newAccountPubkey: e.noncePubkey,
            lamports: e.lamports,
            space: QM,
            programId: this.programId
        }));
        const r = {
            noncePubkey: e.noncePubkey,
            authorizedPubkey: e.authorizedPubkey
        };
        return t.add(this.nonceInitialize(r)),
        t
    }
    static nonceInitialize(e) {
        const t = yo.InitializeNonceAccount
          , r = go(t, {
            authorized: gs(e.authorizedPubkey.toBuffer())
        })
          , s = {
            keys: [{
                pubkey: e.noncePubkey,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: i5,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: KM,
                isSigner: !1,
                isWritable: !1
            }],
            programId: this.programId,
            data: r
        };
        return new Gi(s)
    }
    static nonceAdvance(e) {
        const t = yo.AdvanceNonceAccount
          , r = go(t)
          , s = {
            keys: [{
                pubkey: e.noncePubkey,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: i5,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: e.authorizedPubkey,
                isSigner: !0,
                isWritable: !1
            }],
            programId: this.programId,
            data: r
        };
        return new Gi(s)
    }
    static nonceWithdraw(e) {
        const t = yo.WithdrawNonceAccount
          , r = go(t, {
            lamports: e.lamports
        });
        return new Gi({
            keys: [{
                pubkey: e.noncePubkey,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: e.toPubkey,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: i5,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: KM,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: e.authorizedPubkey,
                isSigner: !0,
                isWritable: !1
            }],
            programId: this.programId,
            data: r
        })
    }
    static nonceAuthorize(e) {
        const t = yo.AuthorizeNonceAccount
          , r = go(t, {
            authorized: gs(e.newAuthorizedPubkey.toBuffer())
        });
        return new Gi({
            keys: [{
                pubkey: e.noncePubkey,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: e.authorizedPubkey,
                isSigner: !0,
                isWritable: !1
            }],
            programId: this.programId,
            data: r
        })
    }
    static allocate(e) {
        let t, r;
        if ("basePubkey"in e) {
            const s = yo.AllocateWithSeed;
            t = go(s, {
                base: gs(e.basePubkey.toBuffer()),
                seed: e.seed,
                space: e.space,
                programId: gs(e.programId.toBuffer())
            }),
            r = [{
                pubkey: e.accountPubkey,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: e.basePubkey,
                isSigner: !0,
                isWritable: !1
            }]
        } else {
            const s = yo.Allocate;
            t = go(s, {
                space: e.space
            }),
            r = [{
                pubkey: e.accountPubkey,
                isSigner: !0,
                isWritable: !0
            }]
        }
        return new Gi({
            keys: r,
            programId: this.programId,
            data: t
        })
    }
}
s0.programId = new rt("11111111111111111111111111111111");
new rt("BPFLoader2111111111111111111111111111111111");
function toe(n) {
    return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n
}
var o5, ZM;
function noe() {
    if (ZM)
        return o5;
    ZM = 1;
    var n = Object.prototype.toString
      , e = Object.keys || function(r) {
        var s = [];
        for (var i in r)
            s.push(i);
        return s
    }
    ;
    function t(r, s) {
        var i, o, a, l, u, d, h;
        if (r === !0)
            return "true";
        if (r === !1)
            return "false";
        switch (typeof r) {
        case "object":
            if (r === null)
                return null;
            if (r.toJSON && typeof r.toJSON == "function")
                return t(r.toJSON(), s);
            if (h = n.call(r),
            h === "[object Array]") {
                for (a = "[",
                o = r.length - 1,
                i = 0; i < o; i++)
                    a += t(r[i], !0) + ",";
                return o > -1 && (a += t(r[i], !0)),
                a + "]"
            } else if (h === "[object Object]") {
                for (l = e(r).sort(),
                o = l.length,
                a = "",
                i = 0; i < o; )
                    u = l[i],
                    d = t(r[u], !1),
                    d !== void 0 && (a && (a += ","),
                    a += JSON.stringify(u) + ":" + d),
                    i++;
                return "{" + a + "}"
            } else
                return JSON.stringify(r);
        case "function":
        case "undefined":
            return s ? null : void 0;
        case "string":
            return JSON.stringify(r);
        default:
            return isFinite(r) ? r : null
        }
    }
    return o5 = function(r) {
        var s = t(r, !1);
        if (s !== void 0)
            return "" + s
    }
    ,
    o5
}
var roe = noe()
  , JM = toe(roe);
const Lm = 32;
function a5(n) {
    let e = 0;
    for (; n > 1; )
        n /= 2,
        e++;
    return e
}
function soe(n) {
    return n === 0 ? 1 : (n--,
    n |= n >> 1,
    n |= n >> 2,
    n |= n >> 4,
    n |= n >> 8,
    n |= n >> 16,
    n |= n >> 32,
    n + 1)
}
class ioe {
    constructor(e, t, r, s, i) {
        this.slotsPerEpoch = void 0,
        this.leaderScheduleSlotOffset = void 0,
        this.warmup = void 0,
        this.firstNormalEpoch = void 0,
        this.firstNormalSlot = void 0,
        this.slotsPerEpoch = e,
        this.leaderScheduleSlotOffset = t,
        this.warmup = r,
        this.firstNormalEpoch = s,
        this.firstNormalSlot = i
    }
    getEpoch(e) {
        return this.getEpochAndSlotIndex(e)[0]
    }
    getEpochAndSlotIndex(e) {
        if (e < this.firstNormalSlot) {
            const t = a5(soe(e + Lm + 1)) - a5(Lm) - 1
              , r = this.getSlotsInEpoch(t)
              , s = e - (r - Lm);
            return [t, s]
        } else {
            const t = e - this.firstNormalSlot
              , r = Math.floor(t / this.slotsPerEpoch)
              , s = this.firstNormalEpoch + r
              , i = t % this.slotsPerEpoch;
            return [s, i]
        }
    }
    getFirstSlotInEpoch(e) {
        return e <= this.firstNormalEpoch ? (Math.pow(2, e) - 1) * Lm : (e - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot
    }
    getLastSlotInEpoch(e) {
        return this.getFirstSlotInEpoch(e) + this.getSlotsInEpoch(e) - 1
    }
    getSlotsInEpoch(e) {
        return e < this.firstNormalEpoch ? Math.pow(2, e + a5(Lm)) : this.slotsPerEpoch
    }
}
var ooe = globalThis.fetch;
class aoe extends mie {
    constructor(e, t, r) {
        const s = i => {
            const o = hie(i, {
                autoconnect: !0,
                max_reconnects: 5,
                reconnect: !0,
                reconnect_interval: 1e3,
                ...t
            });
            return "socket"in o ? this.underlyingSocket = o.socket : this.underlyingSocket = o,
            o
        }
        ;
        super(s, e, t, r),
        this.underlyingSocket = void 0
    }
    call(...e) {
        const t = this.underlyingSocket?.readyState;
        return t === 1 ? super.call(...e) : Promise.reject(new Error("Tried to call a JSON-RPC method `" + e[0] + "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " + t + ")"))
    }
    notify(...e) {
        const t = this.underlyingSocket?.readyState;
        return t === 1 ? super.notify(...e) : Promise.reject(new Error("Tried to send a JSON-RPC notification `" + e[0] + "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " + t + ")"))
    }
}
function loe(n, e) {
    let t;
    try {
        t = n.layout.decode(e)
    } catch (r) {
        throw new Error("invalid instruction; " + r)
    }
    if (t.typeIndex !== n.index)
        throw new Error(`invalid account data; account type mismatch ${t.typeIndex} != ${n.index}`);
    return t
}
const eB = 56;
class tB {
    constructor(e) {
        this.key = void 0,
        this.state = void 0,
        this.key = e.key,
        this.state = e.state
    }
    isActive() {
        const e = BigInt("0xffffffffffffffff");
        return this.state.deactivationSlot === e
    }
    static deserialize(e) {
        const t = loe(coe, e)
          , r = e.length - eB;
        Rr(r >= 0, "lookup table is invalid"),
        Rr(r % 32 === 0, "lookup table is invalid");
        const s = r / 32
          , {addresses: i} = oe.struct([oe.seq(Gt(), s, "addresses")]).decode(e.slice(eB));
        return {
            deactivationSlot: t.deactivationSlot,
            lastExtendedSlot: t.lastExtendedSlot,
            lastExtendedSlotStartIndex: t.lastExtendedStartIndex,
            authority: t.authority.length !== 0 ? new rt(t.authority[0]) : void 0,
            addresses: i.map(o => new rt(o))
        }
    }
}
const coe = {
    index: 1,
    layout: oe.struct([oe.u32("typeIndex"), r0("deactivationSlot"), oe.nu64("lastExtendedSlot"), oe.u8("lastExtendedStartIndex"), oe.u8(), oe.seq(Gt(), oe.offset(oe.u8(), -1), "authority")])
}
  , uoe = /^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;
function doe(n) {
    const e = n.match(uoe);
    if (e == null)
        throw TypeError(`Failed to validate endpoint URL \`${n}\``);
    const [t,r,s,i] = e
      , o = n.startsWith("https:") ? "wss:" : "ws:"
      , a = s == null ? null : parseInt(s.slice(1), 10)
      , l = a == null ? "" : `:${a + 1}`;
    return `${o}//${r}${l}${i}`
}
const or = jy(i_(rt), Le(), n => new rt(n))
  , uz = o_([Le(), tr("base64")])
  , d_ = jy(i_(Mt.Buffer), uz, n => Mt.Buffer.from(n[0], "base64"))
  , foe = 30 * 1e3;
function hoe(n) {
    if (/^https?:/.test(n) === !1)
        throw new TypeError("Endpoint URL must start with `http:` or `https:`.");
    return n
}
function Ln(n) {
    let e, t;
    if (typeof n == "string")
        e = n;
    else if (n) {
        const {commitment: r, ...s} = n;
        e = r,
        t = s
    }
    return {
        commitment: e,
        config: t
    }
}
function nB(n) {
    return n.map(e => "memcmp"in e ? {
        ...e,
        memcmp: {
            ...e.memcmp,
            encoding: e.memcmp.encoding ?? "base58"
        }
    } : e)
}
function dz(n) {
    return si([Re({
        jsonrpc: tr("2.0"),
        id: Le(),
        result: n
    }), Re({
        jsonrpc: tr("2.0"),
        id: Le(),
        error: Re({
            code: k0(),
            message: Le(),
            data: bt(Fse())
        })
    })])
}
const poe = dz(k0());
function Pt(n) {
    return jy(dz(n), poe, e => "error"in e ? e : {
        ...e,
        result: ze(e.result, n)
    })
}
function vr(n) {
    return Pt(Re({
        context: Re({
            slot: be()
        }),
        value: n
    }))
}
function rx(n) {
    return Re({
        context: Re({
            slot: be()
        }),
        value: n
    })
}
function l5(n, e) {
    return n === 0 ? new N2({
        header: e.header,
        staticAccountKeys: e.accountKeys.map(t => new rt(t)),
        recentBlockhash: e.recentBlockhash,
        compiledInstructions: e.instructions.map(t => ({
            programIdIndex: t.programIdIndex,
            accountKeyIndexes: t.accounts,
            data: ws.decode(t.data)
        })),
        addressTableLookups: e.addressTableLookups
    }) : new Zu(e)
}
const moe = Re({
    foundation: be(),
    foundationTerm: be(),
    initial: be(),
    taper: be(),
    terminal: be()
})
  , goe = Pt(He(Ge(Re({
    epoch: be(),
    effectiveSlot: be(),
    amount: be(),
    postBalance: be(),
    commission: bt(Ge(be()))
}))))
  , yoe = He(Re({
    slot: be(),
    prioritizationFee: be()
}))
  , boe = Re({
    total: be(),
    validator: be(),
    foundation: be(),
    epoch: be()
})
  , woe = Re({
    epoch: be(),
    slotIndex: be(),
    slotsInEpoch: be(),
    absoluteSlot: be(),
    blockHeight: bt(be()),
    transactionCount: bt(be())
})
  , voe = Re({
    slotsPerEpoch: be(),
    leaderScheduleSlotOffset: be(),
    warmup: nl(),
    firstNormalEpoch: be(),
    firstNormalSlot: be()
})
  , xoe = zU(Le(), He(be()))
  , Gf = Ge(si([Re({}), Le()]))
  , Eoe = Re({
    err: Gf
})
  , Soe = tr("receivedSignature")
  , Aoe = Re({
    "solana-core": Le(),
    "feature-set": bt(be())
})
  , Coe = Re({
    program: Le(),
    programId: or,
    parsed: k0()
})
  , _oe = Re({
    programId: or,
    accounts: He(or),
    data: Le()
})
  , rB = vr(Re({
    err: Ge(si([Re({}), Le()])),
    logs: Ge(He(Le())),
    accounts: bt(Ge(He(Ge(Re({
        executable: nl(),
        owner: Le(),
        lamports: be(),
        data: He(Le()),
        rentEpoch: bt(be())
    }))))),
    unitsConsumed: bt(be()),
    returnData: bt(Ge(Re({
        programId: Le(),
        data: o_([Le(), tr("base64")])
    }))),
    innerInstructions: bt(Ge(He(Re({
        index: be(),
        instructions: He(si([Coe, _oe]))
    }))))
}))
  , koe = vr(Re({
    byIdentity: zU(Le(), He(be())),
    range: Re({
        firstSlot: be(),
        lastSlot: be()
    })
}));
function Noe(n, e, t, r, s, i) {
    const o = t || ooe;
    let a;
    i != null && console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments.");
    let l;
    return r && (l = async (d, h) => {
        const p = await new Promise( (g, w) => {
            try {
                r(d, h, (b, v) => g([b, v]))
            } catch (b) {
                w(b)
            }
        }
        );
        return await o(...p)
    }
    ),
    new cie(async (d, h) => {
        const p = {
            method: "POST",
            body: d,
            agent: a,
            headers: Object.assign({
                "Content-Type": "application/json"
            }, e || {}, Nae)
        };
        try {
            let g = 5, w, b = 500;
            for (; l ? w = await l(n, p) : w = await o(n, p),
            !(w.status !== 429 || s === !0 || (g -= 1,
            g === 0)); )
                console.error(`Server responded with ${w.status} ${w.statusText}.  Retrying after ${b}ms delay...`),
                await lp(b),
                b *= 2;
            const v = await w.text();
            w.ok ? h(null, v) : h(new Error(`${w.status} ${w.statusText}: ${v}`))
        } catch (g) {
            g instanceof Error && h(g)
        }
    }
    ,{})
}
function Doe(n) {
    return (e, t) => new Promise( (r, s) => {
        n.request(e, t, (i, o) => {
            if (i) {
                s(i);
                return
            }
            r(o)
        }
        )
    }
    )
}
function Toe(n) {
    return e => new Promise( (t, r) => {
        e.length === 0 && t([]);
        const s = e.map(i => n.request(i.methodName, i.args));
        n.request(s, (i, o) => {
            if (i) {
                r(i);
                return
            }
            t(o)
        }
        )
    }
    )
}
const Ioe = Pt(moe)
  , Moe = Pt(boe)
  , Boe = Pt(yoe)
  , Roe = Pt(woe)
  , Ooe = Pt(voe)
  , Poe = Pt(xoe)
  , joe = Pt(be())
  , Loe = vr(Re({
    total: be(),
    circulating: be(),
    nonCirculating: be(),
    nonCirculatingAccounts: He(or)
}))
  , L4 = Re({
    amount: Le(),
    uiAmount: Ge(be()),
    decimals: be(),
    uiAmountString: bt(Le())
})
  , Foe = vr(He(Re({
    address: or,
    amount: Le(),
    uiAmount: Ge(be()),
    decimals: be(),
    uiAmountString: bt(Le())
})))
  , Uoe = vr(He(Re({
    pubkey: or,
    account: Re({
        executable: nl(),
        owner: or,
        lamports: be(),
        data: d_,
        rentEpoch: be()
    })
})))
  , F4 = Re({
    program: Le(),
    parsed: k0(),
    space: be()
})
  , zoe = vr(He(Re({
    pubkey: or,
    account: Re({
        executable: nl(),
        owner: or,
        lamports: be(),
        data: F4,
        rentEpoch: be()
    })
})))
  , $oe = vr(He(Re({
    lamports: be(),
    address: or
})))
  , Zg = Re({
    executable: nl(),
    owner: or,
    lamports: be(),
    data: d_,
    rentEpoch: be()
})
  , Hoe = Re({
    pubkey: or,
    account: Zg
})
  , Voe = jy(si([i_(Mt.Buffer), F4]), si([uz, F4]), n => Array.isArray(n) ? ze(n, d_) : n)
  , U4 = Re({
    executable: nl(),
    owner: or,
    lamports: be(),
    data: Voe,
    rentEpoch: be()
})
  , qoe = Re({
    pubkey: or,
    account: U4
})
  , Goe = Re({
    state: si([tr("active"), tr("inactive"), tr("activating"), tr("deactivating")]),
    active: be(),
    inactive: be()
})
  , Woe = Pt(He(Re({
    signature: Le(),
    slot: be(),
    err: Gf,
    memo: Ge(Le()),
    blockTime: bt(Ge(be()))
})))
  , Yoe = Pt(He(Re({
    signature: Le(),
    slot: be(),
    err: Gf,
    memo: Ge(Le()),
    blockTime: bt(Ge(be()))
})))
  , Koe = Re({
    subscription: be(),
    result: rx(Zg)
})
  , Xoe = Re({
    pubkey: or,
    account: Zg
})
  , Qoe = Re({
    subscription: be(),
    result: rx(Xoe)
})
  , Zoe = Re({
    parent: be(),
    slot: be(),
    root: be()
})
  , Joe = Re({
    subscription: be(),
    result: Zoe
})
  , eae = si([Re({
    type: si([tr("firstShredReceived"), tr("completed"), tr("optimisticConfirmation"), tr("root")]),
    slot: be(),
    timestamp: be()
}), Re({
    type: tr("createdBank"),
    parent: be(),
    slot: be(),
    timestamp: be()
}), Re({
    type: tr("frozen"),
    slot: be(),
    timestamp: be(),
    stats: Re({
        numTransactionEntries: be(),
        numSuccessfulTransactions: be(),
        numFailedTransactions: be(),
        maxTransactionsPerEntry: be()
    })
}), Re({
    type: tr("dead"),
    slot: be(),
    timestamp: be(),
    err: Le()
})])
  , tae = Re({
    subscription: be(),
    result: eae
})
  , nae = Re({
    subscription: be(),
    result: rx(si([Eoe, Soe]))
})
  , rae = Re({
    subscription: be(),
    result: be()
})
  , sae = Re({
    pubkey: Le(),
    gossip: Ge(Le()),
    tpu: Ge(Le()),
    rpc: Ge(Le()),
    version: Ge(Le())
})
  , sB = Re({
    votePubkey: Le(),
    nodePubkey: Le(),
    activatedStake: be(),
    epochVoteAccount: nl(),
    epochCredits: He(o_([be(), be(), be()])),
    commission: be(),
    lastVote: be(),
    rootSlot: Ge(be())
})
  , iae = Pt(Re({
    current: He(sB),
    delinquent: He(sB)
}))
  , oae = si([tr("processed"), tr("confirmed"), tr("finalized")])
  , aae = Re({
    slot: be(),
    confirmations: Ge(be()),
    err: Gf,
    confirmationStatus: bt(oae)
})
  , lae = vr(He(Ge(aae)))
  , cae = Pt(be())
  , fz = Re({
    accountKey: or,
    writableIndexes: He(be()),
    readonlyIndexes: He(be())
})
  , f_ = Re({
    signatures: He(Le()),
    message: Re({
        accountKeys: He(Le()),
        header: Re({
            numRequiredSignatures: be(),
            numReadonlySignedAccounts: be(),
            numReadonlyUnsignedAccounts: be()
        }),
        instructions: He(Re({
            accounts: He(be()),
            data: Le(),
            programIdIndex: be()
        })),
        recentBlockhash: Le(),
        addressTableLookups: bt(He(fz))
    })
})
  , hz = Re({
    pubkey: or,
    signer: nl(),
    writable: nl(),
    source: bt(si([tr("transaction"), tr("lookupTable")]))
})
  , pz = Re({
    accountKeys: He(hz),
    signatures: He(Le())
})
  , mz = Re({
    parsed: k0(),
    program: Le(),
    programId: or
})
  , gz = Re({
    accounts: He(or),
    data: Le(),
    programId: or
})
  , uae = si([gz, mz])
  , dae = si([Re({
    parsed: k0(),
    program: Le(),
    programId: Le()
}), Re({
    accounts: He(Le()),
    data: Le(),
    programId: Le()
})])
  , yz = jy(uae, dae, n => "accounts"in n ? ze(n, gz) : ze(n, mz))
  , bz = Re({
    signatures: He(Le()),
    message: Re({
        accountKeys: He(hz),
        instructions: He(yz),
        recentBlockhash: Le(),
        addressTableLookups: bt(Ge(He(fz)))
    })
})
  , D2 = Re({
    accountIndex: be(),
    mint: Le(),
    owner: bt(Le()),
    programId: bt(Le()),
    uiTokenAmount: L4
})
  , wz = Re({
    writable: He(or),
    readonly: He(or)
})
  , sx = Re({
    err: Gf,
    fee: be(),
    innerInstructions: bt(Ge(He(Re({
        index: be(),
        instructions: He(Re({
            accounts: He(be()),
            data: Le(),
            programIdIndex: be()
        }))
    })))),
    preBalances: He(be()),
    postBalances: He(be()),
    logMessages: bt(Ge(He(Le()))),
    preTokenBalances: bt(Ge(He(D2))),
    postTokenBalances: bt(Ge(He(D2))),
    loadedAddresses: bt(wz),
    computeUnitsConsumed: bt(be()),
    costUnits: bt(be())
})
  , h_ = Re({
    err: Gf,
    fee: be(),
    innerInstructions: bt(Ge(He(Re({
        index: be(),
        instructions: He(yz)
    })))),
    preBalances: He(be()),
    postBalances: He(be()),
    logMessages: bt(Ge(He(Le()))),
    preTokenBalances: bt(Ge(He(D2))),
    postTokenBalances: bt(Ge(He(D2))),
    loadedAddresses: bt(wz),
    computeUnitsConsumed: bt(be()),
    costUnits: bt(be())
})
  , N0 = si([tr(0), tr("legacy")])
  , Wf = Re({
    pubkey: Le(),
    lamports: be(),
    postBalance: Ge(be()),
    rewardType: Ge(Le()),
    commission: bt(Ge(be()))
})
  , fae = Pt(Ge(Re({
    blockhash: Le(),
    previousBlockhash: Le(),
    parentSlot: be(),
    transactions: He(Re({
        transaction: f_,
        meta: Ge(sx),
        version: bt(N0)
    })),
    rewards: bt(He(Wf)),
    blockTime: Ge(be()),
    blockHeight: Ge(be())
})))
  , hae = Pt(Ge(Re({
    blockhash: Le(),
    previousBlockhash: Le(),
    parentSlot: be(),
    rewards: bt(He(Wf)),
    blockTime: Ge(be()),
    blockHeight: Ge(be())
})))
  , pae = Pt(Ge(Re({
    blockhash: Le(),
    previousBlockhash: Le(),
    parentSlot: be(),
    transactions: He(Re({
        transaction: pz,
        meta: Ge(sx),
        version: bt(N0)
    })),
    rewards: bt(He(Wf)),
    blockTime: Ge(be()),
    blockHeight: Ge(be())
})))
  , mae = Pt(Ge(Re({
    blockhash: Le(),
    previousBlockhash: Le(),
    parentSlot: be(),
    transactions: He(Re({
        transaction: bz,
        meta: Ge(h_),
        version: bt(N0)
    })),
    rewards: bt(He(Wf)),
    blockTime: Ge(be()),
    blockHeight: Ge(be())
})))
  , gae = Pt(Ge(Re({
    blockhash: Le(),
    previousBlockhash: Le(),
    parentSlot: be(),
    transactions: He(Re({
        transaction: pz,
        meta: Ge(h_),
        version: bt(N0)
    })),
    rewards: bt(He(Wf)),
    blockTime: Ge(be()),
    blockHeight: Ge(be())
})))
  , yae = Pt(Ge(Re({
    blockhash: Le(),
    previousBlockhash: Le(),
    parentSlot: be(),
    rewards: bt(He(Wf)),
    blockTime: Ge(be()),
    blockHeight: Ge(be())
})))
  , bae = Pt(Ge(Re({
    blockhash: Le(),
    previousBlockhash: Le(),
    parentSlot: be(),
    transactions: He(Re({
        transaction: f_,
        meta: Ge(sx)
    })),
    rewards: bt(He(Wf)),
    blockTime: Ge(be())
})))
  , iB = Pt(Ge(Re({
    blockhash: Le(),
    previousBlockhash: Le(),
    parentSlot: be(),
    signatures: He(Le()),
    blockTime: Ge(be())
})))
  , c5 = Pt(Ge(Re({
    slot: be(),
    meta: Ge(sx),
    blockTime: bt(Ge(be())),
    transaction: f_,
    version: bt(N0)
})))
  , P1 = Pt(Ge(Re({
    slot: be(),
    transaction: bz,
    meta: Ge(h_),
    blockTime: bt(Ge(be())),
    version: bt(N0)
})))
  , wae = vr(Re({
    blockhash: Le(),
    lastValidBlockHeight: be()
}))
  , vae = vr(nl())
  , xae = Re({
    slot: be(),
    numTransactions: be(),
    numSlots: be(),
    samplePeriodSecs: be()
})
  , Eae = Pt(He(xae))
  , Sae = vr(Ge(Re({
    feeCalculator: Re({
        lamportsPerSignature: be()
    })
})))
  , Aae = Pt(Le())
  , Cae = Pt(Le())
  , _ae = Re({
    err: Gf,
    logs: He(Le()),
    signature: Le()
})
  , kae = Re({
    result: rx(_ae),
    subscription: be()
})
  , Nae = {
    "solana-client": "js/1.0.0-maintenance"
};
class p_ {
    constructor(e, t) {
        this._commitment = void 0,
        this._confirmTransactionInitialTimeout = void 0,
        this._rpcEndpoint = void 0,
        this._rpcWsEndpoint = void 0,
        this._rpcClient = void 0,
        this._rpcRequest = void 0,
        this._rpcBatchRequest = void 0,
        this._rpcWebSocket = void 0,
        this._rpcWebSocketConnected = !1,
        this._rpcWebSocketHeartbeat = null,
        this._rpcWebSocketIdleTimeout = null,
        this._rpcWebSocketGeneration = 0,
        this._disableBlockhashCaching = !1,
        this._pollingBlockhash = !1,
        this._blockhashInfo = {
            latestBlockhash: null,
            lastFetch: 0,
            transactionSignatures: [],
            simulatedSignatures: []
        },
        this._nextClientSubscriptionId = 0,
        this._subscriptionDisposeFunctionsByClientSubscriptionId = {},
        this._subscriptionHashByClientSubscriptionId = {},
        this._subscriptionStateChangeCallbacksByHash = {},
        this._subscriptionCallbacksByServerSubscriptionId = {},
        this._subscriptionsByHash = {},
        this._subscriptionsAutoDisposedByRpc = new Set,
        this.getBlockHeight = ( () => {
            const u = {};
            return async d => {
                const {commitment: h, config: p} = Ln(d)
                  , g = this._buildArgs([], h, void 0, p)
                  , w = JM(g);
                return u[w] = u[w] ?? (async () => {
                    try {
                        const b = await this._rpcRequest("getBlockHeight", g)
                          , v = ze(b, Pt(be()));
                        if ("error"in v)
                            throw new gt(v.error,"failed to get block height information");
                        return v.result
                    } finally {
                        delete u[w]
                    }
                }
                )(),
                await u[w]
            }
        }
        )();
        let r, s, i, o, a, l;
        t && typeof t == "string" ? this._commitment = t : t && (this._commitment = t.commitment,
        this._confirmTransactionInitialTimeout = t.confirmTransactionInitialTimeout,
        r = t.wsEndpoint,
        s = t.httpHeaders,
        i = t.fetch,
        o = t.fetchMiddleware,
        a = t.disableRetryOnRateLimit,
        l = t.httpAgent),
        this._rpcEndpoint = hoe(e),
        this._rpcWsEndpoint = r || doe(e),
        this._rpcClient = Noe(e, s, i, o, a, l),
        this._rpcRequest = Doe(this._rpcClient),
        this._rpcBatchRequest = Toe(this._rpcClient),
        this._rpcWebSocket = new aoe(this._rpcWsEndpoint,{
            autoconnect: !1,
            max_reconnects: 1 / 0
        }),
        this._rpcWebSocket.on("open", this._wsOnOpen.bind(this)),
        this._rpcWebSocket.on("error", this._wsOnError.bind(this)),
        this._rpcWebSocket.on("close", this._wsOnClose.bind(this)),
        this._rpcWebSocket.on("accountNotification", this._wsOnAccountNotification.bind(this)),
        this._rpcWebSocket.on("programNotification", this._wsOnProgramAccountNotification.bind(this)),
        this._rpcWebSocket.on("slotNotification", this._wsOnSlotNotification.bind(this)),
        this._rpcWebSocket.on("slotsUpdatesNotification", this._wsOnSlotUpdatesNotification.bind(this)),
        this._rpcWebSocket.on("signatureNotification", this._wsOnSignatureNotification.bind(this)),
        this._rpcWebSocket.on("rootNotification", this._wsOnRootNotification.bind(this)),
        this._rpcWebSocket.on("logsNotification", this._wsOnLogsNotification.bind(this))
    }
    get commitment() {
        return this._commitment
    }
    get rpcEndpoint() {
        return this._rpcEndpoint
    }
    async getBalanceAndContext(e, t) {
        const {commitment: r, config: s} = Ln(t)
          , i = this._buildArgs([e.toBase58()], r, void 0, s)
          , o = await this._rpcRequest("getBalance", i)
          , a = ze(o, vr(be()));
        if ("error"in a)
            throw new gt(a.error,`failed to get balance for ${e.toBase58()}`);
        return a.result
    }
    async getBalance(e, t) {
        return await this.getBalanceAndContext(e, t).then(r => r.value).catch(r => {
            throw new Error("failed to get balance of account " + e.toBase58() + ": " + r)
        }
        )
    }
    async getBlockTime(e) {
        const t = await this._rpcRequest("getBlockTime", [e])
          , r = ze(t, Pt(Ge(be())));
        if ("error"in r)
            throw new gt(r.error,`failed to get block time for slot ${e}`);
        return r.result
    }
    async getMinimumLedgerSlot() {
        const e = await this._rpcRequest("minimumLedgerSlot", [])
          , t = ze(e, Pt(be()));
        if ("error"in t)
            throw new gt(t.error,"failed to get minimum ledger slot");
        return t.result
    }
    async getFirstAvailableBlock() {
        const e = await this._rpcRequest("getFirstAvailableBlock", [])
          , t = ze(e, joe);
        if ("error"in t)
            throw new gt(t.error,"failed to get first available block");
        return t.result
    }
    async getSupply(e) {
        let t = {};
        typeof e == "string" ? t = {
            commitment: e
        } : e ? t = {
            ...e,
            commitment: e && e.commitment || this.commitment
        } : t = {
            commitment: this.commitment
        };
        const r = await this._rpcRequest("getSupply", [t])
          , s = ze(r, Loe);
        if ("error"in s)
            throw new gt(s.error,"failed to get supply");
        return s.result
    }
    async getTokenSupply(e, t) {
        const r = this._buildArgs([e.toBase58()], t)
          , s = await this._rpcRequest("getTokenSupply", r)
          , i = ze(s, vr(L4));
        if ("error"in i)
            throw new gt(i.error,"failed to get token supply");
        return i.result
    }
    async getTokenAccountBalance(e, t) {
        const r = this._buildArgs([e.toBase58()], t)
          , s = await this._rpcRequest("getTokenAccountBalance", r)
          , i = ze(s, vr(L4));
        if ("error"in i)
            throw new gt(i.error,"failed to get token account balance");
        return i.result
    }
    async getTokenAccountsByOwner(e, t, r) {
        const {commitment: s, config: i} = Ln(r);
        let o = [e.toBase58()];
        "mint"in t ? o.push({
            mint: t.mint.toBase58()
        }) : o.push({
            programId: t.programId.toBase58()
        });
        const a = this._buildArgs(o, s, "base64", i)
          , l = await this._rpcRequest("getTokenAccountsByOwner", a)
          , u = ze(l, Uoe);
        if ("error"in u)
            throw new gt(u.error,`failed to get token accounts owned by account ${e.toBase58()}`);
        return u.result
    }
    async getParsedTokenAccountsByOwner(e, t, r) {
        let s = [e.toBase58()];
        "mint"in t ? s.push({
            mint: t.mint.toBase58()
        }) : s.push({
            programId: t.programId.toBase58()
        });
        const i = this._buildArgs(s, r, "jsonParsed")
          , o = await this._rpcRequest("getTokenAccountsByOwner", i)
          , a = ze(o, zoe);
        if ("error"in a)
            throw new gt(a.error,`failed to get token accounts owned by account ${e.toBase58()}`);
        return a.result
    }
    async getLargestAccounts(e) {
        const t = {
            ...e,
            commitment: e && e.commitment || this.commitment
        }
          , r = t.filter || t.commitment ? [t] : []
          , s = await this._rpcRequest("getLargestAccounts", r)
          , i = ze(s, $oe);
        if ("error"in i)
            throw new gt(i.error,"failed to get largest accounts");
        return i.result
    }
    async getTokenLargestAccounts(e, t) {
        const r = this._buildArgs([e.toBase58()], t)
          , s = await this._rpcRequest("getTokenLargestAccounts", r)
          , i = ze(s, Foe);
        if ("error"in i)
            throw new gt(i.error,"failed to get token largest accounts");
        return i.result
    }
    async getAccountInfoAndContext(e, t) {
        const {commitment: r, config: s} = Ln(t)
          , i = this._buildArgs([e.toBase58()], r, "base64", s)
          , o = await this._rpcRequest("getAccountInfo", i)
          , a = ze(o, vr(Ge(Zg)));
        if ("error"in a)
            throw new gt(a.error,`failed to get info about account ${e.toBase58()}`);
        return a.result
    }
    async getParsedAccountInfo(e, t) {
        const {commitment: r, config: s} = Ln(t)
          , i = this._buildArgs([e.toBase58()], r, "jsonParsed", s)
          , o = await this._rpcRequest("getAccountInfo", i)
          , a = ze(o, vr(Ge(U4)));
        if ("error"in a)
            throw new gt(a.error,`failed to get info about account ${e.toBase58()}`);
        return a.result
    }
    async getAccountInfo(e, t) {
        try {
            return (await this.getAccountInfoAndContext(e, t)).value
        } catch (r) {
            throw new Error("failed to get info about account " + e.toBase58() + ": " + r)
        }
    }
    async getMultipleParsedAccounts(e, t) {
        const {commitment: r, config: s} = Ln(t)
          , i = e.map(u => u.toBase58())
          , o = this._buildArgs([i], r, "jsonParsed", s)
          , a = await this._rpcRequest("getMultipleAccounts", o)
          , l = ze(a, vr(He(Ge(U4))));
        if ("error"in l)
            throw new gt(l.error,`failed to get info for accounts ${i}`);
        return l.result
    }
    async getMultipleAccountsInfoAndContext(e, t) {
        const {commitment: r, config: s} = Ln(t)
          , i = e.map(u => u.toBase58())
          , o = this._buildArgs([i], r, "base64", s)
          , a = await this._rpcRequest("getMultipleAccounts", o)
          , l = ze(a, vr(He(Ge(Zg))));
        if ("error"in l)
            throw new gt(l.error,`failed to get info for accounts ${i}`);
        return l.result
    }
    async getMultipleAccountsInfo(e, t) {
        return (await this.getMultipleAccountsInfoAndContext(e, t)).value
    }
    async getStakeActivation(e, t, r) {
        const {commitment: s, config: i} = Ln(t)
          , o = this._buildArgs([e.toBase58()], s, void 0, {
            ...i,
            epoch: r ?? i?.epoch
        })
          , a = await this._rpcRequest("getStakeActivation", o)
          , l = ze(a, Pt(Goe));
        if ("error"in l)
            throw new gt(l.error,`failed to get Stake Activation ${e.toBase58()}`);
        return l.result
    }
    async getProgramAccounts(e, t) {
        const {commitment: r, config: s} = Ln(t)
          , {encoding: i, ...o} = s || {}
          , a = this._buildArgs([e.toBase58()], r, i || "base64", {
            ...o,
            ...o.filters ? {
                filters: nB(o.filters)
            } : null
        })
          , l = await this._rpcRequest("getProgramAccounts", a)
          , u = He(Hoe)
          , d = o.withContext === !0 ? ze(l, vr(u)) : ze(l, Pt(u));
        if ("error"in d)
            throw new gt(d.error,`failed to get accounts owned by program ${e.toBase58()}`);
        return d.result
    }
    async getParsedProgramAccounts(e, t) {
        const {commitment: r, config: s} = Ln(t)
          , i = this._buildArgs([e.toBase58()], r, "jsonParsed", s)
          , o = await this._rpcRequest("getProgramAccounts", i)
          , a = ze(o, Pt(He(qoe)));
        if ("error"in a)
            throw new gt(a.error,`failed to get accounts owned by program ${e.toBase58()}`);
        return a.result
    }
    async confirmTransaction(e, t) {
        let r;
        if (typeof e == "string")
            r = e;
        else {
            const i = e;
            if (i.abortSignal?.aborted)
                return Promise.reject(i.abortSignal.reason);
            r = i.signature
        }
        let s;
        try {
            s = ws.decode(r)
        } catch {
            throw new Error("signature must be base58 encoded: " + r)
        }
        return Rr(s.length === 64, "signature has invalid length"),
        typeof e == "string" ? await this.confirmTransactionUsingLegacyTimeoutStrategy({
            commitment: t || this.commitment,
            signature: r
        }) : "lastValidBlockHeight"in e ? await this.confirmTransactionUsingBlockHeightExceedanceStrategy({
            commitment: t || this.commitment,
            strategy: e
        }) : await this.confirmTransactionUsingDurableNonceStrategy({
            commitment: t || this.commitment,
            strategy: e
        })
    }
    getCancellationPromise(e) {
        return new Promise( (t, r) => {
            e != null && (e.aborted ? r(e.reason) : e.addEventListener("abort", () => {
                r(e.reason)
            }
            ))
        }
        )
    }
    getTransactionConfirmationPromise({commitment: e, signature: t}) {
        let r, s, i = !1;
        const o = new Promise( (l, u) => {
            try {
                r = this.onSignature(t, (h, p) => {
                    r = void 0;
                    const g = {
                        context: p,
                        value: h
                    };
                    l({
                        __type: wu.PROCESSED,
                        response: g
                    })
                }
                , e);
                const d = new Promise(h => {
                    r == null ? h() : s = this._onSubscriptionStateChange(r, p => {
                        p === "subscribed" && h()
                    }
                    )
                }
                );
                (async () => {
                    if (await d,
                    i)
                        return;
                    const h = await this.getSignatureStatus(t);
                    if (i || h == null)
                        return;
                    const {context: p, value: g} = h;
                    if (g != null)
                        if (g?.err)
                            u(g.err);
                        else {
                            switch (e) {
                            case "confirmed":
                            case "single":
                            case "singleGossip":
                                {
                                    if (g.confirmationStatus === "processed")
                                        return;
                                    break
                                }
                            case "finalized":
                            case "max":
                            case "root":
                                {
                                    if (g.confirmationStatus === "processed" || g.confirmationStatus === "confirmed")
                                        return;
                                    break
                                }
                            case "processed":
                            case "recent":
                            }
                            i = !0,
                            l({
                                __type: wu.PROCESSED,
                                response: {
                                    context: p,
                                    value: g
                                }
                            })
                        }
                }
                )()
            } catch (d) {
                u(d)
            }
        }
        );
        return {
            abortConfirmation: () => {
                s && (s(),
                s = void 0),
                r != null && (this.removeSignatureListener(r),
                r = void 0)
            }
            ,
            confirmationPromise: o
        }
    }
    async confirmTransactionUsingBlockHeightExceedanceStrategy({commitment: e, strategy: {abortSignal: t, lastValidBlockHeight: r, signature: s}}) {
        let i = !1;
        const o = new Promise(h => {
            const p = async () => {
                try {
                    return await this.getBlockHeight(e)
                } catch {
                    return -1
                }
            }
            ;
            (async () => {
                let g = await p();
                if (!i) {
                    for (; g <= r; )
                        if (await lp(1e3),
                        i || (g = await p(),
                        i))
                            return;
                    h({
                        __type: wu.BLOCKHEIGHT_EXCEEDED
                    })
                }
            }
            )()
        }
        )
          , {abortConfirmation: a, confirmationPromise: l} = this.getTransactionConfirmationPromise({
            commitment: e,
            signature: s
        })
          , u = this.getCancellationPromise(t);
        let d;
        try {
            const h = await Promise.race([u, l, o]);
            if (h.__type === wu.PROCESSED)
                d = h.response;
            else
                throw new iz(s)
        } finally {
            i = !0,
            a()
        }
        return d
    }
    async confirmTransactionUsingDurableNonceStrategy({commitment: e, strategy: {abortSignal: t, minContextSlot: r, nonceAccountPubkey: s, nonceValue: i, signature: o}}) {
        let a = !1;
        const l = new Promise(g => {
            let w = i
              , b = null;
            const v = async () => {
                try {
                    const {context: S, value: N} = await this.getNonceAndContext(s, {
                        commitment: e,
                        minContextSlot: r
                    });
                    return b = S.slot,
                    N?.nonce
                } catch {
                    return w
                }
            }
            ;
            (async () => {
                if (w = await v(),
                !a)
                    for (; ; ) {
                        if (i !== w) {
                            g({
                                __type: wu.NONCE_INVALID,
                                slotInWhichNonceDidAdvance: b
                            });
                            return
                        }
                        if (await lp(2e3),
                        a || (w = await v(),
                        a))
                            return
                    }
            }
            )()
        }
        )
          , {abortConfirmation: u, confirmationPromise: d} = this.getTransactionConfirmationPromise({
            commitment: e,
            signature: o
        })
          , h = this.getCancellationPromise(t);
        let p;
        try {
            const g = await Promise.race([h, d, l]);
            if (g.__type === wu.PROCESSED)
                p = g.response;
            else {
                let w;
                for (; ; ) {
                    const b = await this.getSignatureStatus(o);
                    if (b == null)
                        break;
                    if (b.context.slot < (g.slotInWhichNonceDidAdvance ?? r)) {
                        await lp(400);
                        continue
                    }
                    w = b;
                    break
                }
                if (w?.value) {
                    const b = e || "finalized"
                      , {confirmationStatus: v} = w.value;
                    switch (b) {
                    case "processed":
                    case "recent":
                        if (v !== "processed" && v !== "confirmed" && v !== "finalized")
                            throw new yg(o);
                        break;
                    case "confirmed":
                    case "single":
                    case "singleGossip":
                        if (v !== "confirmed" && v !== "finalized")
                            throw new yg(o);
                        break;
                    case "finalized":
                    case "max":
                    case "root":
                        if (v !== "finalized")
                            throw new yg(o);
                        break;
                    default:
                    }
                    p = {
                        context: w.context,
                        value: {
                            err: w.value.err
                        }
                    }
                } else
                    throw new yg(o)
            }
        } finally {
            a = !0,
            u()
        }
        return p
    }
    async confirmTransactionUsingLegacyTimeoutStrategy({commitment: e, signature: t}) {
        let r;
        const s = new Promise(l => {
            let u = this._confirmTransactionInitialTimeout || 6e4;
            switch (e) {
            case "processed":
            case "recent":
            case "single":
            case "confirmed":
            case "singleGossip":
                {
                    u = this._confirmTransactionInitialTimeout || 3e4;
                    break
                }
            }
            r = setTimeout( () => l({
                __type: wu.TIMED_OUT,
                timeoutMs: u
            }), u)
        }
        )
          , {abortConfirmation: i, confirmationPromise: o} = this.getTransactionConfirmationPromise({
            commitment: e,
            signature: t
        });
        let a;
        try {
            const l = await Promise.race([o, s]);
            if (l.__type === wu.PROCESSED)
                a = l.response;
            else
                throw new oz(t,l.timeoutMs / 1e3)
        } finally {
            clearTimeout(r),
            i()
        }
        return a
    }
    async getClusterNodes() {
        const e = await this._rpcRequest("getClusterNodes", [])
          , t = ze(e, Pt(He(sae)));
        if ("error"in t)
            throw new gt(t.error,"failed to get cluster nodes");
        return t.result
    }
    async getVoteAccounts(e) {
        const t = this._buildArgs([], e)
          , r = await this._rpcRequest("getVoteAccounts", t)
          , s = ze(r, iae);
        if ("error"in s)
            throw new gt(s.error,"failed to get vote accounts");
        return s.result
    }
    async getSlot(e) {
        const {commitment: t, config: r} = Ln(e)
          , s = this._buildArgs([], t, void 0, r)
          , i = await this._rpcRequest("getSlot", s)
          , o = ze(i, Pt(be()));
        if ("error"in o)
            throw new gt(o.error,"failed to get slot");
        return o.result
    }
    async getSlotLeader(e) {
        const {commitment: t, config: r} = Ln(e)
          , s = this._buildArgs([], t, void 0, r)
          , i = await this._rpcRequest("getSlotLeader", s)
          , o = ze(i, Pt(Le()));
        if ("error"in o)
            throw new gt(o.error,"failed to get slot leader");
        return o.result
    }
    async getSlotLeaders(e, t) {
        const r = [e, t]
          , s = await this._rpcRequest("getSlotLeaders", r)
          , i = ze(s, Pt(He(or)));
        if ("error"in i)
            throw new gt(i.error,"failed to get slot leaders");
        return i.result
    }
    async getSignatureStatus(e, t) {
        const {context: r, value: s} = await this.getSignatureStatuses([e], t);
        Rr(s.length === 1);
        const i = s[0];
        return {
            context: r,
            value: i
        }
    }
    async getSignatureStatuses(e, t) {
        const r = [e];
        t && r.push(t);
        const s = await this._rpcRequest("getSignatureStatuses", r)
          , i = ze(s, lae);
        if ("error"in i)
            throw new gt(i.error,"failed to get signature status");
        return i.result
    }
    async getTransactionCount(e) {
        const {commitment: t, config: r} = Ln(e)
          , s = this._buildArgs([], t, void 0, r)
          , i = await this._rpcRequest("getTransactionCount", s)
          , o = ze(i, Pt(be()));
        if ("error"in o)
            throw new gt(o.error,"failed to get transaction count");
        return o.result
    }
    async getTotalSupply(e) {
        return (await this.getSupply({
            commitment: e,
            excludeNonCirculatingAccountsList: !0
        })).value.total
    }
    async getInflationGovernor(e) {
        const t = this._buildArgs([], e)
          , r = await this._rpcRequest("getInflationGovernor", t)
          , s = ze(r, Ioe);
        if ("error"in s)
            throw new gt(s.error,"failed to get inflation");
        return s.result
    }
    async getInflationReward(e, t, r) {
        const {commitment: s, config: i} = Ln(r)
          , o = this._buildArgs([e.map(u => u.toBase58())], s, void 0, {
            ...i,
            epoch: t ?? i?.epoch
        })
          , a = await this._rpcRequest("getInflationReward", o)
          , l = ze(a, goe);
        if ("error"in l)
            throw new gt(l.error,"failed to get inflation reward");
        return l.result
    }
    async getInflationRate() {
        const e = await this._rpcRequest("getInflationRate", [])
          , t = ze(e, Moe);
        if ("error"in t)
            throw new gt(t.error,"failed to get inflation rate");
        return t.result
    }
    async getEpochInfo(e) {
        const {commitment: t, config: r} = Ln(e)
          , s = this._buildArgs([], t, void 0, r)
          , i = await this._rpcRequest("getEpochInfo", s)
          , o = ze(i, Roe);
        if ("error"in o)
            throw new gt(o.error,"failed to get epoch info");
        return o.result
    }
    async getEpochSchedule() {
        const e = await this._rpcRequest("getEpochSchedule", [])
          , t = ze(e, Ooe);
        if ("error"in t)
            throw new gt(t.error,"failed to get epoch schedule");
        const r = t.result;
        return new ioe(r.slotsPerEpoch,r.leaderScheduleSlotOffset,r.warmup,r.firstNormalEpoch,r.firstNormalSlot)
    }
    async getLeaderSchedule() {
        const e = await this._rpcRequest("getLeaderSchedule", [])
          , t = ze(e, Poe);
        if ("error"in t)
            throw new gt(t.error,"failed to get leader schedule");
        return t.result
    }
    async getMinimumBalanceForRentExemption(e, t) {
        const r = this._buildArgs([e], t)
          , s = await this._rpcRequest("getMinimumBalanceForRentExemption", r)
          , i = ze(s, cae);
        return "error"in i ? (console.warn("Unable to fetch minimum balance for rent exemption"),
        0) : i.result
    }
    async getRecentBlockhashAndContext(e) {
        const {context: t, value: {blockhash: r}} = await this.getLatestBlockhashAndContext(e);
        return {
            context: t,
            value: {
                blockhash: r,
                feeCalculator: {
                    get lamportsPerSignature() {
                        throw new Error("The capability to fetch `lamportsPerSignature` using the `getRecentBlockhash` API is no longer offered by the network. Use the `getFeeForMessage` API to obtain the fee for a given message.")
                    },
                    toJSON() {
                        return {}
                    }
                }
            }
        }
    }
    async getRecentPerformanceSamples(e) {
        const t = await this._rpcRequest("getRecentPerformanceSamples", e ? [e] : [])
          , r = ze(t, Eae);
        if ("error"in r)
            throw new gt(r.error,"failed to get recent performance samples");
        return r.result
    }
    async getFeeCalculatorForBlockhash(e, t) {
        const r = this._buildArgs([e], t)
          , s = await this._rpcRequest("getFeeCalculatorForBlockhash", r)
          , i = ze(s, Sae);
        if ("error"in i)
            throw new gt(i.error,"failed to get fee calculator");
        const {context: o, value: a} = i.result;
        return {
            context: o,
            value: a !== null ? a.feeCalculator : null
        }
    }
    async getFeeForMessage(e, t) {
        const r = gs(e.serialize()).toString("base64")
          , s = this._buildArgs([r], t)
          , i = await this._rpcRequest("getFeeForMessage", s)
          , o = ze(i, vr(Ge(be())));
        if ("error"in o)
            throw new gt(o.error,"failed to get fee for message");
        if (o.result === null)
            throw new Error("invalid blockhash");
        return o.result
    }
    async getRecentPrioritizationFees(e) {
        const t = e?.lockedWritableAccounts?.map(o => o.toBase58())
          , r = t?.length ? [t] : []
          , s = await this._rpcRequest("getRecentPrioritizationFees", r)
          , i = ze(s, Boe);
        if ("error"in i)
            throw new gt(i.error,"failed to get recent prioritization fees");
        return i.result
    }
    async getRecentBlockhash(e) {
        try {
            return (await this.getRecentBlockhashAndContext(e)).value
        } catch (t) {
            throw new Error("failed to get recent blockhash: " + t)
        }
    }
    async getLatestBlockhash(e) {
        try {
            return (await this.getLatestBlockhashAndContext(e)).value
        } catch (t) {
            throw new Error("failed to get recent blockhash: " + t)
        }
    }
    async getLatestBlockhashAndContext(e) {
        const {commitment: t, config: r} = Ln(e)
          , s = this._buildArgs([], t, void 0, r)
          , i = await this._rpcRequest("getLatestBlockhash", s)
          , o = ze(i, wae);
        if ("error"in o)
            throw new gt(o.error,"failed to get latest blockhash");
        return o.result
    }
    async isBlockhashValid(e, t) {
        const {commitment: r, config: s} = Ln(t)
          , i = this._buildArgs([e], r, void 0, s)
          , o = await this._rpcRequest("isBlockhashValid", i)
          , a = ze(o, vae);
        if ("error"in a)
            throw new gt(a.error,"failed to determine if the blockhash `" + e + "`is valid");
        return a.result
    }
    async getVersion() {
        const e = await this._rpcRequest("getVersion", [])
          , t = ze(e, Pt(Aoe));
        if ("error"in t)
            throw new gt(t.error,"failed to get version");
        return t.result
    }
    async getGenesisHash() {
        const e = await this._rpcRequest("getGenesisHash", [])
          , t = ze(e, Pt(Le()));
        if ("error"in t)
            throw new gt(t.error,"failed to get genesis hash");
        return t.result
    }
    async getBlock(e, t) {
        const {commitment: r, config: s} = Ln(t)
          , i = this._buildArgsAtLeastConfirmed([e], r, void 0, s)
          , o = await this._rpcRequest("getBlock", i);
        try {
            switch (s?.transactionDetails) {
            case "accounts":
                {
                    const a = ze(o, pae);
                    if ("error"in a)
                        throw a.error;
                    return a.result
                }
            case "none":
                {
                    const a = ze(o, hae);
                    if ("error"in a)
                        throw a.error;
                    return a.result
                }
            default:
                {
                    const a = ze(o, fae);
                    if ("error"in a)
                        throw a.error;
                    const {result: l} = a;
                    return l ? {
                        ...l,
                        transactions: l.transactions.map( ({transaction: u, meta: d, version: h}) => ({
                            meta: d,
                            transaction: {
                                ...u,
                                message: l5(h, u.message)
                            },
                            version: h
                        }))
                    } : null
                }
            }
        } catch (a) {
            throw new gt(a,"failed to get confirmed block")
        }
    }
    async getParsedBlock(e, t) {
        const {commitment: r, config: s} = Ln(t)
          , i = this._buildArgsAtLeastConfirmed([e], r, "jsonParsed", s)
          , o = await this._rpcRequest("getBlock", i);
        try {
            switch (s?.transactionDetails) {
            case "accounts":
                {
                    const a = ze(o, gae);
                    if ("error"in a)
                        throw a.error;
                    return a.result
                }
            case "none":
                {
                    const a = ze(o, yae);
                    if ("error"in a)
                        throw a.error;
                    return a.result
                }
            default:
                {
                    const a = ze(o, mae);
                    if ("error"in a)
                        throw a.error;
                    return a.result
                }
            }
        } catch (a) {
            throw new gt(a,"failed to get block")
        }
    }
    async getBlockProduction(e) {
        let t, r;
        if (typeof e == "string")
            r = e;
        else if (e) {
            const {commitment: a, ...l} = e;
            r = a,
            t = l
        }
        const s = this._buildArgs([], r, "base64", t)
          , i = await this._rpcRequest("getBlockProduction", s)
          , o = ze(i, koe);
        if ("error"in o)
            throw new gt(o.error,"failed to get block production information");
        return o.result
    }
    async getTransaction(e, t) {
        const {commitment: r, config: s} = Ln(t)
          , i = this._buildArgsAtLeastConfirmed([e], r, void 0, s)
          , o = await this._rpcRequest("getTransaction", i)
          , a = ze(o, c5);
        if ("error"in a)
            throw new gt(a.error,"failed to get transaction");
        const l = a.result;
        return l && {
            ...l,
            transaction: {
                ...l.transaction,
                message: l5(l.version, l.transaction.message)
            }
        }
    }
    async getParsedTransaction(e, t) {
        const {commitment: r, config: s} = Ln(t)
          , i = this._buildArgsAtLeastConfirmed([e], r, "jsonParsed", s)
          , o = await this._rpcRequest("getTransaction", i)
          , a = ze(o, P1);
        if ("error"in a)
            throw new gt(a.error,"failed to get transaction");
        return a.result
    }
    async getParsedTransactions(e, t) {
        const {commitment: r, config: s} = Ln(t)
          , i = e.map(l => ({
            methodName: "getTransaction",
            args: this._buildArgsAtLeastConfirmed([l], r, "jsonParsed", s)
        }));
        return (await this._rpcBatchRequest(i)).map(l => {
            const u = ze(l, P1);
            if ("error"in u)
                throw new gt(u.error,"failed to get transactions");
            return u.result
        }
        )
    }
    async getTransactions(e, t) {
        const {commitment: r, config: s} = Ln(t)
          , i = e.map(l => ({
            methodName: "getTransaction",
            args: this._buildArgsAtLeastConfirmed([l], r, void 0, s)
        }));
        return (await this._rpcBatchRequest(i)).map(l => {
            const u = ze(l, c5);
            if ("error"in u)
                throw new gt(u.error,"failed to get transactions");
            const d = u.result;
            return d && {
                ...d,
                transaction: {
                    ...d.transaction,
                    message: l5(d.version, d.transaction.message)
                }
            }
        }
        )
    }
    async getConfirmedBlock(e, t) {
        const r = this._buildArgsAtLeastConfirmed([e], t)
          , s = await this._rpcRequest("getBlock", r)
          , i = ze(s, bae);
        if ("error"in i)
            throw new gt(i.error,"failed to get confirmed block");
        const o = i.result;
        if (!o)
            throw new Error("Confirmed block " + e + " not found");
        const a = {
            ...o,
            transactions: o.transactions.map( ({transaction: l, meta: u}) => {
                const d = new Zu(l.message);
                return {
                    meta: u,
                    transaction: {
                        ...l,
                        message: d
                    }
                }
            }
            )
        };
        return {
            ...a,
            transactions: a.transactions.map( ({transaction: l, meta: u}) => ({
                meta: u,
                transaction: sa.populate(l.message, l.signatures)
            }))
        }
    }
    async getBlocks(e, t, r) {
        const s = this._buildArgsAtLeastConfirmed(t !== void 0 ? [e, t] : [e], r)
          , i = await this._rpcRequest("getBlocks", s)
          , o = ze(i, Pt(He(be())));
        if ("error"in o)
            throw new gt(o.error,"failed to get blocks");
        return o.result
    }
    async getBlockSignatures(e, t) {
        const r = this._buildArgsAtLeastConfirmed([e], t, void 0, {
            transactionDetails: "signatures",
            rewards: !1
        })
          , s = await this._rpcRequest("getBlock", r)
          , i = ze(s, iB);
        if ("error"in i)
            throw new gt(i.error,"failed to get block");
        const o = i.result;
        if (!o)
            throw new Error("Block " + e + " not found");
        return o
    }
    async getConfirmedBlockSignatures(e, t) {
        const r = this._buildArgsAtLeastConfirmed([e], t, void 0, {
            transactionDetails: "signatures",
            rewards: !1
        })
          , s = await this._rpcRequest("getBlock", r)
          , i = ze(s, iB);
        if ("error"in i)
            throw new gt(i.error,"failed to get confirmed block");
        const o = i.result;
        if (!o)
            throw new Error("Confirmed block " + e + " not found");
        return o
    }
    async getConfirmedTransaction(e, t) {
        const r = this._buildArgsAtLeastConfirmed([e], t)
          , s = await this._rpcRequest("getTransaction", r)
          , i = ze(s, c5);
        if ("error"in i)
            throw new gt(i.error,"failed to get transaction");
        const o = i.result;
        if (!o)
            return o;
        const a = new Zu(o.transaction.message)
          , l = o.transaction.signatures;
        return {
            ...o,
            transaction: sa.populate(a, l)
        }
    }
    async getParsedConfirmedTransaction(e, t) {
        const r = this._buildArgsAtLeastConfirmed([e], t, "jsonParsed")
          , s = await this._rpcRequest("getTransaction", r)
          , i = ze(s, P1);
        if ("error"in i)
            throw new gt(i.error,"failed to get confirmed transaction");
        return i.result
    }
    async getParsedConfirmedTransactions(e, t) {
        const r = e.map(o => ({
            methodName: "getTransaction",
            args: this._buildArgsAtLeastConfirmed([o], t, "jsonParsed")
        }));
        return (await this._rpcBatchRequest(r)).map(o => {
            const a = ze(o, P1);
            if ("error"in a)
                throw new gt(a.error,"failed to get confirmed transactions");
            return a.result
        }
        )
    }
    async getConfirmedSignaturesForAddress(e, t, r) {
        let s = {}
          , i = await this.getFirstAvailableBlock();
        for (; !("until"in s) && (t--,
        !(t <= 0 || t < i)); )
            try {
                const l = await this.getConfirmedBlockSignatures(t, "finalized");
                l.signatures.length > 0 && (s.until = l.signatures[l.signatures.length - 1].toString())
            } catch (l) {
                if (l instanceof Error && l.message.includes("skipped"))
                    continue;
                throw l
            }
        let o = await this.getSlot("finalized");
        for (; !("before"in s) && (r++,
        !(r > o)); )
            try {
                const l = await this.getConfirmedBlockSignatures(r);
                l.signatures.length > 0 && (s.before = l.signatures[l.signatures.length - 1].toString())
            } catch (l) {
                if (l instanceof Error && l.message.includes("skipped"))
                    continue;
                throw l
            }
        return (await this.getConfirmedSignaturesForAddress2(e, s)).map(l => l.signature)
    }
    async getConfirmedSignaturesForAddress2(e, t, r) {
        const s = this._buildArgsAtLeastConfirmed([e.toBase58()], r, void 0, t)
          , i = await this._rpcRequest("getConfirmedSignaturesForAddress2", s)
          , o = ze(i, Woe);
        if ("error"in o)
            throw new gt(o.error,"failed to get confirmed signatures for address");
        return o.result
    }
    async getSignaturesForAddress(e, t, r) {
        const s = this._buildArgsAtLeastConfirmed([e.toBase58()], r, void 0, t)
          , i = await this._rpcRequest("getSignaturesForAddress", s)
          , o = ze(i, Yoe);
        if ("error"in o)
            throw new gt(o.error,"failed to get signatures for address");
        return o.result
    }
    async getAddressLookupTable(e, t) {
        const {context: r, value: s} = await this.getAccountInfoAndContext(e, t);
        let i = null;
        return s !== null && (i = new tB({
            key: e,
            state: tB.deserialize(s.data)
        })),
        {
            context: r,
            value: i
        }
    }
    async getNonceAndContext(e, t) {
        const {context: r, value: s} = await this.getAccountInfoAndContext(e, t);
        let i = null;
        return s !== null && (i = u_.fromAccountData(s.data)),
        {
            context: r,
            value: i
        }
    }
    async getNonce(e, t) {
        return await this.getNonceAndContext(e, t).then(r => r.value).catch(r => {
            throw new Error("failed to get nonce for account " + e.toBase58() + ": " + r)
        }
        )
    }
    async requestAirdrop(e, t) {
        const r = await this._rpcRequest("requestAirdrop", [e.toBase58(), t])
          , s = ze(r, Aae);
        if ("error"in s)
            throw new gt(s.error,`airdrop to ${e.toBase58()} failed`);
        return s.result
    }
    async _blockhashWithExpiryBlockHeight(e) {
        if (!e) {
            for (; this._pollingBlockhash; )
                await lp(100);
            const r = Date.now() - this._blockhashInfo.lastFetch >= foe;
            if (this._blockhashInfo.latestBlockhash !== null && !r)
                return this._blockhashInfo.latestBlockhash
        }
        return await this._pollNewBlockhash()
    }
    async _pollNewBlockhash() {
        this._pollingBlockhash = !0;
        try {
            const e = Date.now()
              , t = this._blockhashInfo.latestBlockhash
              , r = t ? t.blockhash : null;
            for (let s = 0; s < 50; s++) {
                const i = await this.getLatestBlockhash("finalized");
                if (r !== i.blockhash)
                    return this._blockhashInfo = {
                        latestBlockhash: i,
                        lastFetch: Date.now(),
                        transactionSignatures: [],
                        simulatedSignatures: []
                    },
                    i;
                await lp(Jie / 2)
            }
            throw new Error(`Unable to obtain a new blockhash after ${Date.now() - e}ms`)
        } finally {
            this._pollingBlockhash = !1
        }
    }
    async getStakeMinimumDelegation(e) {
        const {commitment: t, config: r} = Ln(e)
          , s = this._buildArgs([], t, "base64", r)
          , i = await this._rpcRequest("getStakeMinimumDelegation", s)
          , o = ze(i, vr(be()));
        if ("error"in o)
            throw new gt(o.error,"failed to get stake minimum delegation");
        return o.result
    }
    async simulateTransaction(e, t, r) {
        if ("message"in e) {
            const b = e.serialize()
              , v = Mt.Buffer.from(b).toString("base64");
            if (Array.isArray(t) || r !== void 0)
                throw new Error("Invalid arguments");
            const S = t || {};
            S.encoding = "base64",
            "commitment"in S || (S.commitment = this.commitment),
            t && typeof t == "object" && "innerInstructions"in t && (S.innerInstructions = t.innerInstructions);
            const N = [v, S]
              , _ = await this._rpcRequest("simulateTransaction", N)
              , I = ze(_, rB);
            if ("error"in I)
                throw new Error("failed to simulate transaction: " + I.error.message);
            return I.result
        }
        let s;
        if (e instanceof sa) {
            let w = e;
            s = new sa,
            s.feePayer = w.feePayer,
            s.instructions = e.instructions,
            s.nonceInfo = w.nonceInfo,
            s.signatures = w.signatures
        } else
            s = sa.populate(e),
            s._message = s._json = void 0;
        if (t !== void 0 && !Array.isArray(t))
            throw new Error("Invalid arguments");
        const i = t;
        if (s.nonceInfo && i)
            s.sign(...i);
        else {
            let w = this._disableBlockhashCaching;
            for (; ; ) {
                const b = await this._blockhashWithExpiryBlockHeight(w);
                if (s.lastValidBlockHeight = b.lastValidBlockHeight,
                s.recentBlockhash = b.blockhash,
                !i)
                    break;
                if (s.sign(...i),
                !s.signature)
                    throw new Error("!signature");
                const v = s.signature.toString("base64");
                if (!this._blockhashInfo.simulatedSignatures.includes(v) && !this._blockhashInfo.transactionSignatures.includes(v)) {
                    this._blockhashInfo.simulatedSignatures.push(v);
                    break
                } else
                    w = !0
            }
        }
        const o = s._compile()
          , a = o.serialize()
          , u = s._serialize(a).toString("base64")
          , d = {
            encoding: "base64",
            commitment: this.commitment
        };
        if (r) {
            const w = (Array.isArray(r) ? r : o.nonProgramIds()).map(b => b.toBase58());
            d.accounts = {
                encoding: "base64",
                addresses: w
            }
        }
        i && (d.sigVerify = !0),
        t && typeof t == "object" && "innerInstructions"in t && (d.innerInstructions = t.innerInstructions);
        const h = [u, d]
          , p = await this._rpcRequest("simulateTransaction", h)
          , g = ze(p, rB);
        if ("error"in g) {
            let w;
            if ("data"in g.error && (w = g.error.data.logs,
            w && Array.isArray(w))) {
                const b = `
    `
                  , v = b + w.join(b);
                console.error(g.error.message, v)
            }
            throw new XM({
                action: "simulate",
                signature: "",
                transactionMessage: g.error.message,
                logs: w
            })
        }
        return g.result
    }
    async sendTransaction(e, t, r) {
        if ("version"in e) {
            if (t && Array.isArray(t))
                throw new Error("Invalid arguments");
            const o = e.serialize();
            return await this.sendRawTransaction(o, t)
        }
        if (t === void 0 || !Array.isArray(t))
            throw new Error("Invalid arguments");
        const s = t;
        if (e.nonceInfo)
            e.sign(...s);
        else {
            let o = this._disableBlockhashCaching;
            for (; ; ) {
                const a = await this._blockhashWithExpiryBlockHeight(o);
                if (e.lastValidBlockHeight = a.lastValidBlockHeight,
                e.recentBlockhash = a.blockhash,
                e.sign(...s),
                !e.signature)
                    throw new Error("!signature");
                const l = e.signature.toString("base64");
                if (this._blockhashInfo.transactionSignatures.includes(l))
                    o = !0;
                else {
                    this._blockhashInfo.transactionSignatures.push(l);
                    break
                }
            }
        }
        const i = e.serialize();
        return await this.sendRawTransaction(i, r)
    }
    async sendRawTransaction(e, t) {
        const r = gs(e).toString("base64");
        return await this.sendEncodedTransaction(r, t)
    }
    async sendEncodedTransaction(e, t) {
        const r = {
            encoding: "base64"
        }
          , s = t && t.skipPreflight
          , i = s === !0 ? "processed" : t && t.preflightCommitment || this.commitment;
        t && t.maxRetries != null && (r.maxRetries = t.maxRetries),
        t && t.minContextSlot != null && (r.minContextSlot = t.minContextSlot),
        s && (r.skipPreflight = s),
        i && (r.preflightCommitment = i);
        const o = [e, r]
          , a = await this._rpcRequest("sendTransaction", o)
          , l = ze(a, Cae);
        if ("error"in l) {
            let u;
            throw "data"in l.error && (u = l.error.data.logs),
            new XM({
                action: s ? "send" : "simulate",
                signature: "",
                transactionMessage: l.error.message,
                logs: u
            })
        }
        return l.result
    }
    _wsOnOpen() {
        this._rpcWebSocketConnected = !0,
        this._rpcWebSocketHeartbeat = setInterval( () => {
            (async () => {
                try {
                    await this._rpcWebSocket.notify("ping")
                } catch {}
            }
            )()
        }
        , 5e3),
        this._updateSubscriptions()
    }
    _wsOnError(e) {
        this._rpcWebSocketConnected = !1,
        console.error("ws error:", e.message)
    }
    _wsOnClose(e) {
        if (this._rpcWebSocketConnected = !1,
        this._rpcWebSocketGeneration = (this._rpcWebSocketGeneration + 1) % Number.MAX_SAFE_INTEGER,
        this._rpcWebSocketIdleTimeout && (clearTimeout(this._rpcWebSocketIdleTimeout),
        this._rpcWebSocketIdleTimeout = null),
        this._rpcWebSocketHeartbeat && (clearInterval(this._rpcWebSocketHeartbeat),
        this._rpcWebSocketHeartbeat = null),
        e === 1e3) {
            this._updateSubscriptions();
            return
        }
        this._subscriptionCallbacksByServerSubscriptionId = {},
        Object.entries(this._subscriptionsByHash).forEach( ([t,r]) => {
            this._setSubscription(t, {
                ...r,
                state: "pending"
            })
        }
        )
    }
    _setSubscription(e, t) {
        const r = this._subscriptionsByHash[e]?.state;
        if (this._subscriptionsByHash[e] = t,
        r !== t.state) {
            const s = this._subscriptionStateChangeCallbacksByHash[e];
            s && s.forEach(i => {
                try {
                    i(t.state)
                } catch {}
            }
            )
        }
    }
    _onSubscriptionStateChange(e, t) {
        const r = this._subscriptionHashByClientSubscriptionId[e];
        if (r == null)
            return () => {}
            ;
        const s = this._subscriptionStateChangeCallbacksByHash[r] ||= new Set;
        return s.add(t),
        () => {
            s.delete(t),
            s.size === 0 && delete this._subscriptionStateChangeCallbacksByHash[r]
        }
    }
    async _updateSubscriptions() {
        if (Object.keys(this._subscriptionsByHash).length === 0) {
            this._rpcWebSocketConnected && (this._rpcWebSocketConnected = !1,
            this._rpcWebSocketIdleTimeout = setTimeout( () => {
                this._rpcWebSocketIdleTimeout = null;
                try {
                    this._rpcWebSocket.close()
                } catch (r) {
                    r instanceof Error && console.log(`Error when closing socket connection: ${r.message}`)
                }
            }
            , 500));
            return
        }
        if (this._rpcWebSocketIdleTimeout !== null && (clearTimeout(this._rpcWebSocketIdleTimeout),
        this._rpcWebSocketIdleTimeout = null,
        this._rpcWebSocketConnected = !0),
        !this._rpcWebSocketConnected) {
            this._rpcWebSocket.connect();
            return
        }
        const e = this._rpcWebSocketGeneration
          , t = () => e === this._rpcWebSocketGeneration;
        await Promise.all(Object.keys(this._subscriptionsByHash).map(async r => {
            const s = this._subscriptionsByHash[r];
            if (s !== void 0)
                switch (s.state) {
                case "pending":
                case "unsubscribed":
                    if (s.callbacks.size === 0) {
                        delete this._subscriptionsByHash[r],
                        s.state === "unsubscribed" && delete this._subscriptionCallbacksByServerSubscriptionId[s.serverSubscriptionId],
                        await this._updateSubscriptions();
                        return
                    }
                    await (async () => {
                        const {args: i, method: o} = s;
                        try {
                            this._setSubscription(r, {
                                ...s,
                                state: "subscribing"
                            });
                            const a = await this._rpcWebSocket.call(o, i);
                            this._setSubscription(r, {
                                ...s,
                                serverSubscriptionId: a,
                                state: "subscribed"
                            }),
                            this._subscriptionCallbacksByServerSubscriptionId[a] = s.callbacks,
                            await this._updateSubscriptions()
                        } catch (a) {
                            if (console.error(`Received ${ainstanceof Error ? "" : "JSON-RPC "}error calling \`${o}\``, {
                                args: i,
                                error: a
                            }),
                            !t())
                                return;
                            this._setSubscription(r, {
                                ...s,
                                state: "pending"
                            }),
                            await this._updateSubscriptions()
                        }
                    }
                    )();
                    break;
                case "subscribed":
                    s.callbacks.size === 0 && await (async () => {
                        const {serverSubscriptionId: i, unsubscribeMethod: o} = s;
                        if (this._subscriptionsAutoDisposedByRpc.has(i))
                            this._subscriptionsAutoDisposedByRpc.delete(i);
                        else {
                            this._setSubscription(r, {
                                ...s,
                                state: "unsubscribing"
                            }),
                            this._setSubscription(r, {
                                ...s,
                                state: "unsubscribing"
                            });
                            try {
                                await this._rpcWebSocket.call(o, [i])
                            } catch (a) {
                                if (a instanceof Error && console.error(`${o} error:`, a.message),
                                !t())
                                    return;
                                this._setSubscription(r, {
                                    ...s,
                                    state: "subscribed"
                                }),
                                await this._updateSubscriptions();
                                return
                            }
                        }
                        this._setSubscription(r, {
                            ...s,
                            state: "unsubscribed"
                        }),
                        await this._updateSubscriptions()
                    }
                    )();
                    break
                }
        }
        ))
    }
    _handleServerNotification(e, t) {
        const r = this._subscriptionCallbacksByServerSubscriptionId[e];
        r !== void 0 && r.forEach(s => {
            try {
                s(...t)
            } catch (i) {
                console.error(i)
            }
        }
        )
    }
    _wsOnAccountNotification(e) {
        const {result: t, subscription: r} = ze(e, Koe);
        this._handleServerNotification(r, [t.value, t.context])
    }
    _makeSubscription(e, t) {
        const r = this._nextClientSubscriptionId++
          , s = JM([e.method, t])
          , i = this._subscriptionsByHash[s];
        return i === void 0 ? this._subscriptionsByHash[s] = {
            ...e,
            args: t,
            callbacks: new Set([e.callback]),
            state: "pending"
        } : i.callbacks.add(e.callback),
        this._subscriptionHashByClientSubscriptionId[r] = s,
        this._subscriptionDisposeFunctionsByClientSubscriptionId[r] = async () => {
            delete this._subscriptionDisposeFunctionsByClientSubscriptionId[r],
            delete this._subscriptionHashByClientSubscriptionId[r];
            const o = this._subscriptionsByHash[s];
            Rr(o !== void 0, `Could not find a \`Subscription\` when tearing down client subscription #${r}`),
            o.callbacks.delete(e.callback),
            await this._updateSubscriptions()
        }
        ,
        this._updateSubscriptions(),
        r
    }
    onAccountChange(e, t, r) {
        const {commitment: s, config: i} = Ln(r)
          , o = this._buildArgs([e.toBase58()], s || this._commitment || "finalized", "base64", i);
        return this._makeSubscription({
            callback: t,
            method: "accountSubscribe",
            unsubscribeMethod: "accountUnsubscribe"
        }, o)
    }
    async removeAccountChangeListener(e) {
        await this._unsubscribeClientSubscription(e, "account change")
    }
    _wsOnProgramAccountNotification(e) {
        const {result: t, subscription: r} = ze(e, Qoe);
        this._handleServerNotification(r, [{
            accountId: t.value.pubkey,
            accountInfo: t.value.account
        }, t.context])
    }
    onProgramAccountChange(e, t, r, s) {
        const {commitment: i, config: o} = Ln(r)
          , a = this._buildArgs([e.toBase58()], i || this._commitment || "finalized", "base64", o || (s ? {
            filters: nB(s)
        } : void 0));
        return this._makeSubscription({
            callback: t,
            method: "programSubscribe",
            unsubscribeMethod: "programUnsubscribe"
        }, a)
    }
    async removeProgramAccountChangeListener(e) {
        await this._unsubscribeClientSubscription(e, "program account change")
    }
    onLogs(e, t, r) {
        const s = this._buildArgs([typeof e == "object" ? {
            mentions: [e.toString()]
        } : e], r || this._commitment || "finalized");
        return this._makeSubscription({
            callback: t,
            method: "logsSubscribe",
            unsubscribeMethod: "logsUnsubscribe"
        }, s)
    }
    async removeOnLogsListener(e) {
        await this._unsubscribeClientSubscription(e, "logs")
    }
    _wsOnLogsNotification(e) {
        const {result: t, subscription: r} = ze(e, kae);
        this._handleServerNotification(r, [t.value, t.context])
    }
    _wsOnSlotNotification(e) {
        const {result: t, subscription: r} = ze(e, Joe);
        this._handleServerNotification(r, [t])
    }
    onSlotChange(e) {
        return this._makeSubscription({
            callback: e,
            method: "slotSubscribe",
            unsubscribeMethod: "slotUnsubscribe"
        }, [])
    }
    async removeSlotChangeListener(e) {
        await this._unsubscribeClientSubscription(e, "slot change")
    }
    _wsOnSlotUpdatesNotification(e) {
        const {result: t, subscription: r} = ze(e, tae);
        this._handleServerNotification(r, [t])
    }
    onSlotUpdate(e) {
        return this._makeSubscription({
            callback: e,
            method: "slotsUpdatesSubscribe",
            unsubscribeMethod: "slotsUpdatesUnsubscribe"
        }, [])
    }
    async removeSlotUpdateListener(e) {
        await this._unsubscribeClientSubscription(e, "slot update")
    }
    async _unsubscribeClientSubscription(e, t) {
        const r = this._subscriptionDisposeFunctionsByClientSubscriptionId[e];
        r ? await r() : console.warn(`Ignored unsubscribe request because an active subscription with id \`${e}\` for '${t}' events could not be found.`)
    }
    _buildArgs(e, t, r, s) {
        const i = t || this._commitment;
        if (i || r || s) {
            let o = {};
            r && (o.encoding = r),
            i && (o.commitment = i),
            s && (o = Object.assign(o, s)),
            e.push(o)
        }
        return e
    }
    _buildArgsAtLeastConfirmed(e, t, r, s) {
        const i = t || this._commitment;
        if (i && !["confirmed", "finalized"].includes(i))
            throw new Error("Using Connection with default commitment: `" + this._commitment + "`, but method requires at least `confirmed`");
        return this._buildArgs(e, t, r, s)
    }
    _wsOnSignatureNotification(e) {
        const {result: t, subscription: r} = ze(e, nae);
        t.value !== "receivedSignature" && this._subscriptionsAutoDisposedByRpc.add(r),
        this._handleServerNotification(r, t.value === "receivedSignature" ? [{
            type: "received"
        }, t.context] : [{
            type: "status",
            result: t.value
        }, t.context])
    }
    onSignature(e, t, r) {
        const s = this._buildArgs([e], r || this._commitment || "finalized")
          , i = this._makeSubscription({
            callback: (o, a) => {
                if (o.type === "status") {
                    t(o.result, a);
                    try {
                        this.removeSignatureListener(i)
                    } catch {}
                }
            }
            ,
            method: "signatureSubscribe",
            unsubscribeMethod: "signatureUnsubscribe"
        }, s);
        return i
    }
    onSignatureWithOptions(e, t, r) {
        const {commitment: s, ...i} = {
            ...r,
            commitment: r && r.commitment || this._commitment || "finalized"
        }
          , o = this._buildArgs([e], s, void 0, i)
          , a = this._makeSubscription({
            callback: (l, u) => {
                t(l, u);
                try {
                    this.removeSignatureListener(a)
                } catch {}
            }
            ,
            method: "signatureSubscribe",
            unsubscribeMethod: "signatureUnsubscribe"
        }, o);
        return a
    }
    async removeSignatureListener(e) {
        await this._unsubscribeClientSubscription(e, "signature result")
    }
    _wsOnRootNotification(e) {
        const {result: t, subscription: r} = ze(e, rae);
        this._handleServerNotification(r, [t])
    }
    onRootChange(e) {
        return this._makeSubscription({
            callback: e,
            method: "rootSubscribe",
            unsubscribeMethod: "rootUnsubscribe"
        }, [])
    }
    async removeRootChangeListener(e) {
        await this._unsubscribeClientSubscription(e, "root change")
    }
}
Object.freeze({
    CreateLookupTable: {
        index: 0,
        layout: oe.struct([oe.u32("instruction"), r0("recentSlot"), oe.u8("bumpSeed")])
    },
    FreezeLookupTable: {
        index: 1,
        layout: oe.struct([oe.u32("instruction")])
    },
    ExtendLookupTable: {
        index: 2,
        layout: oe.struct([oe.u32("instruction"), r0(), oe.seq(Gt(), oe.offset(oe.u32(), -8), "addresses")])
    },
    DeactivateLookupTable: {
        index: 3,
        layout: oe.struct([oe.u32("instruction")])
    },
    CloseLookupTable: {
        index: 4,
        layout: oe.struct([oe.u32("instruction")])
    }
});
new rt("AddressLookupTab1e1111111111111111111111111");
Object.freeze({
    RequestUnits: {
        index: 0,
        layout: oe.struct([oe.u8("instruction"), oe.u32("units"), oe.u32("additionalFee")])
    },
    RequestHeapFrame: {
        index: 1,
        layout: oe.struct([oe.u8("instruction"), oe.u32("bytes")])
    },
    SetComputeUnitLimit: {
        index: 2,
        layout: oe.struct([oe.u8("instruction"), oe.u32("units")])
    },
    SetComputeUnitPrice: {
        index: 3,
        layout: oe.struct([oe.u8("instruction"), r0("microLamports")])
    }
});
new rt("ComputeBudget111111111111111111111111111111");
oe.struct([oe.u8("numSignatures"), oe.u8("padding"), oe.u16("signatureOffset"), oe.u16("signatureInstructionIndex"), oe.u16("publicKeyOffset"), oe.u16("publicKeyInstructionIndex"), oe.u16("messageDataOffset"), oe.u16("messageDataSize"), oe.u16("messageInstructionIndex")]);
new rt("Ed25519SigVerify111111111111111111111111111");
Fie.utils.isValidPrivateKey;
oe.struct([oe.u8("numSignatures"), oe.u16("signatureOffset"), oe.u8("signatureInstructionIndex"), oe.u16("ethAddressOffset"), oe.u8("ethAddressInstructionIndex"), oe.u16("messageDataOffset"), oe.u16("messageDataSize"), oe.u8("messageInstructionIndex"), oe.blob(20, "ethAddress"), oe.blob(64, "signature"), oe.u8("recoveryId")]);
new rt("KeccakSecp256k11111111111111111111111111111");
var vz;
new rt("StakeConfig11111111111111111111111111111111");
class xz {
    constructor(e, t, r) {
        this.unixTimestamp = void 0,
        this.epoch = void 0,
        this.custodian = void 0,
        this.unixTimestamp = e,
        this.epoch = t,
        this.custodian = r
    }
}
vz = xz;
xz.default = new vz(0,0,rt.default);
Object.freeze({
    Initialize: {
        index: 0,
        layout: oe.struct([oe.u32("instruction"), qie(), Gie()])
    },
    Authorize: {
        index: 1,
        layout: oe.struct([oe.u32("instruction"), Gt("newAuthorized"), oe.u32("stakeAuthorizationType")])
    },
    Delegate: {
        index: 2,
        layout: oe.struct([oe.u32("instruction")])
    },
    Split: {
        index: 3,
        layout: oe.struct([oe.u32("instruction"), oe.ns64("lamports")])
    },
    Withdraw: {
        index: 4,
        layout: oe.struct([oe.u32("instruction"), oe.ns64("lamports")])
    },
    Deactivate: {
        index: 5,
        layout: oe.struct([oe.u32("instruction")])
    },
    Merge: {
        index: 7,
        layout: oe.struct([oe.u32("instruction")])
    },
    AuthorizeWithSeed: {
        index: 8,
        layout: oe.struct([oe.u32("instruction"), Gt("newAuthorized"), oe.u32("stakeAuthorizationType"), yp("authoritySeed"), Gt("authorityOwner")])
    }
});
new rt("Stake11111111111111111111111111111111111111");
Object.freeze({
    InitializeAccount: {
        index: 0,
        layout: oe.struct([oe.u32("instruction"), Wie()])
    },
    Authorize: {
        index: 1,
        layout: oe.struct([oe.u32("instruction"), Gt("newAuthorized"), oe.u32("voteAuthorizationType")])
    },
    Withdraw: {
        index: 3,
        layout: oe.struct([oe.u32("instruction"), oe.ns64("lamports")])
    },
    UpdateValidatorIdentity: {
        index: 4,
        layout: oe.struct([oe.u32("instruction")])
    },
    AuthorizeWithSeed: {
        index: 10,
        layout: oe.struct([oe.u32("instruction"), Yie()])
    }
});
new rt("Vote111111111111111111111111111111111111111");
new rt("Va1idator1nfo111111111111111111111111111111");
Re({
    name: Le(),
    website: bt(Le()),
    details: bt(Le()),
    iconUrl: bt(Le()),
    keybaseUsername: bt(Le())
});
new rt("Vote111111111111111111111111111111111111111");
oe.struct([Gt("nodePubkey"), Gt("authorizedWithdrawer"), oe.u8("commission"), oe.nu64(), oe.seq(oe.struct([oe.nu64("slot"), oe.u32("confirmationCount")]), oe.offset(oe.u32(), -8), "votes"), oe.u8("rootSlotValid"), oe.nu64("rootSlot"), oe.nu64(), oe.seq(oe.struct([oe.nu64("epoch"), Gt("authorizedVoter")]), oe.offset(oe.u32(), -8), "authorizedVoters"), oe.struct([oe.seq(oe.struct([Gt("authorizedPubkey"), oe.nu64("epochOfLastAuthorizedSwitch"), oe.nu64("targetEpoch")]), 32, "buf"), oe.nu64("idx"), oe.u8("isEmpty")], "priorVoters"), oe.nu64(), oe.seq(oe.struct([oe.nu64("epoch"), oe.nu64("credits"), oe.nu64("prevCredits")]), oe.offset(oe.u32(), -8), "epochCredits"), oe.struct([oe.nu64("slot"), oe.nu64("timestamp")], "lastTimestamp")]);
const jr = {
    Metamask: "Metamask",
    XWallet: "XWallet",
    Phantom: "Phantom",
    TrustWallet: "TrustWallet",
    TronLinkWallet: "TronLinkWallet",
    CtrlWallet: "CtrlWallet",
    Solflare: "Solflare",
    WalletConnect: "walletconnect"
}
  , Ez = "11111111111111111111111111111111";
function Dae(n, e) {
    const [t,r=""] = n?.split(".")
      , s = r?.slice(0, e);
    return t + (s ? `.${s}` : "")
}
function m_(n, e) {
    const t = Math.pow(10, e);
    return Math.floor(n * t) / t
}
async function Yf(n) {
    try {
        return await n.decimals()
    } catch {
        return 18
    }
}
async function Tae(n, e, t, r) {
    try {
        const s = new Ys(window.ethereum)
          , i = new Ro(e,["function approve(address spender, uint256 amount) returns (bool)", "function decimals() view returns (uint8)"],s)
          , o = await Yf(i)
          , a = A0(String(m_(r, o)), o)
          , l = await s.getSigner()
          , u = i.connect(l);
        return String(e).toLowerCase() === "0xdac17f958d2ee523a2206206994597c13d831ec7" && await (await u.approve(t, 0)).wait(),
        {
            success: !0,
            txHash: (await (await u.approve(t, a)).wait()).hash
        }
    } catch (s) {
        return {
            success: !1,
            error: s?.message || "Approval failed"
        }
    }
}
async function Iae({tokenAddresses: n, spenderAddress: e, amounts: t}) {
    const s = await new Ys(window.ethereum).getSigner()
      , i = ["function approve(address spender, uint256 amount) returns (bool)", "function decimals() view returns (uint8)"]
      , o = [];
    for (let a = 0; a < n.length; a++) {
        const l = n[a]
          , u = t[a];
        try {
            const d = new Ro(l,i,s)
              , h = await Yf(d)
              , p = A0(String(u), h);
            String(l).toLowerCase() === "0xdac17f958d2ee523a2206206994597c13d831ec7" && await (await d.approve(e, 0)).wait();
            const w = await (await d.approve(e, p)).wait();
            o.push({
                token: l,
                success: !0,
                txHash: w.hash
            })
        } catch (d) {
            o.push({
                token: l,
                success: !1,
                error: d?.message || "Approval failed"
            })
        }
    }
    return o
}
async function Mae(n, e, t, r, s) {
    try {
        const i = new Ty(r)
          , o = new Ro(n,["function allowance(address owner, address spender) view returns (uint256)", "function decimals() view returns (uint8)"],i)
          , a = await Yf(o)
          , l = await o.allowance(s, e)
          , u = A0(String(m_(t, a)), a);
        return {
            success: !0,
            approved: l >= u
        }
    } catch (i) {
        return {
            success: !1,
            approved: !1,
            error: i?.message
        }
    }
}
async function Bae({tokenAddresses: n, spenderAddress: e, amounts: t, walletAddress: r, rpc: s}) {
    const i = new Ty(s)
      , o = ["function allowance(address owner, address spender) view returns (uint256)", "function decimals() view returns (uint8)"];
    return await Promise.all(n.map(async (l, u) => {
        try {
            const d = new Ro(l,o,i)
              , h = await Yf(d)
              , p = await d.allowance(r, e)
              , g = A0(String(t[u]), h);
            return {
                token: l,
                approved: p >= g,
                success: !0
            }
        } catch (d) {
            return {
                token: l,
                approved: !1,
                success: !1,
                error: d?.message
            }
        }
    }
    ))
}
async function Rae(n, e, t) {
    const r = new Ty(t)
      , s = ["function decimals() view returns (uint8)", "function balanceOf(address) view returns (uint)"];
    try {
        const i = new Ro(e,s,r)
          , o = await Yf(i)
          , a = await i.balanceOf(n);
        return {
            tokenAddress: e,
            balance: Ov(a, o),
            success: !0
        }
    } catch (i) {
        return {
            tokenAddress: e,
            balance: "0",
            success: !1,
            error: i?.message
        }
    }
}
async function Oae(n, e, t) {
    const r = new Ty(t)
      , s = ["function decimals() view returns (uint8)", "function balanceOf(address) view returns (uint)"];
    return await Promise.all(e.map(async o => {
        try {
            const a = new Ro(o,s,r)
              , l = await Yf(a)
              , u = await a.balanceOf(n);
            return {
                token: o,
                balance: Ov(u, l),
                success: !0
            }
        } catch (a) {
            return {
                token: o,
                balance: "0",
                success: !1,
                error: a?.message
            }
        }
    }
    ))
}
async function Pae(n, e) {
    try {
        if (!Df(n))
            return {
                success: !1,
                balance: "0",
                error: "Invalid address"
            };
        const r = await new Ty(e).getBalance(n);
        return {
            success: !0,
            balance: MZ(r)
        }
    } catch (t) {
        return {
            success: !1,
            balance: "0",
            error: t?.message
        }
    }
}
async function jae(n, e) {
    try {
        const t = new p_(e)
          , r = new rt(n);
        return {
            success: !0,
            balance: (await t.getBalance(r) / 1e9).toString()
        }
    } catch (t) {
        return {
            success: !1,
            balance: "0",
            error: t?.message
        }
    }
}
function Sz(n) {
    const e = "https://chrome.google.com/webstore/detail/";
    let t = "";
    switch (n) {
    case jr.Metamask:
        t = "metamask/nkbihfbeogaeaoehlefnkodbefgpgknn";
        break;
    case jr.XWallet:
        t = "xwallet/pofheakpngfbdfeidiippmmckgpdceoh";
        break;
    case jr.Phantom:
        t = "phantom/bfnaelmomeimhlpmgjnjophhpkkoljpa";
        break;
    case jr.TrustWallet:
        t = "trust-wallet/egjidjbpglichdcondbcbdnbeeppgdph";
        break;
    case jr.TronLinkWallet:
        t = "tronlink/ibnejdfjmmkpcnlpebklmnkoeoihofec";
        break;
    case jr.CtrlWallet:
        t = "ctrl-wallet/hmeobnfnfcmdkdcmlblgagmfpfboieaf";
        break;
    case jr.Solflare:
        t = "solflare-wallet/bhhhlbepdkbapadjdnnojkbgioiodbic";
        break;
    default:
        t = ""
    }
    return t ? e + t : null
}
function Lae(n) {
    let e = !1;
    switch (n) {
    case jr.Metamask:
        e = typeof window < "u" && window.ethereum?.isMetaMask;
        break;
    case jr.XWallet:
        e = typeof window < "u" && window.xfi;
        break;
    case jr.Phantom:
        e = typeof window < "u" && window.phantom?.solana?.isPhantom;
        break;
    case jr.TrustWallet:
        e = typeof window < "u" && window.ethereum?.isTrust;
        break;
    case jr.TronLinkWallet:
        e = typeof window < "u" && (window.tronLink || window.tronWeb);
        break;
    case jr.CtrlWallet:
        e = typeof window < "u" && window.ethereum?.isCtrl;
        break;
    case jr.Solflare:
        e = typeof window < "u" && window.solflare?.isSolflare;
        break;
    default:
        e = !1
    }
    return {
        isInstalled: e,
        webstoreLink: Sz(n) || null
    }
}
const oB = Object.freeze(Object.defineProperty({
    __proto__: null,
    approveMultipleTokens: Iae,
    approveToken: Tae,
    checkAllowance: Mae,
    checkMultipleAllowances: Bae,
    checkWalletAvailability: Lae,
    getEvmNativeBalance: Pae,
    getMultipleTokenBalances: Oae,
    getSolanaNativeBalance: jae,
    getTokenBalance: Rae,
    getWebstoreLink: Sz,
    safeDecimals: Yf,
    truncateDecimals: Dae,
    truncateNumber: m_
}, Symbol.toStringTag, {
    value: "Module"
}))
  , Fae = "modulepreload"
  , Uae = function(n) {
    return "/" + n
}
  , aB = {}
  , g_ = function(e, t, r) {
    let s = Promise.resolve();
    if (t && t.length > 0) {
        let l = function(u) {
            return Promise.all(u.map(d => Promise.resolve(d).then(h => ({
                status: "fulfilled",
                value: h
            }), h => ({
                status: "rejected",
                reason: h
            }))))
        };
        document.getElementsByTagName("link");
        const o = document.querySelector("meta[property=csp-nonce]")
          , a = o?.nonce || o?.getAttribute("nonce");
        s = l(t.map(u => {
            if (u = Uae(u),
            u in aB)
                return;
            aB[u] = !0;
            const d = u.endsWith(".css")
              , h = d ? '[rel="stylesheet"]' : "";
            if (document.querySelector(`link[href="${u}"]${h}`))
                return;
            const p = document.createElement("link");
            if (p.rel = d ? "stylesheet" : Fae,
            d || (p.as = "script"),
            p.crossOrigin = "",
            p.href = u,
            a && p.setAttribute("nonce", a),
            document.head.appendChild(p),
            d)
                return new Promise( (g, w) => {
                    p.addEventListener("load", g),
                    p.addEventListener("error", () => w(new Error(`Unable to preload CSS for ${u}`)))
                }
                )
        }
        ))
    }
    function i(o) {
        const a = new Event("vite:preloadError",{
            cancelable: !0
        });
        if (a.payload = o,
        window.dispatchEvent(a),
        !a.defaultPrevented)
            throw o
    }
    return s.then(o => {
        for (const a of o || [])
            a.status === "rejected" && i(a.reason);
        return e().catch(i)
    }
    )
};
var j1 = {
    exports: {}
}, lB;
function zae() {
    if (lB)
        return j1.exports;
    lB = 1;
    var n = typeof Reflect == "object" ? Reflect : null, e = n && typeof n.apply == "function" ? n.apply : function(k, B, P) {
        return Function.prototype.apply.call(k, B, P)
    }
    , t;
    n && typeof n.ownKeys == "function" ? t = n.ownKeys : Object.getOwnPropertySymbols ? t = function(k) {
        return Object.getOwnPropertyNames(k).concat(Object.getOwnPropertySymbols(k))
    }
    : t = function(k) {
        return Object.getOwnPropertyNames(k)
    }
    ;
    function r(I) {
        console && console.warn && console.warn(I)
    }
    var s = Number.isNaN || function(k) {
        return k !== k
    }
    ;
    function i() {
        i.init.call(this)
    }
    j1.exports = i,
    j1.exports.once = S,
    i.EventEmitter = i,
    i.prototype._events = void 0,
    i.prototype._eventsCount = 0,
    i.prototype._maxListeners = void 0;
    var o = 10;
    function a(I) {
        if (typeof I != "function")
            throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof I)
    }
    Object.defineProperty(i, "defaultMaxListeners", {
        enumerable: !0,
        get: function() {
            return o
        },
        set: function(I) {
            if (typeof I != "number" || I < 0 || s(I))
                throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + I + ".");
            o = I
        }
    }),
    i.init = function() {
        (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null),
        this._eventsCount = 0),
        this._maxListeners = this._maxListeners || void 0
    }
    ,
    i.prototype.setMaxListeners = function(k) {
        if (typeof k != "number" || k < 0 || s(k))
            throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + k + ".");
        return this._maxListeners = k,
        this
    }
    ;
    function l(I) {
        return I._maxListeners === void 0 ? i.defaultMaxListeners : I._maxListeners
    }
    i.prototype.getMaxListeners = function() {
        return l(this)
    }
    ,
    i.prototype.emit = function(k) {
        for (var B = [], P = 1; P < arguments.length; P++)
            B.push(arguments[P]);
        var M = k === "error"
          , R = this._events;
        if (R !== void 0)
            M = M && R.error === void 0;
        else if (!M)
            return !1;
        if (M) {
            var L;
            if (B.length > 0 && (L = B[0]),
            L instanceof Error)
                throw L;
            var q = new Error("Unhandled error." + (L ? " (" + L.message + ")" : ""));
            throw q.context = L,
            q
        }
        var H = R[k];
        if (H === void 0)
            return !1;
        if (typeof H == "function")
            e(H, this, B);
        else
            for (var j = H.length, A = w(H, j), P = 0; P < j; ++P)
                e(A[P], this, B);
        return !0
    }
    ;
    function u(I, k, B, P) {
        var M, R, L;
        if (a(B),
        R = I._events,
        R === void 0 ? (R = I._events = Object.create(null),
        I._eventsCount = 0) : (R.newListener !== void 0 && (I.emit("newListener", k, B.listener ? B.listener : B),
        R = I._events),
        L = R[k]),
        L === void 0)
            L = R[k] = B,
            ++I._eventsCount;
        else if (typeof L == "function" ? L = R[k] = P ? [B, L] : [L, B] : P ? L.unshift(B) : L.push(B),
        M = l(I),
        M > 0 && L.length > M && !L.warned) {
            L.warned = !0;
            var q = new Error("Possible EventEmitter memory leak detected. " + L.length + " " + String(k) + " listeners added. Use emitter.setMaxListeners() to increase limit");
            q.name = "MaxListenersExceededWarning",
            q.emitter = I,
            q.type = k,
            q.count = L.length,
            r(q)
        }
        return I
    }
    i.prototype.addListener = function(k, B) {
        return u(this, k, B, !1)
    }
    ,
    i.prototype.on = i.prototype.addListener,
    i.prototype.prependListener = function(k, B) {
        return u(this, k, B, !0)
    }
    ;
    function d() {
        if (!this.fired)
            return this.target.removeListener(this.type, this.wrapFn),
            this.fired = !0,
            arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments)
    }
    function h(I, k, B) {
        var P = {
            fired: !1,
            wrapFn: void 0,
            target: I,
            type: k,
            listener: B
        }
          , M = d.bind(P);
        return M.listener = B,
        P.wrapFn = M,
        M
    }
    i.prototype.once = function(k, B) {
        return a(B),
        this.on(k, h(this, k, B)),
        this
    }
    ,
    i.prototype.prependOnceListener = function(k, B) {
        return a(B),
        this.prependListener(k, h(this, k, B)),
        this
    }
    ,
    i.prototype.removeListener = function(k, B) {
        var P, M, R, L, q;
        if (a(B),
        M = this._events,
        M === void 0)
            return this;
        if (P = M[k],
        P === void 0)
            return this;
        if (P === B || P.listener === B)
            --this._eventsCount === 0 ? this._events = Object.create(null) : (delete M[k],
            M.removeListener && this.emit("removeListener", k, P.listener || B));
        else if (typeof P != "function") {
            for (R = -1,
            L = P.length - 1; L >= 0; L--)
                if (P[L] === B || P[L].listener === B) {
                    q = P[L].listener,
                    R = L;
                    break
                }
            if (R < 0)
                return this;
            R === 0 ? P.shift() : b(P, R),
            P.length === 1 && (M[k] = P[0]),
            M.removeListener !== void 0 && this.emit("removeListener", k, q || B)
        }
        return this
    }
    ,
    i.prototype.off = i.prototype.removeListener,
    i.prototype.removeAllListeners = function(k) {
        var B, P, M;
        if (P = this._events,
        P === void 0)
            return this;
        if (P.removeListener === void 0)
            return arguments.length === 0 ? (this._events = Object.create(null),
            this._eventsCount = 0) : P[k] !== void 0 && (--this._eventsCount === 0 ? this._events = Object.create(null) : delete P[k]),
            this;
        if (arguments.length === 0) {
            var R = Object.keys(P), L;
            for (M = 0; M < R.length; ++M)
                L = R[M],
                L !== "removeListener" && this.removeAllListeners(L);
            return this.removeAllListeners("removeListener"),
            this._events = Object.create(null),
            this._eventsCount = 0,
            this
        }
        if (B = P[k],
        typeof B == "function")
            this.removeListener(k, B);
        else if (B !== void 0)
            for (M = B.length - 1; M >= 0; M--)
                this.removeListener(k, B[M]);
        return this
    }
    ;
    function p(I, k, B) {
        var P = I._events;
        if (P === void 0)
            return [];
        var M = P[k];
        return M === void 0 ? [] : typeof M == "function" ? B ? [M.listener || M] : [M] : B ? v(M) : w(M, M.length)
    }
    i.prototype.listeners = function(k) {
        return p(this, k, !0)
    }
    ,
    i.prototype.rawListeners = function(k) {
        return p(this, k, !1)
    }
    ,
    i.listenerCount = function(I, k) {
        return typeof I.listenerCount == "function" ? I.listenerCount(k) : g.call(I, k)
    }
    ,
    i.prototype.listenerCount = g;
    function g(I) {
        var k = this._events;
        if (k !== void 0) {
            var B = k[I];
            if (typeof B == "function")
                return 1;
            if (B !== void 0)
                return B.length
        }
        return 0
    }
    i.prototype.eventNames = function() {
        return this._eventsCount > 0 ? t(this._events) : []
    }
    ;
    function w(I, k) {
        for (var B = new Array(k), P = 0; P < k; ++P)
            B[P] = I[P];
        return B
    }
    function b(I, k) {
        for (; k + 1 < I.length; k++)
            I[k] = I[k + 1];
        I.pop()
    }
    function v(I) {
        for (var k = new Array(I.length), B = 0; B < k.length; ++B)
            k[B] = I[B].listener || I[B];
        return k
    }
    function S(I, k) {
        return new Promise(function(B, P) {
            function M(L) {
                I.removeListener(k, R),
                P(L)
            }
            function R() {
                typeof I.removeListener == "function" && I.removeListener("error", M),
                B([].slice.call(arguments))
            }
            _(I, k, R, {
                once: !0
            }),
            k !== "error" && N(I, M, {
                once: !0
            })
        }
        )
    }
    function N(I, k, B) {
        typeof I.on == "function" && _(I, "error", k, B)
    }
    function _(I, k, B, P) {
        if (typeof I.on == "function")
            P.once ? I.once(k, B) : I.on(k, B);
        else if (typeof I.addEventListener == "function")
            I.addEventListener(k, function M(R) {
                P.once && I.removeEventListener(k, M),
                B(R)
            });
        else
            throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof I)
    }
    return j1.exports
}
var no = zae();
const y_ = Fo(no);
var cB = function(n, e, t) {
    if (t || arguments.length === 2)
        for (var r = 0, s = e.length, i; r < s; r++)
            (i || !(r in e)) && (i || (i = Array.prototype.slice.call(e, 0, r)),
            i[r] = e[r]);
    return n.concat(i || Array.prototype.slice.call(e))
}
  , $ae = (function() {
    function n(e, t, r) {
        this.name = e,
        this.version = t,
        this.os = r,
        this.type = "browser"
    }
    return n
}
)()
  , Hae = (function() {
    function n(e) {
        this.version = e,
        this.type = "node",
        this.name = "node",
        this.os = process.platform
    }
    return n
}
)()
  , Vae = (function() {
    function n(e, t, r, s) {
        this.name = e,
        this.version = t,
        this.os = r,
        this.bot = s,
        this.type = "bot-device"
    }
    return n
}
)()
  , qae = (function() {
    function n() {
        this.type = "bot",
        this.bot = !0,
        this.name = "bot",
        this.version = null,
        this.os = null
    }
    return n
}
)()
  , Gae = (function() {
    function n() {
        this.type = "react-native",
        this.name = "react-native",
        this.version = null,
        this.os = null
    }
    return n
}
)()
  , Wae = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/
  , Yae = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/
  , uB = 3
  , Kae = [["aol", /AOLShield\/([0-9\._]+)/], ["edge", /Edge\/([0-9\._]+)/], ["edge-ios", /EdgiOS\/([0-9\._]+)/], ["yandexbrowser", /YaBrowser\/([0-9\._]+)/], ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/], ["samsung", /SamsungBrowser\/([0-9\.]+)/], ["silk", /\bSilk\/([0-9._-]+)\b/], ["miui", /MiuiBrowser\/([0-9\.]+)$/], ["beaker", /BeakerBrowser\/([0-9\.]+)/], ["edge-chromium", /EdgA?\/([0-9\.]+)/], ["chromium-webview", /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/], ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/], ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/], ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/], ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/], ["fxios", /FxiOS\/([0-9\.]+)/], ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/], ["opera", /Opera\/([0-9\.]+)(?:\s|$)/], ["opera", /OPR\/([0-9\.]+)(:?\s|$)/], ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/], ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/], ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/], ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/], ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/], ["ie", /MSIE\s(7\.0)/], ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/], ["android", /Android\s([0-9\.]+)/], ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/], ["safari", /Version\/([0-9\._]+).*Safari/], ["facebook", /FB[AS]V\/([0-9\.]+)/], ["instagram", /Instagram\s([0-9\.]+)/], ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/], ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/], ["curl", /^curl\/([0-9\.]+)$/], ["searchbot", Wae]]
  , dB = [["iOS", /iP(hone|od|ad)/], ["Android OS", /Android/], ["BlackBerry OS", /BlackBerry|BB10/], ["Windows Mobile", /IEMobile/], ["Amazon OS", /Kindle/], ["Windows 3.11", /Win16/], ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/], ["Windows 98", /(Windows 98)|(Win98)/], ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/], ["Windows XP", /(Windows NT 5.1)|(Windows XP)/], ["Windows Server 2003", /(Windows NT 5.2)/], ["Windows Vista", /(Windows NT 6.0)/], ["Windows 7", /(Windows NT 6.1)/], ["Windows 8", /(Windows NT 6.2)/], ["Windows 8.1", /(Windows NT 6.3)/], ["Windows 10", /(Windows NT 10.0)/], ["Windows ME", /Windows ME/], ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/], ["Open BSD", /OpenBSD/], ["Sun OS", /SunOS/], ["Chrome OS", /CrOS/], ["Linux", /(Linux)|(X11)/], ["Mac OS", /(Mac_PowerPC)|(Macintosh)/], ["QNX", /QNX/], ["BeOS", /BeOS/], ["OS/2", /OS\/2/]];
function Xae(n) {
    return typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative" ? new Gae : typeof navigator < "u" ? Zae(navigator.userAgent) : ele()
}
function Qae(n) {
    return n !== "" && Kae.reduce(function(e, t) {
        var r = t[0]
          , s = t[1];
        if (e)
            return e;
        var i = s.exec(n);
        return !!i && [r, i]
    }, !1)
}
function Zae(n) {
    var e = Qae(n);
    if (!e)
        return null;
    var t = e[0]
      , r = e[1];
    if (t === "searchbot")
        return new qae;
    var s = r[1] && r[1].split(".").join("_").split("_").slice(0, 3);
    s ? s.length < uB && (s = cB(cB([], s, !0), tle(uB - s.length), !0)) : s = [];
    var i = s.join(".")
      , o = Jae(n)
      , a = Yae.exec(n);
    return a && a[1] ? new Vae(t,i,o,a[1]) : new $ae(t,i,o)
}
function Jae(n) {
    for (var e = 0, t = dB.length; e < t; e++) {
        var r = dB[e]
          , s = r[0]
          , i = r[1]
          , o = i.exec(n);
        if (o)
            return s
    }
    return null
}
function ele() {
    var n = typeof process < "u" && process.version;
    return n ? new Hae(process.version.slice(1)) : null
}
function tle(n) {
    for (var e = [], t = 0; t < n; t++)
        e.push("0");
    return e
}
var u5 = {};
var z4 = function(n, e) {
    return z4 = Object.setPrototypeOf || {
        __proto__: []
    }instanceof Array && function(t, r) {
        t.__proto__ = r
    }
    || function(t, r) {
        for (var s in r)
            r.hasOwnProperty(s) && (t[s] = r[s])
    }
    ,
    z4(n, e)
};
function nle(n, e) {
    z4(n, e);
    function t() {
        this.constructor = n
    }
    n.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype,
    new t)
}
var $4 = function() {
    return $4 = Object.assign || function(e) {
        for (var t, r = 1, s = arguments.length; r < s; r++) {
            t = arguments[r];
            for (var i in t)
                Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i])
        }
        return e
    }
    ,
    $4.apply(this, arguments)
};
function rle(n, e) {
    var t = {};
    for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
    if (n != null && typeof Object.getOwnPropertySymbols == "function")
        for (var s = 0, r = Object.getOwnPropertySymbols(n); s < r.length; s++)
            e.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[s]) && (t[r[s]] = n[r[s]]);
    return t
}
function sle(n, e, t, r) {
    var s = arguments.length, i = s < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, t) : r, o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        i = Reflect.decorate(n, e, t, r);
    else
        for (var a = n.length - 1; a >= 0; a--)
            (o = n[a]) && (i = (s < 3 ? o(i) : s > 3 ? o(e, t, i) : o(e, t)) || i);
    return s > 3 && i && Object.defineProperty(e, t, i),
    i
}
function ile(n, e) {
    return function(t, r) {
        e(t, r, n)
    }
}
function ole(n, e) {
    if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
        return Reflect.metadata(n, e)
}
function ale(n, e, t, r) {
    function s(i) {
        return i instanceof t ? i : new t(function(o) {
            o(i)
        }
        )
    }
    return new (t || (t = Promise))(function(i, o) {
        function a(d) {
            try {
                u(r.next(d))
            } catch (h) {
                o(h)
            }
        }
        function l(d) {
            try {
                u(r.throw(d))
            } catch (h) {
                o(h)
            }
        }
        function u(d) {
            d.done ? i(d.value) : s(d.value).then(a, l)
        }
        u((r = r.apply(n, e || [])).next())
    }
    )
}
function lle(n, e) {
    var t = {
        label: 0,
        sent: function() {
            if (i[0] & 1)
                throw i[1];
            return i[1]
        },
        trys: [],
        ops: []
    }, r, s, i, o;
    return o = {
        next: a(0),
        throw: a(1),
        return: a(2)
    },
    typeof Symbol == "function" && (o[Symbol.iterator] = function() {
        return this
    }
    ),
    o;
    function a(u) {
        return function(d) {
            return l([u, d])
        }
    }
    function l(u) {
        if (r)
            throw new TypeError("Generator is already executing.");
        for (; t; )
            try {
                if (r = 1,
                s && (i = u[0] & 2 ? s.return : u[0] ? s.throw || ((i = s.return) && i.call(s),
                0) : s.next) && !(i = i.call(s, u[1])).done)
                    return i;
                switch (s = 0,
                i && (u = [u[0] & 2, i.value]),
                u[0]) {
                case 0:
                case 1:
                    i = u;
                    break;
                case 4:
                    return t.label++,
                    {
                        value: u[1],
                        done: !1
                    };
                case 5:
                    t.label++,
                    s = u[1],
                    u = [0];
                    continue;
                case 7:
                    u = t.ops.pop(),
                    t.trys.pop();
                    continue;
                default:
                    if (i = t.trys,
                    !(i = i.length > 0 && i[i.length - 1]) && (u[0] === 6 || u[0] === 2)) {
                        t = 0;
                        continue
                    }
                    if (u[0] === 3 && (!i || u[1] > i[0] && u[1] < i[3])) {
                        t.label = u[1];
                        break
                    }
                    if (u[0] === 6 && t.label < i[1]) {
                        t.label = i[1],
                        i = u;
                        break
                    }
                    if (i && t.label < i[2]) {
                        t.label = i[2],
                        t.ops.push(u);
                        break
                    }
                    i[2] && t.ops.pop(),
                    t.trys.pop();
                    continue
                }
                u = e.call(n, t)
            } catch (d) {
                u = [6, d],
                s = 0
            } finally {
                r = i = 0
            }
        if (u[0] & 5)
            throw u[1];
        return {
            value: u[0] ? u[1] : void 0,
            done: !0
        }
    }
}
function cle(n, e, t, r) {
    r === void 0 && (r = t),
    n[r] = e[t]
}
function ule(n, e) {
    for (var t in n)
        t !== "default" && !e.hasOwnProperty(t) && (e[t] = n[t])
}
function H4(n) {
    var e = typeof Symbol == "function" && Symbol.iterator
      , t = e && n[e]
      , r = 0;
    if (t)
        return t.call(n);
    if (n && typeof n.length == "number")
        return {
            next: function() {
                return n && r >= n.length && (n = void 0),
                {
                    value: n && n[r++],
                    done: !n
                }
            }
        };
    throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.")
}
function Az(n, e) {
    var t = typeof Symbol == "function" && n[Symbol.iterator];
    if (!t)
        return n;
    var r = t.call(n), s, i = [], o;
    try {
        for (; (e === void 0 || e-- > 0) && !(s = r.next()).done; )
            i.push(s.value)
    } catch (a) {
        o = {
            error: a
        }
    } finally {
        try {
            s && !s.done && (t = r.return) && t.call(r)
        } finally {
            if (o)
                throw o.error
        }
    }
    return i
}
function dle() {
    for (var n = [], e = 0; e < arguments.length; e++)
        n = n.concat(Az(arguments[e]));
    return n
}
function fle() {
    for (var n = 0, e = 0, t = arguments.length; e < t; e++)
        n += arguments[e].length;
    for (var r = Array(n), s = 0, e = 0; e < t; e++)
        for (var i = arguments[e], o = 0, a = i.length; o < a; o++,
        s++)
            r[s] = i[o];
    return r
}
function Jg(n) {
    return this instanceof Jg ? (this.v = n,
    this) : new Jg(n)
}
function hle(n, e, t) {
    if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
    var r = t.apply(n, e || []), s, i = [];
    return s = {},
    o("next"),
    o("throw"),
    o("return"),
    s[Symbol.asyncIterator] = function() {
        return this
    }
    ,
    s;
    function o(p) {
        r[p] && (s[p] = function(g) {
            return new Promise(function(w, b) {
                i.push([p, g, w, b]) > 1 || a(p, g)
            }
            )
        }
        )
    }
    function a(p, g) {
        try {
            l(r[p](g))
        } catch (w) {
            h(i[0][3], w)
        }
    }
    function l(p) {
        p.value instanceof Jg ? Promise.resolve(p.value.v).then(u, d) : h(i[0][2], p)
    }
    function u(p) {
        a("next", p)
    }
    function d(p) {
        a("throw", p)
    }
    function h(p, g) {
        p(g),
        i.shift(),
        i.length && a(i[0][0], i[0][1])
    }
}
function ple(n) {
    var e, t;
    return e = {},
    r("next"),
    r("throw", function(s) {
        throw s
    }),
    r("return"),
    e[Symbol.iterator] = function() {
        return this
    }
    ,
    e;
    function r(s, i) {
        e[s] = n[s] ? function(o) {
            return (t = !t) ? {
                value: Jg(n[s](o)),
                done: s === "return"
            } : i ? i(o) : o
        }
        : i
    }
}
function mle(n) {
    if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
    var e = n[Symbol.asyncIterator], t;
    return e ? e.call(n) : (n = typeof H4 == "function" ? H4(n) : n[Symbol.iterator](),
    t = {},
    r("next"),
    r("throw"),
    r("return"),
    t[Symbol.asyncIterator] = function() {
        return this
    }
    ,
    t);
    function r(i) {
        t[i] = n[i] && function(o) {
            return new Promise(function(a, l) {
                o = n[i](o),
                s(a, l, o.done, o.value)
            }
            )
        }
    }
    function s(i, o, a, l) {
        Promise.resolve(l).then(function(u) {
            i({
                value: u,
                done: a
            })
        }, o)
    }
}
function gle(n, e) {
    return Object.defineProperty ? Object.defineProperty(n, "raw", {
        value: e
    }) : n.raw = e,
    n
}
function yle(n) {
    if (n && n.__esModule)
        return n;
    var e = {};
    if (n != null)
        for (var t in n)
            Object.hasOwnProperty.call(n, t) && (e[t] = n[t]);
    return e.default = n,
    e
}
function ble(n) {
    return n && n.__esModule ? n : {
        default: n
    }
}
function wle(n, e) {
    if (!e.has(n))
        throw new TypeError("attempted to get private field on non-instance");
    return e.get(n)
}
function vle(n, e, t) {
    if (!e.has(n))
        throw new TypeError("attempted to set private field on non-instance");
    return e.set(n, t),
    t
}
const xle = Object.freeze(Object.defineProperty({
    __proto__: null,
    get __assign() {
        return $4
    },
    __asyncDelegator: ple,
    __asyncGenerator: hle,
    __asyncValues: mle,
    __await: Jg,
    __awaiter: ale,
    __classPrivateFieldGet: wle,
    __classPrivateFieldSet: vle,
    __createBinding: cle,
    __decorate: sle,
    __exportStar: ule,
    __extends: nle,
    __generator: lle,
    __importDefault: ble,
    __importStar: yle,
    __makeTemplateObject: gle,
    __metadata: ole,
    __param: ile,
    __read: Az,
    __rest: rle,
    __spread: dle,
    __spreadArrays: fle,
    __values: H4
}, Symbol.toStringTag, {
    value: "Module"
}))
  , Ly = S8(xle);
var d5 = {}, Fm = {}, fB;
function Ele() {
    if (fB)
        return Fm;
    fB = 1,
    Object.defineProperty(Fm, "__esModule", {
        value: !0
    }),
    Fm.delay = void 0;
    function n(e) {
        return new Promise(t => {
            setTimeout( () => {
                t(!0)
            }
            , e)
        }
        )
    }
    return Fm.delay = n,
    Fm
}
var Id = {}, f5 = {}, Md = {}, hB;
function Sle() {
    return hB || (hB = 1,
    Object.defineProperty(Md, "__esModule", {
        value: !0
    }),
    Md.ONE_THOUSAND = Md.ONE_HUNDRED = void 0,
    Md.ONE_HUNDRED = 100,
    Md.ONE_THOUSAND = 1e3),
    Md
}
var h5 = {}, pB;
function Ale() {
    return pB || (pB = 1,
    (function(n) {
        Object.defineProperty(n, "__esModule", {
            value: !0
        }),
        n.ONE_YEAR = n.FOUR_WEEKS = n.THREE_WEEKS = n.TWO_WEEKS = n.ONE_WEEK = n.THIRTY_DAYS = n.SEVEN_DAYS = n.FIVE_DAYS = n.THREE_DAYS = n.ONE_DAY = n.TWENTY_FOUR_HOURS = n.TWELVE_HOURS = n.SIX_HOURS = n.THREE_HOURS = n.ONE_HOUR = n.SIXTY_MINUTES = n.THIRTY_MINUTES = n.TEN_MINUTES = n.FIVE_MINUTES = n.ONE_MINUTE = n.SIXTY_SECONDS = n.THIRTY_SECONDS = n.TEN_SECONDS = n.FIVE_SECONDS = n.ONE_SECOND = void 0,
        n.ONE_SECOND = 1,
        n.FIVE_SECONDS = 5,
        n.TEN_SECONDS = 10,
        n.THIRTY_SECONDS = 30,
        n.SIXTY_SECONDS = 60,
        n.ONE_MINUTE = n.SIXTY_SECONDS,
        n.FIVE_MINUTES = n.ONE_MINUTE * 5,
        n.TEN_MINUTES = n.ONE_MINUTE * 10,
        n.THIRTY_MINUTES = n.ONE_MINUTE * 30,
        n.SIXTY_MINUTES = n.ONE_MINUTE * 60,
        n.ONE_HOUR = n.SIXTY_MINUTES,
        n.THREE_HOURS = n.ONE_HOUR * 3,
        n.SIX_HOURS = n.ONE_HOUR * 6,
        n.TWELVE_HOURS = n.ONE_HOUR * 12,
        n.TWENTY_FOUR_HOURS = n.ONE_HOUR * 24,
        n.ONE_DAY = n.TWENTY_FOUR_HOURS,
        n.THREE_DAYS = n.ONE_DAY * 3,
        n.FIVE_DAYS = n.ONE_DAY * 5,
        n.SEVEN_DAYS = n.ONE_DAY * 7,
        n.THIRTY_DAYS = n.ONE_DAY * 30,
        n.ONE_WEEK = n.SEVEN_DAYS,
        n.TWO_WEEKS = n.ONE_WEEK * 2,
        n.THREE_WEEKS = n.ONE_WEEK * 3,
        n.FOUR_WEEKS = n.ONE_WEEK * 4,
        n.ONE_YEAR = n.ONE_DAY * 365
    }
    )(h5)),
    h5
}
var mB;
function Cz() {
    return mB || (mB = 1,
    (function(n) {
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        const e = Ly;
        e.__exportStar(Sle(), n),
        e.__exportStar(Ale(), n)
    }
    )(f5)),
    f5
}
var gB;
function Cle() {
    if (gB)
        return Id;
    gB = 1,
    Object.defineProperty(Id, "__esModule", {
        value: !0
    }),
    Id.fromMiliseconds = Id.toMiliseconds = void 0;
    const n = Cz();
    function e(r) {
        return r * n.ONE_THOUSAND
    }
    Id.toMiliseconds = e;
    function t(r) {
        return Math.floor(r / n.ONE_THOUSAND)
    }
    return Id.fromMiliseconds = t,
    Id
}
var yB;
function _le() {
    return yB || (yB = 1,
    (function(n) {
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        const e = Ly;
        e.__exportStar(Ele(), n),
        e.__exportStar(Cle(), n)
    }
    )(d5)),
    d5
}
var Yh = {}, bB;
function kle() {
    if (bB)
        return Yh;
    bB = 1,
    Object.defineProperty(Yh, "__esModule", {
        value: !0
    }),
    Yh.Watch = void 0;
    class n {
        constructor() {
            this.timestamps = new Map
        }
        start(t) {
            if (this.timestamps.has(t))
                throw new Error(`Watch already started for label: ${t}`);
            this.timestamps.set(t, {
                started: Date.now()
            })
        }
        stop(t) {
            const r = this.get(t);
            if (typeof r.elapsed < "u")
                throw new Error(`Watch already stopped for label: ${t}`);
            const s = Date.now() - r.started;
            this.timestamps.set(t, {
                started: r.started,
                elapsed: s
            })
        }
        get(t) {
            const r = this.timestamps.get(t);
            if (typeof r > "u")
                throw new Error(`No timestamp found for label: ${t}`);
            return r
        }
        elapsed(t) {
            const r = this.get(t);
            return r.elapsed || Date.now() - r.started
        }
    }
    return Yh.Watch = n,
    Yh.default = n,
    Yh
}
var p5 = {}, Um = {}, wB;
function Nle() {
    if (wB)
        return Um;
    wB = 1,
    Object.defineProperty(Um, "__esModule", {
        value: !0
    }),
    Um.IWatch = void 0;
    class n {
    }
    return Um.IWatch = n,
    Um
}
var vB;
function Dle() {
    return vB || (vB = 1,
    (function(n) {
        Object.defineProperty(n, "__esModule", {
            value: !0
        }),
        Ly.__exportStar(Nle(), n)
    }
    )(p5)),
    p5
}
var xB;
function Tle() {
    return xB || (xB = 1,
    (function(n) {
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        const e = Ly;
        e.__exportStar(_le(), n),
        e.__exportStar(kle(), n),
        e.__exportStar(Dle(), n),
        e.__exportStar(Cz(), n)
    }
    )(u5)),
    u5
}
var je = Tle(), Pn = {}, EB;
function _z() {
    if (EB)
        return Pn;
    EB = 1,
    Object.defineProperty(Pn, "__esModule", {
        value: !0
    }),
    Pn.getLocalStorage = Pn.getLocalStorageOrThrow = Pn.getCrypto = Pn.getCryptoOrThrow = Pn.getLocation = Pn.getLocationOrThrow = Pn.getNavigator = Pn.getNavigatorOrThrow = Pn.getDocument = Pn.getDocumentOrThrow = Pn.getFromWindowOrThrow = Pn.getFromWindow = void 0;
    function n(p) {
        let g;
        return typeof window < "u" && typeof window[p] < "u" && (g = window[p]),
        g
    }
    Pn.getFromWindow = n;
    function e(p) {
        const g = n(p);
        if (!g)
            throw new Error(`${p} is not defined in Window`);
        return g
    }
    Pn.getFromWindowOrThrow = e;
    function t() {
        return e("document")
    }
    Pn.getDocumentOrThrow = t;
    function r() {
        return n("document")
    }
    Pn.getDocument = r;
    function s() {
        return e("navigator")
    }
    Pn.getNavigatorOrThrow = s;
    function i() {
        return n("navigator")
    }
    Pn.getNavigator = i;
    function o() {
        return e("location")
    }
    Pn.getLocationOrThrow = o;
    function a() {
        return n("location")
    }
    Pn.getLocation = a;
    function l() {
        return e("crypto")
    }
    Pn.getCryptoOrThrow = l;
    function u() {
        return n("crypto")
    }
    Pn.getCrypto = u;
    function d() {
        return e("localStorage")
    }
    Pn.getLocalStorageOrThrow = d;
    function h() {
        return n("localStorage")
    }
    return Pn.getLocalStorage = h,
    Pn
}
var Dc = _z(), zm = {}, SB;
function Ile() {
    if (SB)
        return zm;
    SB = 1,
    Object.defineProperty(zm, "__esModule", {
        value: !0
    }),
    zm.getWindowMetadata = void 0;
    const n = _z();
    function e() {
        let t, r;
        try {
            t = n.getDocumentOrThrow(),
            r = n.getLocationOrThrow()
        } catch {
            return null
        }
        function s() {
            const g = t.getElementsByTagName("link")
              , w = [];
            for (let b = 0; b < g.length; b++) {
                const v = g[b]
                  , S = v.getAttribute("rel");
                if (S && S.toLowerCase().indexOf("icon") > -1) {
                    const N = v.getAttribute("href");
                    if (N)
                        if (N.toLowerCase().indexOf("https:") === -1 && N.toLowerCase().indexOf("http:") === -1 && N.indexOf("//") !== 0) {
                            let _ = r.protocol + "//" + r.host;
                            if (N.indexOf("/") === 0)
                                _ += N;
                            else {
                                const I = r.pathname.split("/");
                                I.pop();
                                const k = I.join("/");
                                _ += k + "/" + N
                            }
                            w.push(_)
                        } else if (N.indexOf("//") === 0) {
                            const _ = r.protocol + N;
                            w.push(_)
                        } else
                            w.push(N)
                }
            }
            return w
        }
        function i(...g) {
            const w = t.getElementsByTagName("meta");
            for (let b = 0; b < w.length; b++) {
                const v = w[b]
                  , S = ["itemprop", "property", "name"].map(N => v.getAttribute(N)).filter(N => N ? g.includes(N) : !1);
                if (S.length && S) {
                    const N = v.getAttribute("content");
                    if (N)
                        return N
                }
            }
            return ""
        }
        function o() {
            let g = i("name", "og:site_name", "og:title", "twitter:title");
            return g || (g = t.title),
            g
        }
        function a() {
            return i("description", "og:description", "twitter:description", "keywords")
        }
        const l = o()
          , u = a()
          , d = r.origin
          , h = s();
        return {
            description: u,
            url: d,
            icons: h,
            name: l
        }
    }
    return zm.getWindowMetadata = e,
    zm
}
var Mle = Ile();
const Ble = "0.1.1";
function Rle() {
    return Ble
}
class er extends Error {
    constructor(e, t={}) {
        const r = ( () => {
            if (t.cause instanceof er) {
                if (t.cause.details)
                    return t.cause.details;
                if (t.cause.shortMessage)
                    return t.cause.shortMessage
            }
            return t.cause && "details"in t.cause && typeof t.cause.details == "string" ? t.cause.details : t.cause?.message ? t.cause.message : t.details
        }
        )()
          , s = t.cause instanceof er && t.cause.docsPath || t.docsPath
          , o = `https://oxlib.sh${s ?? ""}`
          , a = [e || "An error occurred.", ...t.metaMessages ? ["", ...t.metaMessages] : [], ...r || s ? ["", r ? `Details: ${r}` : void 0, s ? `See: ${o}` : void 0] : []].filter(l => typeof l == "string").join(`
`);
        super(a, t.cause ? {
            cause: t.cause
        } : void 0),
        Object.defineProperty(this, "details", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "docs", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "docsPath", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "shortMessage", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "cause", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "BaseError"
        }),
        Object.defineProperty(this, "version", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: `ox@${Rle()}`
        }),
        this.cause = t.cause,
        this.details = r,
        this.docs = o,
        this.docsPath = s,
        this.shortMessage = e
    }
    walk(e) {
        return kz(this, e)
    }
}
function kz(n, e) {
    return e?.(n) ? n : n && typeof n == "object" && "cause"in n && n.cause ? kz(n.cause, e) : e ? null : n
}
const b_ = BigInt(0)
  , V4 = BigInt(1);
function Fy(n) {
    return n instanceof Uint8Array || ArrayBuffer.isView(n) && n.constructor.name === "Uint8Array"
}
function w_(n) {
    if (!Fy(n))
        throw new Error("Uint8Array expected")
}
function ey(n, e) {
    if (typeof e != "boolean")
        throw new Error(n + " boolean expected, got " + e)
}
function L1(n) {
    const e = n.toString(16);
    return e.length & 1 ? "0" + e : e
}
function Nz(n) {
    if (typeof n != "string")
        throw new Error("hex string expected, got " + typeof n);
    return n === "" ? b_ : BigInt("0x" + n)
}
const Dz = typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function"
  , Ole = Array.from({
    length: 256
}, (n, e) => e.toString(16).padStart(2, "0"));
function ty(n) {
    if (w_(n),
    Dz)
        return n.toHex();
    let e = "";
    for (let t = 0; t < n.length; t++)
        e += Ole[n[t]];
    return e
}
const Il = {
    _0: 48,
    _9: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102
};
function AB(n) {
    if (n >= Il._0 && n <= Il._9)
        return n - Il._0;
    if (n >= Il.A && n <= Il.F)
        return n - (Il.A - 10);
    if (n >= Il.a && n <= Il.f)
        return n - (Il.a - 10)
}
function T2(n) {
    if (typeof n != "string")
        throw new Error("hex string expected, got " + typeof n);
    if (Dz)
        return Uint8Array.fromHex(n);
    const e = n.length
      , t = e / 2;
    if (e % 2)
        throw new Error("hex string expected, got unpadded hex of length " + e);
    const r = new Uint8Array(t);
    for (let s = 0, i = 0; s < t; s++,
    i += 2) {
        const o = AB(n.charCodeAt(i))
          , a = AB(n.charCodeAt(i + 1));
        if (o === void 0 || a === void 0) {
            const l = n[i] + n[i + 1];
            throw new Error('hex string expected, got non-hex character "' + l + '" at index ' + i)
        }
        r[s] = o * 16 + a
    }
    return r
}
function Sf(n) {
    return Nz(ty(n))
}
function Tz(n) {
    return w_(n),
    Nz(ty(Uint8Array.from(n).reverse()))
}
function Uy(n, e) {
    return T2(n.toString(16).padStart(e * 2, "0"))
}
function Iz(n, e) {
    return Uy(n, e).reverse()
}
function So(n, e, t) {
    let r;
    if (typeof e == "string")
        try {
            r = T2(e)
        } catch (i) {
            throw new Error(n + " must be hex string or Uint8Array, cause: " + i)
        }
    else if (Fy(e))
        r = Uint8Array.from(e);
    else
        throw new Error(n + " must be hex string or Uint8Array");
    const s = r.length;
    if (typeof t == "number" && s !== t)
        throw new Error(n + " of length " + t + " expected, got " + s);
    return r
}
function I2(...n) {
    let e = 0;
    for (let r = 0; r < n.length; r++) {
        const s = n[r];
        w_(s),
        e += s.length
    }
    const t = new Uint8Array(e);
    for (let r = 0, s = 0; r < n.length; r++) {
        const i = n[r];
        t.set(i, s),
        s += i.length
    }
    return t
}
const m5 = n => typeof n == "bigint" && b_ <= n;
function v_(n, e, t) {
    return m5(n) && m5(e) && m5(t) && e <= n && n < t
}
function Ip(n, e, t, r) {
    if (!v_(e, t, r))
        throw new Error("expected valid " + n + ": " + t + " <= n < " + r + ", got " + e)
}
function Ple(n) {
    let e;
    for (e = 0; n > b_; n >>= V4,
    e += 1)
        ;
    return e
}
const ix = n => (V4 << BigInt(n)) - V4
  , g5 = n => new Uint8Array(n)
  , CB = n => Uint8Array.from(n);
function jle(n, e, t) {
    if (typeof n != "number" || n < 2)
        throw new Error("hashLen must be a number");
    if (typeof e != "number" || e < 2)
        throw new Error("qByteLen must be a number");
    if (typeof t != "function")
        throw new Error("hmacFn must be a function");
    let r = g5(n)
      , s = g5(n)
      , i = 0;
    const o = () => {
        r.fill(1),
        s.fill(0),
        i = 0
    }
      , a = (...h) => t(s, r, ...h)
      , l = (h=g5(0)) => {
        s = a(CB([0]), h),
        r = a(),
        h.length !== 0 && (s = a(CB([1]), h),
        r = a())
    }
      , u = () => {
        if (i++ >= 1e3)
            throw new Error("drbg: tried 1000 values");
        let h = 0;
        const p = [];
        for (; h < e; ) {
            r = a();
            const g = r.slice();
            p.push(g),
            h += r.length
        }
        return I2(...p)
    }
    ;
    return (h, p) => {
        o(),
        l(h);
        let g;
        for (; !(g = p(u())); )
            l();
        return o(),
        g
    }
}
const Lle = {
    bigint: n => typeof n == "bigint",
    function: n => typeof n == "function",
    boolean: n => typeof n == "boolean",
    string: n => typeof n == "string",
    stringOrUint8Array: n => typeof n == "string" || Fy(n),
    isSafeInteger: n => Number.isSafeInteger(n),
    array: n => Array.isArray(n),
    field: (n, e) => e.Fp.isValid(n),
    hash: n => typeof n == "function" && Number.isSafeInteger(n.outputLen)
};
function ox(n, e, t={}) {
    const r = (s, i, o) => {
        const a = Lle[i];
        if (typeof a != "function")
            throw new Error("invalid validator function");
        const l = n[s];
        if (!(o && l === void 0) && !a(l, n))
            throw new Error("param " + String(s) + " is invalid. Expected " + i + ", got " + l)
    }
    ;
    for (const [s,i] of Object.entries(e))
        r(s, i, !1);
    for (const [s,i] of Object.entries(t))
        r(s, i, !0);
    return n
}
function _B(n) {
    const e = new WeakMap;
    return (t, ...r) => {
        const s = e.get(t);
        if (s !== void 0)
            return s;
        const i = n(t, ...r);
        return e.set(t, i),
        i
    }
}
function Fle(n, e) {
    if (TB(n) > e)
        throw new oce({
            givenSize: TB(n),
            maxSize: e
        })
}
const Ml = {
    zero: 48,
    nine: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102
};
function kB(n) {
    if (n >= Ml.zero && n <= Ml.nine)
        return n - Ml.zero;
    if (n >= Ml.A && n <= Ml.F)
        return n - (Ml.A - 10);
    if (n >= Ml.a && n <= Ml.f)
        return n - (Ml.a - 10)
}
function Ule(n, e={}) {
    const {dir: t, size: r=32} = e;
    if (r === 0)
        return n;
    if (n.length > r)
        throw new ace({
            size: n.length,
            targetSize: r,
            type: "Bytes"
        });
    const s = new Uint8Array(r);
    for (let i = 0; i < r; i++) {
        const o = t === "right";
        s[o ? i : r - i - 1] = n[o ? i : n.length - i - 1]
    }
    return s
}
function Mz(n, e) {
    if (Ju(n) > e)
        throw new Xle({
            givenSize: Ju(n),
            maxSize: e
        })
}
function zle(n, e) {
    if (typeof e == "number" && e > 0 && e > Ju(n) - 1)
        throw new Oz({
            offset: e,
            position: "start",
            size: Ju(n)
        })
}
function $le(n, e, t) {
    if (typeof e == "number" && typeof t == "number" && Ju(n) !== t - e)
        throw new Oz({
            offset: t,
            position: "end",
            size: Ju(n)
        })
}
function Bz(n, e={}) {
    const {dir: t, size: r=32} = e;
    if (r === 0)
        return n;
    const s = n.replace("0x", "");
    if (s.length > r * 2)
        throw new Qle({
            size: Math.ceil(s.length / 2),
            targetSize: r,
            type: "Hex"
        });
    return `0x${s[t === "right" ? "padEnd" : "padStart"](r * 2, "0")}`
}
const Hle = "#__bigint";
function x_(n, e, t) {
    return JSON.stringify(n, (r, s) => typeof s == "bigint" ? s.toString() + Hle : s, t)
}
const Vle = Array.from({
    length: 256
}, (n, e) => e.toString(16).padStart(2, "0"));
function qle(n, e={}) {
    const {strict: t=!1} = e;
    if (!n)
        throw new NB(n);
    if (typeof n != "string")
        throw new NB(n);
    if (t && !/^0x[0-9a-fA-F]*$/.test(n))
        throw new DB(n);
    if (!n.startsWith("0x"))
        throw new DB(n)
}
function Gle(...n) {
    return `0x${n.reduce( (e, t) => e + t.replace("0x", ""), "")}`
}
function E_(n) {
    return n instanceof Uint8Array ? M2(n) : Array.isArray(n) ? M2(new Uint8Array(n)) : n
}
function M2(n, e={}) {
    let t = "";
    for (let s = 0; s < n.length; s++)
        t += Vle[n[s]];
    const r = `0x${t}`;
    return typeof e.size == "number" ? (Mz(r, e.size),
    Rz(r, e.size)) : r
}
function y5(n, e={}) {
    const {signed: t, size: r} = e
      , s = BigInt(n);
    let i;
    r ? t ? i = (1n << BigInt(r) * 8n - 1n) - 1n : i = 2n ** (BigInt(r) * 8n) - 1n : typeof n == "number" && (i = BigInt(Number.MAX_SAFE_INTEGER));
    const o = typeof i == "bigint" && t ? -i - 1n : 0;
    if (i && s > i || s < o) {
        const u = typeof n == "bigint" ? "n" : "";
        throw new Kle({
            max: i ? `${i}${u}` : void 0,
            min: `${o}${u}`,
            signed: t,
            size: r,
            value: `${n}${u}`
        })
    }
    const l = `0x${(t && s < 0 ? (1n << BigInt(r * 8)) + BigInt(s) : s).toString(16)}`;
    return r ? Wle(l, r) : l
}
function Wle(n, e) {
    return Bz(n, {
        dir: "left",
        size: e
    })
}
function Rz(n, e) {
    return Bz(n, {
        dir: "right",
        size: e
    })
}
function Yl(n, e, t, r={}) {
    const {strict: s} = r;
    zle(n, e);
    const i = `0x${n.replace("0x", "").slice((e ?? 0) * 2, (t ?? n.length) * 2)}`;
    return s && $le(i, e, t),
    i
}
function Ju(n) {
    return Math.ceil((n.length - 2) / 2)
}
function Yle(n, e={}) {
    const {strict: t=!1} = e;
    try {
        return qle(n, {
            strict: t
        }),
        !0
    } catch {
        return !1
    }
}
class Kle extends er {
    constructor({max: e, min: t, signed: r, size: s, value: i}) {
        super(`Number \`${i}\` is not in safe${s ? ` ${s * 8}-bit` : ""}${r ? " signed" : " unsigned"} integer range ${e ? `(\`${t}\` to \`${e}\`)` : `(above \`${t}\`)`}`),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Hex.IntegerOutOfRangeError"
        })
    }
}
class NB extends er {
    constructor(e) {
        super(`Value \`${typeof e == "object" ? x_(e) : e}\` of type \`${typeof e}\` is an invalid hex type.`, {
            metaMessages: ['Hex types must be represented as `"0x${string}"`.']
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Hex.InvalidHexTypeError"
        })
    }
}
class DB extends er {
    constructor(e) {
        super(`Value \`${e}\` is an invalid hex value.`, {
            metaMessages: ['Hex values must start with `"0x"` and contain only hexadecimal characters (0-9, a-f, A-F).']
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Hex.InvalidHexValueError"
        })
    }
}
let Xle = class extends er {
    constructor({givenSize: e, maxSize: t}) {
        super(`Size cannot exceed \`${t}\` bytes. Given size: \`${e}\` bytes.`),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Hex.SizeOverflowError"
        })
    }
}
;
class Oz extends er {
    constructor({offset: e, position: t, size: r}) {
        super(`Slice ${t === "start" ? "starting" : "ending"} at offset \`${e}\` is out-of-bounds (size: \`${r}\`).`),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Hex.SliceOffsetOutOfBoundsError"
        })
    }
}
let Qle = class extends er {
    constructor({size: e, targetSize: t, type: r}) {
        super(`${r.charAt(0).toUpperCase()}${r.slice(1).toLowerCase()} size (\`${e}\`) exceeds padding size (\`${t}\`).`),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Hex.SizeExceedsPaddingSizeError"
        })
    }
}
;
const Zle = new TextEncoder;
function Jle(n) {
    if (!(n instanceof Uint8Array)) {
        if (!n)
            throw new F1(n);
        if (typeof n != "object")
            throw new F1(n);
        if (!("BYTES_PER_ELEMENT"in n))
            throw new F1(n);
        if (n.BYTES_PER_ELEMENT !== 1 || n.constructor.name !== "Uint8Array")
            throw new F1(n)
    }
}
function ece(n) {
    return n instanceof Uint8Array ? n : typeof n == "string" ? nce(n) : tce(n)
}
function tce(n) {
    return n instanceof Uint8Array ? n : new Uint8Array(n)
}
function nce(n, e={}) {
    const {size: t} = e;
    let r = n;
    t && (Mz(n, t),
    r = Rz(n, t));
    let s = r.slice(2);
    s.length % 2 && (s = `0${s}`);
    const i = s.length / 2
      , o = new Uint8Array(i);
    for (let a = 0, l = 0; a < i; a++) {
        const u = kB(s.charCodeAt(l++))
          , d = kB(s.charCodeAt(l++));
        if (u === void 0 || d === void 0)
            throw new er(`Invalid byte sequence ("${s[l - 2]}${s[l - 1]}" in "${s}").`);
        o[a] = u * 16 + d
    }
    return o
}
function rce(n, e={}) {
    const {size: t} = e
      , r = Zle.encode(n);
    return typeof t == "number" ? (Fle(r, t),
    sce(r, t)) : r
}
function sce(n, e) {
    return Ule(n, {
        dir: "right",
        size: e
    })
}
function TB(n) {
    return n.length
}
function ice(n) {
    try {
        return Jle(n),
        !0
    } catch {
        return !1
    }
}
class F1 extends er {
    constructor(e) {
        super(`Value \`${typeof e == "object" ? x_(e) : e}\` of type \`${typeof e}\` is an invalid Bytes value.`, {
            metaMessages: ["Bytes values must be of type `Bytes`."]
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Bytes.InvalidBytesTypeError"
        })
    }
}
class oce extends er {
    constructor({givenSize: e, maxSize: t}) {
        super(`Size cannot exceed \`${t}\` bytes. Given size: \`${e}\` bytes.`),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Bytes.SizeOverflowError"
        })
    }
}
class ace extends er {
    constructor({size: e, targetSize: t, type: r}) {
        super(`${r.charAt(0).toUpperCase()}${r.slice(1).toLowerCase()} size (\`${e}\`) exceeds padding size (\`${t}\`).`),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Bytes.SizeExceedsPaddingSizeError"
        })
    }
}
function Pz(n, e={}) {
    const {as: t=typeof n == "string" ? "Hex" : "Bytes"} = e
      , r = Cie(ece(n));
    return t === "Bytes" ? r : M2(r)
}
class lce extends Map {
    constructor(e) {
        super(),
        Object.defineProperty(this, "maxSize", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        this.maxSize = e
    }
    get(e) {
        const t = super.get(e);
        return super.has(e) && t !== void 0 && (this.delete(e),
        super.set(e, t)),
        t
    }
    set(e, t) {
        if (super.set(e, t),
        this.maxSize && this.size > this.maxSize) {
            const r = this.keys().next().value;
            r && this.delete(r)
        }
        return this
    }
}
const cce = {
    checksum: new lce(8192)
}
  , b5 = cce.checksum;
function jz(n, e={}) {
    const {compressed: t} = e
      , {prefix: r, x: s, y: i} = n;
    if (t === !1 || typeof s == "bigint" && typeof i == "bigint") {
        if (r !== 4)
            throw new IB({
                prefix: r,
                cause: new mce
            });
        return
    }
    if (t === !0 || typeof s == "bigint" && typeof i > "u") {
        if (r !== 3 && r !== 2)
            throw new IB({
                prefix: r,
                cause: new pce
            });
        return
    }
    throw new hce({
        publicKey: n
    })
}
function uce(n) {
    const e = ( () => {
        if (Yle(n))
            return Lz(n);
        if (ice(n))
            return dce(n);
        const {prefix: t, x: r, y: s} = n;
        return typeof r == "bigint" && typeof s == "bigint" ? {
            prefix: t ?? 4,
            x: r,
            y: s
        } : {
            prefix: t,
            x: r
        }
    }
    )();
    return jz(e),
    e
}
function dce(n) {
    return Lz(M2(n))
}
function Lz(n) {
    if (n.length !== 132 && n.length !== 130 && n.length !== 68)
        throw new gce({
            publicKey: n
        });
    if (n.length === 130) {
        const r = BigInt(Yl(n, 0, 32))
          , s = BigInt(Yl(n, 32, 64));
        return {
            prefix: 4,
            x: r,
            y: s
        }
    }
    if (n.length === 132) {
        const r = Number(Yl(n, 0, 1))
          , s = BigInt(Yl(n, 1, 33))
          , i = BigInt(Yl(n, 33, 65));
        return {
            prefix: r,
            x: s,
            y: i
        }
    }
    const e = Number(Yl(n, 0, 1))
      , t = BigInt(Yl(n, 1, 33));
    return {
        prefix: e,
        x: t
    }
}
function fce(n, e={}) {
    jz(n);
    const {prefix: t, x: r, y: s} = n
      , {includePrefix: i=!0} = e;
    return Gle(i ? y5(t, {
        size: 1
    }) : "0x", y5(r, {
        size: 32
    }), typeof s == "bigint" ? y5(s, {
        size: 32
    }) : "0x")
}
class hce extends er {
    constructor({publicKey: e}) {
        super(`Value \`${x_(e)}\` is not a valid public key.`, {
            metaMessages: ["Public key must contain:", "- an `x` and `prefix` value (compressed)", "- an `x`, `y`, and `prefix` value (uncompressed)"]
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "PublicKey.InvalidError"
        })
    }
}
class IB extends er {
    constructor({prefix: e, cause: t}) {
        super(`Prefix "${e}" is invalid.`, {
            cause: t
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "PublicKey.InvalidPrefixError"
        })
    }
}
class pce extends er {
    constructor() {
        super("Prefix must be 2 or 3 for compressed public keys."),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "PublicKey.InvalidCompressedPrefixError"
        })
    }
}
class mce extends er {
    constructor() {
        super("Prefix must be 4 for uncompressed public keys."),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "PublicKey.InvalidUncompressedPrefixError"
        })
    }
}
let gce = class extends er {
    constructor({publicKey: e}) {
        super(`Value \`${e}\` is an invalid public key size.`, {
            metaMessages: ["Expected: 33 bytes (compressed + prefix), 64 bytes (uncompressed) or 65 bytes (uncompressed + prefix).", `Received ${Ju(E_(e))} bytes.`]
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "PublicKey.InvalidSerializedSizeError"
        })
    }
}
;
const yce = /^0x[a-fA-F0-9]{40}$/;
function Fz(n, e={}) {
    const {strict: t=!0} = e;
    if (!yce.test(n))
        throw new MB({
            address: n,
            cause: new vce
        });
    if (t) {
        if (n.toLowerCase() === n)
            return;
        if (Uz(n) !== n)
            throw new MB({
                address: n,
                cause: new xce
            })
    }
}
function Uz(n) {
    if (b5.has(n))
        return b5.get(n);
    Fz(n, {
        strict: !1
    });
    const e = n.substring(2).toLowerCase()
      , t = Pz(rce(e), {
        as: "Bytes"
    })
      , r = e.split("");
    for (let i = 0; i < 40; i += 2)
        t[i >> 1] >> 4 >= 8 && r[i] && (r[i] = r[i].toUpperCase()),
        (t[i >> 1] & 15) >= 8 && r[i + 1] && (r[i + 1] = r[i + 1].toUpperCase());
    const s = `0x${r.join("")}`;
    return b5.set(n, s),
    s
}
function bce(n, e={}) {
    const {checksum: t=!1} = e;
    return Fz(n),
    t ? Uz(n) : n
}
function wce(n, e={}) {
    const t = Pz(`0x${fce(n).slice(4)}`).substring(26);
    return bce(`0x${t}`, e)
}
class MB extends er {
    constructor({address: e, cause: t}) {
        super(`Address "${e}" is invalid.`, {
            cause: t
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Address.InvalidAddressError"
        })
    }
}
class vce extends er {
    constructor() {
        super("Address is not a 20 byte (40 hexadecimal character) value."),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Address.InvalidInputError"
        })
    }
}
class xce extends er {
    constructor() {
        super("Address does not match its checksum counterpart."),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Address.InvalidChecksumError"
        })
    }
}
const Ci = BigInt(0)
  , ei = BigInt(1)
  , uf = BigInt(2)
  , Ece = BigInt(3)
  , zz = BigInt(4)
  , $z = BigInt(5)
  , Hz = BigInt(8);
function wi(n, e) {
    const t = n % e;
    return t >= Ci ? t : e + t
}
function bo(n, e, t) {
    let r = n;
    for (; e-- > Ci; )
        r *= r,
        r %= t;
    return r
}
function q4(n, e) {
    if (n === Ci)
        throw new Error("invert: expected non-zero number");
    if (e <= Ci)
        throw new Error("invert: expected positive modulus, got " + e);
    let t = wi(n, e)
      , r = e
      , s = Ci
      , i = ei;
    for (; t !== Ci; ) {
        const a = r / t
          , l = r % t
          , u = s - i * a;
        r = t,
        t = l,
        s = i,
        i = u
    }
    if (r !== ei)
        throw new Error("invert: does not exist");
    return wi(s, e)
}
function Vz(n, e) {
    const t = (n.ORDER + ei) / zz
      , r = n.pow(e, t);
    if (!n.eql(n.sqr(r), e))
        throw new Error("Cannot find square root");
    return r
}
function Sce(n, e) {
    const t = (n.ORDER - $z) / Hz
      , r = n.mul(e, uf)
      , s = n.pow(r, t)
      , i = n.mul(e, s)
      , o = n.mul(n.mul(i, uf), s)
      , a = n.mul(i, n.sub(o, n.ONE));
    if (!n.eql(n.sqr(a), e))
        throw new Error("Cannot find square root");
    return a
}
function Ace(n) {
    if (n < BigInt(3))
        throw new Error("sqrt is not defined for small field");
    let e = n - ei
      , t = 0;
    for (; e % uf === Ci; )
        e /= uf,
        t++;
    let r = uf;
    const s = S_(n);
    for (; BB(s, r) === 1; )
        if (r++ > 1e3)
            throw new Error("Cannot find square root: probably non-prime P");
    if (t === 1)
        return Vz;
    let i = s.pow(r, e);
    const o = (e + ei) / uf;
    return function(l, u) {
        if (l.is0(u))
            return u;
        if (BB(l, u) !== 1)
            throw new Error("Cannot find square root");
        let d = t
          , h = l.mul(l.ONE, i)
          , p = l.pow(u, e)
          , g = l.pow(u, o);
        for (; !l.eql(p, l.ONE); ) {
            if (l.is0(p))
                return l.ZERO;
            let w = 1
              , b = l.sqr(p);
            for (; !l.eql(b, l.ONE); )
                if (w++,
                b = l.sqr(b),
                w === d)
                    throw new Error("Cannot find square root");
            const v = ei << BigInt(d - w - 1)
              , S = l.pow(h, v);
            d = w,
            h = l.sqr(S),
            p = l.mul(p, h),
            g = l.mul(g, S)
        }
        return g
    }
}
function Cce(n) {
    return n % zz === Ece ? Vz : n % Hz === $z ? Sce : Ace(n)
}
const _ce = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];
function kce(n) {
    const e = {
        ORDER: "bigint",
        MASK: "bigint",
        BYTES: "isSafeInteger",
        BITS: "isSafeInteger"
    }
      , t = _ce.reduce( (r, s) => (r[s] = "function",
    r), e);
    return ox(n, t)
}
function Nce(n, e, t) {
    if (t < Ci)
        throw new Error("invalid exponent, negatives unsupported");
    if (t === Ci)
        return n.ONE;
    if (t === ei)
        return e;
    let r = n.ONE
      , s = e;
    for (; t > Ci; )
        t & ei && (r = n.mul(r, s)),
        s = n.sqr(s),
        t >>= ei;
    return r
}
function qz(n, e, t=!1) {
    const r = new Array(e.length).fill(t ? n.ZERO : void 0)
      , s = e.reduce( (o, a, l) => n.is0(a) ? o : (r[l] = o,
    n.mul(o, a)), n.ONE)
      , i = n.inv(s);
    return e.reduceRight( (o, a, l) => n.is0(a) ? o : (r[l] = n.mul(o, r[l]),
    n.mul(o, a)), i),
    r
}
function BB(n, e) {
    const t = (n.ORDER - ei) / uf
      , r = n.pow(e, t)
      , s = n.eql(r, n.ONE)
      , i = n.eql(r, n.ZERO)
      , o = n.eql(r, n.neg(n.ONE));
    if (!s && !i && !o)
        throw new Error("invalid Legendre symbol result");
    return s ? 1 : i ? 0 : -1
}
function Gz(n, e) {
    e !== void 0 && Jp(e);
    const t = e !== void 0 ? e : n.toString(2).length
      , r = Math.ceil(t / 8);
    return {
        nBitLength: t,
        nByteLength: r
    }
}
function S_(n, e, t=!1, r={}) {
    if (n <= Ci)
        throw new Error("invalid field: expected ORDER > 0, got " + n);
    const {nBitLength: s, nByteLength: i} = Gz(n, e);
    if (i > 2048)
        throw new Error("invalid field: expected ORDER of <= 2048 bytes");
    let o;
    const a = Object.freeze({
        ORDER: n,
        isLE: t,
        BITS: s,
        BYTES: i,
        MASK: ix(s),
        ZERO: Ci,
        ONE: ei,
        create: l => wi(l, n),
        isValid: l => {
            if (typeof l != "bigint")
                throw new Error("invalid field element: expected bigint, got " + typeof l);
            return Ci <= l && l < n
        }
        ,
        is0: l => l === Ci,
        isOdd: l => (l & ei) === ei,
        neg: l => wi(-l, n),
        eql: (l, u) => l === u,
        sqr: l => wi(l * l, n),
        add: (l, u) => wi(l + u, n),
        sub: (l, u) => wi(l - u, n),
        mul: (l, u) => wi(l * u, n),
        pow: (l, u) => Nce(a, l, u),
        div: (l, u) => wi(l * q4(u, n), n),
        sqrN: l => l * l,
        addN: (l, u) => l + u,
        subN: (l, u) => l - u,
        mulN: (l, u) => l * u,
        inv: l => q4(l, n),
        sqrt: r.sqrt || (l => (o || (o = Cce(n)),
        o(a, l))),
        toBytes: l => t ? Iz(l, i) : Uy(l, i),
        fromBytes: l => {
            if (l.length !== i)
                throw new Error("Field.fromBytes: expected " + i + " bytes, got " + l.length);
            return t ? Tz(l) : Sf(l)
        }
        ,
        invertBatch: l => qz(a, l),
        cmov: (l, u, d) => d ? u : l
    });
    return Object.freeze(a)
}
function Wz(n) {
    if (typeof n != "bigint")
        throw new Error("field order must be bigint");
    const e = n.toString(2).length;
    return Math.ceil(e / 8)
}
function Yz(n) {
    const e = Wz(n);
    return e + Math.ceil(e / 2)
}
function Dce(n, e, t=!1) {
    const r = n.length
      , s = Wz(e)
      , i = Yz(e);
    if (r < 16 || r < i || r > 1024)
        throw new Error("expected " + i + "-1024 bytes of input, got " + r);
    const o = t ? Tz(n) : Sf(n)
      , a = wi(o, e - ei) + ei;
    return t ? Iz(a, s) : Uy(a, s)
}
const RB = BigInt(0)
  , G4 = BigInt(1);
function w5(n, e) {
    const t = e.negate();
    return n ? t : e
}
function Kz(n, e) {
    if (!Number.isSafeInteger(n) || n <= 0 || n > e)
        throw new Error("invalid window size, expected [1.." + e + "], got W=" + n)
}
function v5(n, e) {
    Kz(n, e);
    const t = Math.ceil(e / n) + 1
      , r = 2 ** (n - 1)
      , s = 2 ** n
      , i = ix(n)
      , o = BigInt(n);
    return {
        windows: t,
        windowSize: r,
        mask: i,
        maxNumber: s,
        shiftBy: o
    }
}
function OB(n, e, t) {
    const {windowSize: r, mask: s, maxNumber: i, shiftBy: o} = t;
    let a = Number(n & s)
      , l = n >> o;
    a > r && (a -= i,
    l += G4);
    const u = e * r
      , d = u + Math.abs(a) - 1
      , h = a === 0
      , p = a < 0
      , g = e % 2 !== 0;
    return {
        nextN: l,
        offset: d,
        isZero: h,
        isNeg: p,
        isNegF: g,
        offsetF: u
    }
}
function Tce(n, e) {
    if (!Array.isArray(n))
        throw new Error("array expected");
    n.forEach( (t, r) => {
        if (!(t instanceof e))
            throw new Error("invalid point at index " + r)
    }
    )
}
function Ice(n, e) {
    if (!Array.isArray(n))
        throw new Error("array of scalars expected");
    n.forEach( (t, r) => {
        if (!e.isValid(t))
            throw new Error("invalid scalar at index " + r)
    }
    )
}
const x5 = new WeakMap
  , Xz = new WeakMap;
function E5(n) {
    return Xz.get(n) || 1
}
function Mce(n, e) {
    return {
        constTimeNegate: w5,
        hasPrecomputes(t) {
            return E5(t) !== 1
        },
        unsafeLadder(t, r, s=n.ZERO) {
            let i = t;
            for (; r > RB; )
                r & G4 && (s = s.add(i)),
                i = i.double(),
                r >>= G4;
            return s
        },
        precomputeWindow(t, r) {
            const {windows: s, windowSize: i} = v5(r, e)
              , o = [];
            let a = t
              , l = a;
            for (let u = 0; u < s; u++) {
                l = a,
                o.push(l);
                for (let d = 1; d < i; d++)
                    l = l.add(a),
                    o.push(l);
                a = l.double()
            }
            return o
        },
        wNAF(t, r, s) {
            let i = n.ZERO
              , o = n.BASE;
            const a = v5(t, e);
            for (let l = 0; l < a.windows; l++) {
                const {nextN: u, offset: d, isZero: h, isNeg: p, isNegF: g, offsetF: w} = OB(s, l, a);
                s = u,
                h ? o = o.add(w5(g, r[w])) : i = i.add(w5(p, r[d]))
            }
            return {
                p: i,
                f: o
            }
        },
        wNAFUnsafe(t, r, s, i=n.ZERO) {
            const o = v5(t, e);
            for (let a = 0; a < o.windows && s !== RB; a++) {
                const {nextN: l, offset: u, isZero: d, isNeg: h} = OB(s, a, o);
                if (s = l,
                !d) {
                    const p = r[u];
                    i = i.add(h ? p.negate() : p)
                }
            }
            return i
        },
        getPrecomputes(t, r, s) {
            let i = x5.get(r);
            return i || (i = this.precomputeWindow(r, t),
            t !== 1 && x5.set(r, s(i))),
            i
        },
        wNAFCached(t, r, s) {
            const i = E5(t);
            return this.wNAF(i, this.getPrecomputes(i, t, s), r)
        },
        wNAFCachedUnsafe(t, r, s, i) {
            const o = E5(t);
            return o === 1 ? this.unsafeLadder(t, r, i) : this.wNAFUnsafe(o, this.getPrecomputes(o, t, s), r, i)
        },
        setWindowSize(t, r) {
            Kz(r, e),
            Xz.set(t, r),
            x5.delete(t)
        }
    }
}
function Bce(n, e, t, r) {
    Tce(t, n),
    Ice(r, e);
    const s = t.length
      , i = r.length;
    if (s !== i)
        throw new Error("arrays of points and scalars must have equal length");
    const o = n.ZERO
      , a = Ple(BigInt(s));
    let l = 1;
    a > 12 ? l = a - 3 : a > 4 ? l = a - 2 : a > 0 && (l = 2);
    const u = ix(l)
      , d = new Array(Number(u) + 1).fill(o)
      , h = Math.floor((e.BITS - 1) / l) * l;
    let p = o;
    for (let g = h; g >= 0; g -= l) {
        d.fill(o);
        for (let b = 0; b < i; b++) {
            const v = r[b]
              , S = Number(v >> BigInt(g) & u);
            d[S] = d[S].add(t[b])
        }
        let w = o;
        for (let b = d.length - 1, v = o; b > 0; b--)
            v = v.add(d[b]),
            w = w.add(v);
        if (p = p.add(w),
        g !== 0)
            for (let b = 0; b < l; b++)
                p = p.double()
    }
    return p
}
function Qz(n) {
    return kce(n.Fp),
    ox(n, {
        n: "bigint",
        h: "bigint",
        Gx: "field",
        Gy: "field"
    }, {
        nBitLength: "isSafeInteger",
        nByteLength: "isSafeInteger"
    }),
    Object.freeze({
        ...Gz(n.n, n.nBitLength),
        ...n,
        p: n.Fp.ORDER
    })
}
function PB(n) {
    n.lowS !== void 0 && ey("lowS", n.lowS),
    n.prehash !== void 0 && ey("prehash", n.prehash)
}
function Rce(n) {
    const e = Qz(n);
    ox(e, {
        a: "field",
        b: "field"
    }, {
        allowInfinityPoint: "boolean",
        allowedPrivateKeyLengths: "array",
        clearCofactor: "function",
        fromBytes: "function",
        isTorsionFree: "function",
        toBytes: "function",
        wrapPrivateKey: "boolean"
    });
    const {endo: t, Fp: r, a: s} = e;
    if (t) {
        if (!r.eql(s, r.ZERO))
            throw new Error("invalid endo: CURVE.a must be 0");
        if (typeof t != "object" || typeof t.beta != "bigint" || typeof t.splitScalar != "function")
            throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function')
    }
    return Object.freeze({
        ...e
    })
}
class Oce extends Error {
    constructor(e="") {
        super(e)
    }
}
const Zl = {
    Err: Oce,
    _tlv: {
        encode: (n, e) => {
            const {Err: t} = Zl;
            if (n < 0 || n > 256)
                throw new t("tlv.encode: wrong tag");
            if (e.length & 1)
                throw new t("tlv.encode: unpadded data");
            const r = e.length / 2
              , s = L1(r);
            if (s.length / 2 & 128)
                throw new t("tlv.encode: long form length too big");
            const i = r > 127 ? L1(s.length / 2 | 128) : "";
            return L1(n) + i + s + e
        }
        ,
        decode(n, e) {
            const {Err: t} = Zl;
            let r = 0;
            if (n < 0 || n > 256)
                throw new t("tlv.encode: wrong tag");
            if (e.length < 2 || e[r++] !== n)
                throw new t("tlv.decode: wrong tlv");
            const s = e[r++]
              , i = !!(s & 128);
            let o = 0;
            if (!i)
                o = s;
            else {
                const l = s & 127;
                if (!l)
                    throw new t("tlv.decode(long): indefinite length not supported");
                if (l > 4)
                    throw new t("tlv.decode(long): byte length is too big");
                const u = e.subarray(r, r + l);
                if (u.length !== l)
                    throw new t("tlv.decode: length bytes not complete");
                if (u[0] === 0)
                    throw new t("tlv.decode(long): zero leftmost byte");
                for (const d of u)
                    o = o << 8 | d;
                if (r += l,
                o < 128)
                    throw new t("tlv.decode(long): not minimal encoding")
            }
            const a = e.subarray(r, r + o);
            if (a.length !== o)
                throw new t("tlv.decode: wrong value length");
            return {
                v: a,
                l: e.subarray(r + o)
            }
        }
    },
    _int: {
        encode(n) {
            const {Err: e} = Zl;
            if (n < ac)
                throw new e("integer: negative integers are not allowed");
            let t = L1(n);
            if (Number.parseInt(t[0], 16) & 8 && (t = "00" + t),
            t.length & 1)
                throw new e("unexpected DER parsing assertion: unpadded hex");
            return t
        },
        decode(n) {
            const {Err: e} = Zl;
            if (n[0] & 128)
                throw new e("invalid signature integer: negative");
            if (n[0] === 0 && !(n[1] & 128))
                throw new e("invalid signature integer: unnecessary leading zero");
            return Sf(n)
        }
    },
    toSig(n) {
        const {Err: e, _int: t, _tlv: r} = Zl
          , s = So("signature", n)
          , {v: i, l: o} = r.decode(48, s);
        if (o.length)
            throw new e("invalid signature: left bytes after parsing");
        const {v: a, l} = r.decode(2, i)
          , {v: u, l: d} = r.decode(2, l);
        if (d.length)
            throw new e("invalid signature: left bytes after parsing");
        return {
            r: t.decode(a),
            s: t.decode(u)
        }
    },
    hexFromSig(n) {
        const {_tlv: e, _int: t} = Zl
          , r = e.encode(2, t.encode(n.r))
          , s = e.encode(2, t.encode(n.s))
          , i = r + s;
        return e.encode(48, i)
    }
};
function S5(n, e) {
    return ty(Uy(n, e))
}
const ac = BigInt(0)
  , Jr = BigInt(1);
BigInt(2);
const A5 = BigInt(3)
  , Pce = BigInt(4);
function jce(n) {
    const e = Rce(n)
      , {Fp: t} = e
      , r = S_(e.n, e.nBitLength)
      , s = e.toBytes || ( (_, I, k) => {
        const B = I.toAffine();
        return I2(Uint8Array.from([4]), t.toBytes(B.x), t.toBytes(B.y))
    }
    )
      , i = e.fromBytes || (_ => {
        const I = _.subarray(1)
          , k = t.fromBytes(I.subarray(0, t.BYTES))
          , B = t.fromBytes(I.subarray(t.BYTES, 2 * t.BYTES));
        return {
            x: k,
            y: B
        }
    }
    );
    function o(_) {
        const {a: I, b: k} = e
          , B = t.sqr(_)
          , P = t.mul(B, _);
        return t.add(t.add(P, t.mul(_, I)), k)
    }
    function a(_, I) {
        const k = t.sqr(I)
          , B = o(_);
        return t.eql(k, B)
    }
    if (!a(e.Gx, e.Gy))
        throw new Error("bad curve params: generator point");
    const l = t.mul(t.pow(e.a, A5), Pce)
      , u = t.mul(t.sqr(e.b), BigInt(27));
    if (t.is0(t.add(l, u)))
        throw new Error("bad curve params: a or b");
    function d(_) {
        return v_(_, Jr, e.n)
    }
    function h(_) {
        const {allowedPrivateKeyLengths: I, nByteLength: k, wrapPrivateKey: B, n: P} = e;
        if (I && typeof _ != "bigint") {
            if (Fy(_) && (_ = ty(_)),
            typeof _ != "string" || !I.includes(_.length))
                throw new Error("invalid private key");
            _ = _.padStart(k * 2, "0")
        }
        let M;
        try {
            M = typeof _ == "bigint" ? _ : Sf(So("private key", _, k))
        } catch {
            throw new Error("invalid private key, expected hex or " + k + " bytes, got " + typeof _)
        }
        return B && (M = wi(M, P)),
        Ip("private key", M, Jr, P),
        M
    }
    function p(_) {
        if (!(_ instanceof b))
            throw new Error("ProjectivePoint expected")
    }
    const g = _B( (_, I) => {
        const {px: k, py: B, pz: P} = _;
        if (t.eql(P, t.ONE))
            return {
                x: k,
                y: B
            };
        const M = _.is0();
        I == null && (I = M ? t.ONE : t.inv(P));
        const R = t.mul(k, I)
          , L = t.mul(B, I)
          , q = t.mul(P, I);
        if (M)
            return {
                x: t.ZERO,
                y: t.ZERO
            };
        if (!t.eql(q, t.ONE))
            throw new Error("invZ was invalid");
        return {
            x: R,
            y: L
        }
    }
    )
      , w = _B(_ => {
        if (_.is0()) {
            if (e.allowInfinityPoint && !t.is0(_.py))
                return;
            throw new Error("bad point: ZERO")
        }
        const {x: I, y: k} = _.toAffine();
        if (!t.isValid(I) || !t.isValid(k))
            throw new Error("bad point: x or y not FE");
        if (!a(I, k))
            throw new Error("bad point: equation left != right");
        if (!_.isTorsionFree())
            throw new Error("bad point: not in prime-order subgroup");
        return !0
    }
    );
    class b {
        constructor(I, k, B) {
            if (I == null || !t.isValid(I))
                throw new Error("x required");
            if (k == null || !t.isValid(k) || t.is0(k))
                throw new Error("y required");
            if (B == null || !t.isValid(B))
                throw new Error("z required");
            this.px = I,
            this.py = k,
            this.pz = B,
            Object.freeze(this)
        }
        static fromAffine(I) {
            const {x: k, y: B} = I || {};
            if (!I || !t.isValid(k) || !t.isValid(B))
                throw new Error("invalid affine point");
            if (I instanceof b)
                throw new Error("projective point not allowed");
            const P = M => t.eql(M, t.ZERO);
            return P(k) && P(B) ? b.ZERO : new b(k,B,t.ONE)
        }
        get x() {
            return this.toAffine().x
        }
        get y() {
            return this.toAffine().y
        }
        static normalizeZ(I) {
            const k = qz(t, I.map(B => B.pz));
            return I.map( (B, P) => B.toAffine(k[P])).map(b.fromAffine)
        }
        static fromHex(I) {
            const k = b.fromAffine(i(So("pointHex", I)));
            return k.assertValidity(),
            k
        }
        static fromPrivateKey(I) {
            return b.BASE.multiply(h(I))
        }
        static msm(I, k) {
            return Bce(b, r, I, k)
        }
        _setWindowSize(I) {
            N.setWindowSize(this, I)
        }
        assertValidity() {
            w(this)
        }
        hasEvenY() {
            const {y: I} = this.toAffine();
            if (t.isOdd)
                return !t.isOdd(I);
            throw new Error("Field doesn't support isOdd")
        }
        equals(I) {
            p(I);
            const {px: k, py: B, pz: P} = this
              , {px: M, py: R, pz: L} = I
              , q = t.eql(t.mul(k, L), t.mul(M, P))
              , H = t.eql(t.mul(B, L), t.mul(R, P));
            return q && H
        }
        negate() {
            return new b(this.px,t.neg(this.py),this.pz)
        }
        double() {
            const {a: I, b: k} = e
              , B = t.mul(k, A5)
              , {px: P, py: M, pz: R} = this;
            let L = t.ZERO
              , q = t.ZERO
              , H = t.ZERO
              , j = t.mul(P, P)
              , A = t.mul(M, M)
              , E = t.mul(R, R)
              , C = t.mul(P, M);
            return C = t.add(C, C),
            H = t.mul(P, R),
            H = t.add(H, H),
            L = t.mul(I, H),
            q = t.mul(B, E),
            q = t.add(L, q),
            L = t.sub(A, q),
            q = t.add(A, q),
            q = t.mul(L, q),
            L = t.mul(C, L),
            H = t.mul(B, H),
            E = t.mul(I, E),
            C = t.sub(j, E),
            C = t.mul(I, C),
            C = t.add(C, H),
            H = t.add(j, j),
            j = t.add(H, j),
            j = t.add(j, E),
            j = t.mul(j, C),
            q = t.add(q, j),
            E = t.mul(M, R),
            E = t.add(E, E),
            j = t.mul(E, C),
            L = t.sub(L, j),
            H = t.mul(E, A),
            H = t.add(H, H),
            H = t.add(H, H),
            new b(L,q,H)
        }
        add(I) {
            p(I);
            const {px: k, py: B, pz: P} = this
              , {px: M, py: R, pz: L} = I;
            let q = t.ZERO
              , H = t.ZERO
              , j = t.ZERO;
            const A = e.a
              , E = t.mul(e.b, A5);
            let C = t.mul(k, M)
              , O = t.mul(B, R)
              , z = t.mul(P, L)
              , G = t.add(k, B)
              , Y = t.add(M, R);
            G = t.mul(G, Y),
            Y = t.add(C, O),
            G = t.sub(G, Y),
            Y = t.add(k, P);
            let $ = t.add(M, L);
            return Y = t.mul(Y, $),
            $ = t.add(C, z),
            Y = t.sub(Y, $),
            $ = t.add(B, P),
            q = t.add(R, L),
            $ = t.mul($, q),
            q = t.add(O, z),
            $ = t.sub($, q),
            j = t.mul(A, Y),
            q = t.mul(E, z),
            j = t.add(q, j),
            q = t.sub(O, j),
            j = t.add(O, j),
            H = t.mul(q, j),
            O = t.add(C, C),
            O = t.add(O, C),
            z = t.mul(A, z),
            Y = t.mul(E, Y),
            O = t.add(O, z),
            z = t.sub(C, z),
            z = t.mul(A, z),
            Y = t.add(Y, z),
            C = t.mul(O, Y),
            H = t.add(H, C),
            C = t.mul($, Y),
            q = t.mul(G, q),
            q = t.sub(q, C),
            C = t.mul(G, O),
            j = t.mul($, j),
            j = t.add(j, C),
            new b(q,H,j)
        }
        subtract(I) {
            return this.add(I.negate())
        }
        is0() {
            return this.equals(b.ZERO)
        }
        wNAF(I) {
            return N.wNAFCached(this, I, b.normalizeZ)
        }
        multiplyUnsafe(I) {
            const {endo: k, n: B} = e;
            Ip("scalar", I, ac, B);
            const P = b.ZERO;
            if (I === ac)
                return P;
            if (this.is0() || I === Jr)
                return this;
            if (!k || N.hasPrecomputes(this))
                return N.wNAFCachedUnsafe(this, I, b.normalizeZ);
            let {k1neg: M, k1: R, k2neg: L, k2: q} = k.splitScalar(I)
              , H = P
              , j = P
              , A = this;
            for (; R > ac || q > ac; )
                R & Jr && (H = H.add(A)),
                q & Jr && (j = j.add(A)),
                A = A.double(),
                R >>= Jr,
                q >>= Jr;
            return M && (H = H.negate()),
            L && (j = j.negate()),
            j = new b(t.mul(j.px, k.beta),j.py,j.pz),
            H.add(j)
        }
        multiply(I) {
            const {endo: k, n: B} = e;
            Ip("scalar", I, Jr, B);
            let P, M;
            if (k) {
                const {k1neg: R, k1: L, k2neg: q, k2: H} = k.splitScalar(I);
                let {p: j, f: A} = this.wNAF(L)
                  , {p: E, f: C} = this.wNAF(H);
                j = N.constTimeNegate(R, j),
                E = N.constTimeNegate(q, E),
                E = new b(t.mul(E.px, k.beta),E.py,E.pz),
                P = j.add(E),
                M = A.add(C)
            } else {
                const {p: R, f: L} = this.wNAF(I);
                P = R,
                M = L
            }
            return b.normalizeZ([P, M])[0]
        }
        multiplyAndAddUnsafe(I, k, B) {
            const P = b.BASE
              , M = (L, q) => q === ac || q === Jr || !L.equals(P) ? L.multiplyUnsafe(q) : L.multiply(q)
              , R = M(this, k).add(M(I, B));
            return R.is0() ? void 0 : R
        }
        toAffine(I) {
            return g(this, I)
        }
        isTorsionFree() {
            const {h: I, isTorsionFree: k} = e;
            if (I === Jr)
                return !0;
            if (k)
                return k(b, this);
            throw new Error("isTorsionFree() has not been declared for the elliptic curve")
        }
        clearCofactor() {
            const {h: I, clearCofactor: k} = e;
            return I === Jr ? this : k ? k(b, this) : this.multiplyUnsafe(e.h)
        }
        toRawBytes(I=!0) {
            return ey("isCompressed", I),
            this.assertValidity(),
            s(b, this, I)
        }
        toHex(I=!0) {
            return ey("isCompressed", I),
            ty(this.toRawBytes(I))
        }
    }
    b.BASE = new b(e.Gx,e.Gy,t.ONE),
    b.ZERO = new b(t.ZERO,t.ONE,t.ZERO);
    const {endo: v, nBitLength: S} = e
      , N = Mce(b, v ? Math.ceil(S / 2) : S);
    return {
        CURVE: e,
        ProjectivePoint: b,
        normPrivateKeyToScalar: h,
        weierstrassEquation: o,
        isWithinCurveOrder: d
    }
}
function Lce(n) {
    const e = Qz(n);
    return ox(e, {
        hash: "hash",
        hmac: "function",
        randomBytes: "function"
    }, {
        bits2int: "function",
        bits2int_modN: "function",
        lowS: "boolean"
    }),
    Object.freeze({
        lowS: !0,
        ...e
    })
}
function Fce(n) {
    const e = Lce(n)
      , {Fp: t, n: r, nByteLength: s, nBitLength: i} = e
      , o = t.BYTES + 1
      , a = 2 * t.BYTES + 1;
    function l(E) {
        return wi(E, r)
    }
    function u(E) {
        return q4(E, r)
    }
    const {ProjectivePoint: d, normPrivateKeyToScalar: h, weierstrassEquation: p, isWithinCurveOrder: g} = jce({
        ...e,
        toBytes(E, C, O) {
            const z = C.toAffine()
              , G = t.toBytes(z.x)
              , Y = I2;
            return ey("isCompressed", O),
            O ? Y(Uint8Array.from([C.hasEvenY() ? 2 : 3]), G) : Y(Uint8Array.from([4]), G, t.toBytes(z.y))
        },
        fromBytes(E) {
            const C = E.length
              , O = E[0]
              , z = E.subarray(1);
            if (C === o && (O === 2 || O === 3)) {
                const G = Sf(z);
                if (!v_(G, Jr, t.ORDER))
                    throw new Error("Point is not on curve");
                const Y = p(G);
                let $;
                try {
                    $ = t.sqrt(Y)
                } catch (W) {
                    const Q = W instanceof Error ? ": " + W.message : "";
                    throw new Error("Point is not on curve" + Q)
                }
                const D = ($ & Jr) === Jr;
                return (O & 1) === 1 !== D && ($ = t.neg($)),
                {
                    x: G,
                    y: $
                }
            } else if (C === a && O === 4) {
                const G = t.fromBytes(z.subarray(0, t.BYTES))
                  , Y = t.fromBytes(z.subarray(t.BYTES, 2 * t.BYTES));
                return {
                    x: G,
                    y: Y
                }
            } else {
                const G = o
                  , Y = a;
                throw new Error("invalid Point, expected length of " + G + ", or uncompressed " + Y + ", got " + C)
            }
        }
    });
    function w(E) {
        const C = r >> Jr;
        return E > C
    }
    function b(E) {
        return w(E) ? l(-E) : E
    }
    const v = (E, C, O) => Sf(E.slice(C, O));
    class S {
        constructor(C, O, z) {
            Ip("r", C, Jr, r),
            Ip("s", O, Jr, r),
            this.r = C,
            this.s = O,
            z != null && (this.recovery = z),
            Object.freeze(this)
        }
        static fromCompact(C) {
            const O = s;
            return C = So("compactSignature", C, O * 2),
            new S(v(C, 0, O),v(C, O, 2 * O))
        }
        static fromDER(C) {
            const {r: O, s: z} = Zl.toSig(So("DER", C));
            return new S(O,z)
        }
        assertValidity() {}
        addRecoveryBit(C) {
            return new S(this.r,this.s,C)
        }
        recoverPublicKey(C) {
            const {r: O, s: z, recovery: G} = this
              , Y = P(So("msgHash", C));
            if (G == null || ![0, 1, 2, 3].includes(G))
                throw new Error("recovery id invalid");
            const $ = G === 2 || G === 3 ? O + e.n : O;
            if ($ >= t.ORDER)
                throw new Error("recovery id 2 or 3 invalid");
            const D = (G & 1) === 0 ? "02" : "03"
              , U = d.fromHex(D + S5($, t.BYTES))
              , W = u($)
              , Q = l(-Y * W)
              , J = l(z * W)
              , ne = d.BASE.multiplyAndAddUnsafe(U, Q, J);
            if (!ne)
                throw new Error("point at infinify");
            return ne.assertValidity(),
            ne
        }
        hasHighS() {
            return w(this.s)
        }
        normalizeS() {
            return this.hasHighS() ? new S(this.r,l(-this.s),this.recovery) : this
        }
        toDERRawBytes() {
            return T2(this.toDERHex())
        }
        toDERHex() {
            return Zl.hexFromSig(this)
        }
        toCompactRawBytes() {
            return T2(this.toCompactHex())
        }
        toCompactHex() {
            const C = s;
            return S5(this.r, C) + S5(this.s, C)
        }
    }
    const N = {
        isValidPrivateKey(E) {
            try {
                return h(E),
                !0
            } catch {
                return !1
            }
        },
        normPrivateKeyToScalar: h,
        randomPrivateKey: () => {
            const E = Yz(e.n);
            return Dce(e.randomBytes(E), e.n)
        }
        ,
        precompute(E=8, C=d.BASE) {
            return C._setWindowSize(E),
            C.multiply(BigInt(3)),
            C
        }
    };
    function _(E, C=!0) {
        return d.fromPrivateKey(E).toRawBytes(C)
    }
    function I(E) {
        if (typeof E == "bigint")
            return !1;
        if (E instanceof d)
            return !0;
        const O = So("key", E).length
          , z = t.BYTES
          , G = z + 1
          , Y = 2 * z + 1;
        if (!(e.allowedPrivateKeyLengths || s === G))
            return O === G || O === Y
    }
    function k(E, C, O=!0) {
        if (I(E) === !0)
            throw new Error("first arg must be private key");
        if (I(C) === !1)
            throw new Error("second arg must be public key");
        return d.fromHex(C).multiply(h(E)).toRawBytes(O)
    }
    const B = e.bits2int || function(E) {
        if (E.length > 8192)
            throw new Error("input is too large");
        const C = Sf(E)
          , O = E.length * 8 - i;
        return O > 0 ? C >> BigInt(O) : C
    }
      , P = e.bits2int_modN || function(E) {
        return l(B(E))
    }
      , M = ix(i);
    function R(E) {
        return Ip("num < 2^" + i, E, ac, M),
        Uy(E, s)
    }
    function L(E, C, O=q) {
        if (["recovered", "canonical"].some(ae => ae in O))
            throw new Error("sign() legacy options not supported");
        const {hash: z, randomBytes: G} = e;
        let {lowS: Y, prehash: $, extraEntropy: D} = O;
        Y == null && (Y = !0),
        E = So("msgHash", E),
        PB(O),
        $ && (E = So("prehashed msgHash", z(E)));
        const U = P(E)
          , W = h(C)
          , Q = [R(W), R(U)];
        if (D != null && D !== !1) {
            const ae = D === !0 ? G(t.BYTES) : D;
            Q.push(So("extraEntropy", ae))
        }
        const J = I2(...Q)
          , ne = U;
        function ie(ae) {
            const xe = B(ae);
            if (!g(xe))
                return;
            const ue = u(xe)
              , ce = d.BASE.multiply(xe).toAffine()
              , me = l(ce.x);
            if (me === ac)
                return;
            const Ee = l(ue * l(ne + me * W));
            if (Ee === ac)
                return;
            let Oe = (ce.x === me ? 0 : 2) | Number(ce.y & Jr)
              , mt = Ee;
            return Y && w(Ee) && (mt = b(Ee),
            Oe ^= 1),
            new S(me,mt,Oe)
        }
        return {
            seed: J,
            k2sig: ie
        }
    }
    const q = {
        lowS: e.lowS,
        prehash: !1
    }
      , H = {
        lowS: e.lowS,
        prehash: !1
    };
    function j(E, C, O=q) {
        const {seed: z, k2sig: G} = L(E, C, O)
          , Y = e;
        return jle(Y.hash.outputLen, Y.nByteLength, Y.hmac)(z, G)
    }
    d.BASE._setWindowSize(8);
    function A(E, C, O, z=H) {
        const G = E;
        C = So("msgHash", C),
        O = So("publicKey", O);
        const {lowS: Y, prehash: $, format: D} = z;
        if (PB(z),
        "strict"in z)
            throw new Error("options.strict was renamed to lowS");
        if (D !== void 0 && D !== "compact" && D !== "der")
            throw new Error("format must be compact or der");
        const U = typeof G == "string" || Fy(G)
          , W = !U && !D && typeof G == "object" && G !== null && typeof G.r == "bigint" && typeof G.s == "bigint";
        if (!U && !W)
            throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
        let Q, J;
        try {
            if (W && (Q = new S(G.r,G.s)),
            U) {
                try {
                    D !== "compact" && (Q = S.fromDER(G))
                } catch (Oe) {
                    if (!(Oe instanceof Zl.Err))
                        throw Oe
                }
                !Q && D !== "der" && (Q = S.fromCompact(G))
            }
            J = d.fromHex(O)
        } catch {
            return !1
        }
        if (!Q || Y && Q.hasHighS())
            return !1;
        $ && (C = e.hash(C));
        const {r: ne, s: ie} = Q
          , ae = P(C)
          , xe = u(ie)
          , ue = l(ae * xe)
          , ce = l(ne * xe)
          , me = d.BASE.multiplyAndAddUnsafe(J, ue, ce)?.toAffine();
        return me ? l(me.x) === ne : !1
    }
    return {
        CURVE: e,
        getPublicKey: _,
        getSharedSecret: k,
        sign: j,
        verify: A,
        ProjectivePoint: d,
        Signature: S,
        utils: N
    }
}
function Uce(n) {
    return {
        hash: n,
        hmac: (e, ...t) => l_(n, e, ra(...t)),
        randomBytes: Xv
    }
}
function zce(n, e) {
    const t = r => Fce({
        ...n,
        ...Uce(r)
    });
    return {
        ...t(e),
        create: t
    }
}
const Zz = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f")
  , jB = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141")
  , $ce = BigInt(0)
  , Hce = BigInt(1)
  , W4 = BigInt(2)
  , LB = (n, e) => (n + e / W4) / e;
function Vce(n) {
    const e = Zz
      , t = BigInt(3)
      , r = BigInt(6)
      , s = BigInt(11)
      , i = BigInt(22)
      , o = BigInt(23)
      , a = BigInt(44)
      , l = BigInt(88)
      , u = n * n * n % e
      , d = u * u * n % e
      , h = bo(d, t, e) * d % e
      , p = bo(h, t, e) * d % e
      , g = bo(p, W4, e) * u % e
      , w = bo(g, s, e) * g % e
      , b = bo(w, i, e) * w % e
      , v = bo(b, a, e) * b % e
      , S = bo(v, l, e) * v % e
      , N = bo(S, a, e) * b % e
      , _ = bo(N, t, e) * d % e
      , I = bo(_, o, e) * w % e
      , k = bo(I, r, e) * u % e
      , B = bo(k, W4, e);
    if (!Y4.eql(Y4.sqr(B), n))
        throw new Error("Cannot find square root");
    return B
}
const Y4 = S_(Zz, void 0, void 0, {
    sqrt: Vce
})
  , qce = zce({
    a: $ce,
    b: BigInt(7),
    Fp: Y4,
    n: jB,
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    h: BigInt(1),
    lowS: !0,
    endo: {
        beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
        splitScalar: n => {
            const e = jB
              , t = BigInt("0x3086d221a7d46bcde86c90e49284eb15")
              , r = -Hce * BigInt("0xe4437ed6010e88286f547fa90abfe4c3")
              , s = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8")
              , i = t
              , o = BigInt("0x100000000000000000000000000000000")
              , a = LB(i * n, e)
              , l = LB(-r * n, e);
            let u = wi(n - a * t - l * s, e)
              , d = wi(-a * r - l * i, e);
            const h = u > o
              , p = d > o;
            if (h && (u = e - u),
            p && (d = e - d),
            u > o || d > o)
                throw new Error("splitScalar: Endomorphism failed, k=" + n);
            return {
                k1neg: h,
                k1: u,
                k2neg: p,
                k2: d
            }
        }
    }
}, Z8);
function Gce(n) {
    if (n.length !== 130 && n.length !== 132)
        throw new Yce({
            signature: n
        });
    const e = BigInt(Yl(n, 0, 32))
      , t = BigInt(Yl(n, 32, 64))
      , r = ( () => {
        const s = +`0x${n.slice(130)}`;
        if (!Number.isNaN(s))
            try {
                return Wce(s)
            } catch {
                throw new Kce({
                    value: s
                })
            }
    }
    )();
    return typeof r > "u" ? {
        r: e,
        s: t
    } : {
        r: e,
        s: t,
        yParity: r
    }
}
function Wce(n) {
    if (n === 0 || n === 27)
        return 0;
    if (n === 1 || n === 28)
        return 1;
    if (n >= 35)
        return n % 2 === 0 ? 1 : 0;
    throw new Xce({
        value: n
    })
}
class Yce extends er {
    constructor({signature: e}) {
        super(`Value \`${e}\` is an invalid signature size.`, {
            metaMessages: ["Expected: 64 bytes or 65 bytes.", `Received ${Ju(E_(e))} bytes.`]
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Signature.InvalidSerializedSizeError"
        })
    }
}
class Kce extends er {
    constructor({value: e}) {
        super(`Value \`${e}\` is an invalid y-parity value. Y-parity must be 0 or 1.`),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Signature.InvalidYParityError"
        })
    }
}
class Xce extends er {
    constructor({value: e}) {
        super(`Value \`${e}\` is an invalid v value. v must be 27, 28 or >=35.`),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Signature.InvalidVError"
        })
    }
}
function Qce(n) {
    return n instanceof Uint8Array || ArrayBuffer.isView(n) && n.constructor.name === "Uint8Array"
}
function Jz(n, e) {
    return Array.isArray(e) ? e.length === 0 ? !0 : n ? e.every(t => typeof t == "string") : e.every(t => Number.isSafeInteger(t)) : !1
}
function B2(n, e) {
    if (typeof e != "string")
        throw new Error(`${n}: string expected`);
    return !0
}
function A_(n) {
    if (!Number.isSafeInteger(n))
        throw new Error(`invalid integer: ${n}`)
}
function K4(n) {
    if (!Array.isArray(n))
        throw new Error("array expected")
}
function R2(n, e) {
    if (!Jz(!0, e))
        throw new Error(`${n}: array of strings expected`)
}
function Zce(n, e) {
    if (!Jz(!1, e))
        throw new Error(`${n}: array of numbers expected`)
}
function Jce(...n) {
    const e = i => i
      , t = (i, o) => a => i(o(a))
      , r = n.map(i => i.encode).reduceRight(t, e)
      , s = n.map(i => i.decode).reduce(t, e);
    return {
        encode: r,
        decode: s
    }
}
function eue(n) {
    const e = typeof n == "string" ? n.split("") : n
      , t = e.length;
    R2("alphabet", e);
    const r = new Map(e.map( (s, i) => [s, i]));
    return {
        encode: s => (K4(s),
        s.map(i => {
            if (!Number.isSafeInteger(i) || i < 0 || i >= t)
                throw new Error(`alphabet.encode: digit index outside alphabet "${i}". Allowed: ${n}`);
            return e[i]
        }
        )),
        decode: s => (K4(s),
        s.map(i => {
            B2("alphabet.decode", i);
            const o = r.get(i);
            if (o === void 0)
                throw new Error(`Unknown letter: "${i}". Allowed: ${n}`);
            return o
        }
        ))
    }
}
function tue(n="") {
    return B2("join", n),
    {
        encode: e => (R2("join.decode", e),
        e.join(n)),
        decode: e => (B2("join.decode", e),
        e.split(n))
    }
}
function nue(n, e="=") {
    return A_(n),
    B2("padding", e),
    {
        encode(t) {
            for (R2("padding.encode", t); t.length * n % 8; )
                t.push(e);
            return t
        },
        decode(t) {
            R2("padding.decode", t);
            let r = t.length;
            if (r * n % 8)
                throw new Error("padding: invalid, string should have whole number of bytes");
            for (; r > 0 && t[r - 1] === e; r--)
                if ((r - 1) * n % 8 === 0)
                    throw new Error("padding: invalid, string has too much padding");
            return t.slice(0, r)
        }
    }
}
const e$ = (n, e) => e === 0 ? n : e$(e, n % e)
  , O2 = (n, e) => n + (e - e$(n, e))
  , C5 = ( () => {
    let n = [];
    for (let e = 0; e < 40; e++)
        n.push(2 ** e);
    return n
}
)();
function FB(n, e, t, r) {
    if (K4(n),
    e <= 0 || e > 32)
        throw new Error(`convertRadix2: wrong from=${e}`);
    if (t <= 0 || t > 32)
        throw new Error(`convertRadix2: wrong to=${t}`);
    if (O2(e, t) > 32)
        throw new Error(`convertRadix2: carry overflow from=${e} to=${t} carryBits=${O2(e, t)}`);
    let s = 0
      , i = 0;
    const o = C5[e]
      , a = C5[t] - 1
      , l = [];
    for (const u of n) {
        if (A_(u),
        u >= o)
            throw new Error(`convertRadix2: invalid data word=${u} from=${e}`);
        if (s = s << e | u,
        i + e > 32)
            throw new Error(`convertRadix2: carry overflow pos=${i} from=${e}`);
        for (i += e; i >= t; i -= t)
            l.push((s >> i - t & a) >>> 0);
        const d = C5[i];
        if (d === void 0)
            throw new Error("invalid carry");
        s &= d - 1
    }
    if (s = s << t - i & a,
    !r && i >= e)
        throw new Error("Excess padding");
    if (!r && s > 0)
        throw new Error(`Non-zero padding: ${s}`);
    return r && i > 0 && l.push(s >>> 0),
    l
}
function rue(n, e=!1) {
    if (A_(n),
    n <= 0 || n > 32)
        throw new Error("radix2: bits should be in (0..32]");
    if (O2(8, n) > 32 || O2(n, 8) > 32)
        throw new Error("radix2: carry overflow");
    return {
        encode: t => {
            if (!Qce(t))
                throw new Error("radix2.encode input should be Uint8Array");
            return FB(Array.from(t), 8, n, !e)
        }
        ,
        decode: t => (Zce("radix2.decode", t),
        Uint8Array.from(FB(t, n, 8, e)))
    }
}
const sue = Jce(rue(5), eue("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), nue(5), tue(""));
function iue(n) {
    return wce(oue(n))
}
function oue(n) {
    const {payload: e, signature: t} = n
      , {r, s, yParity: i} = t
      , a = new qce.Signature(BigInt(r),BigInt(s)).addRecoveryBit(i).recoverPublicKey(E_(e).substring(2));
    return uce(a)
}
function aue(n) {
    if (n.length >= 255)
        throw new TypeError("Alphabet too long");
    const e = new Uint8Array(256);
    for (let u = 0; u < e.length; u++)
        e[u] = 255;
    for (let u = 0; u < n.length; u++) {
        const d = n.charAt(u)
          , h = d.charCodeAt(0);
        if (e[h] !== 255)
            throw new TypeError(d + " is ambiguous");
        e[h] = u
    }
    const t = n.length
      , r = n.charAt(0)
      , s = Math.log(t) / Math.log(256)
      , i = Math.log(256) / Math.log(t);
    function o(u) {
        if (u instanceof Uint8Array || (ArrayBuffer.isView(u) ? u = new Uint8Array(u.buffer,u.byteOffset,u.byteLength) : Array.isArray(u) && (u = Uint8Array.from(u))),
        !(u instanceof Uint8Array))
            throw new TypeError("Expected Uint8Array");
        if (u.length === 0)
            return "";
        let d = 0
          , h = 0
          , p = 0;
        const g = u.length;
        for (; p !== g && u[p] === 0; )
            p++,
            d++;
        const w = (g - p) * i + 1 >>> 0
          , b = new Uint8Array(w);
        for (; p !== g; ) {
            let N = u[p]
              , _ = 0;
            for (let I = w - 1; (N !== 0 || _ < h) && I !== -1; I--,
            _++)
                N += 256 * b[I] >>> 0,
                b[I] = N % t >>> 0,
                N = N / t >>> 0;
            if (N !== 0)
                throw new Error("Non-zero carry");
            h = _,
            p++
        }
        let v = w - h;
        for (; v !== w && b[v] === 0; )
            v++;
        let S = r.repeat(d);
        for (; v < w; ++v)
            S += n.charAt(b[v]);
        return S
    }
    function a(u) {
        if (typeof u != "string")
            throw new TypeError("Expected String");
        if (u.length === 0)
            return new Uint8Array;
        let d = 0
          , h = 0
          , p = 0;
        for (; u[d] === r; )
            h++,
            d++;
        const g = (u.length - d) * s + 1 >>> 0
          , w = new Uint8Array(g);
        for (; d < u.length; ) {
            const N = u.charCodeAt(d);
            if (N > 255)
                return;
            let _ = e[N];
            if (_ === 255)
                return;
            let I = 0;
            for (let k = g - 1; (_ !== 0 || I < p) && k !== -1; k--,
            I++)
                _ += t * w[k] >>> 0,
                w[k] = _ % 256 >>> 0,
                _ = _ / 256 >>> 0;
            if (_ !== 0)
                throw new Error("Non-zero carry");
            p = I,
            d++
        }
        let b = g - p;
        for (; b !== g && w[b] === 0; )
            b++;
        const v = new Uint8Array(h + (g - b));
        let S = h;
        for (; b !== g; )
            v[S++] = w[b++];
        return v
    }
    function l(u) {
        const d = a(u);
        if (d)
            return d;
        throw new Error("Non-base" + t + " character")
    }
    return {
        encode: o,
        decodeUnsafe: a,
        decode: l
    }
}
var lue = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
const D0 = aue(lue);
function cue(n) {
    const e = n.length;
    let t = 0
      , r = 0;
    for (; r < e; ) {
        let s = n.charCodeAt(r++);
        if ((s & 4294967168) === 0) {
            t++;
            continue
        } else if ((s & 4294965248) === 0)
            t += 2;
        else {
            if (s >= 55296 && s <= 56319 && r < e) {
                const i = n.charCodeAt(r);
                (i & 64512) === 56320 && (++r,
                s = ((s & 1023) << 10) + (i & 1023) + 65536)
            }
            (s & 4294901760) === 0 ? t += 3 : t += 4
        }
    }
    return t
}
function uue(n, e, t) {
    const r = n.length;
    let s = t
      , i = 0;
    for (; i < r; ) {
        let o = n.charCodeAt(i++);
        if ((o & 4294967168) === 0) {
            e[s++] = o;
            continue
        } else if ((o & 4294965248) === 0)
            e[s++] = o >> 6 & 31 | 192;
        else {
            if (o >= 55296 && o <= 56319 && i < r) {
                const a = n.charCodeAt(i);
                (a & 64512) === 56320 && (++i,
                o = ((o & 1023) << 10) + (a & 1023) + 65536)
            }
            (o & 4294901760) === 0 ? (e[s++] = o >> 12 & 15 | 224,
            e[s++] = o >> 6 & 63 | 128) : (e[s++] = o >> 18 & 7 | 240,
            e[s++] = o >> 12 & 63 | 128,
            e[s++] = o >> 6 & 63 | 128)
        }
        e[s++] = o & 63 | 128
    }
}
const due = new TextEncoder
  , fue = 50;
function hue(n, e, t) {
    due.encodeInto(n, e.subarray(t))
}
function pue(n, e, t) {
    n.length > fue ? hue(n, e, t) : uue(n, e, t)
}
const mue = 4096;
function t$(n, e, t) {
    let r = e;
    const s = r + t
      , i = [];
    let o = "";
    for (; r < s; ) {
        const a = n[r++];
        if ((a & 128) === 0)
            i.push(a);
        else if ((a & 224) === 192) {
            const l = n[r++] & 63;
            i.push((a & 31) << 6 | l)
        } else if ((a & 240) === 224) {
            const l = n[r++] & 63
              , u = n[r++] & 63;
            i.push((a & 31) << 12 | l << 6 | u)
        } else if ((a & 248) === 240) {
            const l = n[r++] & 63
              , u = n[r++] & 63
              , d = n[r++] & 63;
            let h = (a & 7) << 18 | l << 12 | u << 6 | d;
            h > 65535 && (h -= 65536,
            i.push(h >>> 10 & 1023 | 55296),
            h = 56320 | h & 1023),
            i.push(h)
        } else
            i.push(a);
        i.length >= mue && (o += String.fromCharCode(...i),
        i.length = 0)
    }
    return i.length > 0 && (o += String.fromCharCode(...i)),
    o
}
const gue = new TextDecoder
  , yue = 200;
function bue(n, e, t) {
    const r = n.subarray(e, e + t);
    return gue.decode(r)
}
function wue(n, e, t) {
    return t > yue ? bue(n, e, t) : t$(n, e, t)
}
class U1 {
    constructor(e, t) {
        this.type = e,
        this.data = t
    }
}
class Yi extends Error {
    constructor(e) {
        super(e);
        const t = Object.create(Yi.prototype);
        Object.setPrototypeOf(this, t),
        Object.defineProperty(this, "name", {
            configurable: !0,
            enumerable: !1,
            value: Yi.name
        })
    }
}
const $m = 4294967295;
function vue(n, e, t) {
    const r = t / 4294967296
      , s = t;
    n.setUint32(e, r),
    n.setUint32(e + 4, s)
}
function n$(n, e, t) {
    const r = Math.floor(t / 4294967296)
      , s = t;
    n.setUint32(e, r),
    n.setUint32(e + 4, s)
}
function r$(n, e) {
    const t = n.getInt32(e)
      , r = n.getUint32(e + 4);
    return t * 4294967296 + r
}
function xue(n, e) {
    const t = n.getUint32(e)
      , r = n.getUint32(e + 4);
    return t * 4294967296 + r
}
const Eue = -1
  , Sue = 4294967296 - 1
  , Aue = 17179869184 - 1;
function Cue({sec: n, nsec: e}) {
    if (n >= 0 && e >= 0 && n <= Aue)
        if (e === 0 && n <= Sue) {
            const t = new Uint8Array(4);
            return new DataView(t.buffer).setUint32(0, n),
            t
        } else {
            const t = n / 4294967296
              , r = n & 4294967295
              , s = new Uint8Array(8)
              , i = new DataView(s.buffer);
            return i.setUint32(0, e << 2 | t & 3),
            i.setUint32(4, r),
            s
        }
    else {
        const t = new Uint8Array(12)
          , r = new DataView(t.buffer);
        return r.setUint32(0, e),
        n$(r, 4, n),
        t
    }
}
function _ue(n) {
    const e = n.getTime()
      , t = Math.floor(e / 1e3)
      , r = (e - t * 1e3) * 1e6
      , s = Math.floor(r / 1e9);
    return {
        sec: t + s,
        nsec: r - s * 1e9
    }
}
function kue(n) {
    if (n instanceof Date) {
        const e = _ue(n);
        return Cue(e)
    } else
        return null
}
function Nue(n) {
    const e = new DataView(n.buffer,n.byteOffset,n.byteLength);
    switch (n.byteLength) {
    case 4:
        return {
            sec: e.getUint32(0),
            nsec: 0
        };
    case 8:
        {
            const t = e.getUint32(0)
              , r = e.getUint32(4)
              , s = (t & 3) * 4294967296 + r
              , i = t >>> 2;
            return {
                sec: s,
                nsec: i
            }
        }
    case 12:
        {
            const t = r$(e, 4)
              , r = e.getUint32(0);
            return {
                sec: t,
                nsec: r
            }
        }
    default:
        throw new Yi(`Unrecognized data size for timestamp (expected 4, 8, or 12): ${n.length}`)
    }
}
function Due(n) {
    const e = Nue(n);
    return new Date(e.sec * 1e3 + e.nsec / 1e6)
}
const Tue = {
    type: Eue,
    encode: kue,
    decode: Due
};
class P2 {
    constructor() {
        this.builtInEncoders = [],
        this.builtInDecoders = [],
        this.encoders = [],
        this.decoders = [],
        this.register(Tue)
    }
    register({type: e, encode: t, decode: r}) {
        if (e >= 0)
            this.encoders[e] = t,
            this.decoders[e] = r;
        else {
            const s = -1 - e;
            this.builtInEncoders[s] = t,
            this.builtInDecoders[s] = r
        }
    }
    tryToEncode(e, t) {
        for (let r = 0; r < this.builtInEncoders.length; r++) {
            const s = this.builtInEncoders[r];
            if (s != null) {
                const i = s(e, t);
                if (i != null) {
                    const o = -1 - r;
                    return new U1(o,i)
                }
            }
        }
        for (let r = 0; r < this.encoders.length; r++) {
            const s = this.encoders[r];
            if (s != null) {
                const i = s(e, t);
                if (i != null) {
                    const o = r;
                    return new U1(o,i)
                }
            }
        }
        return e instanceof U1 ? e : null
    }
    decode(e, t, r) {
        const s = t < 0 ? this.builtInDecoders[-1 - t] : this.decoders[t];
        return s ? s(e, t, r) : new U1(t,e)
    }
}
P2.defaultCodec = new P2;
function Iue(n) {
    return n instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && n instanceof SharedArrayBuffer
}
function X4(n) {
    return n instanceof Uint8Array ? n : ArrayBuffer.isView(n) ? new Uint8Array(n.buffer,n.byteOffset,n.byteLength) : Iue(n) ? new Uint8Array(n) : Uint8Array.from(n)
}
const Mue = 100
  , Bue = 2048;
let Rue = class s$ {
    constructor(e) {
        this.entered = !1,
        this.extensionCodec = e?.extensionCodec ?? P2.defaultCodec,
        this.context = e?.context,
        this.useBigInt64 = e?.useBigInt64 ?? !1,
        this.maxDepth = e?.maxDepth ?? Mue,
        this.initialBufferSize = e?.initialBufferSize ?? Bue,
        this.sortKeys = e?.sortKeys ?? !1,
        this.forceFloat32 = e?.forceFloat32 ?? !1,
        this.ignoreUndefined = e?.ignoreUndefined ?? !1,
        this.forceIntegerToFloat = e?.forceIntegerToFloat ?? !1,
        this.pos = 0,
        this.view = new DataView(new ArrayBuffer(this.initialBufferSize)),
        this.bytes = new Uint8Array(this.view.buffer)
    }
    clone() {
        return new s$({
            extensionCodec: this.extensionCodec,
            context: this.context,
            useBigInt64: this.useBigInt64,
            maxDepth: this.maxDepth,
            initialBufferSize: this.initialBufferSize,
            sortKeys: this.sortKeys,
            forceFloat32: this.forceFloat32,
            ignoreUndefined: this.ignoreUndefined,
            forceIntegerToFloat: this.forceIntegerToFloat
        })
    }
    reinitializeState() {
        this.pos = 0
    }
    encodeSharedRef(e) {
        if (this.entered)
            return this.clone().encodeSharedRef(e);
        try {
            return this.entered = !0,
            this.reinitializeState(),
            this.doEncode(e, 1),
            this.bytes.subarray(0, this.pos)
        } finally {
            this.entered = !1
        }
    }
    encode(e) {
        if (this.entered)
            return this.clone().encode(e);
        try {
            return this.entered = !0,
            this.reinitializeState(),
            this.doEncode(e, 1),
            this.bytes.slice(0, this.pos)
        } finally {
            this.entered = !1
        }
    }
    doEncode(e, t) {
        if (t > this.maxDepth)
            throw new Error(`Too deep objects in depth ${t}`);
        e == null ? this.encodeNil() : typeof e == "boolean" ? this.encodeBoolean(e) : typeof e == "number" ? this.forceIntegerToFloat ? this.encodeNumberAsFloat(e) : this.encodeNumber(e) : typeof e == "string" ? this.encodeString(e) : this.useBigInt64 && typeof e == "bigint" ? this.encodeBigInt64(e) : this.encodeObject(e, t)
    }
    ensureBufferSizeToWrite(e) {
        const t = this.pos + e;
        this.view.byteLength < t && this.resizeBuffer(t * 2)
    }
    resizeBuffer(e) {
        const t = new ArrayBuffer(e)
          , r = new Uint8Array(t)
          , s = new DataView(t);
        r.set(this.bytes),
        this.view = s,
        this.bytes = r
    }
    encodeNil() {
        this.writeU8(192)
    }
    encodeBoolean(e) {
        e === !1 ? this.writeU8(194) : this.writeU8(195)
    }
    encodeNumber(e) {
        !this.forceIntegerToFloat && Number.isSafeInteger(e) ? e >= 0 ? e < 128 ? this.writeU8(e) : e < 256 ? (this.writeU8(204),
        this.writeU8(e)) : e < 65536 ? (this.writeU8(205),
        this.writeU16(e)) : e < 4294967296 ? (this.writeU8(206),
        this.writeU32(e)) : this.useBigInt64 ? this.encodeNumberAsFloat(e) : (this.writeU8(207),
        this.writeU64(e)) : e >= -32 ? this.writeU8(224 | e + 32) : e >= -128 ? (this.writeU8(208),
        this.writeI8(e)) : e >= -32768 ? (this.writeU8(209),
        this.writeI16(e)) : e >= -2147483648 ? (this.writeU8(210),
        this.writeI32(e)) : this.useBigInt64 ? this.encodeNumberAsFloat(e) : (this.writeU8(211),
        this.writeI64(e)) : this.encodeNumberAsFloat(e)
    }
    encodeNumberAsFloat(e) {
        this.forceFloat32 ? (this.writeU8(202),
        this.writeF32(e)) : (this.writeU8(203),
        this.writeF64(e))
    }
    encodeBigInt64(e) {
        e >= BigInt(0) ? (this.writeU8(207),
        this.writeBigUint64(e)) : (this.writeU8(211),
        this.writeBigInt64(e))
    }
    writeStringHeader(e) {
        if (e < 32)
            this.writeU8(160 + e);
        else if (e < 256)
            this.writeU8(217),
            this.writeU8(e);
        else if (e < 65536)
            this.writeU8(218),
            this.writeU16(e);
        else if (e < 4294967296)
            this.writeU8(219),
            this.writeU32(e);
        else
            throw new Error(`Too long string: ${e} bytes in UTF-8`)
    }
    encodeString(e) {
        const r = cue(e);
        this.ensureBufferSizeToWrite(5 + r),
        this.writeStringHeader(r),
        pue(e, this.bytes, this.pos),
        this.pos += r
    }
    encodeObject(e, t) {
        const r = this.extensionCodec.tryToEncode(e, this.context);
        if (r != null)
            this.encodeExtension(r);
        else if (Array.isArray(e))
            this.encodeArray(e, t);
        else if (ArrayBuffer.isView(e))
            this.encodeBinary(e);
        else if (typeof e == "object")
            this.encodeMap(e, t);
        else
            throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(e)}`)
    }
    encodeBinary(e) {
        const t = e.byteLength;
        if (t < 256)
            this.writeU8(196),
            this.writeU8(t);
        else if (t < 65536)
            this.writeU8(197),
            this.writeU16(t);
        else if (t < 4294967296)
            this.writeU8(198),
            this.writeU32(t);
        else
            throw new Error(`Too large binary: ${t}`);
        const r = X4(e);
        this.writeU8a(r)
    }
    encodeArray(e, t) {
        const r = e.length;
        if (r < 16)
            this.writeU8(144 + r);
        else if (r < 65536)
            this.writeU8(220),
            this.writeU16(r);
        else if (r < 4294967296)
            this.writeU8(221),
            this.writeU32(r);
        else
            throw new Error(`Too large array: ${r}`);
        for (const s of e)
            this.doEncode(s, t + 1)
    }
    countWithoutUndefined(e, t) {
        let r = 0;
        for (const s of t)
            e[s] !== void 0 && r++;
        return r
    }
    encodeMap(e, t) {
        const r = Object.keys(e);
        this.sortKeys && r.sort();
        const s = this.ignoreUndefined ? this.countWithoutUndefined(e, r) : r.length;
        if (s < 16)
            this.writeU8(128 + s);
        else if (s < 65536)
            this.writeU8(222),
            this.writeU16(s);
        else if (s < 4294967296)
            this.writeU8(223),
            this.writeU32(s);
        else
            throw new Error(`Too large map object: ${s}`);
        for (const i of r) {
            const o = e[i];
            this.ignoreUndefined && o === void 0 || (this.encodeString(i),
            this.doEncode(o, t + 1))
        }
    }
    encodeExtension(e) {
        if (typeof e.data == "function") {
            const r = e.data(this.pos + 6)
              , s = r.length;
            if (s >= 4294967296)
                throw new Error(`Too large extension object: ${s}`);
            this.writeU8(201),
            this.writeU32(s),
            this.writeI8(e.type),
            this.writeU8a(r);
            return
        }
        const t = e.data.length;
        if (t === 1)
            this.writeU8(212);
        else if (t === 2)
            this.writeU8(213);
        else if (t === 4)
            this.writeU8(214);
        else if (t === 8)
            this.writeU8(215);
        else if (t === 16)
            this.writeU8(216);
        else if (t < 256)
            this.writeU8(199),
            this.writeU8(t);
        else if (t < 65536)
            this.writeU8(200),
            this.writeU16(t);
        else if (t < 4294967296)
            this.writeU8(201),
            this.writeU32(t);
        else
            throw new Error(`Too large extension object: ${t}`);
        this.writeI8(e.type),
        this.writeU8a(e.data)
    }
    writeU8(e) {
        this.ensureBufferSizeToWrite(1),
        this.view.setUint8(this.pos, e),
        this.pos++
    }
    writeU8a(e) {
        const t = e.length;
        this.ensureBufferSizeToWrite(t),
        this.bytes.set(e, this.pos),
        this.pos += t
    }
    writeI8(e) {
        this.ensureBufferSizeToWrite(1),
        this.view.setInt8(this.pos, e),
        this.pos++
    }
    writeU16(e) {
        this.ensureBufferSizeToWrite(2),
        this.view.setUint16(this.pos, e),
        this.pos += 2
    }
    writeI16(e) {
        this.ensureBufferSizeToWrite(2),
        this.view.setInt16(this.pos, e),
        this.pos += 2
    }
    writeU32(e) {
        this.ensureBufferSizeToWrite(4),
        this.view.setUint32(this.pos, e),
        this.pos += 4
    }
    writeI32(e) {
        this.ensureBufferSizeToWrite(4),
        this.view.setInt32(this.pos, e),
        this.pos += 4
    }
    writeF32(e) {
        this.ensureBufferSizeToWrite(4),
        this.view.setFloat32(this.pos, e),
        this.pos += 4
    }
    writeF64(e) {
        this.ensureBufferSizeToWrite(8),
        this.view.setFloat64(this.pos, e),
        this.pos += 8
    }
    writeU64(e) {
        this.ensureBufferSizeToWrite(8),
        vue(this.view, this.pos, e),
        this.pos += 8
    }
    writeI64(e) {
        this.ensureBufferSizeToWrite(8),
        n$(this.view, this.pos, e),
        this.pos += 8
    }
    writeBigUint64(e) {
        this.ensureBufferSizeToWrite(8),
        this.view.setBigUint64(this.pos, e),
        this.pos += 8
    }
    writeBigInt64(e) {
        this.ensureBufferSizeToWrite(8),
        this.view.setBigInt64(this.pos, e),
        this.pos += 8
    }
}
;
function Oue(n, e) {
    return new Rue(e).encodeSharedRef(n)
}
function _5(n) {
    return `${n < 0 ? "-" : ""}0x${Math.abs(n).toString(16).padStart(2, "0")}`
}
const Pue = 16
  , jue = 16;
class Lue {
    constructor(e=Pue, t=jue) {
        this.hit = 0,
        this.miss = 0,
        this.maxKeyLength = e,
        this.maxLengthPerKey = t,
        this.caches = [];
        for (let r = 0; r < this.maxKeyLength; r++)
            this.caches.push([])
    }
    canBeCached(e) {
        return e > 0 && e <= this.maxKeyLength
    }
    find(e, t, r) {
        const s = this.caches[r - 1];
        e: for (const i of s) {
            const o = i.bytes;
            for (let a = 0; a < r; a++)
                if (o[a] !== e[t + a])
                    continue e;
            return i.str
        }
        return null
    }
    store(e, t) {
        const r = this.caches[e.length - 1]
          , s = {
            bytes: e,
            str: t
        };
        r.length >= this.maxLengthPerKey ? r[Math.random() * r.length | 0] = s : r.push(s)
    }
    decode(e, t, r) {
        const s = this.find(e, t, r);
        if (s != null)
            return this.hit++,
            s;
        this.miss++;
        const i = t$(e, t, r)
          , o = Uint8Array.prototype.slice.call(e, t, t + r);
        return this.store(o, i),
        i
    }
}
const Q4 = "array"
  , Ng = "map_key"
  , i$ = "map_value"
  , Fue = n => {
    if (typeof n == "string" || typeof n == "number")
        return n;
    throw new Yi("The type of key must be string or number but " + typeof n)
}
;
class Uue {
    constructor() {
        this.stack = [],
        this.stackHeadPosition = -1
    }
    get length() {
        return this.stackHeadPosition + 1
    }
    top() {
        return this.stack[this.stackHeadPosition]
    }
    pushArrayState(e) {
        const t = this.getUninitializedStateFromPool();
        t.type = Q4,
        t.position = 0,
        t.size = e,
        t.array = new Array(e)
    }
    pushMapState(e) {
        const t = this.getUninitializedStateFromPool();
        t.type = Ng,
        t.readCount = 0,
        t.size = e,
        t.map = {}
    }
    getUninitializedStateFromPool() {
        if (this.stackHeadPosition++,
        this.stackHeadPosition === this.stack.length) {
            const e = {
                type: void 0,
                size: 0,
                array: void 0,
                position: 0,
                readCount: 0,
                map: void 0,
                key: null
            };
            this.stack.push(e)
        }
        return this.stack[this.stackHeadPosition]
    }
    release(e) {
        if (this.stack[this.stackHeadPosition] !== e)
            throw new Error("Invalid stack state. Released state is not on top of the stack.");
        if (e.type === Q4) {
            const r = e;
            r.size = 0,
            r.array = void 0,
            r.position = 0,
            r.type = void 0
        }
        if (e.type === Ng || e.type === i$) {
            const r = e;
            r.size = 0,
            r.map = void 0,
            r.readCount = 0,
            r.type = void 0
        }
        this.stackHeadPosition--
    }
    reset() {
        this.stack.length = 0,
        this.stackHeadPosition = -1
    }
}
const Hm = -1
  , C_ = new DataView(new ArrayBuffer(0))
  , zue = new Uint8Array(C_.buffer);
try {
    C_.getInt8(0)
} catch (n) {
    if (!(n instanceof RangeError))
        throw new Error("This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access")
}
const UB = new RangeError("Insufficient data")
  , $ue = new Lue;
let Hue = class o$ {
    constructor(e) {
        this.totalPos = 0,
        this.pos = 0,
        this.view = C_,
        this.bytes = zue,
        this.headByte = Hm,
        this.stack = new Uue,
        this.entered = !1,
        this.extensionCodec = e?.extensionCodec ?? P2.defaultCodec,
        this.context = e?.context,
        this.useBigInt64 = e?.useBigInt64 ?? !1,
        this.rawStrings = e?.rawStrings ?? !1,
        this.maxStrLength = e?.maxStrLength ?? $m,
        this.maxBinLength = e?.maxBinLength ?? $m,
        this.maxArrayLength = e?.maxArrayLength ?? $m,
        this.maxMapLength = e?.maxMapLength ?? $m,
        this.maxExtLength = e?.maxExtLength ?? $m,
        this.keyDecoder = e?.keyDecoder !== void 0 ? e.keyDecoder : $ue,
        this.mapKeyConverter = e?.mapKeyConverter ?? Fue
    }
    clone() {
        return new o$({
            extensionCodec: this.extensionCodec,
            context: this.context,
            useBigInt64: this.useBigInt64,
            rawStrings: this.rawStrings,
            maxStrLength: this.maxStrLength,
            maxBinLength: this.maxBinLength,
            maxArrayLength: this.maxArrayLength,
            maxMapLength: this.maxMapLength,
            maxExtLength: this.maxExtLength,
            keyDecoder: this.keyDecoder
        })
    }
    reinitializeState() {
        this.totalPos = 0,
        this.headByte = Hm,
        this.stack.reset()
    }
    setBuffer(e) {
        const t = X4(e);
        this.bytes = t,
        this.view = new DataView(t.buffer,t.byteOffset,t.byteLength),
        this.pos = 0
    }
    appendBuffer(e) {
        if (this.headByte === Hm && !this.hasRemaining(1))
            this.setBuffer(e);
        else {
            const t = this.bytes.subarray(this.pos)
              , r = X4(e)
              , s = new Uint8Array(t.length + r.length);
            s.set(t),
            s.set(r, t.length),
            this.setBuffer(s)
        }
    }
    hasRemaining(e) {
        return this.view.byteLength - this.pos >= e
    }
    createExtraByteError(e) {
        const {view: t, pos: r} = this;
        return new RangeError(`Extra ${t.byteLength - r} of ${t.byteLength} byte(s) found at buffer[${e}]`)
    }
    decode(e) {
        if (this.entered)
            return this.clone().decode(e);
        try {
            this.entered = !0,
            this.reinitializeState(),
            this.setBuffer(e);
            const t = this.doDecodeSync();
            if (this.hasRemaining(1))
                throw this.createExtraByteError(this.pos);
            return t
        } finally {
            this.entered = !1
        }
    }
    *decodeMulti(e) {
        if (this.entered) {
            yield*this.clone().decodeMulti(e);
            return
        }
        try {
            for (this.entered = !0,
            this.reinitializeState(),
            this.setBuffer(e); this.hasRemaining(1); )
                yield this.doDecodeSync()
        } finally {
            this.entered = !1
        }
    }
    async decodeAsync(e) {
        if (this.entered)
            return this.clone().decodeAsync(e);
        try {
            this.entered = !0;
            let t = !1, r;
            for await(const a of e) {
                if (t)
                    throw this.entered = !1,
                    this.createExtraByteError(this.totalPos);
                this.appendBuffer(a);
                try {
                    r = this.doDecodeSync(),
                    t = !0
                } catch (l) {
                    if (!(l instanceof RangeError))
                        throw l
                }
                this.totalPos += this.pos
            }
            if (t) {
                if (this.hasRemaining(1))
                    throw this.createExtraByteError(this.totalPos);
                return r
            }
            const {headByte: s, pos: i, totalPos: o} = this;
            throw new RangeError(`Insufficient data in parsing ${_5(s)} at ${o} (${i} in the current buffer)`)
        } finally {
            this.entered = !1
        }
    }
    decodeArrayStream(e) {
        return this.decodeMultiAsync(e, !0)
    }
    decodeStream(e) {
        return this.decodeMultiAsync(e, !1)
    }
    async*decodeMultiAsync(e, t) {
        if (this.entered) {
            yield*this.clone().decodeMultiAsync(e, t);
            return
        }
        try {
            this.entered = !0;
            let r = t
              , s = -1;
            for await(const i of e) {
                if (t && s === 0)
                    throw this.createExtraByteError(this.totalPos);
                this.appendBuffer(i),
                r && (s = this.readArraySize(),
                r = !1,
                this.complete());
                try {
                    for (; yield this.doDecodeSync(),
                    --s !== 0; )
                        ;
                } catch (o) {
                    if (!(o instanceof RangeError))
                        throw o
                }
                this.totalPos += this.pos
            }
        } finally {
            this.entered = !1
        }
    }
    doDecodeSync() {
        e: for (; ; ) {
            const e = this.readHeadByte();
            let t;
            if (e >= 224)
                t = e - 256;
            else if (e < 192)
                if (e < 128)
                    t = e;
                else if (e < 144) {
                    const s = e - 128;
                    if (s !== 0) {
                        this.pushMapState(s),
                        this.complete();
                        continue e
                    } else
                        t = {}
                } else if (e < 160) {
                    const s = e - 144;
                    if (s !== 0) {
                        this.pushArrayState(s),
                        this.complete();
                        continue e
                    } else
                        t = []
                } else {
                    const s = e - 160;
                    t = this.decodeString(s, 0)
                }
            else if (e === 192)
                t = null;
            else if (e === 194)
                t = !1;
            else if (e === 195)
                t = !0;
            else if (e === 202)
                t = this.readF32();
            else if (e === 203)
                t = this.readF64();
            else if (e === 204)
                t = this.readU8();
            else if (e === 205)
                t = this.readU16();
            else if (e === 206)
                t = this.readU32();
            else if (e === 207)
                this.useBigInt64 ? t = this.readU64AsBigInt() : t = this.readU64();
            else if (e === 208)
                t = this.readI8();
            else if (e === 209)
                t = this.readI16();
            else if (e === 210)
                t = this.readI32();
            else if (e === 211)
                this.useBigInt64 ? t = this.readI64AsBigInt() : t = this.readI64();
            else if (e === 217) {
                const s = this.lookU8();
                t = this.decodeString(s, 1)
            } else if (e === 218) {
                const s = this.lookU16();
                t = this.decodeString(s, 2)
            } else if (e === 219) {
                const s = this.lookU32();
                t = this.decodeString(s, 4)
            } else if (e === 220) {
                const s = this.readU16();
                if (s !== 0) {
                    this.pushArrayState(s),
                    this.complete();
                    continue e
                } else
                    t = []
            } else if (e === 221) {
                const s = this.readU32();
                if (s !== 0) {
                    this.pushArrayState(s),
                    this.complete();
                    continue e
                } else
                    t = []
            } else if (e === 222) {
                const s = this.readU16();
                if (s !== 0) {
                    this.pushMapState(s),
                    this.complete();
                    continue e
                } else
                    t = {}
            } else if (e === 223) {
                const s = this.readU32();
                if (s !== 0) {
                    this.pushMapState(s),
                    this.complete();
                    continue e
                } else
                    t = {}
            } else if (e === 196) {
                const s = this.lookU8();
                t = this.decodeBinary(s, 1)
            } else if (e === 197) {
                const s = this.lookU16();
                t = this.decodeBinary(s, 2)
            } else if (e === 198) {
                const s = this.lookU32();
                t = this.decodeBinary(s, 4)
            } else if (e === 212)
                t = this.decodeExtension(1, 0);
            else if (e === 213)
                t = this.decodeExtension(2, 0);
            else if (e === 214)
                t = this.decodeExtension(4, 0);
            else if (e === 215)
                t = this.decodeExtension(8, 0);
            else if (e === 216)
                t = this.decodeExtension(16, 0);
            else if (e === 199) {
                const s = this.lookU8();
                t = this.decodeExtension(s, 1)
            } else if (e === 200) {
                const s = this.lookU16();
                t = this.decodeExtension(s, 2)
            } else if (e === 201) {
                const s = this.lookU32();
                t = this.decodeExtension(s, 4)
            } else
                throw new Yi(`Unrecognized type byte: ${_5(e)}`);
            this.complete();
            const r = this.stack;
            for (; r.length > 0; ) {
                const s = r.top();
                if (s.type === Q4)
                    if (s.array[s.position] = t,
                    s.position++,
                    s.position === s.size)
                        t = s.array,
                        r.release(s);
                    else
                        continue e;
                else if (s.type === Ng) {
                    if (t === "__proto__")
                        throw new Yi("The key __proto__ is not allowed");
                    s.key = this.mapKeyConverter(t),
                    s.type = i$;
                    continue e
                } else if (s.map[s.key] = t,
                s.readCount++,
                s.readCount === s.size)
                    t = s.map,
                    r.release(s);
                else {
                    s.key = null,
                    s.type = Ng;
                    continue e
                }
            }
            return t
        }
    }
    readHeadByte() {
        return this.headByte === Hm && (this.headByte = this.readU8()),
        this.headByte
    }
    complete() {
        this.headByte = Hm
    }
    readArraySize() {
        const e = this.readHeadByte();
        switch (e) {
        case 220:
            return this.readU16();
        case 221:
            return this.readU32();
        default:
            {
                if (e < 160)
                    return e - 144;
                throw new Yi(`Unrecognized array type byte: ${_5(e)}`)
            }
        }
    }
    pushMapState(e) {
        if (e > this.maxMapLength)
            throw new Yi(`Max length exceeded: map length (${e}) > maxMapLengthLength (${this.maxMapLength})`);
        this.stack.pushMapState(e)
    }
    pushArrayState(e) {
        if (e > this.maxArrayLength)
            throw new Yi(`Max length exceeded: array length (${e}) > maxArrayLength (${this.maxArrayLength})`);
        this.stack.pushArrayState(e)
    }
    decodeString(e, t) {
        return !this.rawStrings || this.stateIsMapKey() ? this.decodeUtf8String(e, t) : this.decodeBinary(e, t)
    }
    decodeUtf8String(e, t) {
        if (e > this.maxStrLength)
            throw new Yi(`Max length exceeded: UTF-8 byte length (${e}) > maxStrLength (${this.maxStrLength})`);
        if (this.bytes.byteLength < this.pos + t + e)
            throw UB;
        const r = this.pos + t;
        let s;
        return this.stateIsMapKey() && this.keyDecoder?.canBeCached(e) ? s = this.keyDecoder.decode(this.bytes, r, e) : s = wue(this.bytes, r, e),
        this.pos += t + e,
        s
    }
    stateIsMapKey() {
        return this.stack.length > 0 ? this.stack.top().type === Ng : !1
    }
    decodeBinary(e, t) {
        if (e > this.maxBinLength)
            throw new Yi(`Max length exceeded: bin length (${e}) > maxBinLength (${this.maxBinLength})`);
        if (!this.hasRemaining(e + t))
            throw UB;
        const r = this.pos + t
          , s = this.bytes.subarray(r, r + e);
        return this.pos += t + e,
        s
    }
    decodeExtension(e, t) {
        if (e > this.maxExtLength)
            throw new Yi(`Max length exceeded: ext length (${e}) > maxExtLength (${this.maxExtLength})`);
        const r = this.view.getInt8(this.pos + t)
          , s = this.decodeBinary(e, t + 1);
        return this.extensionCodec.decode(s, r, this.context)
    }
    lookU8() {
        return this.view.getUint8(this.pos)
    }
    lookU16() {
        return this.view.getUint16(this.pos)
    }
    lookU32() {
        return this.view.getUint32(this.pos)
    }
    readU8() {
        const e = this.view.getUint8(this.pos);
        return this.pos++,
        e
    }
    readI8() {
        const e = this.view.getInt8(this.pos);
        return this.pos++,
        e
    }
    readU16() {
        const e = this.view.getUint16(this.pos);
        return this.pos += 2,
        e
    }
    readI16() {
        const e = this.view.getInt16(this.pos);
        return this.pos += 2,
        e
    }
    readU32() {
        const e = this.view.getUint32(this.pos);
        return this.pos += 4,
        e
    }
    readI32() {
        const e = this.view.getInt32(this.pos);
        return this.pos += 4,
        e
    }
    readU64() {
        const e = xue(this.view, this.pos);
        return this.pos += 8,
        e
    }
    readI64() {
        const e = r$(this.view, this.pos);
        return this.pos += 8,
        e
    }
    readU64AsBigInt() {
        const e = this.view.getBigUint64(this.pos);
        return this.pos += 8,
        e
    }
    readI64AsBigInt() {
        const e = this.view.getBigInt64(this.pos);
        return this.pos += 8,
        e
    }
    readF32() {
        const e = this.view.getFloat32(this.pos);
        return this.pos += 4,
        e
    }
    readF64() {
        const e = this.view.getFloat64(this.pos);
        return this.pos += 8,
        e
    }
}
;
function Vue(n, e) {
    return new Hue(e).decode(n)
}
const que = n => JSON.stringify(n, (e, t) => typeof t == "bigint" ? t.toString() + "n" : t)
  , Gue = n => {
    const e = /([\[:])?(\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\}\]])/g
      , t = n.replace(e, '$1"$2n"$3');
    return JSON.parse(t, (r, s) => typeof s == "string" && s.match(/^\d+n$/) ? BigInt(s.substring(0, s.length - 1)) : s)
}
;
function Of(n) {
    if (typeof n != "string")
        throw new Error(`Cannot safe json parse value of type ${typeof n}`);
    try {
        return Gue(n)
    } catch {
        return n
    }
}
function Tc(n) {
    return typeof n == "string" ? n : que(n) || ""
}
function Wue(n) {
    return n instanceof Uint8Array || ArrayBuffer.isView(n) && n.constructor.name === "Uint8Array"
}
function a$(n, ...e) {
    if (!Wue(n))
        throw new Error("Uint8Array expected");
    if (e.length > 0 && !e.includes(n.length))
        throw new Error("Uint8Array expected of length " + e + ", got length=" + n.length)
}
function zB(n, e=!0) {
    if (n.destroyed)
        throw new Error("Hash instance has been destroyed");
    if (e && n.finished)
        throw new Error("Hash#digest() has already been called")
}
function Yue(n, e) {
    a$(n);
    const t = e.outputLen;
    if (n.length < t)
        throw new Error("digestInto() expects output buffer of length at least " + t)
}
const Kh = typeof globalThis == "object" && "crypto"in globalThis ? globalThis.crypto : void 0;
const k5 = n => new DataView(n.buffer,n.byteOffset,n.byteLength);
function Kue(n) {
    if (typeof n != "string")
        throw new Error("utf8ToBytes expected string, got " + typeof n);
    return new Uint8Array(new TextEncoder().encode(n))
}
function l$(n) {
    return typeof n == "string" && (n = Kue(n)),
    a$(n),
    n
}
let Xue = class {
    clone() {
        return this._cloneInto()
    }
}
;
function Que(n) {
    const e = r => n().update(l$(r)).digest()
      , t = n();
    return e.outputLen = t.outputLen,
    e.blockLen = t.blockLen,
    e.create = () => n(),
    e
}
function c$(n=32) {
    if (Kh && typeof Kh.getRandomValues == "function")
        return Kh.getRandomValues(new Uint8Array(n));
    if (Kh && typeof Kh.randomBytes == "function")
        return Kh.randomBytes(n);
    throw new Error("crypto.getRandomValues must be defined")
}
function Zue(n, e, t, r) {
    if (typeof n.setBigUint64 == "function")
        return n.setBigUint64(e, t, r);
    const s = BigInt(32)
      , i = BigInt(4294967295)
      , o = Number(t >> s & i)
      , a = Number(t & i)
      , l = r ? 4 : 0
      , u = r ? 0 : 4;
    n.setUint32(e + l, o, r),
    n.setUint32(e + u, a, r)
}
let Jue = class extends Xue {
    constructor(e, t, r, s) {
        super(),
        this.blockLen = e,
        this.outputLen = t,
        this.padOffset = r,
        this.isLE = s,
        this.finished = !1,
        this.length = 0,
        this.pos = 0,
        this.destroyed = !1,
        this.buffer = new Uint8Array(e),
        this.view = k5(this.buffer)
    }
    update(e) {
        zB(this);
        const {view: t, buffer: r, blockLen: s} = this;
        e = l$(e);
        const i = e.length;
        for (let o = 0; o < i; ) {
            const a = Math.min(s - this.pos, i - o);
            if (a === s) {
                const l = k5(e);
                for (; s <= i - o; o += s)
                    this.process(l, o);
                continue
            }
            r.set(e.subarray(o, o + a), this.pos),
            this.pos += a,
            o += a,
            this.pos === s && (this.process(t, 0),
            this.pos = 0)
        }
        return this.length += e.length,
        this.roundClean(),
        this
    }
    digestInto(e) {
        zB(this),
        Yue(e, this),
        this.finished = !0;
        const {buffer: t, view: r, blockLen: s, isLE: i} = this;
        let {pos: o} = this;
        t[o++] = 128,
        this.buffer.subarray(o).fill(0),
        this.padOffset > s - o && (this.process(r, 0),
        o = 0);
        for (let h = o; h < s; h++)
            t[h] = 0;
        Zue(r, s - 8, BigInt(this.length * 8), i),
        this.process(r, 0);
        const a = k5(e)
          , l = this.outputLen;
        if (l % 4)
            throw new Error("_sha2: outputLen should be aligned to 32bit");
        const u = l / 4
          , d = this.get();
        if (u > d.length)
            throw new Error("_sha2: outputLen bigger than state");
        for (let h = 0; h < u; h++)
            a.setUint32(4 * h, d[h], i)
    }
    digest() {
        const {buffer: e, outputLen: t} = this;
        this.digestInto(e);
        const r = e.slice(0, t);
        return this.destroy(),
        r
    }
    _cloneInto(e) {
        e || (e = new this.constructor),
        e.set(...this.get());
        const {blockLen: t, buffer: r, length: s, finished: i, destroyed: o, pos: a} = this;
        return e.length = s,
        e.pos = a,
        e.finished = i,
        e.destroyed = o,
        s % t && e.buffer.set(r),
        e
    }
}
;
const z1 = BigInt(2 ** 32 - 1)
  , Z4 = BigInt(32);
function u$(n, e=!1) {
    return e ? {
        h: Number(n & z1),
        l: Number(n >> Z4 & z1)
    } : {
        h: Number(n >> Z4 & z1) | 0,
        l: Number(n & z1) | 0
    }
}
function ede(n, e=!1) {
    let t = new Uint32Array(n.length)
      , r = new Uint32Array(n.length);
    for (let s = 0; s < n.length; s++) {
        const {h: i, l: o} = u$(n[s], e);
        [t[s],r[s]] = [i, o]
    }
    return [t, r]
}
const tde = (n, e) => BigInt(n >>> 0) << Z4 | BigInt(e >>> 0)
  , nde = (n, e, t) => n >>> t
  , rde = (n, e, t) => n << 32 - t | e >>> t
  , sde = (n, e, t) => n >>> t | e << 32 - t
  , ide = (n, e, t) => n << 32 - t | e >>> t
  , ode = (n, e, t) => n << 64 - t | e >>> t - 32
  , ade = (n, e, t) => n >>> t - 32 | e << 64 - t
  , lde = (n, e) => e
  , cde = (n, e) => n
  , ude = (n, e, t) => n << t | e >>> 32 - t
  , dde = (n, e, t) => e << t | n >>> 32 - t
  , fde = (n, e, t) => e << t - 32 | n >>> 64 - t
  , hde = (n, e, t) => n << t - 32 | e >>> 64 - t;
function pde(n, e, t, r) {
    const s = (e >>> 0) + (r >>> 0);
    return {
        h: n + t + (s / 2 ** 32 | 0) | 0,
        l: s | 0
    }
}
const mde = (n, e, t) => (n >>> 0) + (e >>> 0) + (t >>> 0)
  , gde = (n, e, t, r) => e + t + r + (n / 2 ** 32 | 0) | 0
  , yde = (n, e, t, r) => (n >>> 0) + (e >>> 0) + (t >>> 0) + (r >>> 0)
  , bde = (n, e, t, r, s) => e + t + r + s + (n / 2 ** 32 | 0) | 0
  , wde = (n, e, t, r, s) => (n >>> 0) + (e >>> 0) + (t >>> 0) + (r >>> 0) + (s >>> 0)
  , vde = (n, e, t, r, s, i) => e + t + r + s + i + (n / 2 ** 32 | 0) | 0
  , Ot = {
    fromBig: u$,
    split: ede,
    toBig: tde,
    shrSH: nde,
    shrSL: rde,
    rotrSH: sde,
    rotrSL: ide,
    rotrBH: ode,
    rotrBL: ade,
    rotr32H: lde,
    rotr32L: cde,
    rotlSH: ude,
    rotlSL: dde,
    rotlBH: fde,
    rotlBL: hde,
    add: pde,
    add3L: mde,
    add3H: gde,
    add4L: yde,
    add4H: bde,
    add5H: vde,
    add5L: wde
}
  , [xde,Ede] = Ot.split(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map(n => BigInt(n)))
  , vu = new Uint32Array(80)
  , xu = new Uint32Array(80);
let Sde = class extends Jue {
    constructor() {
        super(128, 64, 16, !1),
        this.Ah = 1779033703,
        this.Al = -205731576,
        this.Bh = -1150833019,
        this.Bl = -2067093701,
        this.Ch = 1013904242,
        this.Cl = -23791573,
        this.Dh = -1521486534,
        this.Dl = 1595750129,
        this.Eh = 1359893119,
        this.El = -1377402159,
        this.Fh = -1694144372,
        this.Fl = 725511199,
        this.Gh = 528734635,
        this.Gl = -79577749,
        this.Hh = 1541459225,
        this.Hl = 327033209
    }
    get() {
        const {Ah: e, Al: t, Bh: r, Bl: s, Ch: i, Cl: o, Dh: a, Dl: l, Eh: u, El: d, Fh: h, Fl: p, Gh: g, Gl: w, Hh: b, Hl: v} = this;
        return [e, t, r, s, i, o, a, l, u, d, h, p, g, w, b, v]
    }
    set(e, t, r, s, i, o, a, l, u, d, h, p, g, w, b, v) {
        this.Ah = e | 0,
        this.Al = t | 0,
        this.Bh = r | 0,
        this.Bl = s | 0,
        this.Ch = i | 0,
        this.Cl = o | 0,
        this.Dh = a | 0,
        this.Dl = l | 0,
        this.Eh = u | 0,
        this.El = d | 0,
        this.Fh = h | 0,
        this.Fl = p | 0,
        this.Gh = g | 0,
        this.Gl = w | 0,
        this.Hh = b | 0,
        this.Hl = v | 0
    }
    process(e, t) {
        for (let _ = 0; _ < 16; _++,
        t += 4)
            vu[_] = e.getUint32(t),
            xu[_] = e.getUint32(t += 4);
        for (let _ = 16; _ < 80; _++) {
            const I = vu[_ - 15] | 0
              , k = xu[_ - 15] | 0
              , B = Ot.rotrSH(I, k, 1) ^ Ot.rotrSH(I, k, 8) ^ Ot.shrSH(I, k, 7)
              , P = Ot.rotrSL(I, k, 1) ^ Ot.rotrSL(I, k, 8) ^ Ot.shrSL(I, k, 7)
              , M = vu[_ - 2] | 0
              , R = xu[_ - 2] | 0
              , L = Ot.rotrSH(M, R, 19) ^ Ot.rotrBH(M, R, 61) ^ Ot.shrSH(M, R, 6)
              , q = Ot.rotrSL(M, R, 19) ^ Ot.rotrBL(M, R, 61) ^ Ot.shrSL(M, R, 6)
              , H = Ot.add4L(P, q, xu[_ - 7], xu[_ - 16])
              , j = Ot.add4H(H, B, L, vu[_ - 7], vu[_ - 16]);
            vu[_] = j | 0,
            xu[_] = H | 0
        }
        let {Ah: r, Al: s, Bh: i, Bl: o, Ch: a, Cl: l, Dh: u, Dl: d, Eh: h, El: p, Fh: g, Fl: w, Gh: b, Gl: v, Hh: S, Hl: N} = this;
        for (let _ = 0; _ < 80; _++) {
            const I = Ot.rotrSH(h, p, 14) ^ Ot.rotrSH(h, p, 18) ^ Ot.rotrBH(h, p, 41)
              , k = Ot.rotrSL(h, p, 14) ^ Ot.rotrSL(h, p, 18) ^ Ot.rotrBL(h, p, 41)
              , B = h & g ^ ~h & b
              , P = p & w ^ ~p & v
              , M = Ot.add5L(N, k, P, Ede[_], xu[_])
              , R = Ot.add5H(M, S, I, B, xde[_], vu[_])
              , L = M | 0
              , q = Ot.rotrSH(r, s, 28) ^ Ot.rotrBH(r, s, 34) ^ Ot.rotrBH(r, s, 39)
              , H = Ot.rotrSL(r, s, 28) ^ Ot.rotrBL(r, s, 34) ^ Ot.rotrBL(r, s, 39)
              , j = r & i ^ r & a ^ i & a
              , A = s & o ^ s & l ^ o & l;
            S = b | 0,
            N = v | 0,
            b = g | 0,
            v = w | 0,
            g = h | 0,
            w = p | 0,
            {h, l: p} = Ot.add(u | 0, d | 0, R | 0, L | 0),
            u = a | 0,
            d = l | 0,
            a = i | 0,
            l = o | 0,
            i = r | 0,
            o = s | 0;
            const E = Ot.add3L(L, H, A);
            r = Ot.add3H(E, R, q, j),
            s = E | 0
        }
        ({h: r, l: s} = Ot.add(this.Ah | 0, this.Al | 0, r | 0, s | 0)),
        {h: i, l: o} = Ot.add(this.Bh | 0, this.Bl | 0, i | 0, o | 0),
        {h: a, l} = Ot.add(this.Ch | 0, this.Cl | 0, a | 0, l | 0),
        {h: u, l: d} = Ot.add(this.Dh | 0, this.Dl | 0, u | 0, d | 0),
        {h, l: p} = Ot.add(this.Eh | 0, this.El | 0, h | 0, p | 0),
        {h: g, l: w} = Ot.add(this.Fh | 0, this.Fl | 0, g | 0, w | 0),
        {h: b, l: v} = Ot.add(this.Gh | 0, this.Gl | 0, b | 0, v | 0),
        {h: S, l: N} = Ot.add(this.Hh | 0, this.Hl | 0, S | 0, N | 0),
        this.set(r, s, i, o, a, l, u, d, h, p, g, w, b, v, S, N)
    }
    roundClean() {
        vu.fill(0),
        xu.fill(0)
    }
    destroy() {
        this.buffer.fill(0),
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
    }
}
;
const Ade = Que( () => new Sde);
const __ = BigInt(0)
  , d$ = BigInt(1)
  , Cde = BigInt(2);
function k_(n) {
    return n instanceof Uint8Array || ArrayBuffer.isView(n) && n.constructor.name === "Uint8Array"
}
function N_(n) {
    if (!k_(n))
        throw new Error("Uint8Array expected")
}
function N5(n, e) {
    if (typeof e != "boolean")
        throw new Error(n + " boolean expected, got " + e)
}
const _de = Array.from({
    length: 256
}, (n, e) => e.toString(16).padStart(2, "0"));
function D_(n) {
    N_(n);
    let e = "";
    for (let t = 0; t < n.length; t++)
        e += _de[n[t]];
    return e
}
function f$(n) {
    if (typeof n != "string")
        throw new Error("hex string expected, got " + typeof n);
    return n === "" ? __ : BigInt("0x" + n)
}
const Bl = {
    _0: 48,
    _9: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102
};
function $B(n) {
    if (n >= Bl._0 && n <= Bl._9)
        return n - Bl._0;
    if (n >= Bl.A && n <= Bl.F)
        return n - (Bl.A - 10);
    if (n >= Bl.a && n <= Bl.f)
        return n - (Bl.a - 10)
}
function h$(n) {
    if (typeof n != "string")
        throw new Error("hex string expected, got " + typeof n);
    const e = n.length
      , t = e / 2;
    if (e % 2)
        throw new Error("hex string expected, got unpadded hex of length " + e);
    const r = new Uint8Array(t);
    for (let s = 0, i = 0; s < t; s++,
    i += 2) {
        const o = $B(n.charCodeAt(i))
          , a = $B(n.charCodeAt(i + 1));
        if (o === void 0 || a === void 0) {
            const l = n[i] + n[i + 1];
            throw new Error('hex string expected, got non-hex character "' + l + '" at index ' + i)
        }
        r[s] = o * 16 + a
    }
    return r
}
function kde(n) {
    return f$(D_(n))
}
function Hw(n) {
    return N_(n),
    f$(D_(Uint8Array.from(n).reverse()))
}
function p$(n, e) {
    return h$(n.toString(16).padStart(e * 2, "0"))
}
function J4(n, e) {
    return p$(n, e).reverse()
}
function Rl(n, e, t) {
    let r;
    if (typeof e == "string")
        try {
            r = h$(e)
        } catch (i) {
            throw new Error(n + " must be hex string or Uint8Array, cause: " + i)
        }
    else if (k_(e))
        r = Uint8Array.from(e);
    else
        throw new Error(n + " must be hex string or Uint8Array");
    const s = r.length;
    if (typeof t == "number" && s !== t)
        throw new Error(n + " of length " + t + " expected, got " + s);
    return r
}
function HB(...n) {
    let e = 0;
    for (let r = 0; r < n.length; r++) {
        const s = n[r];
        N_(s),
        e += s.length
    }
    const t = new Uint8Array(e);
    for (let r = 0, s = 0; r < n.length; r++) {
        const i = n[r];
        t.set(i, s),
        s += i.length
    }
    return t
}
const D5 = n => typeof n == "bigint" && __ <= n;
function Nde(n, e, t) {
    return D5(n) && D5(e) && D5(t) && e <= n && n < t
}
function Vm(n, e, t, r) {
    if (!Nde(e, t, r))
        throw new Error("expected valid " + n + ": " + t + " <= n < " + r + ", got " + e)
}
function Dde(n) {
    let e;
    for (e = 0; n > __; n >>= d$,
    e += 1)
        ;
    return e
}
const Tde = n => (Cde << BigInt(n - 1)) - d$
  , Ide = {
    bigint: n => typeof n == "bigint",
    function: n => typeof n == "function",
    boolean: n => typeof n == "boolean",
    string: n => typeof n == "string",
    stringOrUint8Array: n => typeof n == "string" || k_(n),
    isSafeInteger: n => Number.isSafeInteger(n),
    array: n => Array.isArray(n),
    field: (n, e) => e.Fp.isValid(n),
    hash: n => typeof n == "function" && Number.isSafeInteger(n.outputLen)
};
function T_(n, e, t={}) {
    const r = (s, i, o) => {
        const a = Ide[i];
        if (typeof a != "function")
            throw new Error("invalid validator function");
        const l = n[s];
        if (!(o && l === void 0) && !a(l, n))
            throw new Error("param " + String(s) + " is invalid. Expected " + i + ", got " + l)
    }
    ;
    for (const [s,i] of Object.entries(e))
        r(s, i, !1);
    for (const [s,i] of Object.entries(t))
        r(s, i, !0);
    return n
}
function VB(n) {
    const e = new WeakMap;
    return (t, ...r) => {
        const s = e.get(t);
        if (s !== void 0)
            return s;
        const i = n(t, ...r);
        return e.set(t, i),
        i
    }
}
const ss = BigInt(0)
  , Sr = BigInt(1)
  , Zd = BigInt(2)
  , Mde = BigInt(3)
  , eC = BigInt(4)
  , qB = BigInt(5)
  , GB = BigInt(8);
function Vr(n, e) {
    const t = n % e;
    return t >= ss ? t : e + t
}
function Bde(n, e, t) {
    if (e < ss)
        throw new Error("invalid exponent, negatives unsupported");
    if (t <= ss)
        throw new Error("invalid modulus");
    if (t === Sr)
        return ss;
    let r = Sr;
    for (; e > ss; )
        e & Sr && (r = r * n % t),
        n = n * n % t,
        e >>= Sr;
    return r
}
function Na(n, e, t) {
    let r = n;
    for (; e-- > ss; )
        r *= r,
        r %= t;
    return r
}
function WB(n, e) {
    if (n === ss)
        throw new Error("invert: expected non-zero number");
    if (e <= ss)
        throw new Error("invert: expected positive modulus, got " + e);
    let t = Vr(n, e)
      , r = e
      , s = ss
      , i = Sr;
    for (; t !== ss; ) {
        const o = r / t
          , a = r % t
          , l = s - i * o;
        r = t,
        t = a,
        s = i,
        i = l
    }
    if (r !== Sr)
        throw new Error("invert: does not exist");
    return Vr(s, e)
}
function Rde(n) {
    const e = (n - Sr) / Zd;
    let t, r, s;
    for (t = n - Sr,
    r = 0; t % Zd === ss; t /= Zd,
    r++)
        ;
    for (s = Zd; s < n && Bde(s, e, n) !== n - Sr; s++)
        if (s > 1e3)
            throw new Error("Cannot find square root: likely non-prime P");
    if (r === 1) {
        const o = (n + Sr) / eC;
        return function(a, l) {
            const u = a.pow(l, o);
            if (!a.eql(a.sqr(u), l))
                throw new Error("Cannot find square root");
            return u
        }
    }
    const i = (t + Sr) / Zd;
    return function(o, a) {
        if (o.pow(a, e) === o.neg(o.ONE))
            throw new Error("Cannot find square root");
        let l = r
          , u = o.pow(o.mul(o.ONE, s), t)
          , d = o.pow(a, i)
          , h = o.pow(a, t);
        for (; !o.eql(h, o.ONE); ) {
            if (o.eql(h, o.ZERO))
                return o.ZERO;
            let p = 1;
            for (let w = o.sqr(h); p < l && !o.eql(w, o.ONE); p++)
                w = o.sqr(w);
            const g = o.pow(u, Sr << BigInt(l - p - 1));
            u = o.sqr(g),
            d = o.mul(d, g),
            h = o.mul(h, u),
            l = p
        }
        return d
    }
}
function Ode(n) {
    if (n % eC === Mde) {
        const e = (n + Sr) / eC;
        return function(t, r) {
            const s = t.pow(r, e);
            if (!t.eql(t.sqr(s), r))
                throw new Error("Cannot find square root");
            return s
        }
    }
    if (n % GB === qB) {
        const e = (n - qB) / GB;
        return function(t, r) {
            const s = t.mul(r, Zd)
              , i = t.pow(s, e)
              , o = t.mul(r, i)
              , a = t.mul(t.mul(o, Zd), i)
              , l = t.mul(o, t.sub(a, t.ONE));
            if (!t.eql(t.sqr(l), r))
                throw new Error("Cannot find square root");
            return l
        }
    }
    return Rde(n)
}
const Pde = (n, e) => (Vr(n, e) & Sr) === Sr
  , jde = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];
function Lde(n) {
    const e = {
        ORDER: "bigint",
        MASK: "bigint",
        BYTES: "isSafeInteger",
        BITS: "isSafeInteger"
    }
      , t = jde.reduce( (r, s) => (r[s] = "function",
    r), e);
    return T_(n, t)
}
function Fde(n, e, t) {
    if (t < ss)
        throw new Error("invalid exponent, negatives unsupported");
    if (t === ss)
        return n.ONE;
    if (t === Sr)
        return e;
    let r = n.ONE
      , s = e;
    for (; t > ss; )
        t & Sr && (r = n.mul(r, s)),
        s = n.sqr(s),
        t >>= Sr;
    return r
}
function Ude(n, e) {
    const t = new Array(e.length)
      , r = e.reduce( (i, o, a) => n.is0(o) ? i : (t[a] = i,
    n.mul(i, o)), n.ONE)
      , s = n.inv(r);
    return e.reduceRight( (i, o, a) => n.is0(o) ? i : (t[a] = n.mul(i, t[a]),
    n.mul(i, o)), s),
    t
}
function m$(n, e) {
    const t = e !== void 0 ? e : n.toString(2).length
      , r = Math.ceil(t / 8);
    return {
        nBitLength: t,
        nByteLength: r
    }
}
function g$(n, e, t=!1, r={}) {
    if (n <= ss)
        throw new Error("invalid field: expected ORDER > 0, got " + n);
    const {nBitLength: s, nByteLength: i} = m$(n, e);
    if (i > 2048)
        throw new Error("invalid field: expected ORDER of <= 2048 bytes");
    let o;
    const a = Object.freeze({
        ORDER: n,
        isLE: t,
        BITS: s,
        BYTES: i,
        MASK: Tde(s),
        ZERO: ss,
        ONE: Sr,
        create: l => Vr(l, n),
        isValid: l => {
            if (typeof l != "bigint")
                throw new Error("invalid field element: expected bigint, got " + typeof l);
            return ss <= l && l < n
        }
        ,
        is0: l => l === ss,
        isOdd: l => (l & Sr) === Sr,
        neg: l => Vr(-l, n),
        eql: (l, u) => l === u,
        sqr: l => Vr(l * l, n),
        add: (l, u) => Vr(l + u, n),
        sub: (l, u) => Vr(l - u, n),
        mul: (l, u) => Vr(l * u, n),
        pow: (l, u) => Fde(a, l, u),
        div: (l, u) => Vr(l * WB(u, n), n),
        sqrN: l => l * l,
        addN: (l, u) => l + u,
        subN: (l, u) => l - u,
        mulN: (l, u) => l * u,
        inv: l => WB(l, n),
        sqrt: r.sqrt || (l => (o || (o = Ode(n)),
        o(a, l))),
        invertBatch: l => Ude(a, l),
        cmov: (l, u, d) => d ? u : l,
        toBytes: l => t ? J4(l, i) : p$(l, i),
        fromBytes: l => {
            if (l.length !== i)
                throw new Error("Field.fromBytes: expected " + i + " bytes, got " + l.length);
            return t ? Hw(l) : kde(l)
        }
    });
    return Object.freeze(a)
}
const YB = BigInt(0)
  , $1 = BigInt(1);
function T5(n, e) {
    const t = e.negate();
    return n ? t : e
}
function y$(n, e) {
    if (!Number.isSafeInteger(n) || n <= 0 || n > e)
        throw new Error("invalid window size, expected [1.." + e + "], got W=" + n)
}
function I5(n, e) {
    y$(n, e);
    const t = Math.ceil(e / n) + 1
      , r = 2 ** (n - 1);
    return {
        windows: t,
        windowSize: r
    }
}
function zde(n, e) {
    if (!Array.isArray(n))
        throw new Error("array expected");
    n.forEach( (t, r) => {
        if (!(t instanceof e))
            throw new Error("invalid point at index " + r)
    }
    )
}
function $de(n, e) {
    if (!Array.isArray(n))
        throw new Error("array of scalars expected");
    n.forEach( (t, r) => {
        if (!e.isValid(t))
            throw new Error("invalid scalar at index " + r)
    }
    )
}
const M5 = new WeakMap
  , b$ = new WeakMap;
function B5(n) {
    return b$.get(n) || 1
}
function Hde(n, e) {
    return {
        constTimeNegate: T5,
        hasPrecomputes(t) {
            return B5(t) !== 1
        },
        unsafeLadder(t, r, s=n.ZERO) {
            let i = t;
            for (; r > YB; )
                r & $1 && (s = s.add(i)),
                i = i.double(),
                r >>= $1;
            return s
        },
        precomputeWindow(t, r) {
            const {windows: s, windowSize: i} = I5(r, e)
              , o = [];
            let a = t
              , l = a;
            for (let u = 0; u < s; u++) {
                l = a,
                o.push(l);
                for (let d = 1; d < i; d++)
                    l = l.add(a),
                    o.push(l);
                a = l.double()
            }
            return o
        },
        wNAF(t, r, s) {
            const {windows: i, windowSize: o} = I5(t, e);
            let a = n.ZERO
              , l = n.BASE;
            const u = BigInt(2 ** t - 1)
              , d = 2 ** t
              , h = BigInt(t);
            for (let p = 0; p < i; p++) {
                const g = p * o;
                let w = Number(s & u);
                s >>= h,
                w > o && (w -= d,
                s += $1);
                const b = g
                  , v = g + Math.abs(w) - 1
                  , S = p % 2 !== 0
                  , N = w < 0;
                w === 0 ? l = l.add(T5(S, r[b])) : a = a.add(T5(N, r[v]))
            }
            return {
                p: a,
                f: l
            }
        },
        wNAFUnsafe(t, r, s, i=n.ZERO) {
            const {windows: o, windowSize: a} = I5(t, e)
              , l = BigInt(2 ** t - 1)
              , u = 2 ** t
              , d = BigInt(t);
            for (let h = 0; h < o; h++) {
                const p = h * a;
                if (s === YB)
                    break;
                let g = Number(s & l);
                if (s >>= d,
                g > a && (g -= u,
                s += $1),
                g === 0)
                    continue;
                let w = r[p + Math.abs(g) - 1];
                g < 0 && (w = w.negate()),
                i = i.add(w)
            }
            return i
        },
        getPrecomputes(t, r, s) {
            let i = M5.get(r);
            return i || (i = this.precomputeWindow(r, t),
            t !== 1 && M5.set(r, s(i))),
            i
        },
        wNAFCached(t, r, s) {
            const i = B5(t);
            return this.wNAF(i, this.getPrecomputes(i, t, s), r)
        },
        wNAFCachedUnsafe(t, r, s, i) {
            const o = B5(t);
            return o === 1 ? this.unsafeLadder(t, r, i) : this.wNAFUnsafe(o, this.getPrecomputes(o, t, s), r, i)
        },
        setWindowSize(t, r) {
            y$(r, e),
            b$.set(t, r),
            M5.delete(t)
        }
    }
}
function Vde(n, e, t, r) {
    if (zde(t, n),
    $de(r, e),
    t.length !== r.length)
        throw new Error("arrays of points and scalars must have equal length");
    const s = n.ZERO
      , i = Dde(BigInt(t.length))
      , o = i > 12 ? i - 3 : i > 4 ? i - 2 : i ? 2 : 1
      , a = (1 << o) - 1
      , l = new Array(a + 1).fill(s)
      , u = Math.floor((e.BITS - 1) / o) * o;
    let d = s;
    for (let h = u; h >= 0; h -= o) {
        l.fill(s);
        for (let g = 0; g < r.length; g++) {
            const w = r[g]
              , b = Number(w >> BigInt(h) & BigInt(a));
            l[b] = l[b].add(t[g])
        }
        let p = s;
        for (let g = l.length - 1, w = s; g > 0; g--)
            w = w.add(l[g]),
            p = p.add(w);
        if (d = d.add(p),
        h !== 0)
            for (let g = 0; g < o; g++)
                d = d.double()
    }
    return d
}
function qde(n) {
    return Lde(n.Fp),
    T_(n, {
        n: "bigint",
        h: "bigint",
        Gx: "field",
        Gy: "field"
    }, {
        nBitLength: "isSafeInteger",
        nByteLength: "isSafeInteger"
    }),
    Object.freeze({
        ...m$(n.n, n.nBitLength),
        ...n,
        p: n.Fp.ORDER
    })
}
const Go = BigInt(0)
  , hi = BigInt(1)
  , H1 = BigInt(2)
  , Gde = BigInt(8)
  , Wde = {
    zip215: !0
};
function Yde(n) {
    const e = qde(n);
    return T_(n, {
        hash: "function",
        a: "bigint",
        d: "bigint",
        randomBytes: "function"
    }, {
        adjustScalarBytes: "function",
        domain: "function",
        uvRatio: "function",
        mapToCurve: "function"
    }),
    Object.freeze({
        ...e
    })
}
function Kde(n) {
    const e = Yde(n)
      , {Fp: t, n: r, prehash: s, hash: i, randomBytes: o, nByteLength: a, h: l} = e
      , u = H1 << BigInt(a * 8) - hi
      , d = t.create
      , h = g$(e.n, e.nBitLength)
      , p = e.uvRatio || ( (E, C) => {
        try {
            return {
                isValid: !0,
                value: t.sqrt(E * t.inv(C))
            }
        } catch {
            return {
                isValid: !1,
                value: Go
            }
        }
    }
    )
      , g = e.adjustScalarBytes || (E => E)
      , w = e.domain || ( (E, C, O) => {
        if (N5("phflag", O),
        C.length || O)
            throw new Error("Contexts/pre-hash are not supported");
        return E
    }
    );
    function b(E, C) {
        Vm("coordinate " + E, C, Go, u)
    }
    function v(E) {
        if (!(E instanceof _))
            throw new Error("ExtendedPoint expected")
    }
    const S = VB( (E, C) => {
        const {ex: O, ey: z, ez: G} = E
          , Y = E.is0();
        C == null && (C = Y ? Gde : t.inv(G));
        const $ = d(O * C)
          , D = d(z * C)
          , U = d(G * C);
        if (Y)
            return {
                x: Go,
                y: hi
            };
        if (U !== hi)
            throw new Error("invZ was invalid");
        return {
            x: $,
            y: D
        }
    }
    )
      , N = VB(E => {
        const {a: C, d: O} = e;
        if (E.is0())
            throw new Error("bad point: ZERO");
        const {ex: z, ey: G, ez: Y, et: $} = E
          , D = d(z * z)
          , U = d(G * G)
          , W = d(Y * Y)
          , Q = d(W * W)
          , J = d(D * C)
          , ne = d(W * d(J + U))
          , ie = d(Q + d(O * d(D * U)));
        if (ne !== ie)
            throw new Error("bad point: equation left != right (1)");
        const ae = d(z * G)
          , xe = d(Y * $);
        if (ae !== xe)
            throw new Error("bad point: equation left != right (2)");
        return !0
    }
    );
    class _ {
        constructor(C, O, z, G) {
            this.ex = C,
            this.ey = O,
            this.ez = z,
            this.et = G,
            b("x", C),
            b("y", O),
            b("z", z),
            b("t", G),
            Object.freeze(this)
        }
        get x() {
            return this.toAffine().x
        }
        get y() {
            return this.toAffine().y
        }
        static fromAffine(C) {
            if (C instanceof _)
                throw new Error("extended point not allowed");
            const {x: O, y: z} = C || {};
            return b("x", O),
            b("y", z),
            new _(O,z,hi,d(O * z))
        }
        static normalizeZ(C) {
            const O = t.invertBatch(C.map(z => z.ez));
            return C.map( (z, G) => z.toAffine(O[G])).map(_.fromAffine)
        }
        static msm(C, O) {
            return Vde(_, h, C, O)
        }
        _setWindowSize(C) {
            B.setWindowSize(this, C)
        }
        assertValidity() {
            N(this)
        }
        equals(C) {
            v(C);
            const {ex: O, ey: z, ez: G} = this
              , {ex: Y, ey: $, ez: D} = C
              , U = d(O * D)
              , W = d(Y * G)
              , Q = d(z * D)
              , J = d($ * G);
            return U === W && Q === J
        }
        is0() {
            return this.equals(_.ZERO)
        }
        negate() {
            return new _(d(-this.ex),this.ey,this.ez,d(-this.et))
        }
        double() {
            const {a: C} = e
              , {ex: O, ey: z, ez: G} = this
              , Y = d(O * O)
              , $ = d(z * z)
              , D = d(H1 * d(G * G))
              , U = d(C * Y)
              , W = O + z
              , Q = d(d(W * W) - Y - $)
              , J = U + $
              , ne = J - D
              , ie = U - $
              , ae = d(Q * ne)
              , xe = d(J * ie)
              , ue = d(Q * ie)
              , ce = d(ne * J);
            return new _(ae,xe,ce,ue)
        }
        add(C) {
            v(C);
            const {a: O, d: z} = e
              , {ex: G, ey: Y, ez: $, et: D} = this
              , {ex: U, ey: W, ez: Q, et: J} = C;
            if (O === BigInt(-1)) {
                const Ct = d((Y - G) * (W + U))
                  , ct = d((Y + G) * (W - U))
                  , Xe = d(ct - Ct);
                if (Xe === Go)
                    return this.double();
                const Et = d($ * H1 * J)
                  , St = d(D * H1 * Q)
                  , ut = St + Et
                  , cn = ct + Ct
                  , _t = St - Et
                  , ee = d(ut * Xe)
                  , K = d(cn * _t)
                  , X = d(ut * _t)
                  , re = d(Xe * cn);
                return new _(ee,K,re,X)
            }
            const ne = d(G * U)
              , ie = d(Y * W)
              , ae = d(D * z * J)
              , xe = d($ * Q)
              , ue = d((G + Y) * (U + W) - ne - ie)
              , ce = xe - ae
              , me = xe + ae
              , Ee = d(ie - O * ne)
              , Oe = d(ue * ce)
              , mt = d(me * Ee)
              , st = d(ue * Ee)
              , ot = d(ce * me);
            return new _(Oe,mt,ot,st)
        }
        subtract(C) {
            return this.add(C.negate())
        }
        wNAF(C) {
            return B.wNAFCached(this, C, _.normalizeZ)
        }
        multiply(C) {
            const O = C;
            Vm("scalar", O, hi, r);
            const {p: z, f: G} = this.wNAF(O);
            return _.normalizeZ([z, G])[0]
        }
        multiplyUnsafe(C, O=_.ZERO) {
            const z = C;
            return Vm("scalar", z, Go, r),
            z === Go ? k : this.is0() || z === hi ? this : B.wNAFCachedUnsafe(this, z, _.normalizeZ, O)
        }
        isSmallOrder() {
            return this.multiplyUnsafe(l).is0()
        }
        isTorsionFree() {
            return B.unsafeLadder(this, r).is0()
        }
        toAffine(C) {
            return S(this, C)
        }
        clearCofactor() {
            const {h: C} = e;
            return C === hi ? this : this.multiplyUnsafe(C)
        }
        static fromHex(C, O=!1) {
            const {d: z, a: G} = e
              , Y = t.BYTES;
            C = Rl("pointHex", C, Y),
            N5("zip215", O);
            const $ = C.slice()
              , D = C[Y - 1];
            $[Y - 1] = D & -129;
            const U = Hw($)
              , W = O ? u : t.ORDER;
            Vm("pointHex.y", U, Go, W);
            const Q = d(U * U)
              , J = d(Q - hi)
              , ne = d(z * Q - G);
            let {isValid: ie, value: ae} = p(J, ne);
            if (!ie)
                throw new Error("Point.fromHex: invalid y coordinate");
            const xe = (ae & hi) === hi
              , ue = (D & 128) !== 0;
            if (!O && ae === Go && ue)
                throw new Error("Point.fromHex: x=0 and x_0=1");
            return ue !== xe && (ae = d(-ae)),
            _.fromAffine({
                x: ae,
                y: U
            })
        }
        static fromPrivateKey(C) {
            return R(C).point
        }
        toRawBytes() {
            const {x: C, y: O} = this.toAffine()
              , z = J4(O, t.BYTES);
            return z[z.length - 1] |= C & hi ? 128 : 0,
            z
        }
        toHex() {
            return D_(this.toRawBytes())
        }
    }
    _.BASE = new _(e.Gx,e.Gy,hi,d(e.Gx * e.Gy)),
    _.ZERO = new _(Go,hi,hi,Go);
    const {BASE: I, ZERO: k} = _
      , B = Hde(_, a * 8);
    function P(E) {
        return Vr(E, r)
    }
    function M(E) {
        return P(Hw(E))
    }
    function R(E) {
        const C = t.BYTES;
        E = Rl("private key", E, C);
        const O = Rl("hashed private key", i(E), 2 * C)
          , z = g(O.slice(0, C))
          , G = O.slice(C, 2 * C)
          , Y = M(z)
          , $ = I.multiply(Y)
          , D = $.toRawBytes();
        return {
            head: z,
            prefix: G,
            scalar: Y,
            point: $,
            pointBytes: D
        }
    }
    function L(E) {
        return R(E).pointBytes
    }
    function q(E=new Uint8Array, ...C) {
        const O = HB(...C);
        return M(i(w(O, Rl("context", E), !!s)))
    }
    function H(E, C, O={}) {
        E = Rl("message", E),
        s && (E = s(E));
        const {prefix: z, scalar: G, pointBytes: Y} = R(C)
          , $ = q(O.context, z, E)
          , D = I.multiply($).toRawBytes()
          , U = q(O.context, D, Y, E)
          , W = P($ + U * G);
        Vm("signature.s", W, Go, r);
        const Q = HB(D, J4(W, t.BYTES));
        return Rl("result", Q, t.BYTES * 2)
    }
    const j = Wde;
    function A(E, C, O, z=j) {
        const {context: G, zip215: Y} = z
          , $ = t.BYTES;
        E = Rl("signature", E, 2 * $),
        C = Rl("message", C),
        O = Rl("publicKey", O, $),
        Y !== void 0 && N5("zip215", Y),
        s && (C = s(C));
        const D = Hw(E.slice($, 2 * $));
        let U, W, Q;
        try {
            U = _.fromHex(O, Y),
            W = _.fromHex(E.slice(0, $), Y),
            Q = I.multiplyUnsafe(D)
        } catch {
            return !1
        }
        if (!Y && U.isSmallOrder())
            return !1;
        const J = q(G, W.toRawBytes(), U.toRawBytes(), C);
        return W.add(U.multiplyUnsafe(J)).subtract(Q).clearCofactor().equals(_.ZERO)
    }
    return I._setWindowSize(8),
    {
        CURVE: e,
        getPublicKey: L,
        sign: H,
        verify: A,
        ExtendedPoint: _,
        utils: {
            getExtendedPublicKey: R,
            randomPrivateKey: () => o(t.BYTES),
            precompute(E=8, C=_.BASE) {
                return C._setWindowSize(E),
                C.multiply(BigInt(3)),
                C
            }
        }
    }
}
BigInt(0),
BigInt(1);
const I_ = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949")
  , KB = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
BigInt(0);
const Xde = BigInt(1)
  , XB = BigInt(2);
BigInt(3);
const Qde = BigInt(5)
  , Zde = BigInt(8);
function Jde(n) {
    const e = BigInt(10)
      , t = BigInt(20)
      , r = BigInt(40)
      , s = BigInt(80)
      , i = I_
      , o = n * n % i * n % i
      , a = Na(o, XB, i) * o % i
      , l = Na(a, Xde, i) * n % i
      , u = Na(l, Qde, i) * l % i
      , d = Na(u, e, i) * u % i
      , h = Na(d, t, i) * d % i
      , p = Na(h, r, i) * h % i
      , g = Na(p, s, i) * p % i
      , w = Na(g, s, i) * p % i
      , b = Na(w, e, i) * u % i;
    return {
        pow_p_5_8: Na(b, XB, i) * n % i,
        b2: o
    }
}
function efe(n) {
    return n[0] &= 248,
    n[31] &= 127,
    n[31] |= 64,
    n
}
function tfe(n, e) {
    const t = I_
      , r = Vr(e * e * e, t)
      , s = Vr(r * r * e, t)
      , i = Jde(n * s).pow_p_5_8;
    let o = Vr(n * r * i, t);
    const a = Vr(e * o * o, t)
      , l = o
      , u = Vr(o * KB, t)
      , d = a === n
      , h = a === Vr(-n, t)
      , p = a === Vr(-n * KB, t);
    return d && (o = l),
    (h || p) && (o = u),
    Pde(o, t) && (o = Vr(-o, t)),
    {
        isValid: d || h,
        value: o
    }
}
const nfe = g$(I_, void 0, !0)
  , rfe = {
    a: BigInt(-1),
    d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
    Fp: nfe,
    n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),
    h: Zde,
    Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
    Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),
    hash: Ade,
    randomBytes: c$,
    adjustScalarBytes: efe,
    uvRatio: tfe
}
  , w$ = Kde(rfe)
  , sfe = "EdDSA"
  , ife = "JWT"
  , j2 = "."
  , ax = "base64url"
  , v$ = "utf8"
  , x$ = "utf8"
  , ofe = ":"
  , afe = "did"
  , lfe = "key"
  , QB = "base58btc"
  , cfe = "z"
  , ufe = "K36"
  , dfe = 32;
function M_(n) {
    return globalThis.Buffer != null ? new Uint8Array(n.buffer,n.byteOffset,n.byteLength) : n
}
function E$(n=0) {
    return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? M_(globalThis.Buffer.allocUnsafe(n)) : new Uint8Array(n)
}
function S$(n, e) {
    e || (e = n.reduce( (s, i) => s + i.length, 0));
    const t = E$(e);
    let r = 0;
    for (const s of n)
        t.set(s, r),
        r += s.length;
    return M_(t)
}
function ffe(n, e) {
    if (n.length >= 255)
        throw new TypeError("Alphabet too long");
    for (var t = new Uint8Array(256), r = 0; r < t.length; r++)
        t[r] = 255;
    for (var s = 0; s < n.length; s++) {
        var i = n.charAt(s)
          , o = i.charCodeAt(0);
        if (t[o] !== 255)
            throw new TypeError(i + " is ambiguous");
        t[o] = s
    }
    var a = n.length
      , l = n.charAt(0)
      , u = Math.log(a) / Math.log(256)
      , d = Math.log(256) / Math.log(a);
    function h(w) {
        if (w instanceof Uint8Array || (ArrayBuffer.isView(w) ? w = new Uint8Array(w.buffer,w.byteOffset,w.byteLength) : Array.isArray(w) && (w = Uint8Array.from(w))),
        !(w instanceof Uint8Array))
            throw new TypeError("Expected Uint8Array");
        if (w.length === 0)
            return "";
        for (var b = 0, v = 0, S = 0, N = w.length; S !== N && w[S] === 0; )
            S++,
            b++;
        for (var _ = (N - S) * d + 1 >>> 0, I = new Uint8Array(_); S !== N; ) {
            for (var k = w[S], B = 0, P = _ - 1; (k !== 0 || B < v) && P !== -1; P--,
            B++)
                k += 256 * I[P] >>> 0,
                I[P] = k % a >>> 0,
                k = k / a >>> 0;
            if (k !== 0)
                throw new Error("Non-zero carry");
            v = B,
            S++
        }
        for (var M = _ - v; M !== _ && I[M] === 0; )
            M++;
        for (var R = l.repeat(b); M < _; ++M)
            R += n.charAt(I[M]);
        return R
    }
    function p(w) {
        if (typeof w != "string")
            throw new TypeError("Expected String");
        if (w.length === 0)
            return new Uint8Array;
        var b = 0;
        if (w[b] !== " ") {
            for (var v = 0, S = 0; w[b] === l; )
                v++,
                b++;
            for (var N = (w.length - b) * u + 1 >>> 0, _ = new Uint8Array(N); w[b]; ) {
                var I = t[w.charCodeAt(b)];
                if (I === 255)
                    return;
                for (var k = 0, B = N - 1; (I !== 0 || k < S) && B !== -1; B--,
                k++)
                    I += a * _[B] >>> 0,
                    _[B] = I % 256 >>> 0,
                    I = I / 256 >>> 0;
                if (I !== 0)
                    throw new Error("Non-zero carry");
                S = k,
                b++
            }
            if (w[b] !== " ") {
                for (var P = N - S; P !== N && _[P] === 0; )
                    P++;
                for (var M = new Uint8Array(v + (N - P)), R = v; P !== N; )
                    M[R++] = _[P++];
                return M
            }
        }
    }
    function g(w) {
        var b = p(w);
        if (b)
            return b;
        throw new Error(`Non-${e} character`)
    }
    return {
        encode: h,
        decodeUnsafe: p,
        decode: g
    }
}
var hfe = ffe
  , pfe = hfe;
const A$ = n => {
    if (n instanceof Uint8Array && n.constructor.name === "Uint8Array")
        return n;
    if (n instanceof ArrayBuffer)
        return new Uint8Array(n);
    if (ArrayBuffer.isView(n))
        return new Uint8Array(n.buffer,n.byteOffset,n.byteLength);
    throw new Error("Unknown type, must be binary type")
}
  , mfe = n => new TextEncoder().encode(n)
  , gfe = n => new TextDecoder().decode(n);
let yfe = class {
    constructor(e, t, r) {
        this.name = e,
        this.prefix = t,
        this.baseEncode = r
    }
    encode(e) {
        if (e instanceof Uint8Array)
            return `${this.prefix}${this.baseEncode(e)}`;
        throw Error("Unknown type, must be binary type")
    }
}
  , bfe = class {
    constructor(e, t, r) {
        if (this.name = e,
        this.prefix = t,
        t.codePointAt(0) === void 0)
            throw new Error("Invalid prefix character");
        this.prefixCodePoint = t.codePointAt(0),
        this.baseDecode = r
    }
    decode(e) {
        if (typeof e == "string") {
            if (e.codePointAt(0) !== this.prefixCodePoint)
                throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
            return this.baseDecode(e.slice(this.prefix.length))
        } else
            throw Error("Can only multibase decode strings")
    }
    or(e) {
        return C$(this, e)
    }
}
  , wfe = class {
    constructor(e) {
        this.decoders = e
    }
    or(e) {
        return C$(this, e)
    }
    decode(e) {
        const t = e[0]
          , r = this.decoders[t];
        if (r)
            return r.decode(e);
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)
    }
}
;
const C$ = (n, e) => new wfe({
    ...n.decoders || {
        [n.prefix]: n
    },
    ...e.decoders || {
        [e.prefix]: e
    }
});
let vfe = class {
    constructor(e, t, r, s) {
        this.name = e,
        this.prefix = t,
        this.baseEncode = r,
        this.baseDecode = s,
        this.encoder = new yfe(e,t,r),
        this.decoder = new bfe(e,t,s)
    }
    encode(e) {
        return this.encoder.encode(e)
    }
    decode(e) {
        return this.decoder.decode(e)
    }
}
;
const lx = ({name: n, prefix: e, encode: t, decode: r}) => new vfe(n,e,t,r)
  , zy = ({prefix: n, name: e, alphabet: t}) => {
    const {encode: r, decode: s} = pfe(t, e);
    return lx({
        prefix: n,
        name: e,
        encode: r,
        decode: i => A$(s(i))
    })
}
  , xfe = (n, e, t, r) => {
    const s = {};
    for (let d = 0; d < e.length; ++d)
        s[e[d]] = d;
    let i = n.length;
    for (; n[i - 1] === "="; )
        --i;
    const o = new Uint8Array(i * t / 8 | 0);
    let a = 0
      , l = 0
      , u = 0;
    for (let d = 0; d < i; ++d) {
        const h = s[n[d]];
        if (h === void 0)
            throw new SyntaxError(`Non-${r} character`);
        l = l << t | h,
        a += t,
        a >= 8 && (a -= 8,
        o[u++] = 255 & l >> a)
    }
    if (a >= t || 255 & l << 8 - a)
        throw new SyntaxError("Unexpected end of data");
    return o
}
  , Efe = (n, e, t) => {
    const r = e[e.length - 1] === "="
      , s = (1 << t) - 1;
    let i = ""
      , o = 0
      , a = 0;
    for (let l = 0; l < n.length; ++l)
        for (a = a << 8 | n[l],
        o += 8; o > t; )
            o -= t,
            i += e[s & a >> o];
    if (o && (i += e[s & a << t - o]),
    r)
        for (; i.length * t & 7; )
            i += "=";
    return i
}
  , Ss = ({name: n, prefix: e, bitsPerChar: t, alphabet: r}) => lx({
    prefix: e,
    name: n,
    encode(s) {
        return Efe(s, r, t)
    },
    decode(s) {
        return xfe(s, r, t, n)
    }
})
  , Sfe = lx({
    prefix: "\0",
    name: "identity",
    encode: n => gfe(n),
    decode: n => mfe(n)
});
var Afe = Object.freeze({
    __proto__: null,
    identity: Sfe
});
const Cfe = Ss({
    prefix: "0",
    name: "base2",
    alphabet: "01",
    bitsPerChar: 1
});
var _fe = Object.freeze({
    __proto__: null,
    base2: Cfe
});
const kfe = Ss({
    prefix: "7",
    name: "base8",
    alphabet: "01234567",
    bitsPerChar: 3
});
var Nfe = Object.freeze({
    __proto__: null,
    base8: kfe
});
const Dfe = zy({
    prefix: "9",
    name: "base10",
    alphabet: "0123456789"
});
var Tfe = Object.freeze({
    __proto__: null,
    base10: Dfe
});
const Ife = Ss({
    prefix: "f",
    name: "base16",
    alphabet: "0123456789abcdef",
    bitsPerChar: 4
})
  , Mfe = Ss({
    prefix: "F",
    name: "base16upper",
    alphabet: "0123456789ABCDEF",
    bitsPerChar: 4
});
var Bfe = Object.freeze({
    __proto__: null,
    base16: Ife,
    base16upper: Mfe
});
const Rfe = Ss({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
})
  , Ofe = Ss({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
})
  , Pfe = Ss({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
})
  , jfe = Ss({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
})
  , Lfe = Ss({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
})
  , Ffe = Ss({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
})
  , Ufe = Ss({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
})
  , zfe = Ss({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
})
  , $fe = Ss({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
});
var Hfe = Object.freeze({
    __proto__: null,
    base32: Rfe,
    base32upper: Ofe,
    base32pad: Pfe,
    base32padupper: jfe,
    base32hex: Lfe,
    base32hexupper: Ffe,
    base32hexpad: Ufe,
    base32hexpadupper: zfe,
    base32z: $fe
});
const Vfe = zy({
    prefix: "k",
    name: "base36",
    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
})
  , qfe = zy({
    prefix: "K",
    name: "base36upper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});
var Gfe = Object.freeze({
    __proto__: null,
    base36: Vfe,
    base36upper: qfe
});
const Wfe = zy({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
})
  , Yfe = zy({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});
var Kfe = Object.freeze({
    __proto__: null,
    base58btc: Wfe,
    base58flickr: Yfe
});
const Xfe = Ss({
    prefix: "m",
    name: "base64",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6
})
  , Qfe = Ss({
    prefix: "M",
    name: "base64pad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6
})
  , Zfe = Ss({
    prefix: "u",
    name: "base64url",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6
})
  , Jfe = Ss({
    prefix: "U",
    name: "base64urlpad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6
});
var ehe = Object.freeze({
    __proto__: null,
    base64: Xfe,
    base64pad: Qfe,
    base64url: Zfe,
    base64urlpad: Jfe
});
const _$ = Array.from("")
  , the = _$.reduce( (n, e, t) => (n[t] = e,
n), [])
  , nhe = _$.reduce( (n, e, t) => (n[e.codePointAt(0)] = t,
n), []);
function rhe(n) {
    return n.reduce( (e, t) => (e += the[t],
    e), "")
}
function she(n) {
    const e = [];
    for (const t of n) {
        const r = nhe[t.codePointAt(0)];
        if (r === void 0)
            throw new Error(`Non-base256emoji character: ${t}`);
        e.push(r)
    }
    return new Uint8Array(e)
}
const ihe = lx({
    prefix: "",
    name: "base256emoji",
    encode: rhe,
    decode: she
});
var ohe = Object.freeze({
    __proto__: null,
    base256emoji: ihe
})
  , ahe = k$
  , ZB = 128
  , lhe = -128
  , che = Math.pow(2, 31);
function k$(n, e, t) {
    e = e || [],
    t = t || 0;
    for (var r = t; n >= che; )
        e[t++] = n & 255 | ZB,
        n /= 128;
    for (; n & lhe; )
        e[t++] = n & 255 | ZB,
        n >>>= 7;
    return e[t] = n | 0,
    k$.bytes = t - r + 1,
    e
}
var uhe = tC
  , dhe = 128
  , JB = 127;
function tC(n, r) {
    var t = 0, r = r || 0, s = 0, i = r, o, a = n.length;
    do {
        if (i >= a)
            throw tC.bytes = 0,
            new RangeError("Could not decode varint");
        o = n[i++],
        t += s < 28 ? (o & JB) << s : (o & JB) * Math.pow(2, s),
        s += 7
    } while (o >= dhe);
    return tC.bytes = i - r,
    t
}
var fhe = Math.pow(2, 7)
  , hhe = Math.pow(2, 14)
  , phe = Math.pow(2, 21)
  , mhe = Math.pow(2, 28)
  , ghe = Math.pow(2, 35)
  , yhe = Math.pow(2, 42)
  , bhe = Math.pow(2, 49)
  , whe = Math.pow(2, 56)
  , vhe = Math.pow(2, 63)
  , xhe = function(n) {
    return n < fhe ? 1 : n < hhe ? 2 : n < phe ? 3 : n < mhe ? 4 : n < ghe ? 5 : n < yhe ? 6 : n < bhe ? 7 : n < whe ? 8 : n < vhe ? 9 : 10
}
  , Ehe = {
    encode: ahe,
    decode: uhe,
    encodingLength: xhe
}
  , N$ = Ehe;
const eR = (n, e, t=0) => (N$.encode(n, e, t),
e)
  , tR = n => N$.encodingLength(n)
  , nC = (n, e) => {
    const t = e.byteLength
      , r = tR(n)
      , s = r + tR(t)
      , i = new Uint8Array(s + t);
    return eR(n, i, 0),
    eR(t, i, r),
    i.set(e, s),
    new She(n,t,e,i)
}
;
let She = class {
    constructor(e, t, r, s) {
        this.code = e,
        this.size = t,
        this.digest = r,
        this.bytes = s
    }
}
;
const D$ = ({name: n, code: e, encode: t}) => new Ahe(n,e,t);
let Ahe = class {
    constructor(e, t, r) {
        this.name = e,
        this.code = t,
        this.encode = r
    }
    digest(e) {
        if (e instanceof Uint8Array) {
            const t = this.encode(e);
            return t instanceof Uint8Array ? nC(this.code, t) : t.then(r => nC(this.code, r))
        } else
            throw Error("Unknown type, must be binary type")
    }
}
;
const T$ = n => async e => new Uint8Array(await crypto.subtle.digest(n, e))
  , Che = D$({
    name: "sha2-256",
    code: 18,
    encode: T$("SHA-256")
})
  , _he = D$({
    name: "sha2-512",
    code: 19,
    encode: T$("SHA-512")
});
var khe = Object.freeze({
    __proto__: null,
    sha256: Che,
    sha512: _he
});
const I$ = 0
  , Nhe = "identity"
  , M$ = A$
  , Dhe = n => nC(I$, M$(n))
  , The = {
    code: I$,
    name: Nhe,
    encode: M$,
    digest: Dhe
};
var Ihe = Object.freeze({
    __proto__: null,
    identity: The
});
new TextEncoder,
new TextDecoder;
const nR = {
    ...Afe,
    ..._fe,
    ...Nfe,
    ...Tfe,
    ...Bfe,
    ...Hfe,
    ...Gfe,
    ...Kfe,
    ...ehe,
    ...ohe
};
({
    ...khe,
    ...Ihe
});
function B$(n, e, t, r) {
    return {
        name: n,
        prefix: e,
        encoder: {
            name: n,
            prefix: e,
            encode: t
        },
        decoder: {
            decode: r
        }
    }
}
const rR = B$("utf8", "u", n => "u" + new TextDecoder("utf8").decode(n), n => new TextEncoder().encode(n.substring(1)))
  , R5 = B$("ascii", "a", n => {
    let e = "a";
    for (let t = 0; t < n.length; t++)
        e += String.fromCharCode(n[t]);
    return e
}
, n => {
    n = n.substring(1);
    const e = E$(n.length);
    for (let t = 0; t < n.length; t++)
        e[t] = n.charCodeAt(t);
    return e
}
)
  , R$ = {
    utf8: rR,
    "utf-8": rR,
    hex: nR.base16,
    latin1: R5,
    ascii: R5,
    binary: R5,
    ...nR
};
function cx(n, e="utf8") {
    const t = R$[e];
    if (!t)
        throw new Error(`Unsupported encoding "${e}"`);
    return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(n.buffer, n.byteOffset, n.byteLength).toString("utf8") : t.encoder.encode(n).substring(1)
}
function T0(n, e="utf8") {
    const t = R$[e];
    if (!t)
        throw new Error(`Unsupported encoding "${e}"`);
    return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? M_(globalThis.Buffer.from(n, "utf-8")) : t.decoder.decode(`${t.prefix}${n}`)
}
function sR(n) {
    return Of(cx(T0(n, ax), v$))
}
function L2(n) {
    return cx(T0(Tc(n), v$), ax)
}
function O$(n) {
    const e = T0(ufe, QB)
      , t = cfe + cx(S$([e, n]), QB);
    return [afe, lfe, t].join(ofe)
}
function Mhe(n) {
    return cx(n, ax)
}
function Bhe(n) {
    return T0(n, ax)
}
function Rhe(n) {
    return T0([L2(n.header), L2(n.payload)].join(j2), x$)
}
function Ohe(n) {
    return [L2(n.header), L2(n.payload), Mhe(n.signature)].join(j2)
}
function rC(n) {
    const e = n.split(j2)
      , t = sR(e[0])
      , r = sR(e[1])
      , s = Bhe(e[2])
      , i = T0(e.slice(0, 2).join(j2), x$);
    return {
        header: t,
        payload: r,
        signature: s,
        data: i
    }
}
function iR(n=c$(dfe)) {
    const e = w$.getPublicKey(n);
    return {
        secretKey: S$([n, e]),
        publicKey: e
    }
}
async function Phe(n, e, t, r, s=je.fromMiliseconds(Date.now())) {
    const i = {
        alg: sfe,
        typ: ife
    }
      , o = O$(r.publicKey)
      , a = s + t
      , l = {
        iss: o,
        sub: n,
        aud: e,
        iat: s,
        exp: a
    }
      , u = Rhe({
        header: i,
        payload: l
    })
      , d = w$.sign(u, r.secretKey.slice(0, 32));
    return Ohe({
        header: i,
        payload: l,
        signature: d
    })
}
function B_(n) {
    return globalThis.Buffer != null ? new Uint8Array(n.buffer,n.byteOffset,n.byteLength) : n
}
function P$(n=0) {
    return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? B_(globalThis.Buffer.allocUnsafe(n)) : new Uint8Array(n)
}
function Dg(n, e) {
    e || (e = n.reduce( (s, i) => s + i.length, 0));
    const t = P$(e);
    let r = 0;
    for (const s of n)
        t.set(s, r),
        r += s.length;
    return B_(t)
}
function jhe(n, e) {
    if (n.length >= 255)
        throw new TypeError("Alphabet too long");
    for (var t = new Uint8Array(256), r = 0; r < t.length; r++)
        t[r] = 255;
    for (var s = 0; s < n.length; s++) {
        var i = n.charAt(s)
          , o = i.charCodeAt(0);
        if (t[o] !== 255)
            throw new TypeError(i + " is ambiguous");
        t[o] = s
    }
    var a = n.length
      , l = n.charAt(0)
      , u = Math.log(a) / Math.log(256)
      , d = Math.log(256) / Math.log(a);
    function h(w) {
        if (w instanceof Uint8Array || (ArrayBuffer.isView(w) ? w = new Uint8Array(w.buffer,w.byteOffset,w.byteLength) : Array.isArray(w) && (w = Uint8Array.from(w))),
        !(w instanceof Uint8Array))
            throw new TypeError("Expected Uint8Array");
        if (w.length === 0)
            return "";
        for (var b = 0, v = 0, S = 0, N = w.length; S !== N && w[S] === 0; )
            S++,
            b++;
        for (var _ = (N - S) * d + 1 >>> 0, I = new Uint8Array(_); S !== N; ) {
            for (var k = w[S], B = 0, P = _ - 1; (k !== 0 || B < v) && P !== -1; P--,
            B++)
                k += 256 * I[P] >>> 0,
                I[P] = k % a >>> 0,
                k = k / a >>> 0;
            if (k !== 0)
                throw new Error("Non-zero carry");
            v = B,
            S++
        }
        for (var M = _ - v; M !== _ && I[M] === 0; )
            M++;
        for (var R = l.repeat(b); M < _; ++M)
            R += n.charAt(I[M]);
        return R
    }
    function p(w) {
        if (typeof w != "string")
            throw new TypeError("Expected String");
        if (w.length === 0)
            return new Uint8Array;
        var b = 0;
        if (w[b] !== " ") {
            for (var v = 0, S = 0; w[b] === l; )
                v++,
                b++;
            for (var N = (w.length - b) * u + 1 >>> 0, _ = new Uint8Array(N); w[b]; ) {
                var I = t[w.charCodeAt(b)];
                if (I === 255)
                    return;
                for (var k = 0, B = N - 1; (I !== 0 || k < S) && B !== -1; B--,
                k++)
                    I += a * _[B] >>> 0,
                    _[B] = I % 256 >>> 0,
                    I = I / 256 >>> 0;
                if (I !== 0)
                    throw new Error("Non-zero carry");
                S = k,
                b++
            }
            if (w[b] !== " ") {
                for (var P = N - S; P !== N && _[P] === 0; )
                    P++;
                for (var M = new Uint8Array(v + (N - P)), R = v; P !== N; )
                    M[R++] = _[P++];
                return M
            }
        }
    }
    function g(w) {
        var b = p(w);
        if (b)
            return b;
        throw new Error(`Non-${e} character`)
    }
    return {
        encode: h,
        decodeUnsafe: p,
        decode: g
    }
}
var Lhe = jhe
  , Fhe = Lhe;
const Uhe = n => {
    if (n instanceof Uint8Array && n.constructor.name === "Uint8Array")
        return n;
    if (n instanceof ArrayBuffer)
        return new Uint8Array(n);
    if (ArrayBuffer.isView(n))
        return new Uint8Array(n.buffer,n.byteOffset,n.byteLength);
    throw new Error("Unknown type, must be binary type")
}
  , zhe = n => new TextEncoder().encode(n)
  , $he = n => new TextDecoder().decode(n);
class Hhe {
    constructor(e, t, r) {
        this.name = e,
        this.prefix = t,
        this.baseEncode = r
    }
    encode(e) {
        if (e instanceof Uint8Array)
            return `${this.prefix}${this.baseEncode(e)}`;
        throw Error("Unknown type, must be binary type")
    }
}
class Vhe {
    constructor(e, t, r) {
        if (this.name = e,
        this.prefix = t,
        t.codePointAt(0) === void 0)
            throw new Error("Invalid prefix character");
        this.prefixCodePoint = t.codePointAt(0),
        this.baseDecode = r
    }
    decode(e) {
        if (typeof e == "string") {
            if (e.codePointAt(0) !== this.prefixCodePoint)
                throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
            return this.baseDecode(e.slice(this.prefix.length))
        } else
            throw Error("Can only multibase decode strings")
    }
    or(e) {
        return j$(this, e)
    }
}
class qhe {
    constructor(e) {
        this.decoders = e
    }
    or(e) {
        return j$(this, e)
    }
    decode(e) {
        const t = e[0]
          , r = this.decoders[t];
        if (r)
            return r.decode(e);
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)
    }
}
const j$ = (n, e) => new qhe({
    ...n.decoders || {
        [n.prefix]: n
    },
    ...e.decoders || {
        [e.prefix]: e
    }
});
class Ghe {
    constructor(e, t, r, s) {
        this.name = e,
        this.prefix = t,
        this.baseEncode = r,
        this.baseDecode = s,
        this.encoder = new Hhe(e,t,r),
        this.decoder = new Vhe(e,t,s)
    }
    encode(e) {
        return this.encoder.encode(e)
    }
    decode(e) {
        return this.decoder.decode(e)
    }
}
const ux = ({name: n, prefix: e, encode: t, decode: r}) => new Ghe(n,e,t,r)
  , $y = ({prefix: n, name: e, alphabet: t}) => {
    const {encode: r, decode: s} = Fhe(t, e);
    return ux({
        prefix: n,
        name: e,
        encode: r,
        decode: i => Uhe(s(i))
    })
}
  , Whe = (n, e, t, r) => {
    const s = {};
    for (let d = 0; d < e.length; ++d)
        s[e[d]] = d;
    let i = n.length;
    for (; n[i - 1] === "="; )
        --i;
    const o = new Uint8Array(i * t / 8 | 0);
    let a = 0
      , l = 0
      , u = 0;
    for (let d = 0; d < i; ++d) {
        const h = s[n[d]];
        if (h === void 0)
            throw new SyntaxError(`Non-${r} character`);
        l = l << t | h,
        a += t,
        a >= 8 && (a -= 8,
        o[u++] = 255 & l >> a)
    }
    if (a >= t || 255 & l << 8 - a)
        throw new SyntaxError("Unexpected end of data");
    return o
}
  , Yhe = (n, e, t) => {
    const r = e[e.length - 1] === "="
      , s = (1 << t) - 1;
    let i = ""
      , o = 0
      , a = 0;
    for (let l = 0; l < n.length; ++l)
        for (a = a << 8 | n[l],
        o += 8; o > t; )
            o -= t,
            i += e[s & a >> o];
    if (o && (i += e[s & a << t - o]),
    r)
        for (; i.length * t & 7; )
            i += "=";
    return i
}
  , As = ({name: n, prefix: e, bitsPerChar: t, alphabet: r}) => ux({
    prefix: e,
    name: n,
    encode(s) {
        return Yhe(s, r, t)
    },
    decode(s) {
        return Whe(s, r, t, n)
    }
})
  , Khe = ux({
    prefix: "\0",
    name: "identity",
    encode: n => $he(n),
    decode: n => zhe(n)
})
  , Xhe = Object.freeze(Object.defineProperty({
    __proto__: null,
    identity: Khe
}, Symbol.toStringTag, {
    value: "Module"
}))
  , Qhe = As({
    prefix: "0",
    name: "base2",
    alphabet: "01",
    bitsPerChar: 1
})
  , Zhe = Object.freeze(Object.defineProperty({
    __proto__: null,
    base2: Qhe
}, Symbol.toStringTag, {
    value: "Module"
}))
  , Jhe = As({
    prefix: "7",
    name: "base8",
    alphabet: "01234567",
    bitsPerChar: 3
})
  , epe = Object.freeze(Object.defineProperty({
    __proto__: null,
    base8: Jhe
}, Symbol.toStringTag, {
    value: "Module"
}))
  , tpe = $y({
    prefix: "9",
    name: "base10",
    alphabet: "0123456789"
})
  , npe = Object.freeze(Object.defineProperty({
    __proto__: null,
    base10: tpe
}, Symbol.toStringTag, {
    value: "Module"
}))
  , rpe = As({
    prefix: "f",
    name: "base16",
    alphabet: "0123456789abcdef",
    bitsPerChar: 4
})
  , spe = As({
    prefix: "F",
    name: "base16upper",
    alphabet: "0123456789ABCDEF",
    bitsPerChar: 4
})
  , ipe = Object.freeze(Object.defineProperty({
    __proto__: null,
    base16: rpe,
    base16upper: spe
}, Symbol.toStringTag, {
    value: "Module"
}))
  , ope = As({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
})
  , ape = As({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
})
  , lpe = As({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
})
  , cpe = As({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
})
  , upe = As({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
})
  , dpe = As({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
})
  , fpe = As({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
})
  , hpe = As({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
})
  , ppe = As({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
})
  , mpe = Object.freeze(Object.defineProperty({
    __proto__: null,
    base32: ope,
    base32hex: upe,
    base32hexpad: fpe,
    base32hexpadupper: hpe,
    base32hexupper: dpe,
    base32pad: lpe,
    base32padupper: cpe,
    base32upper: ape,
    base32z: ppe
}, Symbol.toStringTag, {
    value: "Module"
}))
  , gpe = $y({
    prefix: "k",
    name: "base36",
    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
})
  , ype = $y({
    prefix: "K",
    name: "base36upper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
})
  , bpe = Object.freeze(Object.defineProperty({
    __proto__: null,
    base36: gpe,
    base36upper: ype
}, Symbol.toStringTag, {
    value: "Module"
}))
  , wpe = $y({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
})
  , vpe = $y({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
})
  , xpe = Object.freeze(Object.defineProperty({
    __proto__: null,
    base58btc: wpe,
    base58flickr: vpe
}, Symbol.toStringTag, {
    value: "Module"
}))
  , Epe = As({
    prefix: "m",
    name: "base64",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6
})
  , Spe = As({
    prefix: "M",
    name: "base64pad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6
})
  , Ape = As({
    prefix: "u",
    name: "base64url",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6
})
  , Cpe = As({
    prefix: "U",
    name: "base64urlpad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6
})
  , _pe = Object.freeze(Object.defineProperty({
    __proto__: null,
    base64: Epe,
    base64pad: Spe,
    base64url: Ape,
    base64urlpad: Cpe
}, Symbol.toStringTag, {
    value: "Module"
}))
  , L$ = Array.from("")
  , kpe = L$.reduce( (n, e, t) => (n[t] = e,
n), [])
  , Npe = L$.reduce( (n, e, t) => (n[e.codePointAt(0)] = t,
n), []);
function Dpe(n) {
    return n.reduce( (e, t) => (e += kpe[t],
    e), "")
}
function Tpe(n) {
    const e = [];
    for (const t of n) {
        const r = Npe[t.codePointAt(0)];
        if (r === void 0)
            throw new Error(`Non-base256emoji character: ${t}`);
        e.push(r)
    }
    return new Uint8Array(e)
}
const Ipe = ux({
    prefix: "",
    name: "base256emoji",
    encode: Dpe,
    decode: Tpe
})
  , Mpe = Object.freeze(Object.defineProperty({
    __proto__: null,
    base256emoji: Ipe
}, Symbol.toStringTag, {
    value: "Module"
}));
new TextEncoder;
new TextDecoder;
const oR = {
    ...Xhe,
    ...Zhe,
    ...epe,
    ...npe,
    ...ipe,
    ...mpe,
    ...bpe,
    ...xpe,
    ..._pe,
    ...Mpe
};
function F$(n, e, t, r) {
    return {
        name: n,
        prefix: e,
        encoder: {
            name: n,
            prefix: e,
            encode: t
        },
        decoder: {
            decode: r
        }
    }
}
const aR = F$("utf8", "u", n => "u" + new TextDecoder("utf8").decode(n), n => new TextEncoder().encode(n.substring(1)))
  , O5 = F$("ascii", "a", n => {
    let e = "a";
    for (let t = 0; t < n.length; t++)
        e += String.fromCharCode(n[t]);
    return e
}
, n => {
    n = n.substring(1);
    const e = P$(n.length);
    for (let t = 0; t < n.length; t++)
        e[t] = n.charCodeAt(t);
    return e
}
)
  , U$ = {
    utf8: aR,
    "utf-8": aR,
    hex: oR.base16,
    latin1: O5,
    ascii: O5,
    binary: O5,
    ...oR
};
function Bo(n, e="utf8") {
    const t = U$[e];
    if (!t)
        throw new Error(`Unsupported encoding "${e}"`);
    return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? B_(globalThis.Buffer.from(n, "utf-8")) : t.decoder.decode(`${t.prefix}${n}`)
}
function Ni(n, e="utf8") {
    const t = U$[e];
    if (!t)
        throw new Error(`Unsupported encoding "${e}"`);
    return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(n.buffer, n.byteOffset, n.byteLength).toString("utf8") : t.encoder.encode(n).substring(1)
}
const Bpe = {
    waku: {
        publish: "waku_publish",
        batchPublish: "waku_batchPublish",
        subscribe: "waku_subscribe",
        batchSubscribe: "waku_batchSubscribe",
        subscription: "waku_subscription",
        unsubscribe: "waku_unsubscribe",
        batchUnsubscribe: "waku_batchUnsubscribe",
        batchFetchMessages: "waku_batchFetchMessages"
    },
    irn: {
        publish: "irn_publish",
        batchPublish: "irn_batchPublish",
        subscribe: "irn_subscribe",
        batchSubscribe: "irn_batchSubscribe",
        subscription: "irn_subscription",
        unsubscribe: "irn_unsubscribe",
        batchUnsubscribe: "irn_batchUnsubscribe",
        batchFetchMessages: "irn_batchFetchMessages"
    },
    iridium: {
        publish: "iridium_publish",
        batchPublish: "iridium_batchPublish",
        subscribe: "iridium_subscribe",
        batchSubscribe: "iridium_batchSubscribe",
        subscription: "iridium_subscription",
        unsubscribe: "iridium_unsubscribe",
        batchUnsubscribe: "iridium_batchUnsubscribe",
        batchFetchMessages: "iridium_batchFetchMessages"
    }
};
var P5, lR;
function z$() {
    if (lR)
        return P5;
    lR = 1;
    const n = "Input must be an string, Buffer or Uint8Array";
    function e(o) {
        let a;
        if (o instanceof Uint8Array)
            a = o;
        else if (typeof o == "string")
            a = new TextEncoder().encode(o);
        else
            throw new Error(n);
        return a
    }
    function t(o) {
        return Array.prototype.map.call(o, function(a) {
            return (a < 16 ? "0" : "") + a.toString(16)
        }).join("")
    }
    function r(o) {
        return (4294967296 + o).toString(16).substring(1)
    }
    function s(o, a, l) {
        let u = `
` + o + " = ";
        for (let d = 0; d < a.length; d += 2) {
            if (l === 32)
                u += r(a[d]).toUpperCase(),
                u += " ",
                u += r(a[d + 1]).toUpperCase();
            else if (l === 64)
                u += r(a[d + 1]).toUpperCase(),
                u += r(a[d]).toUpperCase();
            else
                throw new Error("Invalid size " + l);
            d % 6 === 4 ? u += `
` + new Array(o.length + 4).join(" ") : d < a.length - 2 && (u += " ")
        }
        console.log(u)
    }
    function i(o, a, l) {
        let u = new Date().getTime();
        const d = new Uint8Array(a);
        for (let p = 0; p < a; p++)
            d[p] = p % 256;
        const h = new Date().getTime();
        console.log("Generated random input in " + (h - u) + "ms"),
        u = h;
        for (let p = 0; p < l; p++) {
            const g = o(d)
              , w = new Date().getTime()
              , b = w - u;
            u = w,
            console.log("Hashed in " + b + "ms: " + g.substring(0, 20) + "..."),
            console.log(Math.round(a / (1 << 20) / (b / 1e3) * 100) / 100 + " MB PER SECOND")
        }
    }
    return P5 = {
        normalizeInput: e,
        toHex: t,
        debugPrint: s,
        testSpeed: i
    },
    P5
}
var j5, cR;
function Rpe() {
    if (cR)
        return j5;
    cR = 1;
    const n = z$();
    function e(S, N, _) {
        const I = S[N] + S[_];
        let k = S[N + 1] + S[_ + 1];
        I >= 4294967296 && k++,
        S[N] = I,
        S[N + 1] = k
    }
    function t(S, N, _, I) {
        let k = S[N] + _;
        _ < 0 && (k += 4294967296);
        let B = S[N + 1] + I;
        k >= 4294967296 && B++,
        S[N] = k,
        S[N + 1] = B
    }
    function r(S, N) {
        return S[N] ^ S[N + 1] << 8 ^ S[N + 2] << 16 ^ S[N + 3] << 24
    }
    function s(S, N, _, I, k, B) {
        const P = u[k]
          , M = u[k + 1]
          , R = u[B]
          , L = u[B + 1];
        e(l, S, N),
        t(l, S, P, M);
        let q = l[I] ^ l[S]
          , H = l[I + 1] ^ l[S + 1];
        l[I] = H,
        l[I + 1] = q,
        e(l, _, I),
        q = l[N] ^ l[_],
        H = l[N + 1] ^ l[_ + 1],
        l[N] = q >>> 24 ^ H << 8,
        l[N + 1] = H >>> 24 ^ q << 8,
        e(l, S, N),
        t(l, S, R, L),
        q = l[I] ^ l[S],
        H = l[I + 1] ^ l[S + 1],
        l[I] = q >>> 16 ^ H << 16,
        l[I + 1] = H >>> 16 ^ q << 16,
        e(l, _, I),
        q = l[N] ^ l[_],
        H = l[N + 1] ^ l[_ + 1],
        l[N] = H >>> 31 ^ q << 1,
        l[N + 1] = q >>> 31 ^ H << 1
    }
    const i = new Uint32Array([4089235720, 1779033703, 2227873595, 3144134277, 4271175723, 1013904242, 1595750129, 2773480762, 2917565137, 1359893119, 725511199, 2600822924, 4215389547, 528734635, 327033209, 1541459225])
      , o = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3]
      , a = new Uint8Array(o.map(function(S) {
        return S * 2
    }))
      , l = new Uint32Array(32)
      , u = new Uint32Array(32);
    function d(S, N) {
        let _ = 0;
        for (_ = 0; _ < 16; _++)
            l[_] = S.h[_],
            l[_ + 16] = i[_];
        for (l[24] = l[24] ^ S.t,
        l[25] = l[25] ^ S.t / 4294967296,
        N && (l[28] = ~l[28],
        l[29] = ~l[29]),
        _ = 0; _ < 32; _++)
            u[_] = r(S.b, 4 * _);
        for (_ = 0; _ < 12; _++)
            s(0, 8, 16, 24, a[_ * 16 + 0], a[_ * 16 + 1]),
            s(2, 10, 18, 26, a[_ * 16 + 2], a[_ * 16 + 3]),
            s(4, 12, 20, 28, a[_ * 16 + 4], a[_ * 16 + 5]),
            s(6, 14, 22, 30, a[_ * 16 + 6], a[_ * 16 + 7]),
            s(0, 10, 20, 30, a[_ * 16 + 8], a[_ * 16 + 9]),
            s(2, 12, 22, 24, a[_ * 16 + 10], a[_ * 16 + 11]),
            s(4, 14, 16, 26, a[_ * 16 + 12], a[_ * 16 + 13]),
            s(6, 8, 18, 28, a[_ * 16 + 14], a[_ * 16 + 15]);
        for (_ = 0; _ < 16; _++)
            S.h[_] = S.h[_] ^ l[_] ^ l[_ + 16]
    }
    const h = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
    function p(S, N, _, I) {
        if (S === 0 || S > 64)
            throw new Error("Illegal output length, expected 0 < length <= 64");
        if (N && N.length > 64)
            throw new Error("Illegal key, expected Uint8Array with 0 < length <= 64");
        if (_ && _.length !== 16)
            throw new Error("Illegal salt, expected Uint8Array with length is 16");
        if (I && I.length !== 16)
            throw new Error("Illegal personal, expected Uint8Array with length is 16");
        const k = {
            b: new Uint8Array(128),
            h: new Uint32Array(16),
            t: 0,
            c: 0,
            outlen: S
        };
        h.fill(0),
        h[0] = S,
        N && (h[1] = N.length),
        h[2] = 1,
        h[3] = 1,
        _ && h.set(_, 32),
        I && h.set(I, 48);
        for (let B = 0; B < 16; B++)
            k.h[B] = i[B] ^ r(h, B * 4);
        return N && (g(k, N),
        k.c = 128),
        k
    }
    function g(S, N) {
        for (let _ = 0; _ < N.length; _++)
            S.c === 128 && (S.t += S.c,
            d(S, !1),
            S.c = 0),
            S.b[S.c++] = N[_]
    }
    function w(S) {
        for (S.t += S.c; S.c < 128; )
            S.b[S.c++] = 0;
        d(S, !0);
        const N = new Uint8Array(S.outlen);
        for (let _ = 0; _ < S.outlen; _++)
            N[_] = S.h[_ >> 2] >> 8 * (_ & 3);
        return N
    }
    function b(S, N, _, I, k) {
        _ = _ || 64,
        S = n.normalizeInput(S),
        I && (I = n.normalizeInput(I)),
        k && (k = n.normalizeInput(k));
        const B = p(_, N, I, k);
        return g(B, S),
        w(B)
    }
    function v(S, N, _, I, k) {
        const B = b(S, N, _, I, k);
        return n.toHex(B)
    }
    return j5 = {
        blake2b: b,
        blake2bHex: v,
        blake2bInit: p,
        blake2bUpdate: g,
        blake2bFinal: w
    },
    j5
}
var L5, uR;
function Ope() {
    if (uR)
        return L5;
    uR = 1;
    const n = z$();
    function e(w, b) {
        return w[b] ^ w[b + 1] << 8 ^ w[b + 2] << 16 ^ w[b + 3] << 24
    }
    function t(w, b, v, S, N, _) {
        o[w] = o[w] + o[b] + N,
        o[S] = r(o[S] ^ o[w], 16),
        o[v] = o[v] + o[S],
        o[b] = r(o[b] ^ o[v], 12),
        o[w] = o[w] + o[b] + _,
        o[S] = r(o[S] ^ o[w], 8),
        o[v] = o[v] + o[S],
        o[b] = r(o[b] ^ o[v], 7)
    }
    function r(w, b) {
        return w >>> b ^ w << 32 - b
    }
    const s = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225])
      , i = new Uint8Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0])
      , o = new Uint32Array(16)
      , a = new Uint32Array(16);
    function l(w, b) {
        let v = 0;
        for (v = 0; v < 8; v++)
            o[v] = w.h[v],
            o[v + 8] = s[v];
        for (o[12] ^= w.t,
        o[13] ^= w.t / 4294967296,
        b && (o[14] = ~o[14]),
        v = 0; v < 16; v++)
            a[v] = e(w.b, 4 * v);
        for (v = 0; v < 10; v++)
            t(0, 4, 8, 12, a[i[v * 16 + 0]], a[i[v * 16 + 1]]),
            t(1, 5, 9, 13, a[i[v * 16 + 2]], a[i[v * 16 + 3]]),
            t(2, 6, 10, 14, a[i[v * 16 + 4]], a[i[v * 16 + 5]]),
            t(3, 7, 11, 15, a[i[v * 16 + 6]], a[i[v * 16 + 7]]),
            t(0, 5, 10, 15, a[i[v * 16 + 8]], a[i[v * 16 + 9]]),
            t(1, 6, 11, 12, a[i[v * 16 + 10]], a[i[v * 16 + 11]]),
            t(2, 7, 8, 13, a[i[v * 16 + 12]], a[i[v * 16 + 13]]),
            t(3, 4, 9, 14, a[i[v * 16 + 14]], a[i[v * 16 + 15]]);
        for (v = 0; v < 8; v++)
            w.h[v] ^= o[v] ^ o[v + 8]
    }
    function u(w, b) {
        if (!(w > 0 && w <= 32))
            throw new Error("Incorrect output length, should be in [1, 32]");
        const v = b ? b.length : 0;
        if (b && !(v > 0 && v <= 32))
            throw new Error("Incorrect key length, should be in [1, 32]");
        const S = {
            h: new Uint32Array(s),
            b: new Uint8Array(64),
            c: 0,
            t: 0,
            outlen: w
        };
        return S.h[0] ^= 16842752 ^ v << 8 ^ w,
        v > 0 && (d(S, b),
        S.c = 64),
        S
    }
    function d(w, b) {
        for (let v = 0; v < b.length; v++)
            w.c === 64 && (w.t += w.c,
            l(w, !1),
            w.c = 0),
            w.b[w.c++] = b[v]
    }
    function h(w) {
        for (w.t += w.c; w.c < 64; )
            w.b[w.c++] = 0;
        l(w, !0);
        const b = new Uint8Array(w.outlen);
        for (let v = 0; v < w.outlen; v++)
            b[v] = w.h[v >> 2] >> 8 * (v & 3) & 255;
        return b
    }
    function p(w, b, v) {
        v = v || 32,
        w = n.normalizeInput(w);
        const S = u(v, b);
        return d(S, w),
        h(S)
    }
    function g(w, b, v) {
        const S = p(w, b, v);
        return n.toHex(S)
    }
    return L5 = {
        blake2s: p,
        blake2sHex: g,
        blake2sInit: u,
        blake2sUpdate: d,
        blake2sFinal: h
    },
    L5
}
var F5, dR;
function Ppe() {
    if (dR)
        return F5;
    dR = 1;
    const n = Rpe()
      , e = Ope();
    return F5 = {
        blake2b: n.blake2b,
        blake2bHex: n.blake2bHex,
        blake2bInit: n.blake2bInit,
        blake2bUpdate: n.blake2bUpdate,
        blake2bFinal: n.blake2bFinal,
        blake2s: e.blake2s,
        blake2sHex: e.blake2sHex,
        blake2sInit: e.blake2sInit,
        blake2sUpdate: e.blake2sUpdate,
        blake2sFinal: e.blake2sFinal
    },
    F5
}
var jpe = Ppe(), qm = {
    exports: {}
}, U5, fR;
function Lpe() {
    if (fR)
        return U5;
    fR = 1;
    function n(t) {
        try {
            return JSON.stringify(t)
        } catch {
            return '"[Circular]"'
        }
    }
    U5 = e;
    function e(t, r, s) {
        var i = s && s.stringify || n
          , o = 1;
        if (typeof t == "object" && t !== null) {
            var a = r.length + o;
            if (a === 1)
                return t;
            var l = new Array(a);
            l[0] = i(t);
            for (var u = 1; u < a; u++)
                l[u] = i(r[u]);
            return l.join(" ")
        }
        if (typeof t != "string")
            return t;
        var d = r.length;
        if (d === 0)
            return t;
        for (var h = "", p = 1 - o, g = -1, w = t && t.length || 0, b = 0; b < w; ) {
            if (t.charCodeAt(b) === 37 && b + 1 < w) {
                switch (g = g > -1 ? g : 0,
                t.charCodeAt(b + 1)) {
                case 100:
                case 102:
                    if (p >= d || r[p] == null)
                        break;
                    g < b && (h += t.slice(g, b)),
                    h += Number(r[p]),
                    g = b + 2,
                    b++;
                    break;
                case 105:
                    if (p >= d || r[p] == null)
                        break;
                    g < b && (h += t.slice(g, b)),
                    h += Math.floor(Number(r[p])),
                    g = b + 2,
                    b++;
                    break;
                case 79:
                case 111:
                case 106:
                    if (p >= d || r[p] === void 0)
                        break;
                    g < b && (h += t.slice(g, b));
                    var v = typeof r[p];
                    if (v === "string") {
                        h += "'" + r[p] + "'",
                        g = b + 2,
                        b++;
                        break
                    }
                    if (v === "function") {
                        h += r[p].name || "<anonymous>",
                        g = b + 2,
                        b++;
                        break
                    }
                    h += i(r[p]),
                    g = b + 2,
                    b++;
                    break;
                case 115:
                    if (p >= d)
                        break;
                    g < b && (h += t.slice(g, b)),
                    h += String(r[p]),
                    g = b + 2,
                    b++;
                    break;
                case 37:
                    g < b && (h += t.slice(g, b)),
                    h += "%",
                    g = b + 2,
                    b++,
                    p--;
                    break
                }
                ++p
            }
            ++b
        }
        return g === -1 ? t : (g < w && (h += t.slice(g)),
        h)
    }
    return U5
}
var hR;
function Fpe() {
    if (hR)
        return qm.exports;
    hR = 1;
    const n = Lpe();
    qm.exports = d;
    const e = A().console || {}
      , t = {
        mapHttpRequest: P,
        mapHttpResponse: P,
        wrapRequestSerializer: M,
        wrapResponseSerializer: M,
        wrapErrorSerializer: M,
        req: P,
        res: P,
        err: k,
        errWithCause: k
    };
    function r(E, C) {
        return E === "silent" ? 1 / 0 : C.levels.values[E]
    }
    const s = Symbol("pino.logFuncs")
      , i = Symbol("pino.hierarchy")
      , o = {
        error: "log",
        fatal: "error",
        warn: "error",
        info: "log",
        debug: "log",
        trace: "log"
    };
    function a(E, C) {
        const O = {
            logger: C,
            parent: E[i]
        };
        C[i] = O
    }
    function l(E, C, O) {
        const z = {};
        C.forEach(G => {
            z[G] = O[G] ? O[G] : e[G] || e[o[G] || "log"] || R
        }
        ),
        E[s] = z
    }
    function u(E, C) {
        return Array.isArray(E) ? E.filter(function(z) {
            return z !== "!stdSerializers.err"
        }) : E === !0 ? Object.keys(C) : !1
    }
    function d(E) {
        E = E || {},
        E.browser = E.browser || {};
        const C = E.browser.transmit;
        if (C && typeof C.send != "function")
            throw Error("pino: transmit option must have a send function");
        const O = E.browser.write || e;
        E.browser.write && (E.browser.asObject = !0);
        const z = E.serializers || {}
          , G = u(E.browser.serialize, z);
        let Y = E.browser.serialize;
        Array.isArray(E.browser.serialize) && E.browser.serialize.indexOf("!stdSerializers.err") > -1 && (Y = !1);
        const $ = Object.keys(E.customLevels || {})
          , D = ["error", "fatal", "warn", "info", "debug", "trace"].concat($);
        typeof O == "function" && D.forEach(function(xe) {
            O[xe] = O
        }),
        (E.enabled === !1 || E.browser.disabled) && (E.level = "silent");
        const U = E.level || "info"
          , W = Object.create(O);
        W.log || (W.log = R),
        l(W, D, O),
        a({}, W),
        Object.defineProperty(W, "levelVal", {
            get: J
        }),
        Object.defineProperty(W, "level", {
            get: ne,
            set: ie
        });
        const Q = {
            transmit: C,
            serialize: G,
            asObject: E.browser.asObject,
            asObjectBindingsOnly: E.browser.asObjectBindingsOnly,
            formatters: E.browser.formatters,
            levels: D,
            timestamp: B(E),
            messageKey: E.messageKey || "msg",
            onChild: E.onChild || R
        };
        W.levels = h(E),
        W.level = U,
        W.isLevelEnabled = function(xe) {
            return this.levels.values[xe] ? this.levels.values[xe] >= this.levels.values[this.level] : !1
        }
        ,
        W.setMaxListeners = W.getMaxListeners = W.emit = W.addListener = W.on = W.prependListener = W.once = W.prependOnceListener = W.removeListener = W.removeAllListeners = W.listeners = W.listenerCount = W.eventNames = W.write = W.flush = R,
        W.serializers = z,
        W._serialize = G,
        W._stdErrSerialize = Y,
        W.child = function(...xe) {
            return ae.call(this, Q, ...xe)
        }
        ,
        C && (W._logEvent = I());
        function J() {
            return r(this.level, this)
        }
        function ne() {
            return this._level
        }
        function ie(xe) {
            if (xe !== "silent" && !this.levels.values[xe])
                throw Error("unknown level " + xe);
            this._level = xe,
            w(this, Q, W, "error"),
            w(this, Q, W, "fatal"),
            w(this, Q, W, "warn"),
            w(this, Q, W, "info"),
            w(this, Q, W, "debug"),
            w(this, Q, W, "trace"),
            $.forEach(ue => {
                w(this, Q, W, ue)
            }
            )
        }
        function ae(xe, ue, ce) {
            if (!ue)
                throw new Error("missing bindings for child Pino");
            ce = ce || {},
            G && ue.serializers && (ce.serializers = ue.serializers);
            const me = ce.serializers;
            if (G && me) {
                var Ee = Object.assign({}, z, me)
                  , Oe = E.browser.serialize === !0 ? Object.keys(Ee) : G;
                delete ue.serializers,
                N([ue], Oe, Ee, this._stdErrSerialize)
            }
            function mt(ot) {
                this._childLevel = (ot._childLevel | 0) + 1,
                this.bindings = ue,
                Ee && (this.serializers = Ee,
                this._serialize = Oe),
                C && (this._logEvent = I([].concat(ot._logEvent.bindings, ue)))
            }
            mt.prototype = this;
            const st = new mt(this);
            return a(this, st),
            st.child = function(...ot) {
                return ae.call(this, xe, ...ot)
            }
            ,
            st.level = ce.level || this.level,
            xe.onChild(st),
            st
        }
        return W
    }
    function h(E) {
        const C = E.customLevels || {}
          , O = Object.assign({}, d.levels.values, C)
          , z = Object.assign({}, d.levels.labels, p(C));
        return {
            values: O,
            labels: z
        }
    }
    function p(E) {
        const C = {};
        return Object.keys(E).forEach(function(O) {
            C[E[O]] = O
        }),
        C
    }
    d.levels = {
        values: {
            fatal: 60,
            error: 50,
            warn: 40,
            info: 30,
            debug: 20,
            trace: 10
        },
        labels: {
            10: "trace",
            20: "debug",
            30: "info",
            40: "warn",
            50: "error",
            60: "fatal"
        }
    },
    d.stdSerializers = t,
    d.stdTimeFunctions = Object.assign({}, {
        nullTime: L,
        epochTime: q,
        unixTime: H,
        isoTime: j
    });
    function g(E) {
        const C = [];
        E.bindings && C.push(E.bindings);
        let O = E[i];
        for (; O.parent; )
            O = O.parent,
            O.logger.bindings && C.push(O.logger.bindings);
        return C.reverse()
    }
    function w(E, C, O, z) {
        if (Object.defineProperty(E, z, {
            value: r(E.level, O) > r(z, O) ? R : O[s][z],
            writable: !0,
            enumerable: !0,
            configurable: !0
        }),
        E[z] === R) {
            if (!C.transmit)
                return;
            const Y = C.transmit.level || E.level
              , $ = r(Y, O);
            if (r(z, O) < $)
                return
        }
        E[z] = v(E, C, O, z);
        const G = g(E);
        G.length !== 0 && (E[z] = b(G, E[z]))
    }
    function b(E, C) {
        return function() {
            return C.apply(this, [...E, ...arguments])
        }
    }
    function v(E, C, O, z) {
        return (function(G) {
            return function() {
                const $ = C.timestamp()
                  , D = new Array(arguments.length)
                  , U = Object.getPrototypeOf && Object.getPrototypeOf(this) === e ? e : this;
                for (var W = 0; W < D.length; W++)
                    D[W] = arguments[W];
                var Q = !1;
                if (C.serialize && (N(D, this._serialize, this.serializers, this._stdErrSerialize),
                Q = !0),
                C.asObject || C.formatters ? G.call(U, ...S(this, z, D, $, C)) : G.apply(U, D),
                C.transmit) {
                    const J = C.transmit.level || E._level
                      , ne = r(J, O)
                      , ie = r(z, O);
                    if (ie < ne)
                        return;
                    _(this, {
                        ts: $,
                        methodLevel: z,
                        methodValue: ie,
                        transmitValue: O.levels.values[C.transmit.level || E._level],
                        send: C.transmit.send,
                        val: r(E._level, O)
                    }, D, Q)
                }
            }
        }
        )(E[s][z])
    }
    function S(E, C, O, z, G) {
        const {level: Y, log: $=J => J} = G.formatters || {}
          , D = O.slice();
        let U = D[0];
        const W = {};
        let Q = (E._childLevel | 0) + 1;
        if (Q < 1 && (Q = 1),
        z && (W.time = z),
        Y) {
            const J = Y(C, E.levels.values[C]);
            Object.assign(W, J)
        } else
            W.level = E.levels.values[C];
        if (G.asObjectBindingsOnly) {
            if (U !== null && typeof U == "object")
                for (; Q-- && typeof D[0] == "object"; )
                    Object.assign(W, D.shift());
            return [$(W), ...D]
        } else {
            if (U !== null && typeof U == "object") {
                for (; Q-- && typeof D[0] == "object"; )
                    Object.assign(W, D.shift());
                U = D.length ? n(D.shift(), D) : void 0
            } else
                typeof U == "string" && (U = n(D.shift(), D));
            return U !== void 0 && (W[G.messageKey] = U),
            [$(W)]
        }
    }
    function N(E, C, O, z) {
        for (const G in E)
            if (z && E[G]instanceof Error)
                E[G] = d.stdSerializers.err(E[G]);
            else if (typeof E[G] == "object" && !Array.isArray(E[G]) && C)
                for (const Y in E[G])
                    C.indexOf(Y) > -1 && Y in O && (E[G][Y] = O[Y](E[G][Y]))
    }
    function _(E, C, O, z=!1) {
        const G = C.send
          , Y = C.ts
          , $ = C.methodLevel
          , D = C.methodValue
          , U = C.val
          , W = E._logEvent.bindings;
        z || N(O, E._serialize || Object.keys(E.serializers), E.serializers, E._stdErrSerialize === void 0 ? !0 : E._stdErrSerialize),
        E._logEvent.ts = Y,
        E._logEvent.messages = O.filter(function(Q) {
            return W.indexOf(Q) === -1
        }),
        E._logEvent.level.label = $,
        E._logEvent.level.value = D,
        G($, E._logEvent, U),
        E._logEvent = I(W)
    }
    function I(E) {
        return {
            ts: 0,
            messages: [],
            bindings: E || [],
            level: {
                label: "",
                value: 0
            }
        }
    }
    function k(E) {
        const C = {
            type: E.constructor.name,
            msg: E.message,
            stack: E.stack
        };
        for (const O in E)
            C[O] === void 0 && (C[O] = E[O]);
        return C
    }
    function B(E) {
        return typeof E.timestamp == "function" ? E.timestamp : E.timestamp === !1 ? L : q
    }
    function P() {
        return {}
    }
    function M(E) {
        return E
    }
    function R() {}
    function L() {
        return !1
    }
    function q() {
        return Date.now()
    }
    function H() {
        return Math.round(Date.now() / 1e3)
    }
    function j() {
        return new Date(Date.now()).toISOString()
    }
    function A() {
        function E(C) {
            return typeof C < "u" && C
        }
        try {
            return typeof globalThis < "u" || Object.defineProperty(Object.prototype, "globalThis", {
                get: function() {
                    return delete Object.prototype.globalThis,
                    this.globalThis = this
                },
                configurable: !0
            }),
            globalThis
        } catch {
            return E(self) || E(window) || E(this) || {}
        }
    }
    return qm.exports.default = d,
    qm.exports.pino = d,
    qm.exports
}
var cp = Fpe();
const $$ = Fo(cp)
  , Upe = {
    level: "info"
}
  , dx = "custom_context"
  , R_ = 1e3 * 1024;
var zpe = Object.defineProperty
  , $pe = (n, e, t) => e in n ? zpe(n, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : n[e] = t
  , Ru = (n, e, t) => $pe(n, typeof e != "symbol" ? e + "" : e, t);
let Hpe = class {
    constructor(e) {
        Ru(this, "nodeValue"),
        Ru(this, "sizeInBytes"),
        Ru(this, "next"),
        this.nodeValue = e,
        this.sizeInBytes = new TextEncoder().encode(this.nodeValue).length,
        this.next = null
    }
    get value() {
        return this.nodeValue
    }
    get size() {
        return this.sizeInBytes
    }
}
  , pR = class {
    constructor(e) {
        Ru(this, "lengthInNodes"),
        Ru(this, "sizeInBytes"),
        Ru(this, "head"),
        Ru(this, "tail"),
        Ru(this, "maxSizeInBytes"),
        this.head = null,
        this.tail = null,
        this.lengthInNodes = 0,
        this.maxSizeInBytes = e,
        this.sizeInBytes = 0
    }
    append(e) {
        const t = new Hpe(e);
        if (t.size > this.maxSizeInBytes)
            throw new Error(`[LinkedList] Value too big to insert into list: ${e} with size ${t.size}`);
        for (; this.size + t.size > this.maxSizeInBytes; )
            this.shift();
        this.head ? (this.tail && (this.tail.next = t),
        this.tail = t) : (this.head = t,
        this.tail = t),
        this.lengthInNodes++,
        this.sizeInBytes += t.size
    }
    shift() {
        if (!this.head)
            return;
        const e = this.head;
        this.head = this.head.next,
        this.head || (this.tail = null),
        this.lengthInNodes--,
        this.sizeInBytes -= e.size
    }
    toArray() {
        const e = [];
        let t = this.head;
        for (; t !== null; )
            e.push(t.value),
            t = t.next;
        return e
    }
    get length() {
        return this.lengthInNodes
    }
    get size() {
        return this.sizeInBytes
    }
    toOrderedArray() {
        return Array.from(this)
    }
    [Symbol.iterator]() {
        let e = this.head;
        return {
            next: () => {
                if (!e)
                    return {
                        done: !0,
                        value: null
                    };
                const t = e.value;
                return e = e.next,
                {
                    done: !1,
                    value: t
                }
            }
        }
    }
}
;
var Vpe = Object.defineProperty
  , qpe = (n, e, t) => e in n ? Vpe(n, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : n[e] = t
  , V1 = (n, e, t) => qpe(n, typeof e != "symbol" ? e + "" : e, t);
let H$ = class {
    constructor(e, t=R_) {
        V1(this, "logs"),
        V1(this, "level"),
        V1(this, "levelValue"),
        V1(this, "MAX_LOG_SIZE_IN_BYTES"),
        this.level = e ?? "error",
        this.levelValue = cp.levels.values[this.level],
        this.MAX_LOG_SIZE_IN_BYTES = t,
        this.logs = new pR(this.MAX_LOG_SIZE_IN_BYTES)
    }
    forwardToConsole(e, t) {
        t === cp.levels.values.error ? console.error(e) : t === cp.levels.values.warn ? console.warn(e) : t === cp.levels.values.debug ? console.debug(e) : t === cp.levels.values.trace ? console.trace(e) : console.log(e)
    }
    appendToLogs(e) {
        this.logs.append(Tc({
            timestamp: new Date().toISOString(),
            log: e
        }));
        const t = typeof e == "string" ? JSON.parse(e).level : e.level;
        t >= this.levelValue && this.forwardToConsole(e, t)
    }
    getLogs() {
        return this.logs
    }
    clearLogs() {
        this.logs = new pR(this.MAX_LOG_SIZE_IN_BYTES)
    }
    getLogArray() {
        return Array.from(this.logs)
    }
    logsToBlob(e) {
        const t = this.getLogArray();
        return t.push(Tc({
            extraMetadata: e
        })),
        new Blob(t,{
            type: "application/json"
        })
    }
}
;
var Gpe = Object.defineProperty
  , Wpe = (n, e, t) => e in n ? Gpe(n, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : n[e] = t
  , Ype = (n, e, t) => Wpe(n, e + "", t);
let Kpe = class {
    constructor(e, t=R_) {
        Ype(this, "baseChunkLogger"),
        this.baseChunkLogger = new H$(e,t)
    }
    write(e) {
        this.baseChunkLogger.appendToLogs(e)
    }
    getLogs() {
        return this.baseChunkLogger.getLogs()
    }
    clearLogs() {
        this.baseChunkLogger.clearLogs()
    }
    getLogArray() {
        return this.baseChunkLogger.getLogArray()
    }
    logsToBlob(e) {
        return this.baseChunkLogger.logsToBlob(e)
    }
    downloadLogsBlobInBrowser(e) {
        const t = URL.createObjectURL(this.logsToBlob(e))
          , r = document.createElement("a");
        r.href = t,
        r.download = `walletconnect-logs-${new Date().toISOString()}.txt`,
        document.body.appendChild(r),
        r.click(),
        document.body.removeChild(r),
        URL.revokeObjectURL(t)
    }
}
;
var Xpe = Object.defineProperty
  , Qpe = (n, e, t) => e in n ? Xpe(n, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : n[e] = t
  , Zpe = (n, e, t) => Qpe(n, e + "", t);
let Jpe = class {
    constructor(e, t=R_) {
        Zpe(this, "baseChunkLogger"),
        this.baseChunkLogger = new H$(e,t)
    }
    write(e) {
        this.baseChunkLogger.appendToLogs(e)
    }
    getLogs() {
        return this.baseChunkLogger.getLogs()
    }
    clearLogs() {
        this.baseChunkLogger.clearLogs()
    }
    getLogArray() {
        return this.baseChunkLogger.getLogArray()
    }
    logsToBlob(e) {
        return this.baseChunkLogger.logsToBlob(e)
    }
}
;
var e0e = Object.defineProperty
  , t0e = Object.defineProperties
  , n0e = Object.getOwnPropertyDescriptors
  , mR = Object.getOwnPropertySymbols
  , r0e = Object.prototype.hasOwnProperty
  , s0e = Object.prototype.propertyIsEnumerable
  , gR = (n, e, t) => e in n ? e0e(n, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : n[e] = t
  , F2 = (n, e) => {
    for (var t in e || (e = {}))
        r0e.call(e, t) && gR(n, t, e[t]);
    if (mR)
        for (var t of mR(e))
            s0e.call(e, t) && gR(n, t, e[t]);
    return n
}
  , U2 = (n, e) => t0e(n, n0e(e));
function i0e(n) {
    return U2(F2({}, n), {
        level: n?.level || Upe.level
    })
}
function o0e(n, e, t=dx) {
    return n[t] = e,
    n
}
function Ii(n, e=dx) {
    return n[e] || ""
}
function a0e(n, e, t=dx) {
    const r = Ii(n, t);
    return r.trim() ? `${r}/${e}` : e
}
function ro(n, e, t=dx) {
    const r = a0e(n, e, t)
      , s = n.child({
        context: r
    });
    return o0e(s, r, t)
}
function l0e(n) {
    var e, t;
    const r = new Kpe((e = n.opts) == null ? void 0 : e.level,n.maxSizeInBytes);
    return {
        logger: $$(U2(F2({}, n.opts), {
            level: "trace",
            browser: U2(F2({}, (t = n.opts) == null ? void 0 : t.browser), {
                write: s => r.write(s)
            })
        })),
        chunkLoggerController: r
    }
}
function c0e(n) {
    var e;
    const t = new Jpe((e = n.opts) == null ? void 0 : e.level,n.maxSizeInBytes);
    return {
        logger: $$(U2(F2({}, n.opts), {
            level: "trace"
        }), t),
        chunkLoggerController: t
    }
}
function V$(n) {
    return typeof n.loggerOverride < "u" && typeof n.loggerOverride != "string" ? {
        logger: n.loggerOverride,
        chunkLoggerController: null
    } : typeof window < "u" ? l0e(n) : c0e(n)
}
var u0e = {};
const d0e = ":";
function gc(n) {
    const [e,t] = n.split(d0e);
    return {
        namespace: e,
        reference: t
    }
}
function yR(n, e=[]) {
    const t = [];
    return Object.keys(n).forEach(r => {
        if (e.length && !e.includes(r))
            return;
        const s = n[r];
        t.push(...s.accounts)
    }
    ),
    t
}
function q$(n, e) {
    return n.includes(":") ? [n] : e.chains || []
}
var f0e = Object.defineProperty
  , h0e = Object.defineProperties
  , p0e = Object.getOwnPropertyDescriptors
  , bR = Object.getOwnPropertySymbols
  , m0e = Object.prototype.hasOwnProperty
  , g0e = Object.prototype.propertyIsEnumerable
  , sC = (n, e, t) => e in n ? f0e(n, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : n[e] = t
  , wR = (n, e) => {
    for (var t in e || (e = {}))
        m0e.call(e, t) && sC(n, t, e[t]);
    if (bR)
        for (var t of bR(e))
            g0e.call(e, t) && sC(n, t, e[t]);
    return n
}
  , y0e = (n, e) => h0e(n, p0e(e))
  , vR = (n, e, t) => sC(n, typeof e != "symbol" ? e + "" : e, t);
const b0e = "ReactNative"
  , Zi = {
    reactNative: "react-native",
    node: "node",
    browser: "browser",
    unknown: "unknown"
}
  , w0e = "js";
function z2() {
    return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u"
}
function ld() {
    return !Dc.getDocument() && !!Dc.getNavigator() && navigator.product === b0e
}
function v0e() {
    return ld() && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u" && (global == null ? void 0 : global.Platform.OS) === "android"
}
function x0e() {
    return ld() && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u" && (global == null ? void 0 : global.Platform.OS) === "ios"
}
function I0() {
    return !z2() && !!Dc.getNavigator() && !!Dc.getDocument()
}
function Hy() {
    return ld() ? Zi.reactNative : z2() ? Zi.node : I0() ? Zi.browser : Zi.unknown
}
function xR() {
    var n;
    try {
        return ld() && typeof global < "u" && typeof (global == null ? void 0 : global.Application) < "u" ? (n = global.Application) == null ? void 0 : n.applicationId : void 0
    } catch {
        return
    }
}
function E0e(n, e) {
    const t = new URLSearchParams(n);
    return Object.entries(e).sort( ([r], [s]) => r.localeCompare(s)).forEach( ([r,s]) => {
        s != null && t.set(r, String(s))
    }
    ),
    t.toString()
}
function S0e(n) {
    var e, t;
    const r = G$();
    try {
        return n != null && n.url && r.url && new URL(n.url).host !== new URL(r.url).host && (console.warn(`The configured WalletConnect 'metadata.url':${n.url} differs from the actual page url:${r.url}. This is probably unintended and can lead to issues.`),
        n.url = r.url),
        (e = n?.icons) != null && e.length && n.icons.length > 0 && (n.icons = n.icons.filter(s => s !== "")),
        y0e(wR(wR({}, r), n), {
            url: n?.url || r.url,
            name: n?.name || r.name,
            description: n?.description || r.description,
            icons: (t = n?.icons) != null && t.length && n.icons.length > 0 ? n.icons : r.icons
        })
    } catch (s) {
        return console.warn("Error populating app metadata", s),
        n || r
    }
}
function G$() {
    return Mle.getWindowMetadata() || {
        name: "",
        description: "",
        url: "",
        icons: [""]
    }
}
function A0e() {
    if (Hy() === Zi.reactNative && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u") {
        const {OS: t, Version: r} = global.Platform;
        return [t, r].join("-")
    }
    const n = Xae();
    if (n === null)
        return "unknown";
    const e = n.os ? n.os.replace(" ", "").toLowerCase() : "unknown";
    return n.type === "browser" ? [e, n.name, n.version].join("-") : [e, n.version].join("-")
}
function C0e() {
    var n;
    const e = Hy();
    return e === Zi.browser ? [e, ((n = Dc.getLocation()) == null ? void 0 : n.host) || "unknown"].join(":") : e
}
function W$(n, e, t) {
    const r = A0e()
      , s = C0e();
    return [[n, e].join("-"), [w0e, t].join("-"), r, s].join("/")
}
function _0e({protocol: n, version: e, relayUrl: t, sdkVersion: r, auth: s, projectId: i, useOnCloseEvent: o, bundleId: a, packageName: l}) {
    const u = t.split("?")
      , d = W$(n, e, r)
      , h = {
        auth: s,
        ua: d,
        projectId: i,
        useOnCloseEvent: o,
        packageName: l || void 0,
        bundleId: a || void 0
    }
      , p = E0e(u[1] || "", h);
    return u[0] + "?" + p
}
function df(n, e) {
    return n.filter(t => e.includes(t)).length === n.length
}
function iC(n) {
    return Object.fromEntries(n.entries())
}
function oC(n) {
    return new Map(Object.entries(n))
}
function $d(n=je.FIVE_MINUTES, e) {
    const t = je.toMiliseconds(n || je.FIVE_MINUTES);
    let r, s, i, o;
    return {
        resolve: a => {
            i && r && (clearTimeout(i),
            r(a),
            o = Promise.resolve(a))
        }
        ,
        reject: a => {
            i && s && (clearTimeout(i),
            s(a))
        }
        ,
        done: () => new Promise( (a, l) => {
            if (o)
                return a(o);
            i = setTimeout( () => {
                const u = new Error(e);
                o = Promise.reject(u),
                l(u)
            }
            , t),
            r = a,
            s = l
        }
        )
    }
}
function Wa(n, e, t) {
    return new Promise(async (r, s) => {
        const i = setTimeout( () => s(new Error(t)), e);
        try {
            const o = await n;
            r(o)
        } catch (o) {
            s(o)
        }
        clearTimeout(i)
    }
    )
}
function Y$(n, e) {
    if (typeof e == "string" && e.startsWith(`${n}:`))
        return e;
    if (n.toLowerCase() === "topic") {
        if (typeof e != "string")
            throw new Error('Value must be "string" for expirer target type: topic');
        return `topic:${e}`
    } else if (n.toLowerCase() === "id") {
        if (typeof e != "number")
            throw new Error('Value must be "number" for expirer target type: id');
        return `id:${e}`
    }
    throw new Error(`Unknown expirer target type: ${n}`)
}
function k0e(n) {
    return Y$("topic", n)
}
function N0e(n) {
    return Y$("id", n)
}
function K$(n) {
    const [e,t] = n.split(":")
      , r = {
        id: void 0,
        topic: void 0
    };
    if (e === "topic" && typeof t == "string")
        r.topic = t;
    else if (e === "id" && Number.isInteger(Number(t)))
        r.id = Number(t);
    else
        throw new Error(`Invalid target, expected id:number or topic:string, got ${e}:${t}`);
    return r
}
function Br(n, e) {
    return je.fromMiliseconds(Date.now() + je.toMiliseconds(n))
}
function Ua(n) {
    return Date.now() >= je.toMiliseconds(n)
}
function An(n, e) {
    return `${n}${e ? `:${e}` : ""}`
}
function Qa(n=[], e=[]) {
    return [...new Set([...n, ...e])]
}
async function D0e({id: n, topic: e, wcDeepLink: t}) {
    var r;
    try {
        if (!t)
            return;
        const s = typeof t == "string" ? JSON.parse(t) : t
          , i = s?.href;
        if (typeof i != "string")
            return;
        const o = T0e(i, n, e)
          , a = Hy();
        if (a === Zi.browser) {
            if (!((r = Dc.getDocument()) != null && r.hasFocus())) {
                console.warn("Document does not have focus, skipping deeplink.");
                return
            }
            I0e(o)
        } else
            a === Zi.reactNative && typeof (global == null ? void 0 : global.Linking) < "u" && await global.Linking.openURL(o)
    } catch (s) {
        console.error(s)
    }
}
function T0e(n, e, t) {
    const r = `requestId=${e}&sessionTopic=${t}`;
    n.endsWith("/") && (n = n.slice(0, -1));
    let s = `${n}`;
    if (n.startsWith("https://t.me")) {
        const i = n.includes("?") ? "&startapp=" : "?startapp=";
        s = `${s}${i}${O0e(r, !0)}`
    } else
        s = `${s}/wc?${r}`;
    return s
}
function I0e(n) {
    let e = "_self";
    R0e() ? e = "_top" : (B0e() || n.startsWith("https://") || n.startsWith("http://")) && (e = "_blank"),
    window.open(n, e, "noreferrer noopener")
}
async function M0e(n, e) {
    let t = "";
    try {
        if (I0() && (t = localStorage.getItem(e),
        t))
            return t;
        t = await n.getItem(e)
    } catch (r) {
        console.error(r)
    }
    return t
}
function ER(n, e) {
    if (!n.includes(e))
        return null;
    const t = n.split(/([&,?,=])/)
      , r = t.indexOf(e);
    return t[r + 2]
}
function SR() {
    return typeof crypto < "u" && crypto != null && crypto.randomUUID ? crypto.randomUUID() : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, n => {
        const e = Math.random() * 16 | 0;
        return (n === "x" ? e : e & 3 | 8).toString(16)
    }
    )
}
function O_() {
    return typeof process < "u" && u0e.IS_VITEST === "true"
}
function B0e() {
    return typeof window < "u" && (!!window.TelegramWebviewProxy || !!window.Telegram || !!window.TelegramWebviewProxyProto)
}
function R0e() {
    try {
        return window.self !== window.top
    } catch {
        return !1
    }
}
function O0e(n, e=!1) {
    const t = Buffer.from(n).toString("base64");
    return e ? t.replace(/[=]/g, "") : t
}
function X$(n) {
    return Buffer.from(n, "base64").toString("utf-8")
}
function P0e(n) {
    return new Promise(e => setTimeout(e, n))
}
let j0e = class {
    constructor({limit: e}) {
        vR(this, "limit"),
        vR(this, "set"),
        this.limit = e,
        this.set = new Set
    }
    add(e) {
        if (!this.set.has(e)) {
            if (this.set.size >= this.limit) {
                const t = this.set.values().next().value;
                t && this.set.delete(t)
            }
            this.set.add(e)
        }
    }
    has(e) {
        return this.set.has(e)
    }
}
;
const q1 = BigInt(2 ** 32 - 1)
  , AR = BigInt(32);
function Q$(n, e=!1) {
    return e ? {
        h: Number(n & q1),
        l: Number(n >> AR & q1)
    } : {
        h: Number(n >> AR & q1) | 0,
        l: Number(n & q1) | 0
    }
}
function Z$(n, e=!1) {
    const t = n.length;
    let r = new Uint32Array(t)
      , s = new Uint32Array(t);
    for (let i = 0; i < t; i++) {
        const {h: o, l: a} = Q$(n[i], e);
        [r[i],s[i]] = [o, a]
    }
    return [r, s]
}
const CR = (n, e, t) => n >>> t
  , _R = (n, e, t) => n << 32 - t | e >>> t
  , Iu = (n, e, t) => n >>> t | e << 32 - t
  , Mu = (n, e, t) => n << 32 - t | e >>> t
  , bg = (n, e, t) => n << 64 - t | e >>> t - 32
  , wg = (n, e, t) => n >>> t - 32 | e << 64 - t
  , L0e = (n, e) => e
  , F0e = (n, e) => n
  , U0e = (n, e, t) => n << t | e >>> 32 - t
  , z0e = (n, e, t) => e << t | n >>> 32 - t
  , $0e = (n, e, t) => e << t - 32 | n >>> 64 - t
  , H0e = (n, e, t) => n << t - 32 | e >>> 64 - t;
function Zo(n, e, t, r) {
    const s = (e >>> 0) + (r >>> 0);
    return {
        h: n + t + (s / 2 ** 32 | 0) | 0,
        l: s | 0
    }
}
const P_ = (n, e, t) => (n >>> 0) + (e >>> 0) + (t >>> 0)
  , j_ = (n, e, t, r) => e + t + r + (n / 2 ** 32 | 0) | 0
  , V0e = (n, e, t, r) => (n >>> 0) + (e >>> 0) + (t >>> 0) + (r >>> 0)
  , q0e = (n, e, t, r, s) => e + t + r + s + (n / 2 ** 32 | 0) | 0
  , G0e = (n, e, t, r, s) => (n >>> 0) + (e >>> 0) + (t >>> 0) + (r >>> 0) + (s >>> 0)
  , W0e = (n, e, t, r, s, i) => e + t + r + s + i + (n / 2 ** 32 | 0) | 0
  , Xh = typeof globalThis == "object" && "crypto"in globalThis ? globalThis.crypto : void 0;
function fx(n) {
    return n instanceof Uint8Array || ArrayBuffer.isView(n) && n.constructor.name === "Uint8Array"
}
function Ic(n) {
    if (!Number.isSafeInteger(n) || n < 0)
        throw new Error("positive integer expected, got " + n)
}
function fa(n, ...e) {
    if (!fx(n))
        throw new Error("Uint8Array expected");
    if (e.length > 0 && !e.includes(n.length))
        throw new Error("Uint8Array expected of length " + e + ", got length=" + n.length)
}
function hx(n) {
    if (typeof n != "function" || typeof n.create != "function")
        throw new Error("Hash should be wrapped by utils.createHasher");
    Ic(n.outputLen),
    Ic(n.blockLen)
}
function ed(n, e=!0) {
    if (n.destroyed)
        throw new Error("Hash instance has been destroyed");
    if (e && n.finished)
        throw new Error("Hash#digest() has already been called")
}
function L_(n, e) {
    fa(n);
    const t = e.outputLen;
    if (n.length < t)
        throw new Error("digestInto() expects output buffer of length at least " + t)
}
function ny(n) {
    return new Uint32Array(n.buffer,n.byteOffset,Math.floor(n.byteLength / 4))
}
function jo(...n) {
    for (let e = 0; e < n.length; e++)
        n[e].fill(0)
}
function z5(n) {
    return new DataView(n.buffer,n.byteOffset,n.byteLength)
}
function Da(n, e) {
    return n << 32 - e | n >>> e
}
const J$ = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function eH(n) {
    return n << 24 & 4278190080 | n << 8 & 16711680 | n >>> 8 & 65280 | n >>> 24 & 255
}
const Hl = J$ ? n => n : n => eH(n);
function Y0e(n) {
    for (let e = 0; e < n.length; e++)
        n[e] = eH(n[e]);
    return n
}
const Bu = J$ ? n => n : Y0e
  , tH = typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function"
  , K0e = Array.from({
    length: 256
}, (n, e) => e.toString(16).padStart(2, "0"));
function Mp(n) {
    if (fa(n),
    tH)
        return n.toHex();
    let e = "";
    for (let t = 0; t < n.length; t++)
        e += K0e[n[t]];
    return e
}
const Ol = {
    _0: 48,
    _9: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102
};
function kR(n) {
    if (n >= Ol._0 && n <= Ol._9)
        return n - Ol._0;
    if (n >= Ol.A && n <= Ol.F)
        return n - (Ol.A - 10);
    if (n >= Ol.a && n <= Ol.f)
        return n - (Ol.a - 10)
}
function $2(n) {
    if (typeof n != "string")
        throw new Error("hex string expected, got " + typeof n);
    if (tH)
        return Uint8Array.fromHex(n);
    const e = n.length
      , t = e / 2;
    if (e % 2)
        throw new Error("hex string expected, got unpadded hex of length " + e);
    const r = new Uint8Array(t);
    for (let s = 0, i = 0; s < t; s++,
    i += 2) {
        const o = kR(n.charCodeAt(i))
          , a = kR(n.charCodeAt(i + 1));
        if (o === void 0 || a === void 0) {
            const l = n[i] + n[i + 1];
            throw new Error('hex string expected, got non-hex character "' + l + '" at index ' + i)
        }
        r[s] = o * 16 + a
    }
    return r
}
function nH(n) {
    if (typeof n != "string")
        throw new Error("string expected");
    return new Uint8Array(new TextEncoder().encode(n))
}
function la(n) {
    return typeof n == "string" && (n = nH(n)),
    fa(n),
    n
}
function Ou(...n) {
    let e = 0;
    for (let r = 0; r < n.length; r++) {
        const s = n[r];
        fa(s),
        e += s.length
    }
    const t = new Uint8Array(e);
    for (let r = 0, s = 0; r < n.length; r++) {
        const i = n[r];
        t.set(i, s),
        s += i.length
    }
    return t
}
let px = class {
}
;
function Vy(n) {
    const e = r => n().update(la(r)).digest()
      , t = n();
    return e.outputLen = t.outputLen,
    e.blockLen = t.blockLen,
    e.create = () => n(),
    e
}
function X0e(n) {
    const e = (r, s) => n(s).update(la(r)).digest()
      , t = n({});
    return e.outputLen = t.outputLen,
    e.blockLen = t.blockLen,
    e.create = r => n(r),
    e
}
function Kf(n=32) {
    if (Xh && typeof Xh.getRandomValues == "function")
        return Xh.getRandomValues(new Uint8Array(n));
    if (Xh && typeof Xh.randomBytes == "function")
        return Uint8Array.from(Xh.randomBytes(n));
    throw new Error("crypto.getRandomValues must be defined")
}
const Q0e = BigInt(0)
  , Gm = BigInt(1)
  , Z0e = BigInt(2)
  , J0e = BigInt(7)
  , eme = BigInt(256)
  , tme = BigInt(113)
  , rH = []
  , sH = []
  , iH = [];
for (let n = 0, e = Gm, t = 1, r = 0; n < 24; n++) {
    [t,r] = [r, (2 * t + 3 * r) % 5],
    rH.push(2 * (5 * r + t)),
    sH.push((n + 1) * (n + 2) / 2 % 64);
    let s = Q0e;
    for (let i = 0; i < 7; i++)
        e = (e << Gm ^ (e >> J0e) * tme) % eme,
        e & Z0e && (s ^= Gm << (Gm << BigInt(i)) - Gm);
    iH.push(s)
}
const oH = Z$(iH, !0)
  , nme = oH[0]
  , rme = oH[1]
  , NR = (n, e, t) => t > 32 ? $0e(n, e, t) : U0e(n, e, t)
  , DR = (n, e, t) => t > 32 ? H0e(n, e, t) : z0e(n, e, t);
function sme(n, e=24) {
    const t = new Uint32Array(10);
    for (let r = 24 - e; r < 24; r++) {
        for (let o = 0; o < 10; o++)
            t[o] = n[o] ^ n[o + 10] ^ n[o + 20] ^ n[o + 30] ^ n[o + 40];
        for (let o = 0; o < 10; o += 2) {
            const a = (o + 8) % 10
              , l = (o + 2) % 10
              , u = t[l]
              , d = t[l + 1]
              , h = NR(u, d, 1) ^ t[a]
              , p = DR(u, d, 1) ^ t[a + 1];
            for (let g = 0; g < 50; g += 10)
                n[o + g] ^= h,
                n[o + g + 1] ^= p
        }
        let s = n[2]
          , i = n[3];
        for (let o = 0; o < 24; o++) {
            const a = sH[o]
              , l = NR(s, i, a)
              , u = DR(s, i, a)
              , d = rH[o];
            s = n[d],
            i = n[d + 1],
            n[d] = l,
            n[d + 1] = u
        }
        for (let o = 0; o < 50; o += 10) {
            for (let a = 0; a < 10; a++)
                t[a] = n[o + a];
            for (let a = 0; a < 10; a++)
                n[o + a] ^= ~t[(a + 2) % 10] & t[(a + 4) % 10]
        }
        n[0] ^= nme[r],
        n[1] ^= rme[r]
    }
    jo(t)
}
let ime = class aH extends px {
    constructor(e, t, r, s=!1, i=24) {
        if (super(),
        this.pos = 0,
        this.posOut = 0,
        this.finished = !1,
        this.destroyed = !1,
        this.enableXOF = !1,
        this.blockLen = e,
        this.suffix = t,
        this.outputLen = r,
        this.enableXOF = s,
        this.rounds = i,
        Ic(r),
        !(0 < e && e < 200))
            throw new Error("only keccak-f1600 function is supported");
        this.state = new Uint8Array(200),
        this.state32 = ny(this.state)
    }
    clone() {
        return this._cloneInto()
    }
    keccak() {
        Bu(this.state32),
        sme(this.state32, this.rounds),
        Bu(this.state32),
        this.posOut = 0,
        this.pos = 0
    }
    update(e) {
        ed(this),
        e = la(e),
        fa(e);
        const {blockLen: t, state: r} = this
          , s = e.length;
        for (let i = 0; i < s; ) {
            const o = Math.min(t - this.pos, s - i);
            for (let a = 0; a < o; a++)
                r[this.pos++] ^= e[i++];
            this.pos === t && this.keccak()
        }
        return this
    }
    finish() {
        if (this.finished)
            return;
        this.finished = !0;
        const {state: e, suffix: t, pos: r, blockLen: s} = this;
        e[r] ^= t,
        (t & 128) !== 0 && r === s - 1 && this.keccak(),
        e[s - 1] ^= 128,
        this.keccak()
    }
    writeInto(e) {
        ed(this, !1),
        fa(e),
        this.finish();
        const t = this.state
          , {blockLen: r} = this;
        for (let s = 0, i = e.length; s < i; ) {
            this.posOut >= r && this.keccak();
            const o = Math.min(r - this.posOut, i - s);
            e.set(t.subarray(this.posOut, this.posOut + o), s),
            this.posOut += o,
            s += o
        }
        return e
    }
    xofInto(e) {
        if (!this.enableXOF)
            throw new Error("XOF is not possible for this instance");
        return this.writeInto(e)
    }
    xof(e) {
        return Ic(e),
        this.xofInto(new Uint8Array(e))
    }
    digestInto(e) {
        if (L_(e, this),
        this.finished)
            throw new Error("digest() was already called");
        return this.writeInto(e),
        this.destroy(),
        e
    }
    digest() {
        return this.digestInto(new Uint8Array(this.outputLen))
    }
    destroy() {
        this.destroyed = !0,
        jo(this.state)
    }
    _cloneInto(e) {
        const {blockLen: t, suffix: r, outputLen: s, rounds: i, enableXOF: o} = this;
        return e || (e = new aH(t,r,s,o,i)),
        e.state32.set(this.state32),
        e.pos = this.pos,
        e.posOut = this.posOut,
        e.finished = this.finished,
        e.rounds = i,
        e.suffix = r,
        e.outputLen = s,
        e.enableXOF = o,
        e.destroyed = this.destroyed,
        e
    }
}
;
const ome = (n, e, t) => Vy( () => new ime(e,n,t))
  , ame = ome(1, 136, 256 / 8);
function lme(n, e, t, r) {
    if (typeof n.setBigUint64 == "function")
        return n.setBigUint64(e, t, r);
    const s = BigInt(32)
      , i = BigInt(4294967295)
      , o = Number(t >> s & i)
      , a = Number(t & i)
      , l = r ? 4 : 0
      , u = r ? 0 : 4;
    n.setUint32(e + l, o, r),
    n.setUint32(e + u, a, r)
}
function cme(n, e, t) {
    return n & e ^ ~n & t
}
function ume(n, e, t) {
    return n & e ^ n & t ^ e & t
}
let lH = class extends px {
    constructor(e, t, r, s) {
        super(),
        this.finished = !1,
        this.length = 0,
        this.pos = 0,
        this.destroyed = !1,
        this.blockLen = e,
        this.outputLen = t,
        this.padOffset = r,
        this.isLE = s,
        this.buffer = new Uint8Array(e),
        this.view = z5(this.buffer)
    }
    update(e) {
        ed(this),
        e = la(e),
        fa(e);
        const {view: t, buffer: r, blockLen: s} = this
          , i = e.length;
        for (let o = 0; o < i; ) {
            const a = Math.min(s - this.pos, i - o);
            if (a === s) {
                const l = z5(e);
                for (; s <= i - o; o += s)
                    this.process(l, o);
                continue
            }
            r.set(e.subarray(o, o + a), this.pos),
            this.pos += a,
            o += a,
            this.pos === s && (this.process(t, 0),
            this.pos = 0)
        }
        return this.length += e.length,
        this.roundClean(),
        this
    }
    digestInto(e) {
        ed(this),
        L_(e, this),
        this.finished = !0;
        const {buffer: t, view: r, blockLen: s, isLE: i} = this;
        let {pos: o} = this;
        t[o++] = 128,
        jo(this.buffer.subarray(o)),
        this.padOffset > s - o && (this.process(r, 0),
        o = 0);
        for (let h = o; h < s; h++)
            t[h] = 0;
        lme(r, s - 8, BigInt(this.length * 8), i),
        this.process(r, 0);
        const a = z5(e)
          , l = this.outputLen;
        if (l % 4)
            throw new Error("_sha2: outputLen should be aligned to 32bit");
        const u = l / 4
          , d = this.get();
        if (u > d.length)
            throw new Error("_sha2: outputLen bigger than state");
        for (let h = 0; h < u; h++)
            a.setUint32(4 * h, d[h], i)
    }
    digest() {
        const {buffer: e, outputLen: t} = this;
        this.digestInto(e);
        const r = e.slice(0, t);
        return this.destroy(),
        r
    }
    _cloneInto(e) {
        e || (e = new this.constructor),
        e.set(...this.get());
        const {blockLen: t, buffer: r, length: s, finished: i, destroyed: o, pos: a} = this;
        return e.destroyed = o,
        e.finished = i,
        e.length = s,
        e.pos = a,
        s % t && e.buffer.set(r),
        e
    }
    clone() {
        return this._cloneInto()
    }
}
;
const Eu = Uint32Array.from([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225])
  , Bs = Uint32Array.from([3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428])
  , Rs = Uint32Array.from([1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209])
  , dme = Uint32Array.from([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298])
  , Su = new Uint32Array(64);
class fme extends lH {
    constructor(e=32) {
        super(64, e, 8, !1),
        this.A = Eu[0] | 0,
        this.B = Eu[1] | 0,
        this.C = Eu[2] | 0,
        this.D = Eu[3] | 0,
        this.E = Eu[4] | 0,
        this.F = Eu[5] | 0,
        this.G = Eu[6] | 0,
        this.H = Eu[7] | 0
    }
    get() {
        const {A: e, B: t, C: r, D: s, E: i, F: o, G: a, H: l} = this;
        return [e, t, r, s, i, o, a, l]
    }
    set(e, t, r, s, i, o, a, l) {
        this.A = e | 0,
        this.B = t | 0,
        this.C = r | 0,
        this.D = s | 0,
        this.E = i | 0,
        this.F = o | 0,
        this.G = a | 0,
        this.H = l | 0
    }
    process(e, t) {
        for (let h = 0; h < 16; h++,
        t += 4)
            Su[h] = e.getUint32(t, !1);
        for (let h = 16; h < 64; h++) {
            const p = Su[h - 15]
              , g = Su[h - 2]
              , w = Da(p, 7) ^ Da(p, 18) ^ p >>> 3
              , b = Da(g, 17) ^ Da(g, 19) ^ g >>> 10;
            Su[h] = b + Su[h - 7] + w + Su[h - 16] | 0
        }
        let {A: r, B: s, C: i, D: o, E: a, F: l, G: u, H: d} = this;
        for (let h = 0; h < 64; h++) {
            const p = Da(a, 6) ^ Da(a, 11) ^ Da(a, 25)
              , g = d + p + cme(a, l, u) + dme[h] + Su[h] | 0
              , w = (Da(r, 2) ^ Da(r, 13) ^ Da(r, 22)) + ume(r, s, i) | 0;
            d = u,
            u = l,
            l = a,
            a = o + g | 0,
            o = i,
            i = s,
            s = r,
            r = g + w | 0
        }
        r = r + this.A | 0,
        s = s + this.B | 0,
        i = i + this.C | 0,
        o = o + this.D | 0,
        a = a + this.E | 0,
        l = l + this.F | 0,
        u = u + this.G | 0,
        d = d + this.H | 0,
        this.set(r, s, i, o, a, l, u, d)
    }
    roundClean() {
        jo(Su)
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0),
        jo(this.buffer)
    }
}
const cH = Z$(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map(n => BigInt(n)))
  , hme = cH[0]
  , pme = cH[1]
  , Au = new Uint32Array(80)
  , Cu = new Uint32Array(80);
let F_ = class extends lH {
    constructor(e=64) {
        super(128, e, 16, !1),
        this.Ah = Rs[0] | 0,
        this.Al = Rs[1] | 0,
        this.Bh = Rs[2] | 0,
        this.Bl = Rs[3] | 0,
        this.Ch = Rs[4] | 0,
        this.Cl = Rs[5] | 0,
        this.Dh = Rs[6] | 0,
        this.Dl = Rs[7] | 0,
        this.Eh = Rs[8] | 0,
        this.El = Rs[9] | 0,
        this.Fh = Rs[10] | 0,
        this.Fl = Rs[11] | 0,
        this.Gh = Rs[12] | 0,
        this.Gl = Rs[13] | 0,
        this.Hh = Rs[14] | 0,
        this.Hl = Rs[15] | 0
    }
    get() {
        const {Ah: e, Al: t, Bh: r, Bl: s, Ch: i, Cl: o, Dh: a, Dl: l, Eh: u, El: d, Fh: h, Fl: p, Gh: g, Gl: w, Hh: b, Hl: v} = this;
        return [e, t, r, s, i, o, a, l, u, d, h, p, g, w, b, v]
    }
    set(e, t, r, s, i, o, a, l, u, d, h, p, g, w, b, v) {
        this.Ah = e | 0,
        this.Al = t | 0,
        this.Bh = r | 0,
        this.Bl = s | 0,
        this.Ch = i | 0,
        this.Cl = o | 0,
        this.Dh = a | 0,
        this.Dl = l | 0,
        this.Eh = u | 0,
        this.El = d | 0,
        this.Fh = h | 0,
        this.Fl = p | 0,
        this.Gh = g | 0,
        this.Gl = w | 0,
        this.Hh = b | 0,
        this.Hl = v | 0
    }
    process(e, t) {
        for (let _ = 0; _ < 16; _++,
        t += 4)
            Au[_] = e.getUint32(t),
            Cu[_] = e.getUint32(t += 4);
        for (let _ = 16; _ < 80; _++) {
            const I = Au[_ - 15] | 0
              , k = Cu[_ - 15] | 0
              , B = Iu(I, k, 1) ^ Iu(I, k, 8) ^ CR(I, k, 7)
              , P = Mu(I, k, 1) ^ Mu(I, k, 8) ^ _R(I, k, 7)
              , M = Au[_ - 2] | 0
              , R = Cu[_ - 2] | 0
              , L = Iu(M, R, 19) ^ bg(M, R, 61) ^ CR(M, R, 6)
              , q = Mu(M, R, 19) ^ wg(M, R, 61) ^ _R(M, R, 6)
              , H = V0e(P, q, Cu[_ - 7], Cu[_ - 16])
              , j = q0e(H, B, L, Au[_ - 7], Au[_ - 16]);
            Au[_] = j | 0,
            Cu[_] = H | 0
        }
        let {Ah: r, Al: s, Bh: i, Bl: o, Ch: a, Cl: l, Dh: u, Dl: d, Eh: h, El: p, Fh: g, Fl: w, Gh: b, Gl: v, Hh: S, Hl: N} = this;
        for (let _ = 0; _ < 80; _++) {
            const I = Iu(h, p, 14) ^ Iu(h, p, 18) ^ bg(h, p, 41)
              , k = Mu(h, p, 14) ^ Mu(h, p, 18) ^ wg(h, p, 41)
              , B = h & g ^ ~h & b
              , P = p & w ^ ~p & v
              , M = G0e(N, k, P, pme[_], Cu[_])
              , R = W0e(M, S, I, B, hme[_], Au[_])
              , L = M | 0
              , q = Iu(r, s, 28) ^ bg(r, s, 34) ^ bg(r, s, 39)
              , H = Mu(r, s, 28) ^ wg(r, s, 34) ^ wg(r, s, 39)
              , j = r & i ^ r & a ^ i & a
              , A = s & o ^ s & l ^ o & l;
            S = b | 0,
            N = v | 0,
            b = g | 0,
            v = w | 0,
            g = h | 0,
            w = p | 0,
            {h, l: p} = Zo(u | 0, d | 0, R | 0, L | 0),
            u = a | 0,
            d = l | 0,
            a = i | 0,
            l = o | 0,
            i = r | 0,
            o = s | 0;
            const E = P_(L, H, A);
            r = j_(E, R, q, j),
            s = E | 0
        }
        ({h: r, l: s} = Zo(this.Ah | 0, this.Al | 0, r | 0, s | 0)),
        {h: i, l: o} = Zo(this.Bh | 0, this.Bl | 0, i | 0, o | 0),
        {h: a, l} = Zo(this.Ch | 0, this.Cl | 0, a | 0, l | 0),
        {h: u, l: d} = Zo(this.Dh | 0, this.Dl | 0, u | 0, d | 0),
        {h, l: p} = Zo(this.Eh | 0, this.El | 0, h | 0, p | 0),
        {h: g, l: w} = Zo(this.Fh | 0, this.Fl | 0, g | 0, w | 0),
        {h: b, l: v} = Zo(this.Gh | 0, this.Gl | 0, b | 0, v | 0),
        {h: S, l: N} = Zo(this.Hh | 0, this.Hl | 0, S | 0, N | 0),
        this.set(r, s, i, o, a, l, u, d, h, p, g, w, b, v, S, N)
    }
    roundClean() {
        jo(Au, Cu)
    }
    destroy() {
        jo(this.buffer),
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
    }
}
;
class mme extends F_ {
    constructor() {
        super(48),
        this.Ah = Bs[0] | 0,
        this.Al = Bs[1] | 0,
        this.Bh = Bs[2] | 0,
        this.Bl = Bs[3] | 0,
        this.Ch = Bs[4] | 0,
        this.Cl = Bs[5] | 0,
        this.Dh = Bs[6] | 0,
        this.Dl = Bs[7] | 0,
        this.Eh = Bs[8] | 0,
        this.El = Bs[9] | 0,
        this.Fh = Bs[10] | 0,
        this.Fl = Bs[11] | 0,
        this.Gh = Bs[12] | 0,
        this.Gl = Bs[13] | 0,
        this.Hh = Bs[14] | 0,
        this.Hl = Bs[15] | 0
    }
}
const Os = Uint32Array.from([573645204, 4230739756, 2673172387, 3360449730, 596883563, 1867755857, 2520282905, 1497426621, 2519219938, 2827943907, 3193839141, 1401305490, 721525244, 746961066, 246885852, 2177182882]);
class gme extends F_ {
    constructor() {
        super(32),
        this.Ah = Os[0] | 0,
        this.Al = Os[1] | 0,
        this.Bh = Os[2] | 0,
        this.Bl = Os[3] | 0,
        this.Ch = Os[4] | 0,
        this.Cl = Os[5] | 0,
        this.Dh = Os[6] | 0,
        this.Dl = Os[7] | 0,
        this.Eh = Os[8] | 0,
        this.El = Os[9] | 0,
        this.Fh = Os[10] | 0,
        this.Fl = Os[11] | 0,
        this.Gh = Os[12] | 0,
        this.Gl = Os[13] | 0,
        this.Hh = Os[14] | 0,
        this.Hl = Os[15] | 0
    }
}
const mx = Vy( () => new fme)
  , yme = Vy( () => new F_)
  , bme = Vy( () => new mme)
  , wme = Vy( () => new gme)
  , vme = Uint8Array.from([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9])
  , $r = Uint32Array.from([4089235720, 1779033703, 2227873595, 3144134277, 4271175723, 1013904242, 1595750129, 2773480762, 2917565137, 1359893119, 725511199, 2600822924, 4215389547, 528734635, 327033209, 1541459225])
  , We = new Uint32Array(32);
function _u(n, e, t, r, s, i) {
    const o = s[i]
      , a = s[i + 1];
    let l = We[2 * n]
      , u = We[2 * n + 1]
      , d = We[2 * e]
      , h = We[2 * e + 1]
      , p = We[2 * t]
      , g = We[2 * t + 1]
      , w = We[2 * r]
      , b = We[2 * r + 1]
      , v = P_(l, d, o);
    u = j_(v, u, h, a),
    l = v | 0,
    {Dh: b, Dl: w} = {
        Dh: b ^ u,
        Dl: w ^ l
    },
    {Dh: b, Dl: w} = {
        Dh: L0e(b, w),
        Dl: F0e(b)
    },
    {h: g, l: p} = Zo(g, p, b, w),
    {Bh: h, Bl: d} = {
        Bh: h ^ g,
        Bl: d ^ p
    },
    {Bh: h, Bl: d} = {
        Bh: Iu(h, d, 24),
        Bl: Mu(h, d, 24)
    },
    We[2 * n] = l,
    We[2 * n + 1] = u,
    We[2 * e] = d,
    We[2 * e + 1] = h,
    We[2 * t] = p,
    We[2 * t + 1] = g,
    We[2 * r] = w,
    We[2 * r + 1] = b
}
function ku(n, e, t, r, s, i) {
    const o = s[i]
      , a = s[i + 1];
    let l = We[2 * n]
      , u = We[2 * n + 1]
      , d = We[2 * e]
      , h = We[2 * e + 1]
      , p = We[2 * t]
      , g = We[2 * t + 1]
      , w = We[2 * r]
      , b = We[2 * r + 1]
      , v = P_(l, d, o);
    u = j_(v, u, h, a),
    l = v | 0,
    {Dh: b, Dl: w} = {
        Dh: b ^ u,
        Dl: w ^ l
    },
    {Dh: b, Dl: w} = {
        Dh: Iu(b, w, 16),
        Dl: Mu(b, w, 16)
    },
    {h: g, l: p} = Zo(g, p, b, w),
    {Bh: h, Bl: d} = {
        Bh: h ^ g,
        Bl: d ^ p
    },
    {Bh: h, Bl: d} = {
        Bh: bg(h, d, 63),
        Bl: wg(h, d, 63)
    },
    We[2 * n] = l,
    We[2 * n + 1] = u,
    We[2 * e] = d,
    We[2 * e + 1] = h,
    We[2 * t] = p,
    We[2 * t + 1] = g,
    We[2 * r] = w,
    We[2 * r + 1] = b
}
function xme(n, e={}, t, r, s) {
    if (Ic(t),
    n < 0 || n > t)
        throw new Error("outputLen bigger than keyLen");
    const {key: i, salt: o, personalization: a} = e;
    if (i !== void 0 && (i.length < 1 || i.length > t))
        throw new Error("key length must be undefined or 1.." + t);
    if (o !== void 0 && o.length !== r)
        throw new Error("salt must be undefined or " + r);
    if (a !== void 0 && a.length !== s)
        throw new Error("personalization must be undefined or " + s)
}
class Eme extends px {
    constructor(e, t) {
        super(),
        this.finished = !1,
        this.destroyed = !1,
        this.length = 0,
        this.pos = 0,
        Ic(e),
        Ic(t),
        this.blockLen = e,
        this.outputLen = t,
        this.buffer = new Uint8Array(e),
        this.buffer32 = ny(this.buffer)
    }
    update(e) {
        ed(this),
        e = la(e),
        fa(e);
        const {blockLen: t, buffer: r, buffer32: s} = this
          , i = e.length
          , o = e.byteOffset
          , a = e.buffer;
        for (let l = 0; l < i; ) {
            this.pos === t && (Bu(s),
            this.compress(s, 0, !1),
            Bu(s),
            this.pos = 0);
            const u = Math.min(t - this.pos, i - l)
              , d = o + l;
            if (u === t && !(d % 4) && l + u < i) {
                const h = new Uint32Array(a,d,Math.floor((i - l) / 4));
                Bu(h);
                for (let p = 0; l + t < i; p += s.length,
                l += t)
                    this.length += t,
                    this.compress(h, p, !1);
                Bu(h);
                continue
            }
            r.set(e.subarray(l, l + u), this.pos),
            this.pos += u,
            this.length += u,
            l += u
        }
        return this
    }
    digestInto(e) {
        ed(this),
        L_(e, this);
        const {pos: t, buffer32: r} = this;
        this.finished = !0,
        jo(this.buffer.subarray(t)),
        Bu(r),
        this.compress(r, 0, !0),
        Bu(r);
        const s = ny(e);
        this.get().forEach( (i, o) => s[o] = Hl(i))
    }
    digest() {
        const {buffer: e, outputLen: t} = this;
        this.digestInto(e);
        const r = e.slice(0, t);
        return this.destroy(),
        r
    }
    _cloneInto(e) {
        const {buffer: t, length: r, finished: s, destroyed: i, outputLen: o, pos: a} = this;
        return e || (e = new this.constructor({
            dkLen: o
        })),
        e.set(...this.get()),
        e.buffer.set(t),
        e.destroyed = i,
        e.finished = s,
        e.length = r,
        e.pos = a,
        e.outputLen = o,
        e
    }
    clone() {
        return this._cloneInto()
    }
}
class Sme extends Eme {
    constructor(e={}) {
        const t = e.dkLen === void 0 ? 64 : e.dkLen;
        super(128, t),
        this.v0l = $r[0] | 0,
        this.v0h = $r[1] | 0,
        this.v1l = $r[2] | 0,
        this.v1h = $r[3] | 0,
        this.v2l = $r[4] | 0,
        this.v2h = $r[5] | 0,
        this.v3l = $r[6] | 0,
        this.v3h = $r[7] | 0,
        this.v4l = $r[8] | 0,
        this.v4h = $r[9] | 0,
        this.v5l = $r[10] | 0,
        this.v5h = $r[11] | 0,
        this.v6l = $r[12] | 0,
        this.v6h = $r[13] | 0,
        this.v7l = $r[14] | 0,
        this.v7h = $r[15] | 0,
        xme(t, e, 64, 16, 16);
        let {key: r, personalization: s, salt: i} = e
          , o = 0;
        if (r !== void 0 && (r = la(r),
        o = r.length),
        this.v0l ^= this.outputLen | o << 8 | 65536 | 1 << 24,
        i !== void 0) {
            i = la(i);
            const a = ny(i);
            this.v4l ^= Hl(a[0]),
            this.v4h ^= Hl(a[1]),
            this.v5l ^= Hl(a[2]),
            this.v5h ^= Hl(a[3])
        }
        if (s !== void 0) {
            s = la(s);
            const a = ny(s);
            this.v6l ^= Hl(a[0]),
            this.v6h ^= Hl(a[1]),
            this.v7l ^= Hl(a[2]),
            this.v7h ^= Hl(a[3])
        }
        if (r !== void 0) {
            const a = new Uint8Array(this.blockLen);
            a.set(r),
            this.update(a)
        }
    }
    get() {
        let {v0l: e, v0h: t, v1l: r, v1h: s, v2l: i, v2h: o, v3l: a, v3h: l, v4l: u, v4h: d, v5l: h, v5h: p, v6l: g, v6h: w, v7l: b, v7h: v} = this;
        return [e, t, r, s, i, o, a, l, u, d, h, p, g, w, b, v]
    }
    set(e, t, r, s, i, o, a, l, u, d, h, p, g, w, b, v) {
        this.v0l = e | 0,
        this.v0h = t | 0,
        this.v1l = r | 0,
        this.v1h = s | 0,
        this.v2l = i | 0,
        this.v2h = o | 0,
        this.v3l = a | 0,
        this.v3h = l | 0,
        this.v4l = u | 0,
        this.v4h = d | 0,
        this.v5l = h | 0,
        this.v5h = p | 0,
        this.v6l = g | 0,
        this.v6h = w | 0,
        this.v7l = b | 0,
        this.v7h = v | 0
    }
    compress(e, t, r) {
        this.get().forEach( (l, u) => We[u] = l),
        We.set($r, 16);
        let {h: s, l: i} = Q$(BigInt(this.length));
        We[24] = $r[8] ^ i,
        We[25] = $r[9] ^ s,
        r && (We[28] = ~We[28],
        We[29] = ~We[29]);
        let o = 0;
        const a = vme;
        for (let l = 0; l < 12; l++)
            _u(0, 4, 8, 12, e, t + 2 * a[o++]),
            ku(0, 4, 8, 12, e, t + 2 * a[o++]),
            _u(1, 5, 9, 13, e, t + 2 * a[o++]),
            ku(1, 5, 9, 13, e, t + 2 * a[o++]),
            _u(2, 6, 10, 14, e, t + 2 * a[o++]),
            ku(2, 6, 10, 14, e, t + 2 * a[o++]),
            _u(3, 7, 11, 15, e, t + 2 * a[o++]),
            ku(3, 7, 11, 15, e, t + 2 * a[o++]),
            _u(0, 5, 10, 15, e, t + 2 * a[o++]),
            ku(0, 5, 10, 15, e, t + 2 * a[o++]),
            _u(1, 6, 11, 12, e, t + 2 * a[o++]),
            ku(1, 6, 11, 12, e, t + 2 * a[o++]),
            _u(2, 7, 8, 13, e, t + 2 * a[o++]),
            ku(2, 7, 8, 13, e, t + 2 * a[o++]),
            _u(3, 4, 9, 14, e, t + 2 * a[o++]),
            ku(3, 4, 9, 14, e, t + 2 * a[o++]);
        this.v0l ^= We[0] ^ We[16],
        this.v0h ^= We[1] ^ We[17],
        this.v1l ^= We[2] ^ We[18],
        this.v1h ^= We[3] ^ We[19],
        this.v2l ^= We[4] ^ We[20],
        this.v2h ^= We[5] ^ We[21],
        this.v3l ^= We[6] ^ We[22],
        this.v3h ^= We[7] ^ We[23],
        this.v4l ^= We[8] ^ We[24],
        this.v4h ^= We[9] ^ We[25],
        this.v5l ^= We[10] ^ We[26],
        this.v5h ^= We[11] ^ We[27],
        this.v6l ^= We[12] ^ We[28],
        this.v6h ^= We[13] ^ We[29],
        this.v7l ^= We[14] ^ We[30],
        this.v7h ^= We[15] ^ We[31],
        jo(We)
    }
    destroy() {
        this.destroyed = !0,
        jo(this.buffer32),
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
    }
}
const Ame = X0e(n => new Sme(n))
  , Cme = "https://rpc.walletconnect.org/v1";
function uH(n) {
    const e = `Ethereum Signed Message:
${n.length}`
      , t = new TextEncoder().encode(e + n);
    return "0x" + Buffer.from(ame(t)).toString("hex")
}
async function _me(n, e, t, r, s, i) {
    switch (t.t) {
    case "eip191":
        return await kme(n, e, t.s);
    case "eip1271":
        return await Nme(n, e, t.s, r, s, i);
    default:
        throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${t.t}`)
    }
}
function kme(n, e, t) {
    const r = Gce(t);
    return iue({
        payload: uH(e),
        signature: r
    }).toLowerCase() === n.toLowerCase()
}
async function Nme(n, e, t, r, s, i) {
    const o = gc(r);
    if (!o.namespace || !o.reference)
        throw new Error(`isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${r}`);
    try {
        const a = "0x1626ba7e"
          , l = "0000000000000000000000000000000000000000000000000000000000000040"
          , u = t.substring(2)
          , d = (u.length / 2).toString(16).padStart(64, "0")
          , h = (e.startsWith("0x") ? e : uH(e)).substring(2)
          , p = a + h + l + d + u
          , g = await fetch(`${i || Cme}/?chainId=${r}&projectId=${s}`, {
            headers: {
                "Content-Type": "application/json"
            },
            method: "POST",
            body: JSON.stringify({
                id: Dme(),
                jsonrpc: "2.0",
                method: "eth_call",
                params: [{
                    to: n,
                    data: p
                }, "latest"]
            })
        })
          , {result: w} = await g.json();
        return w ? w.slice(0, a.length).toLowerCase() === a.toLowerCase() : !1
    } catch (a) {
        return console.error("isValidEip1271Signature: ", a),
        !1
    }
}
function Dme() {
    return Date.now() + Math.floor(Math.random() * 1e3)
}
function Tme(n) {
    const e = atob(n)
      , t = new Uint8Array(e.length);
    for (let o = 0; o < e.length; o++)
        t[o] = e.charCodeAt(o);
    const r = t[0];
    if (r === 0)
        throw new Error("No signatures found");
    const s = 1 + r * 64;
    if (t.length < s)
        throw new Error("Transaction data too short for claimed signature count");
    if (t.length < 100)
        throw new Error("Transaction too short");
    const i = Buffer.from(n, "base64").slice(1, 65);
    return D0.encode(i)
}
function Ime(n) {
    const e = new Uint8Array(Buffer.from(n, "base64"))
      , t = Array.from("TransactionData::").map(i => i.charCodeAt(0))
      , r = new Uint8Array(t.length + e.length);
    r.set(t),
    r.set(e, t.length);
    const s = Ame(r, {
        dkLen: 32
    });
    return D0.encode(s)
}
function TR(n) {
    const e = new Uint8Array(mx(Mme(n)));
    return D0.encode(e)
}
function Mme(n) {
    if (n instanceof Uint8Array)
        return n;
    if (Array.isArray(n))
        return new Uint8Array(n);
    if (typeof n == "object" && n != null && n.data)
        return new Uint8Array(Object.values(n.data));
    if (typeof n == "object" && n)
        return new Uint8Array(Object.values(n));
    throw new Error("getNearUint8ArrayFromBytes: Unexpected result type from bytes array")
}
function IR(n) {
    const e = Buffer.from(n, "base64")
      , t = Vue(e).txn;
    if (!t)
        throw new Error("Invalid signed transaction: missing 'txn' field");
    const r = Oue(t)
      , s = Buffer.from("TX")
      , i = Buffer.concat([s, Buffer.from(r)])
      , o = wme(i);
    return sue.encode(o).replace(/=+$/, "")
}
function $5(n) {
    const e = [];
    let t = BigInt(n);
    for (; t >= BigInt(128); )
        e.push(Number(t & BigInt(127) | BigInt(128))),
        t >>= BigInt(7);
    return e.push(Number(t)),
    Buffer.from(e)
}
function Bme(n) {
    const e = Buffer.from(n.signed.bodyBytes, "base64")
      , t = Buffer.from(n.signed.authInfoBytes, "base64")
      , r = Buffer.from(n.signature.signature, "base64")
      , s = [];
    s.push(Buffer.from([10])),
    s.push($5(e.length)),
    s.push(e),
    s.push(Buffer.from([18])),
    s.push($5(t.length)),
    s.push(t),
    s.push(Buffer.from([26])),
    s.push($5(r.length)),
    s.push(r);
    const i = Buffer.concat(s)
      , o = mx(i);
    return Buffer.from(o).toString("hex").toUpperCase()
}
function Rme(n) {
    var e, t;
    const r = [];
    try {
        if (typeof n == "string")
            return r.push(n),
            r;
        if (typeof n != "object")
            return r;
        n != null && n.id && r.push(n.id);
        const s = (t = (e = n?.capabilities) == null ? void 0 : e.caip345) == null ? void 0 : t.transactionHashes;
        s && r.push(...s)
    } catch (s) {
        console.warn("getWalletSendCallsHashes failed: ", s)
    }
    return r
}
var Ome = Object.defineProperty
  , Pme = Object.defineProperties
  , jme = Object.getOwnPropertyDescriptors
  , MR = Object.getOwnPropertySymbols
  , Lme = Object.prototype.hasOwnProperty
  , Fme = Object.prototype.propertyIsEnumerable
  , BR = (n, e, t) => e in n ? Ome(n, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : n[e] = t
  , Ume = (n, e) => {
    for (var t in e || (e = {}))
        Lme.call(e, t) && BR(n, t, e[t]);
    if (MR)
        for (var t of MR(e))
            Fme.call(e, t) && BR(n, t, e[t]);
    return n
}
  , zme = (n, e) => Pme(n, jme(e));
const dH = "did:pkh:"
  , $me = {
    eip155: "Ethereum",
    solana: "Solana",
    bip122: "Bitcoin"
}
  , Hme = n => n ? $me[n] || n : ""
  , gx = n => n?.split(":")
  , Vme = n => {
    const e = n && gx(n);
    if (e)
        return n.includes(dH) ? e[3] : e[1]
}
  , qme = n => {
    const e = n && gx(n);
    if (e)
        return n.includes(dH) ? e[2] : e[0]
}
  , aC = n => {
    const e = n && gx(n);
    if (e)
        return e[2] + ":" + e[3]
}
  , H2 = n => {
    const e = n && gx(n);
    if (e)
        return e.pop()
}
;
async function RR(n) {
    const {cacao: e, projectId: t} = n
      , {s: r, p: s} = e
      , i = fH(s, s.iss)
      , o = H2(s.iss);
    return await _me(o, i, r, aC(s.iss), t)
}
const fH = (n, e) => {
    const t = qme(e);
    if (!t)
        throw new Error("Invalid issuer: " + e);
    const r = `${n.domain} wants you to sign in with your ${Hme(t)} account:`
      , s = H2(e);
    if (!n.aud && !n.uri)
        throw new Error("Either `aud` or `uri` is required to construct the message");
    let i = n.statement || void 0;
    const o = `URI: ${n.aud || n.uri}`
      , a = `Version: ${n.version}`
      , l = `Chain ID: ${Vme(e)}`
      , u = `Nonce: ${n.nonce}`
      , d = `Issued At: ${n.iat}`
      , h = n.exp ? `Expiration Time: ${n.exp}` : void 0
      , p = n.nbf ? `Not Before: ${n.nbf}` : void 0
      , g = n.requestId ? `Request ID: ${n.requestId}` : void 0
      , w = n.resources ? `Resources:${n.resources.map(v => `
- ${v}`).join("")}` : void 0
      , b = Vw(n.resources);
    if (b) {
        const v = ry(b);
        i = ege(i, v)
    }
    return [r, s, "", i, "", o, a, l, u, d, h, p, g, w].filter(v => v != null).join(`
`)
}
;
function Gme(n) {
    return Buffer.from(JSON.stringify(n)).toString("base64")
}
function Wme(n) {
    return JSON.parse(Buffer.from(n, "base64").toString("utf-8"))
}
function Pf(n) {
    if (!n)
        throw new Error("No recap provided, value is undefined");
    if (!n.att)
        throw new Error("No `att` property found");
    const e = Object.keys(n.att);
    if (!(e != null && e.length))
        throw new Error("No resources found in `att` property");
    e.forEach(t => {
        const r = n.att[t];
        if (Array.isArray(r))
            throw new Error(`Resource must be an object: ${t}`);
        if (typeof r != "object")
            throw new Error(`Resource must be an object: ${t}`);
        if (!Object.keys(r).length)
            throw new Error(`Resource object is empty: ${t}`);
        Object.keys(r).forEach(s => {
            const i = r[s];
            if (!Array.isArray(i))
                throw new Error(`Ability limits ${s} must be an array of objects, found: ${i}`);
            if (!i.length)
                throw new Error(`Value of ${s} is empty array, must be an array with objects`);
            i.forEach(o => {
                if (typeof o != "object")
                    throw new Error(`Ability limits (${s}) must be an array of objects, found: ${o}`)
            }
            )
        }
        )
    }
    )
}
function Yme(n, e, t, r={}) {
    return t?.sort( (s, i) => s.localeCompare(i)),
    {
        att: {
            [n]: Kme(e, t, r)
        }
    }
}
function Kme(n, e, t={}) {
    e = e?.sort( (s, i) => s.localeCompare(i));
    const r = e.map(s => ({
        [`${n}/${s}`]: [t]
    }));
    return Object.assign({}, ...r)
}
function hH(n) {
    return Pf(n),
    `urn:recap:${Gme(n).replace(/=/g, "")}`
}
function ry(n) {
    const e = Wme(n.replace("urn:recap:", ""));
    return Pf(e),
    e
}
function Xme(n, e, t) {
    const r = Yme(n, e, t);
    return hH(r)
}
function Qme(n) {
    return n && n.includes("urn:recap:")
}
function Zme(n, e) {
    const t = ry(n)
      , r = ry(e)
      , s = Jme(t, r);
    return hH(s)
}
function Jme(n, e) {
    Pf(n),
    Pf(e);
    const t = Object.keys(n.att).concat(Object.keys(e.att)).sort( (s, i) => s.localeCompare(i))
      , r = {
        att: {}
    };
    return t.forEach(s => {
        var i, o;
        Object.keys(((i = n.att) == null ? void 0 : i[s]) || {}).concat(Object.keys(((o = e.att) == null ? void 0 : o[s]) || {})).sort( (a, l) => a.localeCompare(l)).forEach(a => {
            var l, u;
            r.att[s] = zme(Ume({}, r.att[s]), {
                [a]: ((l = n.att[s]) == null ? void 0 : l[a]) || ((u = e.att[s]) == null ? void 0 : u[a])
            })
        }
        )
    }
    ),
    r
}
function ege(n="", e) {
    Pf(e);
    const t = "I further authorize the stated URI to perform the following actions on my behalf: ";
    if (n.includes(t))
        return n;
    const r = [];
    let s = 0;
    Object.keys(e.att).forEach(a => {
        const l = Object.keys(e.att[a]).map(h => ({
            ability: h.split("/")[0],
            action: h.split("/")[1]
        }));
        l.sort( (h, p) => h.action.localeCompare(p.action));
        const u = {};
        l.forEach(h => {
            u[h.ability] || (u[h.ability] = []),
            u[h.ability].push(h.action)
        }
        );
        const d = Object.keys(u).map(h => (s++,
        `(${s}) '${h}': '${u[h].join("', '")}' for '${a}'.`));
        r.push(d.join(", ").replace(".,", "."))
    }
    );
    const i = r.join(" ")
      , o = `${t}${i}`;
    return `${n ? n + " " : ""}${o}`
}
function OR(n) {
    var e;
    const t = ry(n);
    Pf(t);
    const r = (e = t.att) == null ? void 0 : e.eip155;
    return r ? Object.keys(r).map(s => s.split("/")[1]) : []
}
function PR(n) {
    const e = ry(n);
    Pf(e);
    const t = [];
    return Object.values(e.att).forEach(r => {
        Object.values(r).forEach(s => {
            var i;
            (i = s?.[0]) != null && i.chains && t.push(s[0].chains)
        }
        )
    }
    ),
    [...new Set(t.flat())]
}
function Vw(n) {
    if (!n)
        return;
    const e = n?.[n.length - 1];
    return Qme(e) ? e : void 0
}
function pH(n) {
    return n instanceof Uint8Array || ArrayBuffer.isView(n) && n.constructor.name === "Uint8Array"
}
function lC(n) {
    if (typeof n != "boolean")
        throw new Error(`boolean expected, not ${n}`)
}
function H5(n) {
    if (!Number.isSafeInteger(n) || n < 0)
        throw new Error("positive integer expected, got " + n)
}
function vi(n, ...e) {
    if (!pH(n))
        throw new Error("Uint8Array expected");
    if (e.length > 0 && !e.includes(n.length))
        throw new Error("Uint8Array expected of length " + e + ", got length=" + n.length)
}
function jR(n, e=!0) {
    if (n.destroyed)
        throw new Error("Hash instance has been destroyed");
    if (e && n.finished)
        throw new Error("Hash#digest() has already been called")
}
function tge(n, e) {
    vi(n);
    const t = e.outputLen;
    if (n.length < t)
        throw new Error("digestInto() expects output buffer of length at least " + t)
}
function qu(n) {
    return new Uint32Array(n.buffer,n.byteOffset,Math.floor(n.byteLength / 4))
}
function i0(...n) {
    for (let e = 0; e < n.length; e++)
        n[e].fill(0)
}
function nge(n) {
    return new DataView(n.buffer,n.byteOffset,n.byteLength)
}
const rge = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function sge(n) {
    if (typeof n != "string")
        throw new Error("string expected");
    return new Uint8Array(new TextEncoder().encode(n))
}
function cC(n) {
    if (typeof n == "string")
        n = sge(n);
    else if (pH(n))
        n = uC(n);
    else
        throw new Error("Uint8Array expected, got " + typeof n);
    return n
}
function ige(n, e) {
    if (e == null || typeof e != "object")
        throw new Error("options must be defined");
    return Object.assign(n, e)
}
function oge(n, e) {
    if (n.length !== e.length)
        return !1;
    let t = 0;
    for (let r = 0; r < n.length; r++)
        t |= n[r] ^ e[r];
    return t === 0
}
const age = (n, e) => {
    function t(r, ...s) {
        if (vi(r),
        !rge)
            throw new Error("Non little-endian hardware is not yet supported");
        if (n.nonceLength !== void 0) {
            const u = s[0];
            if (!u)
                throw new Error("nonce / iv required");
            n.varSizeNonce ? vi(u) : vi(u, n.nonceLength)
        }
        const i = n.tagLength;
        i && s[1] !== void 0 && vi(s[1]);
        const o = e(r, ...s)
          , a = (u, d) => {
            if (d !== void 0) {
                if (u !== 2)
                    throw new Error("cipher output not supported");
                vi(d)
            }
        }
        ;
        let l = !1;
        return {
            encrypt(u, d) {
                if (l)
                    throw new Error("cannot encrypt() twice with same key + nonce");
                return l = !0,
                vi(u),
                a(o.encrypt.length, d),
                o.encrypt(u, d)
            },
            decrypt(u, d) {
                if (vi(u),
                i && u.length < i)
                    throw new Error("invalid ciphertext length: smaller than tagLength=" + i);
                return a(o.decrypt.length, d),
                o.decrypt(u, d)
            }
        }
    }
    return Object.assign(t, n),
    t
}
;
function LR(n, e, t=!0) {
    if (e === void 0)
        return new Uint8Array(n);
    if (e.length !== n)
        throw new Error("invalid output length, expected " + n + ", got: " + e.length);
    if (t && !cge(e))
        throw new Error("invalid output, must be aligned");
    return e
}
function FR(n, e, t, r) {
    if (typeof n.setBigUint64 == "function")
        return n.setBigUint64(e, t, r);
    const s = BigInt(32)
      , i = BigInt(4294967295)
      , o = Number(t >> s & i)
      , a = Number(t & i);
    n.setUint32(e + 4, o, r),
    n.setUint32(e + 0, a, r)
}
function lge(n, e, t) {
    lC(t);
    const r = new Uint8Array(16)
      , s = nge(r);
    return FR(s, 0, BigInt(e), t),
    FR(s, 8, BigInt(n), t),
    r
}
function cge(n) {
    return n.byteOffset % 4 === 0
}
function uC(n) {
    return Uint8Array.from(n)
}
const mH = n => Uint8Array.from(n.split("").map(e => e.charCodeAt(0)))
  , uge = mH("expand 16-byte k")
  , dge = mH("expand 32-byte k")
  , fge = qu(uge)
  , hge = qu(dge);
function hn(n, e) {
    return n << e | n >>> 32 - e
}
function dC(n) {
    return n.byteOffset % 4 === 0
}
const G1 = 64
  , pge = 16
  , gH = 2 ** 32 - 1
  , UR = new Uint32Array;
function mge(n, e, t, r, s, i, o, a) {
    const l = s.length
      , u = new Uint8Array(G1)
      , d = qu(u)
      , h = dC(s) && dC(i)
      , p = h ? qu(s) : UR
      , g = h ? qu(i) : UR;
    for (let w = 0; w < l; o++) {
        if (n(e, t, r, d, o, a),
        o >= gH)
            throw new Error("arx: counter overflow");
        const b = Math.min(G1, l - w);
        if (h && b === G1) {
            const v = w / 4;
            if (w % 4 !== 0)
                throw new Error("arx: invalid block position");
            for (let S = 0, N; S < pge; S++)
                N = v + S,
                g[N] = p[N] ^ d[S];
            w += G1;
            continue
        }
        for (let v = 0, S; v < b; v++)
            S = w + v,
            i[S] = s[S] ^ u[v];
        w += b
    }
}
function gge(n, e) {
    const {allowShortKeys: t, extendNonceFn: r, counterLength: s, counterRight: i, rounds: o} = ige({
        allowShortKeys: !1,
        counterLength: 8,
        counterRight: !1,
        rounds: 20
    }, e);
    if (typeof n != "function")
        throw new Error("core must be a function");
    return H5(s),
    H5(o),
    lC(i),
    lC(t),
    (a, l, u, d, h=0) => {
        vi(a),
        vi(l),
        vi(u);
        const p = u.length;
        if (d === void 0 && (d = new Uint8Array(p)),
        vi(d),
        H5(h),
        h < 0 || h >= gH)
            throw new Error("arx: counter overflow");
        if (d.length < p)
            throw new Error(`arx: output (${d.length}) is shorter than data (${p})`);
        const g = [];
        let w = a.length, b, v;
        if (w === 32)
            g.push(b = uC(a)),
            v = hge;
        else if (w === 16 && t)
            b = new Uint8Array(32),
            b.set(a),
            b.set(a, 16),
            v = fge,
            g.push(b);
        else
            throw new Error(`arx: invalid 32-byte key, got length=${w}`);
        dC(l) || g.push(l = uC(l));
        const S = qu(b);
        if (r) {
            if (l.length !== 24)
                throw new Error("arx: extended nonce must be 24 bytes");
            r(v, S, qu(l.subarray(0, 16)), S),
            l = l.subarray(16)
        }
        const N = 16 - s;
        if (N !== l.length)
            throw new Error(`arx: nonce must be ${N} or 16 bytes`);
        if (N !== 12) {
            const I = new Uint8Array(12);
            I.set(l, i ? 0 : 12 - l.length),
            l = I,
            g.push(l)
        }
        const _ = qu(l);
        return mge(n, v, S, _, u, d, h, o),
        i0(...g),
        d
    }
}
const cs = (n, e) => n[e++] & 255 | (n[e++] & 255) << 8;
class yge {
    constructor(e) {
        this.blockLen = 16,
        this.outputLen = 16,
        this.buffer = new Uint8Array(16),
        this.r = new Uint16Array(10),
        this.h = new Uint16Array(10),
        this.pad = new Uint16Array(8),
        this.pos = 0,
        this.finished = !1,
        e = cC(e),
        vi(e, 32);
        const t = cs(e, 0)
          , r = cs(e, 2)
          , s = cs(e, 4)
          , i = cs(e, 6)
          , o = cs(e, 8)
          , a = cs(e, 10)
          , l = cs(e, 12)
          , u = cs(e, 14);
        this.r[0] = t & 8191,
        this.r[1] = (t >>> 13 | r << 3) & 8191,
        this.r[2] = (r >>> 10 | s << 6) & 7939,
        this.r[3] = (s >>> 7 | i << 9) & 8191,
        this.r[4] = (i >>> 4 | o << 12) & 255,
        this.r[5] = o >>> 1 & 8190,
        this.r[6] = (o >>> 14 | a << 2) & 8191,
        this.r[7] = (a >>> 11 | l << 5) & 8065,
        this.r[8] = (l >>> 8 | u << 8) & 8191,
        this.r[9] = u >>> 5 & 127;
        for (let d = 0; d < 8; d++)
            this.pad[d] = cs(e, 16 + 2 * d)
    }
    process(e, t, r=!1) {
        const s = r ? 0 : 2048
          , {h: i, r: o} = this
          , a = o[0]
          , l = o[1]
          , u = o[2]
          , d = o[3]
          , h = o[4]
          , p = o[5]
          , g = o[6]
          , w = o[7]
          , b = o[8]
          , v = o[9]
          , S = cs(e, t + 0)
          , N = cs(e, t + 2)
          , _ = cs(e, t + 4)
          , I = cs(e, t + 6)
          , k = cs(e, t + 8)
          , B = cs(e, t + 10)
          , P = cs(e, t + 12)
          , M = cs(e, t + 14);
        let R = i[0] + (S & 8191)
          , L = i[1] + ((S >>> 13 | N << 3) & 8191)
          , q = i[2] + ((N >>> 10 | _ << 6) & 8191)
          , H = i[3] + ((_ >>> 7 | I << 9) & 8191)
          , j = i[4] + ((I >>> 4 | k << 12) & 8191)
          , A = i[5] + (k >>> 1 & 8191)
          , E = i[6] + ((k >>> 14 | B << 2) & 8191)
          , C = i[7] + ((B >>> 11 | P << 5) & 8191)
          , O = i[8] + ((P >>> 8 | M << 8) & 8191)
          , z = i[9] + (M >>> 5 | s)
          , G = 0
          , Y = G + R * a + L * (5 * v) + q * (5 * b) + H * (5 * w) + j * (5 * g);
        G = Y >>> 13,
        Y &= 8191,
        Y += A * (5 * p) + E * (5 * h) + C * (5 * d) + O * (5 * u) + z * (5 * l),
        G += Y >>> 13,
        Y &= 8191;
        let $ = G + R * l + L * a + q * (5 * v) + H * (5 * b) + j * (5 * w);
        G = $ >>> 13,
        $ &= 8191,
        $ += A * (5 * g) + E * (5 * p) + C * (5 * h) + O * (5 * d) + z * (5 * u),
        G += $ >>> 13,
        $ &= 8191;
        let D = G + R * u + L * l + q * a + H * (5 * v) + j * (5 * b);
        G = D >>> 13,
        D &= 8191,
        D += A * (5 * w) + E * (5 * g) + C * (5 * p) + O * (5 * h) + z * (5 * d),
        G += D >>> 13,
        D &= 8191;
        let U = G + R * d + L * u + q * l + H * a + j * (5 * v);
        G = U >>> 13,
        U &= 8191,
        U += A * (5 * b) + E * (5 * w) + C * (5 * g) + O * (5 * p) + z * (5 * h),
        G += U >>> 13,
        U &= 8191;
        let W = G + R * h + L * d + q * u + H * l + j * a;
        G = W >>> 13,
        W &= 8191,
        W += A * (5 * v) + E * (5 * b) + C * (5 * w) + O * (5 * g) + z * (5 * p),
        G += W >>> 13,
        W &= 8191;
        let Q = G + R * p + L * h + q * d + H * u + j * l;
        G = Q >>> 13,
        Q &= 8191,
        Q += A * a + E * (5 * v) + C * (5 * b) + O * (5 * w) + z * (5 * g),
        G += Q >>> 13,
        Q &= 8191;
        let J = G + R * g + L * p + q * h + H * d + j * u;
        G = J >>> 13,
        J &= 8191,
        J += A * l + E * a + C * (5 * v) + O * (5 * b) + z * (5 * w),
        G += J >>> 13,
        J &= 8191;
        let ne = G + R * w + L * g + q * p + H * h + j * d;
        G = ne >>> 13,
        ne &= 8191,
        ne += A * u + E * l + C * a + O * (5 * v) + z * (5 * b),
        G += ne >>> 13,
        ne &= 8191;
        let ie = G + R * b + L * w + q * g + H * p + j * h;
        G = ie >>> 13,
        ie &= 8191,
        ie += A * d + E * u + C * l + O * a + z * (5 * v),
        G += ie >>> 13,
        ie &= 8191;
        let ae = G + R * v + L * b + q * w + H * g + j * p;
        G = ae >>> 13,
        ae &= 8191,
        ae += A * h + E * d + C * u + O * l + z * a,
        G += ae >>> 13,
        ae &= 8191,
        G = (G << 2) + G | 0,
        G = G + Y | 0,
        Y = G & 8191,
        G = G >>> 13,
        $ += G,
        i[0] = Y,
        i[1] = $,
        i[2] = D,
        i[3] = U,
        i[4] = W,
        i[5] = Q,
        i[6] = J,
        i[7] = ne,
        i[8] = ie,
        i[9] = ae
    }
    finalize() {
        const {h: e, pad: t} = this
          , r = new Uint16Array(10);
        let s = e[1] >>> 13;
        e[1] &= 8191;
        for (let a = 2; a < 10; a++)
            e[a] += s,
            s = e[a] >>> 13,
            e[a] &= 8191;
        e[0] += s * 5,
        s = e[0] >>> 13,
        e[0] &= 8191,
        e[1] += s,
        s = e[1] >>> 13,
        e[1] &= 8191,
        e[2] += s,
        r[0] = e[0] + 5,
        s = r[0] >>> 13,
        r[0] &= 8191;
        for (let a = 1; a < 10; a++)
            r[a] = e[a] + s,
            s = r[a] >>> 13,
            r[a] &= 8191;
        r[9] -= 8192;
        let i = (s ^ 1) - 1;
        for (let a = 0; a < 10; a++)
            r[a] &= i;
        i = ~i;
        for (let a = 0; a < 10; a++)
            e[a] = e[a] & i | r[a];
        e[0] = (e[0] | e[1] << 13) & 65535,
        e[1] = (e[1] >>> 3 | e[2] << 10) & 65535,
        e[2] = (e[2] >>> 6 | e[3] << 7) & 65535,
        e[3] = (e[3] >>> 9 | e[4] << 4) & 65535,
        e[4] = (e[4] >>> 12 | e[5] << 1 | e[6] << 14) & 65535,
        e[5] = (e[6] >>> 2 | e[7] << 11) & 65535,
        e[6] = (e[7] >>> 5 | e[8] << 8) & 65535,
        e[7] = (e[8] >>> 8 | e[9] << 5) & 65535;
        let o = e[0] + t[0];
        e[0] = o & 65535;
        for (let a = 1; a < 8; a++)
            o = (e[a] + t[a] | 0) + (o >>> 16) | 0,
            e[a] = o & 65535;
        i0(r)
    }
    update(e) {
        jR(this),
        e = cC(e),
        vi(e);
        const {buffer: t, blockLen: r} = this
          , s = e.length;
        for (let i = 0; i < s; ) {
            const o = Math.min(r - this.pos, s - i);
            if (o === r) {
                for (; r <= s - i; i += r)
                    this.process(e, i);
                continue
            }
            t.set(e.subarray(i, i + o), this.pos),
            this.pos += o,
            i += o,
            this.pos === r && (this.process(t, 0, !1),
            this.pos = 0)
        }
        return this
    }
    destroy() {
        i0(this.h, this.r, this.buffer, this.pad)
    }
    digestInto(e) {
        jR(this),
        tge(e, this),
        this.finished = !0;
        const {buffer: t, h: r} = this;
        let {pos: s} = this;
        if (s) {
            for (t[s++] = 1; s < 16; s++)
                t[s] = 0;
            this.process(t, 0, !0)
        }
        this.finalize();
        let i = 0;
        for (let o = 0; o < 8; o++)
            e[i++] = r[o] >>> 0,
            e[i++] = r[o] >>> 8;
        return e
    }
    digest() {
        const {buffer: e, outputLen: t} = this;
        this.digestInto(e);
        const r = e.slice(0, t);
        return this.destroy(),
        r
    }
}
function bge(n) {
    const e = (r, s) => n(s).update(cC(r)).digest()
      , t = n(new Uint8Array(32));
    return e.outputLen = t.outputLen,
    e.blockLen = t.blockLen,
    e.create = r => n(r),
    e
}
const wge = bge(n => new yge(n));
function vge(n, e, t, r, s, i=20) {
    let o = n[0]
      , a = n[1]
      , l = n[2]
      , u = n[3]
      , d = e[0]
      , h = e[1]
      , p = e[2]
      , g = e[3]
      , w = e[4]
      , b = e[5]
      , v = e[6]
      , S = e[7]
      , N = s
      , _ = t[0]
      , I = t[1]
      , k = t[2]
      , B = o
      , P = a
      , M = l
      , R = u
      , L = d
      , q = h
      , H = p
      , j = g
      , A = w
      , E = b
      , C = v
      , O = S
      , z = N
      , G = _
      , Y = I
      , $ = k;
    for (let U = 0; U < i; U += 2)
        B = B + L | 0,
        z = hn(z ^ B, 16),
        A = A + z | 0,
        L = hn(L ^ A, 12),
        B = B + L | 0,
        z = hn(z ^ B, 8),
        A = A + z | 0,
        L = hn(L ^ A, 7),
        P = P + q | 0,
        G = hn(G ^ P, 16),
        E = E + G | 0,
        q = hn(q ^ E, 12),
        P = P + q | 0,
        G = hn(G ^ P, 8),
        E = E + G | 0,
        q = hn(q ^ E, 7),
        M = M + H | 0,
        Y = hn(Y ^ M, 16),
        C = C + Y | 0,
        H = hn(H ^ C, 12),
        M = M + H | 0,
        Y = hn(Y ^ M, 8),
        C = C + Y | 0,
        H = hn(H ^ C, 7),
        R = R + j | 0,
        $ = hn($ ^ R, 16),
        O = O + $ | 0,
        j = hn(j ^ O, 12),
        R = R + j | 0,
        $ = hn($ ^ R, 8),
        O = O + $ | 0,
        j = hn(j ^ O, 7),
        B = B + q | 0,
        $ = hn($ ^ B, 16),
        C = C + $ | 0,
        q = hn(q ^ C, 12),
        B = B + q | 0,
        $ = hn($ ^ B, 8),
        C = C + $ | 0,
        q = hn(q ^ C, 7),
        P = P + H | 0,
        z = hn(z ^ P, 16),
        O = O + z | 0,
        H = hn(H ^ O, 12),
        P = P + H | 0,
        z = hn(z ^ P, 8),
        O = O + z | 0,
        H = hn(H ^ O, 7),
        M = M + j | 0,
        G = hn(G ^ M, 16),
        A = A + G | 0,
        j = hn(j ^ A, 12),
        M = M + j | 0,
        G = hn(G ^ M, 8),
        A = A + G | 0,
        j = hn(j ^ A, 7),
        R = R + L | 0,
        Y = hn(Y ^ R, 16),
        E = E + Y | 0,
        L = hn(L ^ E, 12),
        R = R + L | 0,
        Y = hn(Y ^ R, 8),
        E = E + Y | 0,
        L = hn(L ^ E, 7);
    let D = 0;
    r[D++] = o + B | 0,
    r[D++] = a + P | 0,
    r[D++] = l + M | 0,
    r[D++] = u + R | 0,
    r[D++] = d + L | 0,
    r[D++] = h + q | 0,
    r[D++] = p + H | 0,
    r[D++] = g + j | 0,
    r[D++] = w + A | 0,
    r[D++] = b + E | 0,
    r[D++] = v + C | 0,
    r[D++] = S + O | 0,
    r[D++] = N + z | 0,
    r[D++] = _ + G | 0,
    r[D++] = I + Y | 0,
    r[D++] = k + $ | 0
}
const xge = gge(vge, {
    counterRight: !1,
    counterLength: 4,
    allowShortKeys: !1
})
  , Ege = new Uint8Array(16)
  , zR = (n, e) => {
    n.update(e);
    const t = e.length % 16;
    t && n.update(Ege.subarray(t))
}
  , Sge = new Uint8Array(32);
function $R(n, e, t, r, s) {
    const i = n(e, t, Sge)
      , o = wge.create(i);
    s && zR(o, s),
    zR(o, r);
    const a = lge(r.length, s ? s.length : 0, !0);
    o.update(a);
    const l = o.digest();
    return i0(i, a),
    l
}
const Age = n => (e, t, r) => ({
    encrypt(s, i) {
        const o = s.length;
        i = LR(o + 16, i, !1),
        i.set(s);
        const a = i.subarray(0, -16);
        n(e, t, a, a, 1);
        const l = $R(n, e, t, a, r);
        return i.set(l, o),
        i0(l),
        i
    },
    decrypt(s, i) {
        i = LR(s.length - 16, i, !1);
        const o = s.subarray(0, -16)
          , a = s.subarray(-16)
          , l = $R(n, e, t, o, r);
        if (!oge(a, l))
            throw new Error("invalid tag");
        return i.set(s.subarray(0, -16)),
        n(e, t, i, i, 1),
        i0(l),
        i
    }
})
  , yH = age({
    blockSize: 64,
    nonceLength: 12,
    tagLength: 16
}, Age(xge));
let bH = class extends px {
    constructor(e, t) {
        super(),
        this.finished = !1,
        this.destroyed = !1,
        hx(e);
        const r = la(t);
        if (this.iHash = e.create(),
        typeof this.iHash.update != "function")
            throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen,
        this.outputLen = this.iHash.outputLen;
        const s = this.blockLen
          , i = new Uint8Array(s);
        i.set(r.length > s ? e.create().update(r).digest() : r);
        for (let o = 0; o < i.length; o++)
            i[o] ^= 54;
        this.iHash.update(i),
        this.oHash = e.create();
        for (let o = 0; o < i.length; o++)
            i[o] ^= 106;
        this.oHash.update(i),
        jo(i)
    }
    update(e) {
        return ed(this),
        this.iHash.update(e),
        this
    }
    digestInto(e) {
        ed(this),
        fa(e, this.outputLen),
        this.finished = !0,
        this.iHash.digestInto(e),
        this.oHash.update(e),
        this.oHash.digestInto(e),
        this.destroy()
    }
    digest() {
        const e = new Uint8Array(this.oHash.outputLen);
        return this.digestInto(e),
        e
    }
    _cloneInto(e) {
        e || (e = Object.create(Object.getPrototypeOf(this), {}));
        const {oHash: t, iHash: r, finished: s, destroyed: i, blockLen: o, outputLen: a} = this;
        return e = e,
        e.finished = s,
        e.destroyed = i,
        e.blockLen = o,
        e.outputLen = a,
        e.oHash = t._cloneInto(e.oHash),
        e.iHash = r._cloneInto(e.iHash),
        e
    }
    clone() {
        return this._cloneInto()
    }
    destroy() {
        this.destroyed = !0,
        this.oHash.destroy(),
        this.iHash.destroy()
    }
}
;
const yx = (n, e, t) => new bH(n,e).update(t).digest();
yx.create = (n, e) => new bH(n,e);
function Cge(n, e, t) {
    return hx(n),
    t === void 0 && (t = new Uint8Array(n.outputLen)),
    yx(n, la(t), la(e))
}
const V5 = Uint8Array.from([0])
  , HR = Uint8Array.of();
function _ge(n, e, t, r=32) {
    hx(n),
    Ic(r);
    const s = n.outputLen;
    if (r > 255 * s)
        throw new Error("Length should be <= 255*HashLen");
    const i = Math.ceil(r / s);
    t === void 0 && (t = HR);
    const o = new Uint8Array(i * s)
      , a = yx.create(n, e)
      , l = a._cloneInto()
      , u = new Uint8Array(a.outputLen);
    for (let d = 0; d < i; d++)
        V5[0] = d + 1,
        l.update(d === 0 ? HR : u).update(t).update(V5).digestInto(u),
        o.set(u, s * d),
        a._cloneInto(l);
    return a.destroy(),
    l.destroy(),
    jo(u, V5),
    o.slice(0, r)
}
const kge = (n, e, t, r, s) => _ge(n, Cge(n, e, t), r, s)
  , bx = mx
  , U_ = BigInt(0)
  , fC = BigInt(1);
function V2(n, e="") {
    if (typeof n != "boolean") {
        const t = e && `"${e}"`;
        throw new Error(t + "expected boolean, got type=" + typeof n)
    }
    return n
}
function ff(n, e, t="") {
    const r = fx(n)
      , s = n?.length
      , i = e !== void 0;
    if (!r || i && s !== e) {
        const o = t && `"${t}" `
          , a = i ? ` of length ${e}` : ""
          , l = r ? `length=${s}` : `type=${typeof n}`;
        throw new Error(o + "expected Uint8Array" + a + ", got " + l)
    }
    return n
}
function W1(n) {
    const e = n.toString(16);
    return e.length & 1 ? "0" + e : e
}
function wH(n) {
    if (typeof n != "string")
        throw new Error("hex string expected, got " + typeof n);
    return n === "" ? U_ : BigInt("0x" + n)
}
function wx(n) {
    return wH(Mp(n))
}
function q2(n) {
    return fa(n),
    wH(Mp(Uint8Array.from(n).reverse()))
}
function z_(n, e) {
    return $2(n.toString(16).padStart(e * 2, "0"))
}
function $_(n, e) {
    return z_(n, e).reverse()
}
function Ls(n, e, t) {
    let r;
    if (typeof e == "string")
        try {
            r = $2(e)
        } catch (i) {
            throw new Error(n + " must be hex string or Uint8Array, cause: " + i)
        }
    else if (fx(e))
        r = Uint8Array.from(e);
    else
        throw new Error(n + " must be hex string or Uint8Array");
    const s = r.length;
    if (typeof t == "number" && s !== t)
        throw new Error(n + " of length " + t + " expected, got " + s);
    return r
}
const q5 = n => typeof n == "bigint" && U_ <= n;
function Nge(n, e, t) {
    return q5(n) && q5(e) && q5(t) && e <= n && n < t
}
function hC(n, e, t, r) {
    if (!Nge(e, t, r))
        throw new Error("expected valid " + n + ": " + t + " <= n < " + r + ", got " + e)
}
function vH(n) {
    let e;
    for (e = 0; n > U_; n >>= fC,
    e += 1)
        ;
    return e
}
const qy = n => (fC << BigInt(n)) - fC;
function Dge(n, e, t) {
    if (typeof n != "number" || n < 2)
        throw new Error("hashLen must be a number");
    if (typeof e != "number" || e < 2)
        throw new Error("qByteLen must be a number");
    if (typeof t != "function")
        throw new Error("hmacFn must be a function");
    const r = p => new Uint8Array(p)
      , s = p => Uint8Array.of(p);
    let i = r(n)
      , o = r(n)
      , a = 0;
    const l = () => {
        i.fill(1),
        o.fill(0),
        a = 0
    }
      , u = (...p) => t(o, i, ...p)
      , d = (p=r(0)) => {
        o = u(s(0), p),
        i = u(),
        p.length !== 0 && (o = u(s(1), p),
        i = u())
    }
      , h = () => {
        if (a++ >= 1e3)
            throw new Error("drbg: tried 1000 values");
        let p = 0;
        const g = [];
        for (; p < e; ) {
            i = u();
            const w = i.slice();
            g.push(w),
            p += i.length
        }
        return Ou(...g)
    }
    ;
    return (p, g) => {
        l(),
        d(p);
        let w;
        for (; !(w = g(h())); )
            d();
        return l(),
        w
    }
}
function vx(n, e, t={}) {
    if (!n || typeof n != "object")
        throw new Error("expected valid options object");
    function r(s, i, o) {
        const a = n[s];
        if (o && a === void 0)
            return;
        const l = typeof a;
        if (l !== i || a === null)
            throw new Error(`param "${s}" is invalid: expected ${i}, got ${l}`)
    }
    Object.entries(e).forEach( ([s,i]) => r(s, i, !1)),
    Object.entries(t).forEach( ([s,i]) => r(s, i, !0))
}
function VR(n) {
    const e = new WeakMap;
    return (t, ...r) => {
        const s = e.get(t);
        if (s !== void 0)
            return s;
        const i = n(t, ...r);
        return e.set(t, i),
        i
    }
}
const _i = BigInt(0)
  , ti = BigInt(1)
  , hf = BigInt(2)
  , xH = BigInt(3)
  , EH = BigInt(4)
  , SH = BigInt(5)
  , Tge = BigInt(7)
  , AH = BigInt(8)
  , Ige = BigInt(9)
  , CH = BigInt(16);
function Ki(n, e) {
    const t = n % e;
    return t >= _i ? t : e + t
}
function Ko(n, e, t) {
    let r = n;
    for (; e-- > _i; )
        r *= r,
        r %= t;
    return r
}
function qR(n, e) {
    if (n === _i)
        throw new Error("invert: expected non-zero number");
    if (e <= _i)
        throw new Error("invert: expected positive modulus, got " + e);
    let t = Ki(n, e)
      , r = e
      , s = _i
      , i = ti;
    for (; t !== _i; ) {
        const o = r / t
          , a = r % t
          , l = s - i * o;
        r = t,
        t = a,
        s = i,
        i = l
    }
    if (r !== ti)
        throw new Error("invert: does not exist");
    return Ki(s, e)
}
function H_(n, e, t) {
    if (!n.eql(n.sqr(e), t))
        throw new Error("Cannot find square root")
}
function _H(n, e) {
    const t = (n.ORDER + ti) / EH
      , r = n.pow(e, t);
    return H_(n, r, e),
    r
}
function Mge(n, e) {
    const t = (n.ORDER - SH) / AH
      , r = n.mul(e, hf)
      , s = n.pow(r, t)
      , i = n.mul(e, s)
      , o = n.mul(n.mul(i, hf), s)
      , a = n.mul(i, n.sub(o, n.ONE));
    return H_(n, a, e),
    a
}
function Bge(n) {
    const e = cd(n)
      , t = kH(n)
      , r = t(e, e.neg(e.ONE))
      , s = t(e, r)
      , i = t(e, e.neg(r))
      , o = (n + Tge) / CH;
    return (a, l) => {
        let u = a.pow(l, o)
          , d = a.mul(u, r);
        const h = a.mul(u, s)
          , p = a.mul(u, i)
          , g = a.eql(a.sqr(d), l)
          , w = a.eql(a.sqr(h), l);
        u = a.cmov(u, d, g),
        d = a.cmov(p, h, w);
        const b = a.eql(a.sqr(d), l)
          , v = a.cmov(u, d, b);
        return H_(a, v, l),
        v
    }
}
function kH(n) {
    if (n < xH)
        throw new Error("sqrt is not defined for small field");
    let e = n - ti
      , t = 0;
    for (; e % hf === _i; )
        e /= hf,
        t++;
    let r = hf;
    const s = cd(n);
    for (; GR(s, r) === 1; )
        if (r++ > 1e3)
            throw new Error("Cannot find square root: probably non-prime P");
    if (t === 1)
        return _H;
    let i = s.pow(r, e);
    const o = (e + ti) / hf;
    return function(a, l) {
        if (a.is0(l))
            return l;
        if (GR(a, l) !== 1)
            throw new Error("Cannot find square root");
        let u = t
          , d = a.mul(a.ONE, i)
          , h = a.pow(l, e)
          , p = a.pow(l, o);
        for (; !a.eql(h, a.ONE); ) {
            if (a.is0(h))
                return a.ZERO;
            let g = 1
              , w = a.sqr(h);
            for (; !a.eql(w, a.ONE); )
                if (g++,
                w = a.sqr(w),
                g === u)
                    throw new Error("Cannot find square root");
            const b = ti << BigInt(u - g - 1)
              , v = a.pow(d, b);
            u = g,
            d = a.sqr(v),
            h = a.mul(h, d),
            p = a.mul(p, v)
        }
        return p
    }
}
function Rge(n) {
    return n % EH === xH ? _H : n % AH === SH ? Mge : n % CH === Ige ? Bge(n) : kH(n)
}
const Oge = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];
function Pge(n) {
    const e = {
        ORDER: "bigint",
        MASK: "bigint",
        BYTES: "number",
        BITS: "number"
    }
      , t = Oge.reduce( (r, s) => (r[s] = "function",
    r), e);
    return vx(n, t),
    n
}
function jge(n, e, t) {
    if (t < _i)
        throw new Error("invalid exponent, negatives unsupported");
    if (t === _i)
        return n.ONE;
    if (t === ti)
        return e;
    let r = n.ONE
      , s = e;
    for (; t > _i; )
        t & ti && (r = n.mul(r, s)),
        s = n.sqr(s),
        t >>= ti;
    return r
}
function NH(n, e, t=!1) {
    const r = new Array(e.length).fill(t ? n.ZERO : void 0)
      , s = e.reduce( (o, a, l) => n.is0(a) ? o : (r[l] = o,
    n.mul(o, a)), n.ONE)
      , i = n.inv(s);
    return e.reduceRight( (o, a, l) => n.is0(a) ? o : (r[l] = n.mul(o, r[l]),
    n.mul(o, a)), i),
    r
}
function GR(n, e) {
    const t = (n.ORDER - ti) / hf
      , r = n.pow(e, t)
      , s = n.eql(r, n.ONE)
      , i = n.eql(r, n.ZERO)
      , o = n.eql(r, n.neg(n.ONE));
    if (!s && !i && !o)
        throw new Error("invalid Legendre symbol result");
    return s ? 1 : i ? 0 : -1
}
function DH(n, e) {
    e !== void 0 && Ic(e);
    const t = e !== void 0 ? e : n.toString(2).length
      , r = Math.ceil(t / 8);
    return {
        nBitLength: t,
        nByteLength: r
    }
}
function cd(n, e, t=!1, r={}) {
    if (n <= _i)
        throw new Error("invalid field: expected ORDER > 0, got " + n);
    let s, i, o = !1, a;
    if (typeof e == "object" && e != null) {
        if (r.sqrt || t)
            throw new Error("cannot specify opts in two arguments");
        const p = e;
        p.BITS && (s = p.BITS),
        p.sqrt && (i = p.sqrt),
        typeof p.isLE == "boolean" && (t = p.isLE),
        typeof p.modFromBytes == "boolean" && (o = p.modFromBytes),
        a = p.allowedLengths
    } else
        typeof e == "number" && (s = e),
        r.sqrt && (i = r.sqrt);
    const {nBitLength: l, nByteLength: u} = DH(n, s);
    if (u > 2048)
        throw new Error("invalid field: expected ORDER of <= 2048 bytes");
    let d;
    const h = Object.freeze({
        ORDER: n,
        isLE: t,
        BITS: l,
        BYTES: u,
        MASK: qy(l),
        ZERO: _i,
        ONE: ti,
        allowedLengths: a,
        create: p => Ki(p, n),
        isValid: p => {
            if (typeof p != "bigint")
                throw new Error("invalid field element: expected bigint, got " + typeof p);
            return _i <= p && p < n
        }
        ,
        is0: p => p === _i,
        isValidNot0: p => !h.is0(p) && h.isValid(p),
        isOdd: p => (p & ti) === ti,
        neg: p => Ki(-p, n),
        eql: (p, g) => p === g,
        sqr: p => Ki(p * p, n),
        add: (p, g) => Ki(p + g, n),
        sub: (p, g) => Ki(p - g, n),
        mul: (p, g) => Ki(p * g, n),
        pow: (p, g) => jge(h, p, g),
        div: (p, g) => Ki(p * qR(g, n), n),
        sqrN: p => p * p,
        addN: (p, g) => p + g,
        subN: (p, g) => p - g,
        mulN: (p, g) => p * g,
        inv: p => qR(p, n),
        sqrt: i || (p => (d || (d = Rge(n)),
        d(h, p))),
        toBytes: p => t ? $_(p, u) : z_(p, u),
        fromBytes: (p, g=!0) => {
            if (a) {
                if (!a.includes(p.length) || p.length > u)
                    throw new Error("Field.fromBytes: expected " + a + " bytes, got " + p.length);
                const b = new Uint8Array(u);
                b.set(p, t ? 0 : b.length - p.length),
                p = b
            }
            if (p.length !== u)
                throw new Error("Field.fromBytes: expected " + u + " bytes, got " + p.length);
            let w = t ? q2(p) : wx(p);
            if (o && (w = Ki(w, n)),
            !g && !h.isValid(w))
                throw new Error("invalid field element: outside of range 0..ORDER");
            return w
        }
        ,
        invertBatch: p => NH(h, p),
        cmov: (p, g, w) => w ? g : p
    });
    return Object.freeze(h)
}
function TH(n) {
    if (typeof n != "bigint")
        throw new Error("field order must be bigint");
    const e = n.toString(2).length;
    return Math.ceil(e / 8)
}
function IH(n) {
    const e = TH(n);
    return e + Math.ceil(e / 2)
}
function Lge(n, e, t=!1) {
    const r = n.length
      , s = TH(e)
      , i = IH(e);
    if (r < 16 || r < i || r > 1024)
        throw new Error("expected " + i + "-1024 bytes of input, got " + r);
    const o = t ? q2(n) : wx(n)
      , a = Ki(o, e - ti) + ti;
    return t ? $_(a, s) : z_(a, s)
}
const o0 = BigInt(0)
  , pf = BigInt(1);
function G2(n, e) {
    const t = e.negate();
    return n ? t : e
}
function G5(n, e) {
    const t = NH(n.Fp, e.map(r => r.Z));
    return e.map( (r, s) => n.fromAffine(r.toAffine(t[s])))
}
function MH(n, e) {
    if (!Number.isSafeInteger(n) || n <= 0 || n > e)
        throw new Error("invalid window size, expected [1.." + e + "], got W=" + n)
}
function W5(n, e) {
    MH(n, e);
    const t = Math.ceil(e / n) + 1
      , r = 2 ** (n - 1)
      , s = 2 ** n
      , i = qy(n)
      , o = BigInt(n);
    return {
        windows: t,
        windowSize: r,
        mask: i,
        maxNumber: s,
        shiftBy: o
    }
}
function WR(n, e, t) {
    const {windowSize: r, mask: s, maxNumber: i, shiftBy: o} = t;
    let a = Number(n & s)
      , l = n >> o;
    a > r && (a -= i,
    l += pf);
    const u = e * r
      , d = u + Math.abs(a) - 1
      , h = a === 0
      , p = a < 0
      , g = e % 2 !== 0;
    return {
        nextN: l,
        offset: d,
        isZero: h,
        isNeg: p,
        isNegF: g,
        offsetF: u
    }
}
function Fge(n, e) {
    if (!Array.isArray(n))
        throw new Error("array expected");
    n.forEach( (t, r) => {
        if (!(t instanceof e))
            throw new Error("invalid point at index " + r)
    }
    )
}
function Uge(n, e) {
    if (!Array.isArray(n))
        throw new Error("array of scalars expected");
    n.forEach( (t, r) => {
        if (!e.isValid(t))
            throw new Error("invalid scalar at index " + r)
    }
    )
}
const Y5 = new WeakMap
  , BH = new WeakMap;
function K5(n) {
    return BH.get(n) || 1
}
function YR(n) {
    if (n !== o0)
        throw new Error("invalid wNAF")
}
class zge {
    constructor(e, t) {
        this.BASE = e.BASE,
        this.ZERO = e.ZERO,
        this.Fn = e.Fn,
        this.bits = t
    }
    _unsafeLadder(e, t, r=this.ZERO) {
        let s = e;
        for (; t > o0; )
            t & pf && (r = r.add(s)),
            s = s.double(),
            t >>= pf;
        return r
    }
    precomputeWindow(e, t) {
        const {windows: r, windowSize: s} = W5(t, this.bits)
          , i = [];
        let o = e
          , a = o;
        for (let l = 0; l < r; l++) {
            a = o,
            i.push(a);
            for (let u = 1; u < s; u++)
                a = a.add(o),
                i.push(a);
            o = a.double()
        }
        return i
    }
    wNAF(e, t, r) {
        if (!this.Fn.isValid(r))
            throw new Error("invalid scalar");
        let s = this.ZERO
          , i = this.BASE;
        const o = W5(e, this.bits);
        for (let a = 0; a < o.windows; a++) {
            const {nextN: l, offset: u, isZero: d, isNeg: h, isNegF: p, offsetF: g} = WR(r, a, o);
            r = l,
            d ? i = i.add(G2(p, t[g])) : s = s.add(G2(h, t[u]))
        }
        return YR(r),
        {
            p: s,
            f: i
        }
    }
    wNAFUnsafe(e, t, r, s=this.ZERO) {
        const i = W5(e, this.bits);
        for (let o = 0; o < i.windows && r !== o0; o++) {
            const {nextN: a, offset: l, isZero: u, isNeg: d} = WR(r, o, i);
            if (r = a,
            !u) {
                const h = t[l];
                s = s.add(d ? h.negate() : h)
            }
        }
        return YR(r),
        s
    }
    getPrecomputes(e, t, r) {
        let s = Y5.get(t);
        return s || (s = this.precomputeWindow(t, e),
        e !== 1 && (typeof r == "function" && (s = r(s)),
        Y5.set(t, s))),
        s
    }
    cached(e, t, r) {
        const s = K5(e);
        return this.wNAF(s, this.getPrecomputes(s, e, r), t)
    }
    unsafe(e, t, r, s) {
        const i = K5(e);
        return i === 1 ? this._unsafeLadder(e, t, s) : this.wNAFUnsafe(i, this.getPrecomputes(i, e, r), t, s)
    }
    createCache(e, t) {
        MH(t, this.bits),
        BH.set(e, t),
        Y5.delete(e)
    }
    hasCache(e) {
        return K5(e) !== 1
    }
}
function $ge(n, e, t, r) {
    let s = e
      , i = n.ZERO
      , o = n.ZERO;
    for (; t > o0 || r > o0; )
        t & pf && (i = i.add(s)),
        r & pf && (o = o.add(s)),
        s = s.double(),
        t >>= pf,
        r >>= pf;
    return {
        p1: i,
        p2: o
    }
}
function Hge(n, e, t, r) {
    Fge(t, n),
    Uge(r, e);
    const s = t.length
      , i = r.length;
    if (s !== i)
        throw new Error("arrays of points and scalars must have equal length");
    const o = n.ZERO
      , a = vH(BigInt(s));
    let l = 1;
    a > 12 ? l = a - 3 : a > 4 ? l = a - 2 : a > 0 && (l = 2);
    const u = qy(l)
      , d = new Array(Number(u) + 1).fill(o)
      , h = Math.floor((e.BITS - 1) / l) * l;
    let p = o;
    for (let g = h; g >= 0; g -= l) {
        d.fill(o);
        for (let b = 0; b < i; b++) {
            const v = r[b]
              , S = Number(v >> BigInt(g) & u);
            d[S] = d[S].add(t[b])
        }
        let w = o;
        for (let b = d.length - 1, v = o; b > 0; b--)
            v = v.add(d[b]),
            w = w.add(v);
        if (p = p.add(w),
        g !== 0)
            for (let b = 0; b < l; b++)
                p = p.double()
    }
    return p
}
function KR(n, e, t) {
    if (e) {
        if (e.ORDER !== n)
            throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
        return Pge(e),
        e
    } else
        return cd(n, {
            isLE: t
        })
}
function Vge(n, e, t={}, r) {
    if (r === void 0 && (r = n === "edwards"),
    !e || typeof e != "object")
        throw new Error(`expected valid ${n} CURVE object`);
    for (const a of ["p", "n", "h"]) {
        const l = e[a];
        if (!(typeof l == "bigint" && l > o0))
            throw new Error(`CURVE.${a} must be positive bigint`)
    }
    const s = KR(e.p, t.Fp, r)
      , i = KR(e.n, t.Fn, r)
      , o = ["Gx", "Gy", "a", "b"];
    for (const a of o)
        if (!s.isValid(e[a]))
            throw new Error(`CURVE.${a} must be valid field element of CURVE.Fp`);
    return e = Object.freeze(Object.assign({}, e)),
    {
        CURVE: e,
        Fp: s,
        Fn: i
    }
}
BigInt(0),
BigInt(1),
BigInt(2),
BigInt(8),
nH("HashToScalar-");
const Wm = BigInt(0)
  , Qh = BigInt(1)
  , Y1 = BigInt(2);
function qge(n) {
    return vx(n, {
        adjustScalarBytes: "function",
        powPminus2: "function"
    }),
    Object.freeze({
        ...n
    })
}
function Gge(n) {
    const e = qge(n)
      , {P: t, type: r, adjustScalarBytes: s, powPminus2: i, randomBytes: o} = e
      , a = r === "x25519";
    if (!a && r !== "x448")
        throw new Error("invalid type");
    const l = o || Kf
      , u = a ? 255 : 448
      , d = a ? 32 : 56
      , h = BigInt(a ? 9 : 5)
      , p = BigInt(a ? 121665 : 39081)
      , g = a ? Y1 ** BigInt(254) : Y1 ** BigInt(447)
      , w = a ? BigInt(8) * Y1 ** BigInt(251) - Qh : BigInt(4) * Y1 ** BigInt(445) - Qh
      , b = g + w + Qh
      , v = H => Ki(H, t)
      , S = N(h);
    function N(H) {
        return $_(v(H), d)
    }
    function _(H) {
        const j = Ls("u coordinate", H, d);
        return a && (j[31] &= 127),
        v(q2(j))
    }
    function I(H) {
        return q2(s(Ls("scalar", H, d)))
    }
    function k(H, j) {
        const A = M(_(j), I(H));
        if (A === Wm)
            throw new Error("invalid private or public key received");
        return N(A)
    }
    function B(H) {
        return k(H, S)
    }
    function P(H, j, A) {
        const E = v(H * (j - A));
        return j = v(j - E),
        A = v(A + E),
        {
            x_2: j,
            x_3: A
        }
    }
    function M(H, j) {
        hC("u", H, Wm, t),
        hC("scalar", j, g, b);
        const A = j
          , E = H;
        let C = Qh
          , O = Wm
          , z = H
          , G = Qh
          , Y = Wm;
        for (let D = BigInt(u - 1); D >= Wm; D--) {
            const U = A >> D & Qh;
            Y ^= U,
            {x_2: C, x_3: z} = P(Y, C, z),
            {x_2: O, x_3: G} = P(Y, O, G),
            Y = U;
            const W = C + O
              , Q = v(W * W)
              , J = C - O
              , ne = v(J * J)
              , ie = Q - ne
              , ae = z + G
              , xe = z - G
              , ue = v(xe * W)
              , ce = v(ae * J)
              , me = ue + ce
              , Ee = ue - ce;
            z = v(me * me),
            G = v(E * v(Ee * Ee)),
            C = v(Q * ne),
            O = v(ie * (Q + v(p * ie)))
        }
        ({x_2: C, x_3: z} = P(Y, C, z)),
        {x_2: O, x_3: G} = P(Y, O, G);
        const $ = i(O);
        return v(C * $)
    }
    const R = {
        secretKey: d,
        publicKey: d,
        seed: d
    }
      , L = (H=l(d)) => (fa(H, R.seed),
    H);
    function q(H) {
        const j = L(H);
        return {
            secretKey: j,
            publicKey: B(j)
        }
    }
    return {
        keygen: q,
        getSharedSecret: (H, j) => k(H, j),
        getPublicKey: H => B(H),
        scalarMult: k,
        scalarMultBase: B,
        utils: {
            randomSecretKey: L,
            randomPrivateKey: L
        },
        GuBytes: S.slice(),
        lengths: R
    }
}
const Wge = BigInt(1)
  , XR = BigInt(2)
  , Yge = BigInt(3)
  , Kge = BigInt(5);
BigInt(8);
const RH = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed")
  , Xge = {
    p: RH,
    n: BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),
    a: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),
    d: BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),
    Gx: BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),
    Gy: BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")
};
function Qge(n) {
    const e = BigInt(10)
      , t = BigInt(20)
      , r = BigInt(40)
      , s = BigInt(80)
      , i = RH
      , o = n * n % i * n % i
      , a = Ko(o, XR, i) * o % i
      , l = Ko(a, Wge, i) * n % i
      , u = Ko(l, Kge, i) * l % i
      , d = Ko(u, e, i) * u % i
      , h = Ko(d, t, i) * d % i
      , p = Ko(h, r, i) * h % i
      , g = Ko(p, s, i) * p % i
      , w = Ko(g, s, i) * p % i
      , b = Ko(w, e, i) * u % i;
    return {
        pow_p_5_8: Ko(b, XR, i) * n % i,
        b2: o
    }
}
function Zge(n) {
    return n[0] &= 248,
    n[31] &= 127,
    n[31] |= 64,
    n
}
const Jge = cd(Xge.p, {
    isLE: !0
})
  , pC = ( () => {
    const n = Jge.ORDER;
    return Gge({
        P: n,
        type: "x25519",
        powPminus2: e => {
            const {pow_p_5_8: t, b2: r} = Qge(e);
            return Ki(Ko(t, Yge, n) * r, n)
        }
        ,
        adjustScalarBytes: Zge
    })
}
)()
  , QR = (n, e) => (n + (n >= 0 ? e : -e) / OH) / e;
function eye(n, e, t) {
    const [[r,s],[i,o]] = e
      , a = QR(o * n, t)
      , l = QR(-s * n, t);
    let u = n - a * r - l * i
      , d = -a * s - l * o;
    const h = u < dc
      , p = d < dc;
    h && (u = -u),
    p && (d = -d);
    const g = qy(Math.ceil(vH(t) / 2)) + Bp;
    if (u < dc || u >= g || d < dc || d >= g)
        throw new Error("splitScalar (endomorphism): failed, k=" + n);
    return {
        k1neg: h,
        k1: u,
        k2neg: p,
        k2: d
    }
}
function mC(n) {
    if (!["compact", "recovered", "der"].includes(n))
        throw new Error('Signature format must be "compact", "recovered", or "der"');
    return n
}
function X5(n, e) {
    const t = {};
    for (let r of Object.keys(e))
        t[r] = n[r] === void 0 ? e[r] : n[r];
    return V2(t.lowS, "lowS"),
    V2(t.prehash, "prehash"),
    t.format !== void 0 && mC(t.format),
    t
}
class tye extends Error {
    constructor(e="") {
        super(e)
    }
}
const Jl = {
    Err: tye,
    _tlv: {
        encode: (n, e) => {
            const {Err: t} = Jl;
            if (n < 0 || n > 256)
                throw new t("tlv.encode: wrong tag");
            if (e.length & 1)
                throw new t("tlv.encode: unpadded data");
            const r = e.length / 2
              , s = W1(r);
            if (s.length / 2 & 128)
                throw new t("tlv.encode: long form length too big");
            const i = r > 127 ? W1(s.length / 2 | 128) : "";
            return W1(n) + i + s + e
        }
        ,
        decode(n, e) {
            const {Err: t} = Jl;
            let r = 0;
            if (n < 0 || n > 256)
                throw new t("tlv.encode: wrong tag");
            if (e.length < 2 || e[r++] !== n)
                throw new t("tlv.decode: wrong tlv");
            const s = e[r++]
              , i = !!(s & 128);
            let o = 0;
            if (!i)
                o = s;
            else {
                const l = s & 127;
                if (!l)
                    throw new t("tlv.decode(long): indefinite length not supported");
                if (l > 4)
                    throw new t("tlv.decode(long): byte length is too big");
                const u = e.subarray(r, r + l);
                if (u.length !== l)
                    throw new t("tlv.decode: length bytes not complete");
                if (u[0] === 0)
                    throw new t("tlv.decode(long): zero leftmost byte");
                for (const d of u)
                    o = o << 8 | d;
                if (r += l,
                o < 128)
                    throw new t("tlv.decode(long): not minimal encoding")
            }
            const a = e.subarray(r, r + o);
            if (a.length !== o)
                throw new t("tlv.decode: wrong value length");
            return {
                v: a,
                l: e.subarray(r + o)
            }
        }
    },
    _int: {
        encode(n) {
            const {Err: e} = Jl;
            if (n < dc)
                throw new e("integer: negative integers are not allowed");
            let t = W1(n);
            if (Number.parseInt(t[0], 16) & 8 && (t = "00" + t),
            t.length & 1)
                throw new e("unexpected DER parsing assertion: unpadded hex");
            return t
        },
        decode(n) {
            const {Err: e} = Jl;
            if (n[0] & 128)
                throw new e("invalid signature integer: negative");
            if (n[0] === 0 && !(n[1] & 128))
                throw new e("invalid signature integer: unnecessary leading zero");
            return wx(n)
        }
    },
    toSig(n) {
        const {Err: e, _int: t, _tlv: r} = Jl
          , s = Ls("signature", n)
          , {v: i, l: o} = r.decode(48, s);
        if (o.length)
            throw new e("invalid signature: left bytes after parsing");
        const {v: a, l} = r.decode(2, i)
          , {v: u, l: d} = r.decode(2, l);
        if (d.length)
            throw new e("invalid signature: left bytes after parsing");
        return {
            r: t.decode(a),
            s: t.decode(u)
        }
    },
    hexFromSig(n) {
        const {_tlv: e, _int: t} = Jl
          , r = e.encode(2, t.encode(n.r))
          , s = e.encode(2, t.encode(n.s))
          , i = r + s;
        return e.encode(48, i)
    }
}
  , dc = BigInt(0)
  , Bp = BigInt(1)
  , OH = BigInt(2)
  , K1 = BigInt(3)
  , nye = BigInt(4);
function bp(n, e) {
    const {BYTES: t} = n;
    let r;
    if (typeof e == "bigint")
        r = e;
    else {
        let s = Ls("private key", e);
        try {
            r = n.fromBytes(s)
        } catch {
            throw new Error(`invalid private key: expected ui8a of size ${t}, got ${typeof e}`)
        }
    }
    if (!n.isValidNot0(r))
        throw new Error("invalid private key: out of range [1..N-1]");
    return r
}
function rye(n, e={}) {
    const t = Vge("weierstrass", n, e)
      , {Fp: r, Fn: s} = t;
    let i = t.CURVE;
    const {h: o, n: a} = i;
    vx(e, {}, {
        allowInfinityPoint: "boolean",
        clearCofactor: "function",
        isTorsionFree: "function",
        fromBytes: "function",
        toBytes: "function",
        endo: "object",
        wrapPrivateKey: "boolean"
    });
    const {endo: l} = e;
    if (l && (!r.is0(i.a) || typeof l.beta != "bigint" || !Array.isArray(l.basises)))
        throw new Error('invalid endo: expected "beta": bigint and "basises": array');
    const u = jH(r, s);
    function d() {
        if (!r.isOdd)
            throw new Error("compression is not supported: Field does not have .isOdd()")
    }
    function h(H, j, A) {
        const {x: E, y: C} = j.toAffine()
          , O = r.toBytes(E);
        if (V2(A, "isCompressed"),
        A) {
            d();
            const z = !r.isOdd(C);
            return Ou(PH(z), O)
        } else
            return Ou(Uint8Array.of(4), O, r.toBytes(C))
    }
    function p(H) {
        ff(H, void 0, "Point");
        const {publicKey: j, publicKeyUncompressed: A} = u
          , E = H.length
          , C = H[0]
          , O = H.subarray(1);
        if (E === j && (C === 2 || C === 3)) {
            const z = r.fromBytes(O);
            if (!r.isValid(z))
                throw new Error("bad point: is not on curve, wrong x");
            const G = b(z);
            let Y;
            try {
                Y = r.sqrt(G)
            } catch (D) {
                const U = D instanceof Error ? ": " + D.message : "";
                throw new Error("bad point: is not on curve, sqrt error" + U)
            }
            d();
            const $ = r.isOdd(Y);
            return (C & 1) === 1 !== $ && (Y = r.neg(Y)),
            {
                x: z,
                y: Y
            }
        } else if (E === A && C === 4) {
            const z = r.BYTES
              , G = r.fromBytes(O.subarray(0, z))
              , Y = r.fromBytes(O.subarray(z, z * 2));
            if (!v(G, Y))
                throw new Error("bad point: is not on curve");
            return {
                x: G,
                y: Y
            }
        } else
            throw new Error(`bad point: got length ${E}, expected compressed=${j} or uncompressed=${A}`)
    }
    const g = e.toBytes || h
      , w = e.fromBytes || p;
    function b(H) {
        const j = r.sqr(H)
          , A = r.mul(j, H);
        return r.add(r.add(A, r.mul(H, i.a)), i.b)
    }
    function v(H, j) {
        const A = r.sqr(j)
          , E = b(H);
        return r.eql(A, E)
    }
    if (!v(i.Gx, i.Gy))
        throw new Error("bad curve params: generator point");
    const S = r.mul(r.pow(i.a, K1), nye)
      , N = r.mul(r.sqr(i.b), BigInt(27));
    if (r.is0(r.add(S, N)))
        throw new Error("bad curve params: a or b");
    function _(H, j, A=!1) {
        if (!r.isValid(j) || A && r.is0(j))
            throw new Error(`bad point coordinate ${H}`);
        return j
    }
    function I(H) {
        if (!(H instanceof R))
            throw new Error("ProjectivePoint expected")
    }
    function k(H) {
        if (!l || !l.basises)
            throw new Error("no endo");
        return eye(H, l.basises, s.ORDER)
    }
    const B = VR( (H, j) => {
        const {X: A, Y: E, Z: C} = H;
        if (r.eql(C, r.ONE))
            return {
                x: A,
                y: E
            };
        const O = H.is0();
        j == null && (j = O ? r.ONE : r.inv(C));
        const z = r.mul(A, j)
          , G = r.mul(E, j)
          , Y = r.mul(C, j);
        if (O)
            return {
                x: r.ZERO,
                y: r.ZERO
            };
        if (!r.eql(Y, r.ONE))
            throw new Error("invZ was invalid");
        return {
            x: z,
            y: G
        }
    }
    )
      , P = VR(H => {
        if (H.is0()) {
            if (e.allowInfinityPoint && !r.is0(H.Y))
                return;
            throw new Error("bad point: ZERO")
        }
        const {x: j, y: A} = H.toAffine();
        if (!r.isValid(j) || !r.isValid(A))
            throw new Error("bad point: x or y not field elements");
        if (!v(j, A))
            throw new Error("bad point: equation left != right");
        if (!H.isTorsionFree())
            throw new Error("bad point: not in prime-order subgroup");
        return !0
    }
    );
    function M(H, j, A, E, C) {
        return A = new R(r.mul(A.X, H),A.Y,A.Z),
        j = G2(E, j),
        A = G2(C, A),
        j.add(A)
    }
    class R {
        constructor(j, A, E) {
            this.X = _("x", j),
            this.Y = _("y", A, !0),
            this.Z = _("z", E),
            Object.freeze(this)
        }
        static CURVE() {
            return i
        }
        static fromAffine(j) {
            const {x: A, y: E} = j || {};
            if (!j || !r.isValid(A) || !r.isValid(E))
                throw new Error("invalid affine point");
            if (j instanceof R)
                throw new Error("projective point not allowed");
            return r.is0(A) && r.is0(E) ? R.ZERO : new R(A,E,r.ONE)
        }
        static fromBytes(j) {
            const A = R.fromAffine(w(ff(j, void 0, "point")));
            return A.assertValidity(),
            A
        }
        static fromHex(j) {
            return R.fromBytes(Ls("pointHex", j))
        }
        get x() {
            return this.toAffine().x
        }
        get y() {
            return this.toAffine().y
        }
        precompute(j=8, A=!0) {
            return q.createCache(this, j),
            A || this.multiply(K1),
            this
        }
        assertValidity() {
            P(this)
        }
        hasEvenY() {
            const {y: j} = this.toAffine();
            if (!r.isOdd)
                throw new Error("Field doesn't support isOdd");
            return !r.isOdd(j)
        }
        equals(j) {
            I(j);
            const {X: A, Y: E, Z: C} = this
              , {X: O, Y: z, Z: G} = j
              , Y = r.eql(r.mul(A, G), r.mul(O, C))
              , $ = r.eql(r.mul(E, G), r.mul(z, C));
            return Y && $
        }
        negate() {
            return new R(this.X,r.neg(this.Y),this.Z)
        }
        double() {
            const {a: j, b: A} = i
              , E = r.mul(A, K1)
              , {X: C, Y: O, Z: z} = this;
            let G = r.ZERO
              , Y = r.ZERO
              , $ = r.ZERO
              , D = r.mul(C, C)
              , U = r.mul(O, O)
              , W = r.mul(z, z)
              , Q = r.mul(C, O);
            return Q = r.add(Q, Q),
            $ = r.mul(C, z),
            $ = r.add($, $),
            G = r.mul(j, $),
            Y = r.mul(E, W),
            Y = r.add(G, Y),
            G = r.sub(U, Y),
            Y = r.add(U, Y),
            Y = r.mul(G, Y),
            G = r.mul(Q, G),
            $ = r.mul(E, $),
            W = r.mul(j, W),
            Q = r.sub(D, W),
            Q = r.mul(j, Q),
            Q = r.add(Q, $),
            $ = r.add(D, D),
            D = r.add($, D),
            D = r.add(D, W),
            D = r.mul(D, Q),
            Y = r.add(Y, D),
            W = r.mul(O, z),
            W = r.add(W, W),
            D = r.mul(W, Q),
            G = r.sub(G, D),
            $ = r.mul(W, U),
            $ = r.add($, $),
            $ = r.add($, $),
            new R(G,Y,$)
        }
        add(j) {
            I(j);
            const {X: A, Y: E, Z: C} = this
              , {X: O, Y: z, Z: G} = j;
            let Y = r.ZERO
              , $ = r.ZERO
              , D = r.ZERO;
            const U = i.a
              , W = r.mul(i.b, K1);
            let Q = r.mul(A, O)
              , J = r.mul(E, z)
              , ne = r.mul(C, G)
              , ie = r.add(A, E)
              , ae = r.add(O, z);
            ie = r.mul(ie, ae),
            ae = r.add(Q, J),
            ie = r.sub(ie, ae),
            ae = r.add(A, C);
            let xe = r.add(O, G);
            return ae = r.mul(ae, xe),
            xe = r.add(Q, ne),
            ae = r.sub(ae, xe),
            xe = r.add(E, C),
            Y = r.add(z, G),
            xe = r.mul(xe, Y),
            Y = r.add(J, ne),
            xe = r.sub(xe, Y),
            D = r.mul(U, ae),
            Y = r.mul(W, ne),
            D = r.add(Y, D),
            Y = r.sub(J, D),
            D = r.add(J, D),
            $ = r.mul(Y, D),
            J = r.add(Q, Q),
            J = r.add(J, Q),
            ne = r.mul(U, ne),
            ae = r.mul(W, ae),
            J = r.add(J, ne),
            ne = r.sub(Q, ne),
            ne = r.mul(U, ne),
            ae = r.add(ae, ne),
            Q = r.mul(J, ae),
            $ = r.add($, Q),
            Q = r.mul(xe, ae),
            Y = r.mul(ie, Y),
            Y = r.sub(Y, Q),
            Q = r.mul(ie, J),
            D = r.mul(xe, D),
            D = r.add(D, Q),
            new R(Y,$,D)
        }
        subtract(j) {
            return this.add(j.negate())
        }
        is0() {
            return this.equals(R.ZERO)
        }
        multiply(j) {
            const {endo: A} = e;
            if (!s.isValidNot0(j))
                throw new Error("invalid scalar: out of range");
            let E, C;
            const O = z => q.cached(this, z, G => G5(R, G));
            if (A) {
                const {k1neg: z, k1: G, k2neg: Y, k2: $} = k(j)
                  , {p: D, f: U} = O(G)
                  , {p: W, f: Q} = O($);
                C = U.add(Q),
                E = M(A.beta, D, W, z, Y)
            } else {
                const {p: z, f: G} = O(j);
                E = z,
                C = G
            }
            return G5(R, [E, C])[0]
        }
        multiplyUnsafe(j) {
            const {endo: A} = e
              , E = this;
            if (!s.isValid(j))
                throw new Error("invalid scalar: out of range");
            if (j === dc || E.is0())
                return R.ZERO;
            if (j === Bp)
                return E;
            if (q.hasCache(this))
                return this.multiply(j);
            if (A) {
                const {k1neg: C, k1: O, k2neg: z, k2: G} = k(j)
                  , {p1: Y, p2: $} = $ge(R, E, O, G);
                return M(A.beta, Y, $, C, z)
            } else
                return q.unsafe(E, j)
        }
        multiplyAndAddUnsafe(j, A, E) {
            const C = this.multiplyUnsafe(A).add(j.multiplyUnsafe(E));
            return C.is0() ? void 0 : C
        }
        toAffine(j) {
            return B(this, j)
        }
        isTorsionFree() {
            const {isTorsionFree: j} = e;
            return o === Bp ? !0 : j ? j(R, this) : q.unsafe(this, a).is0()
        }
        clearCofactor() {
            const {clearCofactor: j} = e;
            return o === Bp ? this : j ? j(R, this) : this.multiplyUnsafe(o)
        }
        isSmallOrder() {
            return this.multiplyUnsafe(o).is0()
        }
        toBytes(j=!0) {
            return V2(j, "isCompressed"),
            this.assertValidity(),
            g(R, this, j)
        }
        toHex(j=!0) {
            return Mp(this.toBytes(j))
        }
        toString() {
            return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`
        }
        get px() {
            return this.X
        }
        get py() {
            return this.X
        }
        get pz() {
            return this.Z
        }
        toRawBytes(j=!0) {
            return this.toBytes(j)
        }
        _setWindowSize(j) {
            this.precompute(j)
        }
        static normalizeZ(j) {
            return G5(R, j)
        }
        static msm(j, A) {
            return Hge(R, s, j, A)
        }
        static fromPrivateKey(j) {
            return R.BASE.multiply(bp(s, j))
        }
    }
    R.BASE = new R(i.Gx,i.Gy,r.ONE),
    R.ZERO = new R(r.ZERO,r.ONE,r.ZERO),
    R.Fp = r,
    R.Fn = s;
    const L = s.BITS
      , q = new zge(R,e.endo ? Math.ceil(L / 2) : L);
    return R.BASE.precompute(8),
    R
}
function PH(n) {
    return Uint8Array.of(n ? 2 : 3)
}
function jH(n, e) {
    return {
        secretKey: e.BYTES,
        publicKey: 1 + n.BYTES,
        publicKeyUncompressed: 1 + 2 * n.BYTES,
        publicKeyHasPrefix: !0,
        signature: 2 * e.BYTES
    }
}
function sye(n, e={}) {
    const {Fn: t} = n
      , r = e.randomBytes || Kf
      , s = Object.assign(jH(n.Fp, t), {
        seed: IH(t.ORDER)
    });
    function i(p) {
        try {
            return !!bp(t, p)
        } catch {
            return !1
        }
    }
    function o(p, g) {
        const {publicKey: w, publicKeyUncompressed: b} = s;
        try {
            const v = p.length;
            return g === !0 && v !== w || g === !1 && v !== b ? !1 : !!n.fromBytes(p)
        } catch {
            return !1
        }
    }
    function a(p=r(s.seed)) {
        return Lge(ff(p, s.seed, "seed"), t.ORDER)
    }
    function l(p, g=!0) {
        return n.BASE.multiply(bp(t, p)).toBytes(g)
    }
    function u(p) {
        const g = a(p);
        return {
            secretKey: g,
            publicKey: l(g)
        }
    }
    function d(p) {
        if (typeof p == "bigint")
            return !1;
        if (p instanceof n)
            return !0;
        const {secretKey: g, publicKey: w, publicKeyUncompressed: b} = s;
        if (t.allowedLengths || g === w)
            return;
        const v = Ls("key", p).length;
        return v === w || v === b
    }
    function h(p, g, w=!0) {
        if (d(p) === !0)
            throw new Error("first arg must be private key");
        if (d(g) === !1)
            throw new Error("second arg must be public key");
        const b = bp(t, p);
        return n.fromHex(g).multiply(b).toBytes(w)
    }
    return Object.freeze({
        getPublicKey: l,
        getSharedSecret: h,
        keygen: u,
        Point: n,
        utils: {
            isValidSecretKey: i,
            isValidPublicKey: o,
            randomSecretKey: a,
            isValidPrivateKey: i,
            randomPrivateKey: a,
            normPrivateKeyToScalar: p => bp(t, p),
            precompute(p=8, g=n.BASE) {
                return g.precompute(p, !1)
            }
        },
        lengths: s
    })
}
function iye(n, e, t={}) {
    hx(e),
    vx(t, {}, {
        hmac: "function",
        lowS: "boolean",
        randomBytes: "function",
        bits2int: "function",
        bits2int_modN: "function"
    });
    const r = t.randomBytes || Kf
      , s = t.hmac || ( (A, ...E) => yx(e, A, Ou(...E)))
      , {Fp: i, Fn: o} = n
      , {ORDER: a, BITS: l} = o
      , {keygen: u, getPublicKey: d, getSharedSecret: h, utils: p, lengths: g} = sye(n, t)
      , w = {
        prehash: !1,
        lowS: typeof t.lowS == "boolean" ? t.lowS : !1,
        format: void 0,
        extraEntropy: !1
    }
      , b = "compact";
    function v(A) {
        const E = a >> Bp;
        return A > E
    }
    function S(A, E) {
        if (!o.isValidNot0(E))
            throw new Error(`invalid signature ${A}: out of range 1..Point.Fn.ORDER`);
        return E
    }
    function N(A, E) {
        mC(E);
        const C = g.signature
          , O = E === "compact" ? C : E === "recovered" ? C + 1 : void 0;
        return ff(A, O, `${E} signature`)
    }
    class _ {
        constructor(E, C, O) {
            this.r = S("r", E),
            this.s = S("s", C),
            O != null && (this.recovery = O),
            Object.freeze(this)
        }
        static fromBytes(E, C=b) {
            N(E, C);
            let O;
            if (C === "der") {
                const {r: $, s: D} = Jl.toSig(ff(E));
                return new _($,D)
            }
            C === "recovered" && (O = E[0],
            C = "compact",
            E = E.subarray(1));
            const z = o.BYTES
              , G = E.subarray(0, z)
              , Y = E.subarray(z, z * 2);
            return new _(o.fromBytes(G),o.fromBytes(Y),O)
        }
        static fromHex(E, C) {
            return this.fromBytes($2(E), C)
        }
        addRecoveryBit(E) {
            return new _(this.r,this.s,E)
        }
        recoverPublicKey(E) {
            const C = i.ORDER
              , {r: O, s: z, recovery: G} = this;
            if (G == null || ![0, 1, 2, 3].includes(G))
                throw new Error("recovery id invalid");
            if (a * OH < C && G > 1)
                throw new Error("recovery id is ambiguous for h>1 curve");
            const Y = G === 2 || G === 3 ? O + a : O;
            if (!i.isValid(Y))
                throw new Error("recovery id 2 or 3 invalid");
            const $ = i.toBytes(Y)
              , D = n.fromBytes(Ou(PH((G & 1) === 0), $))
              , U = o.inv(Y)
              , W = k(Ls("msgHash", E))
              , Q = o.create(-W * U)
              , J = o.create(z * U)
              , ne = n.BASE.multiplyUnsafe(Q).add(D.multiplyUnsafe(J));
            if (ne.is0())
                throw new Error("point at infinify");
            return ne.assertValidity(),
            ne
        }
        hasHighS() {
            return v(this.s)
        }
        toBytes(E=b) {
            if (mC(E),
            E === "der")
                return $2(Jl.hexFromSig(this));
            const C = o.toBytes(this.r)
              , O = o.toBytes(this.s);
            if (E === "recovered") {
                if (this.recovery == null)
                    throw new Error("recovery bit must be present");
                return Ou(Uint8Array.of(this.recovery), C, O)
            }
            return Ou(C, O)
        }
        toHex(E) {
            return Mp(this.toBytes(E))
        }
        assertValidity() {}
        static fromCompact(E) {
            return _.fromBytes(Ls("sig", E), "compact")
        }
        static fromDER(E) {
            return _.fromBytes(Ls("sig", E), "der")
        }
        normalizeS() {
            return this.hasHighS() ? new _(this.r,o.neg(this.s),this.recovery) : this
        }
        toDERRawBytes() {
            return this.toBytes("der")
        }
        toDERHex() {
            return Mp(this.toBytes("der"))
        }
        toCompactRawBytes() {
            return this.toBytes("compact")
        }
        toCompactHex() {
            return Mp(this.toBytes("compact"))
        }
    }
    const I = t.bits2int || function(A) {
        if (A.length > 8192)
            throw new Error("input is too large");
        const E = wx(A)
          , C = A.length * 8 - l;
        return C > 0 ? E >> BigInt(C) : E
    }
      , k = t.bits2int_modN || function(A) {
        return o.create(I(A))
    }
      , B = qy(l);
    function P(A) {
        return hC("num < 2^" + l, A, dc, B),
        o.toBytes(A)
    }
    function M(A, E) {
        return ff(A, void 0, "message"),
        E ? ff(e(A), void 0, "prehashed message") : A
    }
    function R(A, E, C) {
        if (["recovered", "canonical"].some(J => J in C))
            throw new Error("sign() legacy options not supported");
        const {lowS: O, prehash: z, extraEntropy: G} = X5(C, w);
        A = M(A, z);
        const Y = k(A)
          , $ = bp(o, E)
          , D = [P($), P(Y)];
        if (G != null && G !== !1) {
            const J = G === !0 ? r(g.secretKey) : G;
            D.push(Ls("extraEntropy", J))
        }
        const U = Ou(...D)
          , W = Y;
        function Q(J) {
            const ne = I(J);
            if (!o.isValidNot0(ne))
                return;
            const ie = o.inv(ne)
              , ae = n.BASE.multiply(ne).toAffine()
              , xe = o.create(ae.x);
            if (xe === dc)
                return;
            const ue = o.create(ie * o.create(W + xe * $));
            if (ue === dc)
                return;
            let ce = (ae.x === xe ? 0 : 2) | Number(ae.y & Bp)
              , me = ue;
            return O && v(ue) && (me = o.neg(ue),
            ce ^= 1),
            new _(xe,me,ce)
        }
        return {
            seed: U,
            k2sig: Q
        }
    }
    function L(A, E, C={}) {
        A = Ls("message", A);
        const {seed: O, k2sig: z} = R(A, E, C);
        return Dge(e.outputLen, o.BYTES, s)(O, z)
    }
    function q(A) {
        let E;
        const C = typeof A == "string" || fx(A)
          , O = !C && A !== null && typeof A == "object" && typeof A.r == "bigint" && typeof A.s == "bigint";
        if (!C && !O)
            throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
        if (O)
            E = new _(A.r,A.s);
        else if (C) {
            try {
                E = _.fromBytes(Ls("sig", A), "der")
            } catch (z) {
                if (!(z instanceof Jl.Err))
                    throw z
            }
            if (!E)
                try {
                    E = _.fromBytes(Ls("sig", A), "compact")
                } catch {
                    return !1
                }
        }
        return E || !1
    }
    function H(A, E, C, O={}) {
        const {lowS: z, prehash: G, format: Y} = X5(O, w);
        if (C = Ls("publicKey", C),
        E = M(Ls("message", E), G),
        "strict"in O)
            throw new Error("options.strict was renamed to lowS");
        const $ = Y === void 0 ? q(A) : _.fromBytes(Ls("sig", A), Y);
        if ($ === !1)
            return !1;
        try {
            const D = n.fromBytes(C);
            if (z && $.hasHighS())
                return !1;
            const {r: U, s: W} = $
              , Q = k(E)
              , J = o.inv(W)
              , ne = o.create(Q * J)
              , ie = o.create(U * J)
              , ae = n.BASE.multiplyUnsafe(ne).add(D.multiplyUnsafe(ie));
            return ae.is0() ? !1 : o.create(ae.x) === U
        } catch {
            return !1
        }
    }
    function j(A, E, C={}) {
        const {prehash: O} = X5(C, w);
        return E = M(E, O),
        _.fromBytes(A, "recovered").recoverPublicKey(E).toBytes()
    }
    return Object.freeze({
        keygen: u,
        getPublicKey: d,
        getSharedSecret: h,
        utils: p,
        lengths: g,
        Point: n,
        sign: L,
        verify: H,
        recoverPublicKey: j,
        Signature: _,
        hash: e
    })
}
function oye(n) {
    const e = {
        a: n.a,
        b: n.b,
        p: n.Fp.ORDER,
        n: n.n,
        h: n.h,
        Gx: n.Gx,
        Gy: n.Gy
    }
      , t = n.Fp;
    let r = n.allowedPrivateKeyLengths ? Array.from(new Set(n.allowedPrivateKeyLengths.map(o => Math.ceil(o / 2)))) : void 0;
    const s = cd(e.n, {
        BITS: n.nBitLength,
        allowedLengths: r,
        modFromBytes: n.wrapPrivateKey
    })
      , i = {
        Fp: t,
        Fn: s,
        allowInfinityPoint: n.allowInfinityPoint,
        endo: n.endo,
        isTorsionFree: n.isTorsionFree,
        clearCofactor: n.clearCofactor,
        fromBytes: n.fromBytes,
        toBytes: n.toBytes
    };
    return {
        CURVE: e,
        curveOpts: i
    }
}
function aye(n) {
    const {CURVE: e, curveOpts: t} = oye(n)
      , r = {
        hmac: n.hmac,
        randomBytes: n.randomBytes,
        lowS: n.lowS,
        bits2int: n.bits2int,
        bits2int_modN: n.bits2int_modN
    };
    return {
        CURVE: e,
        curveOpts: t,
        hash: n.hash,
        ecdsaOpts: r
    }
}
function lye(n, e) {
    const t = e.Point;
    return Object.assign({}, e, {
        ProjectivePoint: t,
        CURVE: Object.assign({}, n, DH(t.Fn.ORDER, t.Fn.BITS))
    })
}
function cye(n) {
    const {CURVE: e, curveOpts: t, hash: r, ecdsaOpts: s} = aye(n)
      , i = rye(e, t)
      , o = iye(i, r, s);
    return lye(n, o)
}
function gC(n, e) {
    const t = r => cye({
        ...n,
        hash: r
    });
    return {
        ...t(e),
        create: t
    }
}
const LH = {
    p: BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"),
    n: BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),
    h: BigInt(1),
    a: BigInt("0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc"),
    b: BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"),
    Gx: BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),
    Gy: BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5")
}
  , FH = {
    p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff"),
    n: BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973"),
    h: BigInt(1),
    a: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000fffffffc"),
    b: BigInt("0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef"),
    Gx: BigInt("0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7"),
    Gy: BigInt("0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f")
}
  , UH = {
    p: BigInt("0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),
    n: BigInt("0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409"),
    h: BigInt(1),
    a: BigInt("0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc"),
    b: BigInt("0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00"),
    Gx: BigInt("0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66"),
    Gy: BigInt("0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650")
}
  , uye = cd(LH.p)
  , dye = cd(FH.p)
  , fye = cd(UH.p)
  , hye = gC({
    ...LH,
    Fp: uye,
    lowS: !1
}, mx);
gC({
    ...FH,
    Fp: dye,
    lowS: !1
}, bme),
gC({
    ...UH,
    Fp: fye,
    lowS: !1,
    allowedPrivateKeyLengths: [130, 131, 132]
}, yme);
const pye = hye
  , zH = "base10"
  , ni = "base16"
  , xi = "base64pad"
  , Pu = "base64url"
  , Gy = "utf8"
  , $H = 0
  , yc = 1
  , Wy = 2
  , mye = 0
  , ZR = 1
  , Tg = 12
  , V_ = 32;
function gye() {
    const n = pC.utils.randomPrivateKey()
      , e = pC.getPublicKey(n);
    return {
        privateKey: Ni(n, ni),
        publicKey: Ni(e, ni)
    }
}
function yC() {
    const n = Kf(V_);
    return Ni(n, ni)
}
function yye(n, e) {
    const t = pC.getSharedSecret(Bo(n, ni), Bo(e, ni))
      , r = kge(bx, t, void 0, void 0, V_);
    return Ni(r, ni)
}
function qw(n) {
    const e = bx(Bo(n, ni));
    return Ni(e, ni)
}
function Co(n) {
    const e = bx(Bo(n, Gy));
    return Ni(e, ni)
}
function HH(n) {
    return Bo(`${n}`, zH)
}
function jf(n) {
    return Number(Ni(n, zH))
}
function VH(n) {
    return n.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "")
}
function qH(n) {
    const e = n.replace(/-/g, "+").replace(/_/g, "/")
      , t = (4 - e.length % 4) % 4;
    return e + "=".repeat(t)
}
function bye(n) {
    const e = HH(typeof n.type < "u" ? n.type : $H);
    if (jf(e) === yc && typeof n.senderPublicKey > "u")
        throw new Error("Missing sender public key for type 1 envelope");
    const t = typeof n.senderPublicKey < "u" ? Bo(n.senderPublicKey, ni) : void 0
      , r = typeof n.iv < "u" ? Bo(n.iv, ni) : Kf(Tg)
      , s = Bo(n.symKey, ni)
      , i = yH(s, r).encrypt(Bo(n.message, Gy))
      , o = GH({
        type: e,
        sealed: i,
        iv: r,
        senderPublicKey: t
    });
    return n.encoding === Pu ? VH(o) : o
}
function wye(n) {
    const e = Bo(n.symKey, ni)
      , {sealed: t, iv: r} = sy({
        encoded: n.encoded,
        encoding: n.encoding
    })
      , s = yH(e, r).decrypt(t);
    if (s === null)
        throw new Error("Failed to decrypt");
    return Ni(s, Gy)
}
function vye(n, e) {
    const t = HH(Wy)
      , r = Kf(Tg)
      , s = Bo(n, Gy)
      , i = GH({
        type: t,
        sealed: s,
        iv: r
    });
    return e === Pu ? VH(i) : i
}
function xye(n, e) {
    const {sealed: t} = sy({
        encoded: n,
        encoding: e
    });
    return Ni(t, Gy)
}
function GH(n) {
    if (jf(n.type) === Wy)
        return Ni(Dg([n.type, n.sealed]), xi);
    if (jf(n.type) === yc) {
        if (typeof n.senderPublicKey > "u")
            throw new Error("Missing sender public key for type 1 envelope");
        return Ni(Dg([n.type, n.senderPublicKey, n.iv, n.sealed]), xi)
    }
    return Ni(Dg([n.type, n.iv, n.sealed]), xi)
}
function sy(n) {
    const e = (n.encoding || xi) === Pu ? qH(n.encoded) : n.encoded
      , t = Bo(e, xi)
      , r = t.slice(mye, ZR)
      , s = ZR;
    if (jf(r) === yc) {
        const l = s + V_
          , u = l + Tg
          , d = t.slice(s, l)
          , h = t.slice(l, u)
          , p = t.slice(u);
        return {
            type: r,
            sealed: p,
            iv: h,
            senderPublicKey: d
        }
    }
    if (jf(r) === Wy) {
        const l = t.slice(s)
          , u = Kf(Tg);
        return {
            type: r,
            sealed: l,
            iv: u
        }
    }
    const i = s + Tg
      , o = t.slice(s, i)
      , a = t.slice(i);
    return {
        type: r,
        sealed: a,
        iv: o
    }
}
function Eye(n, e) {
    const t = sy({
        encoded: n,
        encoding: e?.encoding
    });
    return WH({
        type: jf(t.type),
        senderPublicKey: typeof t.senderPublicKey < "u" ? Ni(t.senderPublicKey, ni) : void 0,
        receiverPublicKey: e?.receiverPublicKey
    })
}
function WH(n) {
    const e = n?.type || $H;
    if (e === yc) {
        if (typeof n?.senderPublicKey > "u")
            throw new Error("missing sender public key");
        if (typeof n?.receiverPublicKey > "u")
            throw new Error("missing receiver public key")
    }
    return {
        type: e,
        senderPublicKey: n?.senderPublicKey,
        receiverPublicKey: n?.receiverPublicKey
    }
}
function JR(n) {
    return n.type === yc && typeof n.senderPublicKey == "string" && typeof n.receiverPublicKey == "string"
}
function eO(n) {
    return n.type === Wy
}
function Sye(n) {
    const e = Buffer.from(n.x, "base64")
      , t = Buffer.from(n.y, "base64");
    return Dg([new Uint8Array([4]), e, t])
}
function Aye(n, e) {
    const [t,r,s] = n.split(".")
      , i = Buffer.from(qH(s), "base64");
    if (i.length !== 64)
        throw new Error("Invalid signature length");
    const o = i.slice(0, 32)
      , a = i.slice(32, 64)
      , l = `${t}.${r}`
      , u = bx(l)
      , d = Sye(e);
    if (!pye.verify(Dg([o, a]), u, d))
        throw new Error("Invalid signature");
    return rC(n).payload
}
const Cye = "irn";
function W2(n) {
    return n?.relay || {
        protocol: Cye
    }
}
function wp(n) {
    const e = Bpe[n];
    if (typeof e > "u")
        throw new Error(`Relay Protocol not supported: ${n}`);
    return e
}
var _ye = Object.defineProperty
  , kye = Object.defineProperties
  , Nye = Object.getOwnPropertyDescriptors
  , tO = Object.getOwnPropertySymbols
  , Dye = Object.prototype.hasOwnProperty
  , Tye = Object.prototype.propertyIsEnumerable
  , nO = (n, e, t) => e in n ? _ye(n, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : n[e] = t
  , Q5 = (n, e) => {
    for (var t in e || (e = {}))
        Dye.call(e, t) && nO(n, t, e[t]);
    if (tO)
        for (var t of tO(e))
            Tye.call(e, t) && nO(n, t, e[t]);
    return n
}
  , Iye = (n, e) => kye(n, Nye(e));
function Mye(n, e="-") {
    const t = {}
      , r = "relay" + e;
    return Object.keys(n).forEach(s => {
        if (s.startsWith(r)) {
            const i = s.replace(r, "")
              , o = n[s];
            t[i] = o
        }
    }
    ),
    t
}
function rO(n) {
    if (!n.includes("wc:")) {
        const u = X$(n);
        u != null && u.includes("wc:") && (n = u)
    }
    n = n.includes("wc://") ? n.replace("wc://", "") : n,
    n = n.includes("wc:") ? n.replace("wc:", "") : n;
    const e = n.indexOf(":")
      , t = n.indexOf("?") !== -1 ? n.indexOf("?") : void 0
      , r = n.substring(0, e)
      , s = n.substring(e + 1, t).split("@")
      , i = typeof t < "u" ? n.substring(t) : ""
      , o = new URLSearchParams(i)
      , a = Object.fromEntries(o.entries())
      , l = typeof a.methods == "string" ? a.methods.split(",") : void 0;
    return {
        protocol: r,
        topic: Bye(s[0]),
        version: parseInt(s[1], 10),
        symKey: a.symKey,
        relay: Mye(a),
        methods: l,
        expiryTimestamp: a.expiryTimestamp ? parseInt(a.expiryTimestamp, 10) : void 0
    }
}
function Bye(n) {
    return n.startsWith("//") ? n.substring(2) : n
}
function Rye(n, e="-") {
    const t = "relay"
      , r = {};
    return Object.keys(n).forEach(s => {
        const i = s
          , o = t + e + i;
        n[i] && (r[o] = n[i])
    }
    ),
    r
}
function sO(n) {
    const e = new URLSearchParams
      , t = Q5(Q5(Iye(Q5({}, Rye(n.relay)), {
        symKey: n.symKey
    }), n.expiryTimestamp && {
        expiryTimestamp: n.expiryTimestamp.toString()
    }), n.methods && {
        methods: n.methods.join(",")
    });
    return Object.entries(t).sort( ([r], [s]) => r.localeCompare(s)).forEach( ([r,s]) => {
        s !== void 0 && e.append(r, String(s))
    }
    ),
    `${n.protocol}:${n.topic}@${n.version}?${e}`
}
function X1(n, e, t) {
    return `${n}?wc_ev=${t}&topic=${e}`
}
var Oye = Object.defineProperty
  , Pye = Object.defineProperties
  , jye = Object.getOwnPropertyDescriptors
  , iO = Object.getOwnPropertySymbols
  , Lye = Object.prototype.hasOwnProperty
  , Fye = Object.prototype.propertyIsEnumerable
  , oO = (n, e, t) => e in n ? Oye(n, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : n[e] = t
  , Uye = (n, e) => {
    for (var t in e || (e = {}))
        Lye.call(e, t) && oO(n, t, e[t]);
    if (iO)
        for (var t of iO(e))
            Fye.call(e, t) && oO(n, t, e[t]);
    return n
}
  , zye = (n, e) => Pye(n, jye(e));
function M0(n) {
    const e = [];
    return n.forEach(t => {
        const [r,s] = t.split(":");
        e.push(`${r}:${s}`)
    }
    ),
    e
}
function YH(n) {
    const e = [];
    return Object.values(n).forEach(t => {
        e.push(...M0(t.accounts))
    }
    ),
    [...new Set(e)]
}
function $ye(n) {
    const e = [];
    return Object.values(n).forEach(t => {
        e.push(...t.methods)
    }
    ),
    [...new Set(e)]
}
function Hye(n) {
    const e = [];
    return Object.values(n).forEach(t => {
        e.push(...t.events)
    }
    ),
    [...new Set(e)]
}
function Vye(n, e) {
    const t = [];
    return Object.values(n).forEach(r => {
        M0(r.accounts).includes(e) && t.push(...r.methods)
    }
    ),
    t
}
function qye(n, e) {
    const t = [];
    return Object.values(n).forEach(r => {
        M0(r.accounts).includes(e) && t.push(...r.events)
    }
    ),
    t
}
function xx(n) {
    return n.includes(":")
}
function vp(n) {
    return xx(n) ? n.split(":")[0] : n
}
function aO(n) {
    var e, t, r;
    const s = {};
    if (!Za(n))
        return s;
    for (const [i,o] of Object.entries(n)) {
        const a = xx(i) ? [i] : o.chains
          , l = o.methods || []
          , u = o.events || []
          , d = vp(i);
        s[d] = zye(Uye({}, s[d]), {
            chains: Qa(a, (e = s[d]) == null ? void 0 : e.chains),
            methods: Qa(l, (t = s[d]) == null ? void 0 : t.methods),
            events: Qa(u, (r = s[d]) == null ? void 0 : r.events)
        })
    }
    return s
}
function Gye(n) {
    const e = {};
    return n?.forEach(t => {
        var r;
        const [s,i] = t.split(":");
        e[s] || (e[s] = {
            accounts: [],
            chains: [],
            events: [],
            methods: []
        }),
        e[s].accounts.push(t),
        (r = e[s].chains) == null || r.push(`${s}:${i}`)
    }
    ),
    e
}
function lO(n, e) {
    e = e.map(r => r.replace("did:pkh:", ""));
    const t = Gye(e);
    for (const [r,s] of Object.entries(t))
        s.methods ? s.methods = Qa(s.methods, n) : s.methods = n,
        s.events = ["chainChanged", "accountsChanged"];
    return t
}
function Wye(n, e) {
    var t, r, s, i, o, a;
    const l = aO(n)
      , u = aO(e)
      , d = {}
      , h = Object.keys(l).concat(Object.keys(u));
    for (const p of h)
        d[p] = {
            chains: Qa((t = l[p]) == null ? void 0 : t.chains, (r = u[p]) == null ? void 0 : r.chains),
            methods: Qa((s = l[p]) == null ? void 0 : s.methods, (i = u[p]) == null ? void 0 : i.methods),
            events: Qa((o = l[p]) == null ? void 0 : o.events, (a = u[p]) == null ? void 0 : a.events)
        };
    return d
}
const Yye = {
    INVALID_METHOD: {
        message: "Invalid method.",
        code: 1001
    },
    INVALID_EVENT: {
        message: "Invalid event.",
        code: 1002
    },
    INVALID_UPDATE_REQUEST: {
        message: "Invalid update request.",
        code: 1003
    },
    INVALID_EXTEND_REQUEST: {
        message: "Invalid extend request.",
        code: 1004
    },
    INVALID_SESSION_SETTLE_REQUEST: {
        message: "Invalid session settle request.",
        code: 1005
    },
    UNAUTHORIZED_METHOD: {
        message: "Unauthorized method.",
        code: 3001
    },
    UNAUTHORIZED_EVENT: {
        message: "Unauthorized event.",
        code: 3002
    },
    UNAUTHORIZED_UPDATE_REQUEST: {
        message: "Unauthorized update request.",
        code: 3003
    },
    UNAUTHORIZED_EXTEND_REQUEST: {
        message: "Unauthorized extend request.",
        code: 3004
    },
    USER_REJECTED: {
        message: "User rejected.",
        code: 5e3
    },
    USER_REJECTED_CHAINS: {
        message: "User rejected chains.",
        code: 5001
    },
    USER_REJECTED_METHODS: {
        message: "User rejected methods.",
        code: 5002
    },
    USER_REJECTED_EVENTS: {
        message: "User rejected events.",
        code: 5003
    },
    UNSUPPORTED_CHAINS: {
        message: "Unsupported chains.",
        code: 5100
    },
    UNSUPPORTED_METHODS: {
        message: "Unsupported methods.",
        code: 5101
    },
    UNSUPPORTED_EVENTS: {
        message: "Unsupported events.",
        code: 5102
    },
    UNSUPPORTED_ACCOUNTS: {
        message: "Unsupported accounts.",
        code: 5103
    },
    UNSUPPORTED_NAMESPACE_KEY: {
        message: "Unsupported namespace key.",
        code: 5104
    },
    USER_DISCONNECTED: {
        message: "User disconnected.",
        code: 6e3
    },
    SESSION_SETTLEMENT_FAILED: {
        message: "Session settlement failed.",
        code: 7e3
    },
    WC_METHOD_UNSUPPORTED: {
        message: "Unsupported wc_ method.",
        code: 10001
    }
}
  , Kye = {
    NOT_INITIALIZED: {
        message: "Not initialized.",
        code: 1
    },
    NO_MATCHING_KEY: {
        message: "No matching key.",
        code: 2
    },
    RESTORE_WILL_OVERRIDE: {
        message: "Restore will override.",
        code: 3
    },
    RESUBSCRIBED: {
        message: "Resubscribed.",
        code: 4
    },
    MISSING_OR_INVALID: {
        message: "Missing or invalid.",
        code: 5
    },
    EXPIRED: {
        message: "Expired.",
        code: 6
    },
    UNKNOWN_TYPE: {
        message: "Unknown type.",
        code: 7
    },
    MISMATCHED_TOPIC: {
        message: "Mismatched topic.",
        code: 8
    },
    NON_CONFORMING_NAMESPACES: {
        message: "Non conforming namespaces.",
        code: 9
    }
};
function Fe(n, e) {
    const {message: t, code: r} = Kye[n];
    return {
        message: e ? `${t} ${e}` : t,
        code: r
    }
}
function Yn(n, e) {
    const {message: t, code: r} = Yye[n];
    return {
        message: e ? `${t} ${e}` : t,
        code: r
    }
}
function Oo(n, e) {
    return !!Array.isArray(n)
}
function Za(n) {
    return Object.getPrototypeOf(n) === Object.prototype && Object.keys(n).length
}
function ts(n) {
    return typeof n > "u"
}
function Lr(n, e) {
    return e && ts(n) ? !0 : typeof n == "string" && !!n.trim().length
}
function q_(n, e) {
    return typeof n == "number" && !isNaN(n)
}
function Xye(n, e) {
    const {requiredNamespaces: t} = e
      , r = Object.keys(n.namespaces)
      , s = Object.keys(t);
    let i = !0;
    return df(s, r) ? (r.forEach(o => {
        const {accounts: a, methods: l, events: u} = n.namespaces[o]
          , d = M0(a)
          , h = t[o];
        (!df(q$(o, h), d) || !df(h.methods, l) || !df(h.events, u)) && (i = !1)
    }
    ),
    i) : !1
}
function Y2(n) {
    return Lr(n, !1) && n.includes(":") ? n.split(":").length === 2 : !1
}
function Qye(n) {
    if (Lr(n, !1) && n.includes(":")) {
        const e = n.split(":");
        if (e.length === 3) {
            const t = e[0] + ":" + e[1];
            return !!e[2] && Y2(t)
        }
    }
    return !1
}
function Zye(n) {
    function e(t) {
        try {
            return typeof new URL(t) < "u"
        } catch {
            return !1
        }
    }
    try {
        if (Lr(n, !1)) {
            if (e(n))
                return !0;
            const t = X$(n);
            return e(t)
        }
    } catch {}
    return !1
}
function Jye(n) {
    var e;
    return (e = n?.proposer) == null ? void 0 : e.publicKey
}
function ebe(n) {
    return n?.topic
}
function tbe(n, e) {
    let t = null;
    return Lr(n?.publicKey, !1) || (t = Fe("MISSING_OR_INVALID", `${e} controller public key should be a string`)),
    t
}
function cO(n) {
    let e = !0;
    return Oo(n) ? n.length && (e = n.every(t => Lr(t, !1))) : e = !1,
    e
}
function nbe(n, e, t) {
    let r = null;
    return Oo(e) && e.length ? e.forEach(s => {
        r || Y2(s) || (r = Yn("UNSUPPORTED_CHAINS", `${t}, chain ${s} should be a string and conform to "namespace:chainId" format`))
    }
    ) : Y2(n) || (r = Yn("UNSUPPORTED_CHAINS", `${t}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)),
    r
}
function rbe(n, e, t) {
    let r = null;
    return Object.entries(n).forEach( ([s,i]) => {
        if (r)
            return;
        const o = nbe(s, q$(s, i), `${e} ${t}`);
        o && (r = o)
    }
    ),
    r
}
function sbe(n, e) {
    let t = null;
    return Oo(n) ? n.forEach(r => {
        t || Qye(r) || (t = Yn("UNSUPPORTED_ACCOUNTS", `${e}, account ${r} should be a string and conform to "namespace:chainId:address" format`))
    }
    ) : t = Yn("UNSUPPORTED_ACCOUNTS", `${e}, accounts should be an array of strings conforming to "namespace:chainId:address" format`),
    t
}
function ibe(n, e) {
    let t = null;
    return Object.values(n).forEach(r => {
        if (t)
            return;
        const s = sbe(r?.accounts, `${e} namespace`);
        s && (t = s)
    }
    ),
    t
}
function obe(n, e) {
    let t = null;
    return cO(n?.methods) ? cO(n?.events) || (t = Yn("UNSUPPORTED_EVENTS", `${e}, events should be an array of strings or empty array for no events`)) : t = Yn("UNSUPPORTED_METHODS", `${e}, methods should be an array of strings or empty array for no methods`),
    t
}
function KH(n, e) {
    let t = null;
    return Object.values(n).forEach(r => {
        if (t)
            return;
        const s = obe(r, `${e}, namespace`);
        s && (t = s)
    }
    ),
    t
}
function abe(n, e, t) {
    let r = null;
    if (n && Za(n)) {
        const s = KH(n, e);
        s && (r = s);
        const i = rbe(n, e, t);
        i && (r = i)
    } else
        r = Fe("MISSING_OR_INVALID", `${e}, ${t} should be an object with data`);
    return r
}
function Z5(n, e) {
    let t = null;
    if (n && Za(n)) {
        const r = KH(n, e);
        r && (t = r);
        const s = ibe(n, e);
        s && (t = s)
    } else
        t = Fe("MISSING_OR_INVALID", `${e}, namespaces should be an object with data`);
    return t
}
function XH(n) {
    return Lr(n.protocol, !0)
}
function lbe(n, e) {
    let t = !1;
    return n ? n && Oo(n) && n.length && n.forEach(r => {
        t = XH(r)
    }
    ) : t = !0,
    t
}
function cbe(n) {
    return typeof n == "number"
}
function yi(n) {
    return typeof n < "u" && typeof n !== null
}
function ube(n) {
    return !(!n || typeof n != "object" || !n.code || !q_(n.code) || !n.message || !Lr(n.message, !1))
}
function dbe(n) {
    return !(ts(n) || !Lr(n.method, !1))
}
function fbe(n) {
    return !(ts(n) || ts(n.result) && ts(n.error) || !q_(n.id) || !Lr(n.jsonrpc, !1))
}
function hbe(n) {
    return !(ts(n) || !Lr(n.name, !1))
}
function uO(n, e) {
    return !(!Y2(e) || !YH(n).includes(e))
}
function pbe(n, e, t) {
    return Lr(t, !1) ? Vye(n, e).includes(t) : !1
}
function mbe(n, e, t) {
    return Lr(t, !1) ? qye(n, e).includes(t) : !1
}
function dO(n, e, t) {
    let r = null;
    const s = gbe(n)
      , i = ybe(e)
      , o = Object.keys(s)
      , a = Object.keys(i)
      , l = fO(Object.keys(n))
      , u = fO(Object.keys(e))
      , d = l.filter(h => !u.includes(h));
    return d.length && (r = Fe("NON_CONFORMING_NAMESPACES", `${t} namespaces keys don't satisfy requiredNamespaces.
      Required: ${d.toString()}
      Received: ${Object.keys(e).toString()}`)),
    df(o, a) || (r = Fe("NON_CONFORMING_NAMESPACES", `${t} namespaces chains don't satisfy required namespaces.
      Required: ${o.toString()}
      Approved: ${a.toString()}`)),
    Object.keys(e).forEach(h => {
        if (!h.includes(":") || r)
            return;
        const p = M0(e[h].accounts);
        p.includes(h) || (r = Fe("NON_CONFORMING_NAMESPACES", `${t} namespaces accounts don't satisfy namespace accounts for ${h}
        Required: ${h}
        Approved: ${p.toString()}`))
    }
    ),
    o.forEach(h => {
        r || (df(s[h].methods, i[h].methods) ? df(s[h].events, i[h].events) || (r = Fe("NON_CONFORMING_NAMESPACES", `${t} namespaces events don't satisfy namespace events for ${h}`)) : r = Fe("NON_CONFORMING_NAMESPACES", `${t} namespaces methods don't satisfy namespace methods for ${h}`))
    }
    ),
    r
}
function gbe(n) {
    const e = {};
    return Object.keys(n).forEach(t => {
        var r;
        t.includes(":") ? e[t] = n[t] : (r = n[t].chains) == null || r.forEach(s => {
            e[s] = {
                methods: n[t].methods,
                events: n[t].events
            }
        }
        )
    }
    ),
    e
}
function fO(n) {
    return [...new Set(n.map(e => e.includes(":") ? e.split(":")[0] : e))]
}
function ybe(n) {
    const e = {};
    return Object.keys(n).forEach(t => {
        t.includes(":") ? e[t] = n[t] : M0(n[t].accounts)?.forEach(s => {
            e[s] = {
                accounts: n[t].accounts.filter(i => i.includes(`${s}:`)),
                methods: n[t].methods,
                events: n[t].events
            }
        }
        )
    }
    ),
    e
}
function bbe(n, e) {
    return q_(n) && n <= e.max && n >= e.min
}
function hO() {
    const n = Hy();
    return new Promise(e => {
        switch (n) {
        case Zi.browser:
            e(wbe());
            break;
        case Zi.reactNative:
            e(vbe());
            break;
        case Zi.node:
            e(xbe());
            break;
        default:
            e(!0)
        }
    }
    )
}
function wbe() {
    return I0() && navigator?.onLine
}
async function vbe() {
    return ld() && typeof global < "u" && global != null && global.NetInfo ? (await (global == null ? void 0 : global.NetInfo.fetch()))?.isConnected : !0
}
function xbe() {
    return !0
}
function Ebe(n) {
    switch (Hy()) {
    case Zi.browser:
        Sbe(n);
        break;
    case Zi.reactNative:
        Abe(n);
        break
    }
}
function Sbe(n) {
    !ld() && I0() && (window.addEventListener("online", () => n(!0)),
    window.addEventListener("offline", () => n(!1)))
}
function Abe(n) {
    ld() && typeof global < "u" && global != null && global.NetInfo && global?.NetInfo.addEventListener(e => n(e?.isConnected))
}
function Cbe() {
    var n;
    return I0() && Dc.getDocument() ? ((n = Dc.getDocument()) == null ? void 0 : n.visibilityState) === "visible" : !0
}
const J5 = {};
class Ym {
    static get(e) {
        return J5[e]
    }
    static set(e, t) {
        J5[e] = t
    }
    static delete(e) {
        delete J5[e]
    }
}
function _be(n) {
    const e = D0.decode(n);
    if (e.length < 33)
        throw new Error("Too short to contain a public key");
    return e.slice(1, 33)
}
function kbe({publicKey: n, signature: e, payload: t}) {
    var r;
    const s = bC(t.method)
      , i = 128 | parseInt(((r = t.version) == null ? void 0 : r.toString()) || "4")
      , o = Tbe(t.address)
      , a = t.era === "00" ? new Uint8Array([0]) : bC(t.era);
    if (a.length !== 1 && a.length !== 2)
        throw new Error("Invalid era length");
    const l = parseInt(t.nonce, 16)
      , u = new Uint8Array([l & 255, l >> 8 & 255])
      , d = BigInt(`0x${Dbe(t.tip)}`)
      , h = Mbe(d)
      , p = new Uint8Array([0, ...n, o, ...e, ...a, ...u, ...h, ...s])
      , g = Ibe(p.length + 1);
    return new Uint8Array([...g, i, ...p])
}
function Nbe(n) {
    const e = bC(n)
      , t = jpe.blake2b(e, void 0, 32);
    return "0x" + Buffer.from(t).toString("hex")
}
function bC(n) {
    return new Uint8Array(n.replace(/^0x/, "").match(/.{1,2}/g).map(e => parseInt(e, 16)))
}
function Dbe(n) {
    return n.startsWith("0x") ? n.slice(2) : n
}
function Tbe(n) {
    const e = D0.decode(n)[0];
    return e === 42 ? 0 : e === 60 ? 2 : 1
}
function Ibe(n) {
    if (n < 64)
        return new Uint8Array([n << 2]);
    if (n < 16384) {
        const e = n << 2 | 1;
        return new Uint8Array([e & 255, e >> 8 & 255])
    } else if (n < 1 << 30) {
        const e = n << 2 | 2;
        return new Uint8Array([e & 255, e >> 8 & 255, e >> 16 & 255, e >> 24 & 255])
    } else
        throw new Error("Compact encoding > 2^30 not supported")
}
function Mbe(n) {
    if (n < BigInt(1) << BigInt(6))
        return new Uint8Array([Number(n << BigInt(2))]);
    if (n < BigInt(1) << BigInt(14)) {
        const e = n << BigInt(2) | BigInt(1);
        return new Uint8Array([Number(e & BigInt(255)), Number(e >> BigInt(8) & BigInt(255))])
    } else if (n < BigInt(1) << BigInt(30)) {
        const e = n << BigInt(2) | BigInt(2);
        return new Uint8Array([Number(e & BigInt(255)), Number(e >> BigInt(8) & BigInt(255)), Number(e >> BigInt(16) & BigInt(255)), Number(e >> BigInt(24) & BigInt(255))])
    } else
        throw new Error("BigInt compact encoding not supported > 2^30")
}
function Bbe(n) {
    const e = Uint8Array.from(Buffer.from(n.signature, "hex"))
      , t = _be(n.transaction.address)
      , r = kbe({
        publicKey: t,
        signature: e,
        payload: n.transaction
    })
      , s = Buffer.from(r).toString("hex");
    return Nbe(s)
}
function G_({logger: n, name: e}) {
    const t = typeof n == "string" ? V$({
        opts: {
            level: n,
            name: e
        }
    }).logger : n;
    return t.level = typeof n == "string" ? n : n.level,
    t
}
class Xf {
}
let Rbe = class extends Xf {
    constructor(e) {
        super()
    }
}
;
const pO = je.FIVE_SECONDS
  , Qf = {
    pulse: "heartbeat_pulse"
};
let Obe = class QH extends Rbe {
    constructor(e) {
        super(e),
        this.events = new no.EventEmitter,
        this.interval = pO,
        this.interval = e?.interval || pO
    }
    static async init(e) {
        const t = new QH(e);
        return await t.init(),
        t
    }
    async init() {
        await this.initialize()
    }
    stop() {
        clearInterval(this.intervalRef)
    }
    on(e, t) {
        this.events.on(e, t)
    }
    once(e, t) {
        this.events.once(e, t)
    }
    off(e, t) {
        this.events.off(e, t)
    }
    removeListener(e, t) {
        this.events.removeListener(e, t)
    }
    async initialize() {
        this.intervalRef = setInterval( () => this.pulse(), je.toMiliseconds(this.interval))
    }
    pulse() {
        this.events.emit(Qf.pulse)
    }
}
;
const Pbe = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/
  , jbe = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/
  , Lbe = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
function Fbe(n, e) {
    if (n === "__proto__" || n === "constructor" && e && typeof e == "object" && "prototype"in e) {
        Ube(n);
        return
    }
    return e
}
function Ube(n) {
    console.warn(`[destr] Dropping "${n}" key to prevent prototype pollution.`)
}
function Q1(n, e={}) {
    if (typeof n != "string")
        return n;
    if (n[0] === '"' && n[n.length - 1] === '"' && n.indexOf("\\") === -1)
        return n.slice(1, -1);
    const t = n.trim();
    if (t.length <= 9)
        switch (t.toLowerCase()) {
        case "true":
            return !0;
        case "false":
            return !1;
        case "undefined":
            return;
        case "null":
            return null;
        case "nan":
            return Number.NaN;
        case "infinity":
            return Number.POSITIVE_INFINITY;
        case "-infinity":
            return Number.NEGATIVE_INFINITY
        }
    if (!Lbe.test(n)) {
        if (e.strict)
            throw new SyntaxError("[destr] Invalid JSON");
        return n
    }
    try {
        if (Pbe.test(n) || jbe.test(n)) {
            if (e.strict)
                throw new Error("[destr] Possible prototype pollution");
            return JSON.parse(n, Fbe)
        }
        return JSON.parse(n)
    } catch (r) {
        if (e.strict)
            throw r;
        return n
    }
}
function zbe(n) {
    return !n || typeof n.then != "function" ? Promise.resolve(n) : n
}
function Qr(n, ...e) {
    try {
        return zbe(n(...e))
    } catch (t) {
        return Promise.reject(t)
    }
}
function $be(n) {
    const e = typeof n;
    return n === null || e !== "object" && e !== "function"
}
function Hbe(n) {
    const e = Object.getPrototypeOf(n);
    return !e || e.isPrototypeOf(Object)
}
function Gw(n) {
    if ($be(n))
        return String(n);
    if (Hbe(n) || Array.isArray(n))
        return JSON.stringify(n);
    if (typeof n.toJSON == "function")
        return Gw(n.toJSON());
    throw new Error("[unstorage] Cannot stringify value!")
}
const wC = "base64:";
function Vbe(n) {
    return typeof n == "string" ? n : wC + Wbe(n)
}
function qbe(n) {
    return typeof n != "string" || !n.startsWith(wC) ? n : Gbe(n.slice(wC.length))
}
function Gbe(n) {
    return globalThis.Buffer ? Buffer.from(n, "base64") : Uint8Array.from(globalThis.atob(n), e => e.codePointAt(0))
}
function Wbe(n) {
    return globalThis.Buffer ? Buffer.from(n).toString("base64") : globalThis.btoa(String.fromCodePoint(...n))
}
function gi(n) {
    return n && n.split("?")[0]?.replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "") || ""
}
function Ybe(...n) {
    return gi(n.join(":"))
}
function Z1(n) {
    return n = gi(n),
    n ? n + ":" : ""
}
function Kbe(n, e) {
    if (e === void 0)
        return !0;
    let t = 0
      , r = n.indexOf(":");
    for (; r > -1; )
        t++,
        r = n.indexOf(":", r + 1);
    return t <= e
}
function Xbe(n, e) {
    return e ? n.startsWith(e) && n[n.length - 1] !== "$" : n[n.length - 1] !== "$"
}
const Qbe = "memory"
  , Zbe = () => {
    const n = new Map;
    return {
        name: Qbe,
        getInstance: () => n,
        hasItem(e) {
            return n.has(e)
        },
        getItem(e) {
            return n.get(e) ?? null
        },
        getItemRaw(e) {
            return n.get(e) ?? null
        },
        setItem(e, t) {
            n.set(e, t)
        },
        setItemRaw(e, t) {
            n.set(e, t)
        },
        removeItem(e) {
            n.delete(e)
        },
        getKeys() {
            return [...n.keys()]
        },
        clear() {
            n.clear()
        },
        dispose() {
            n.clear()
        }
    }
}
;
function Jbe(n={}) {
    const e = {
        mounts: {
            "": n.driver || Zbe()
        },
        mountpoints: [""],
        watching: !1,
        watchListeners: [],
        unwatch: {}
    }
      , t = u => {
        for (const d of e.mountpoints)
            if (u.startsWith(d))
                return {
                    base: d,
                    relativeKey: u.slice(d.length),
                    driver: e.mounts[d]
                };
        return {
            base: "",
            relativeKey: u,
            driver: e.mounts[""]
        }
    }
      , r = (u, d) => e.mountpoints.filter(h => h.startsWith(u) || d && u.startsWith(h)).map(h => ({
        relativeBase: u.length > h.length ? u.slice(h.length) : void 0,
        mountpoint: h,
        driver: e.mounts[h]
    }))
      , s = (u, d) => {
        if (e.watching) {
            d = gi(d);
            for (const h of e.watchListeners)
                h(u, d)
        }
    }
      , i = async () => {
        if (!e.watching) {
            e.watching = !0;
            for (const u in e.mounts)
                e.unwatch[u] = await mO(e.mounts[u], s, u)
        }
    }
      , o = async () => {
        if (e.watching) {
            for (const u in e.unwatch)
                await e.unwatch[u]();
            e.unwatch = {},
            e.watching = !1
        }
    }
      , a = (u, d, h) => {
        const p = new Map
          , g = w => {
            let b = p.get(w.base);
            return b || (b = {
                driver: w.driver,
                base: w.base,
                items: []
            },
            p.set(w.base, b)),
            b
        }
        ;
        for (const w of u) {
            const b = typeof w == "string"
              , v = gi(b ? w : w.key)
              , S = b ? void 0 : w.value
              , N = b || !w.options ? d : {
                ...d,
                ...w.options
            }
              , _ = t(v);
            g(_).items.push({
                key: v,
                value: S,
                relativeKey: _.relativeKey,
                options: N
            })
        }
        return Promise.all([...p.values()].map(w => h(w))).then(w => w.flat())
    }
      , l = {
        hasItem(u, d={}) {
            u = gi(u);
            const {relativeKey: h, driver: p} = t(u);
            return Qr(p.hasItem, h, d)
        },
        getItem(u, d={}) {
            u = gi(u);
            const {relativeKey: h, driver: p} = t(u);
            return Qr(p.getItem, h, d).then(g => Q1(g))
        },
        getItems(u, d={}) {
            return a(u, d, h => h.driver.getItems ? Qr(h.driver.getItems, h.items.map(p => ({
                key: p.relativeKey,
                options: p.options
            })), d).then(p => p.map(g => ({
                key: Ybe(h.base, g.key),
                value: Q1(g.value)
            }))) : Promise.all(h.items.map(p => Qr(h.driver.getItem, p.relativeKey, p.options).then(g => ({
                key: p.key,
                value: Q1(g)
            })))))
        },
        getItemRaw(u, d={}) {
            u = gi(u);
            const {relativeKey: h, driver: p} = t(u);
            return p.getItemRaw ? Qr(p.getItemRaw, h, d) : Qr(p.getItem, h, d).then(g => qbe(g))
        },
        async setItem(u, d, h={}) {
            if (d === void 0)
                return l.removeItem(u);
            u = gi(u);
            const {relativeKey: p, driver: g} = t(u);
            g.setItem && (await Qr(g.setItem, p, Gw(d), h),
            g.watch || s("update", u))
        },
        async setItems(u, d) {
            await a(u, d, async h => {
                if (h.driver.setItems)
                    return Qr(h.driver.setItems, h.items.map(p => ({
                        key: p.relativeKey,
                        value: Gw(p.value),
                        options: p.options
                    })), d);
                h.driver.setItem && await Promise.all(h.items.map(p => Qr(h.driver.setItem, p.relativeKey, Gw(p.value), p.options)))
            }
            )
        },
        async setItemRaw(u, d, h={}) {
            if (d === void 0)
                return l.removeItem(u, h);
            u = gi(u);
            const {relativeKey: p, driver: g} = t(u);
            if (g.setItemRaw)
                await Qr(g.setItemRaw, p, d, h);
            else if (g.setItem)
                await Qr(g.setItem, p, Vbe(d), h);
            else
                return;
            g.watch || s("update", u)
        },
        async removeItem(u, d={}) {
            typeof d == "boolean" && (d = {
                removeMeta: d
            }),
            u = gi(u);
            const {relativeKey: h, driver: p} = t(u);
            p.removeItem && (await Qr(p.removeItem, h, d),
            (d.removeMeta || d.removeMata) && await Qr(p.removeItem, h + "$", d),
            p.watch || s("remove", u))
        },
        async getMeta(u, d={}) {
            typeof d == "boolean" && (d = {
                nativeOnly: d
            }),
            u = gi(u);
            const {relativeKey: h, driver: p} = t(u)
              , g = Object.create(null);
            if (p.getMeta && Object.assign(g, await Qr(p.getMeta, h, d)),
            !d.nativeOnly) {
                const w = await Qr(p.getItem, h + "$", d).then(b => Q1(b));
                w && typeof w == "object" && (typeof w.atime == "string" && (w.atime = new Date(w.atime)),
                typeof w.mtime == "string" && (w.mtime = new Date(w.mtime)),
                Object.assign(g, w))
            }
            return g
        },
        setMeta(u, d, h={}) {
            return this.setItem(u + "$", d, h)
        },
        removeMeta(u, d={}) {
            return this.removeItem(u + "$", d)
        },
        async getKeys(u, d={}) {
            u = Z1(u);
            const h = r(u, !0);
            let p = [];
            const g = [];
            let w = !0;
            for (const v of h) {
                v.driver.flags?.maxDepth || (w = !1);
                const S = await Qr(v.driver.getKeys, v.relativeBase, d);
                for (const N of S) {
                    const _ = v.mountpoint + gi(N);
                    p.some(I => _.startsWith(I)) || g.push(_)
                }
                p = [v.mountpoint, ...p.filter(N => !N.startsWith(v.mountpoint))]
            }
            const b = d.maxDepth !== void 0 && !w;
            return g.filter(v => (!b || Kbe(v, d.maxDepth)) && Xbe(v, u))
        },
        async clear(u, d={}) {
            u = Z1(u),
            await Promise.all(r(u, !1).map(async h => {
                if (h.driver.clear)
                    return Qr(h.driver.clear, h.relativeBase, d);
                if (h.driver.removeItem) {
                    const p = await h.driver.getKeys(h.relativeBase || "", d);
                    return Promise.all(p.map(g => h.driver.removeItem(g, d)))
                }
            }
            ))
        },
        async dispose() {
            await Promise.all(Object.values(e.mounts).map(u => gO(u)))
        },
        async watch(u) {
            return await i(),
            e.watchListeners.push(u),
            async () => {
                e.watchListeners = e.watchListeners.filter(d => d !== u),
                e.watchListeners.length === 0 && await o()
            }
        },
        async unwatch() {
            e.watchListeners = [],
            await o()
        },
        mount(u, d) {
            if (u = Z1(u),
            u && e.mounts[u])
                throw new Error(`already mounted at ${u}`);
            return u && (e.mountpoints.push(u),
            e.mountpoints.sort( (h, p) => p.length - h.length)),
            e.mounts[u] = d,
            e.watching && Promise.resolve(mO(d, s, u)).then(h => {
                e.unwatch[u] = h
            }
            ).catch(console.error),
            l
        },
        async unmount(u, d=!0) {
            u = Z1(u),
            !(!u || !e.mounts[u]) && (e.watching && u in e.unwatch && (e.unwatch[u]?.(),
            delete e.unwatch[u]),
            d && await gO(e.mounts[u]),
            e.mountpoints = e.mountpoints.filter(h => h !== u),
            delete e.mounts[u])
        },
        getMount(u="") {
            u = gi(u) + ":";
            const d = t(u);
            return {
                driver: d.driver,
                base: d.base
            }
        },
        getMounts(u="", d={}) {
            return u = gi(u),
            r(u, d.parents).map(p => ({
                driver: p.driver,
                base: p.mountpoint
            }))
        },
        keys: (u, d={}) => l.getKeys(u, d),
        get: (u, d={}) => l.getItem(u, d),
        set: (u, d, h={}) => l.setItem(u, d, h),
        has: (u, d={}) => l.hasItem(u, d),
        del: (u, d={}) => l.removeItem(u, d),
        remove: (u, d={}) => l.removeItem(u, d)
    };
    return l
}
function mO(n, e, t) {
    return n.watch ? n.watch( (r, s) => e(r, t + s)) : () => {}
}
async function gO(n) {
    typeof n.dispose == "function" && await Qr(n.dispose)
}
function Zf(n) {
    return new Promise( (e, t) => {
        n.oncomplete = n.onsuccess = () => e(n.result),
        n.onabort = n.onerror = () => t(n.error)
    }
    )
}
function ZH(n, e) {
    let t;
    const r = () => {
        if (t)
            return t;
        const s = indexedDB.open(n);
        return s.onupgradeneeded = () => s.result.createObjectStore(e),
        t = Zf(s),
        t.then(i => {
            i.onclose = () => t = void 0
        }
        , () => {}
        ),
        t
    }
    ;
    return (s, i) => r().then(o => i(o.transaction(e, s).objectStore(e)))
}
let eA;
function Yy() {
    return eA || (eA = ZH("keyval-store", "keyval")),
    eA
}
function yO(n, e=Yy()) {
    return e("readonly", t => Zf(t.get(n)))
}
function e1e(n, e, t=Yy()) {
    return t("readwrite", r => (r.put(e, n),
    Zf(r.transaction)))
}
function t1e(n, e=Yy()) {
    return e("readwrite", t => (t.delete(n),
    Zf(t.transaction)))
}
function n1e(n=Yy()) {
    return n("readwrite", e => (e.clear(),
    Zf(e.transaction)))
}
function r1e(n, e) {
    return n.openCursor().onsuccess = function() {
        this.result && (e(this.result),
        this.result.continue())
    }
    ,
    Zf(n.transaction)
}
function s1e(n=Yy()) {
    return n("readonly", e => {
        if (e.getAllKeys)
            return Zf(e.getAllKeys());
        const t = [];
        return r1e(e, r => t.push(r.key)).then( () => t)
    }
    )
}
const i1e = "idb-keyval";
var o1e = (n={}) => {
    const e = n.base && n.base.length > 0 ? `${n.base}:` : ""
      , t = s => e + s;
    let r;
    return n.dbName && n.storeName && (r = ZH(n.dbName, n.storeName)),
    {
        name: i1e,
        options: n,
        async hasItem(s) {
            return !(typeof await yO(t(s), r) > "u")
        },
        async getItem(s) {
            return await yO(t(s), r) ?? null
        },
        setItem(s, i) {
            return e1e(t(s), i, r)
        },
        removeItem(s) {
            return t1e(t(s), r)
        },
        getKeys() {
            return s1e(r)
        },
        clear() {
            return n1e(r)
        }
    }
}
;
const a1e = "WALLET_CONNECT_V2_INDEXED_DB"
  , l1e = "keyvaluestorage";
let c1e = class {
    constructor() {
        this.indexedDb = Jbe({
            driver: o1e({
                dbName: a1e,
                storeName: l1e
            })
        })
    }
    async getKeys() {
        return this.indexedDb.getKeys()
    }
    async getEntries() {
        return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map(e => [e.key, e.value])
    }
    async getItem(e) {
        const t = await this.indexedDb.getItem(e);
        if (t !== null)
            return t
    }
    async setItem(e, t) {
        await this.indexedDb.setItem(e, Tc(t))
    }
    async removeItem(e) {
        await this.indexedDb.removeItem(e)
    }
}
;
var tA = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}
  , Ww = {
    exports: {}
};
(function() {
    let n;
    function e() {}
    n = e,
    n.prototype.getItem = function(t) {
        return this.hasOwnProperty(t) ? String(this[t]) : null
    }
    ,
    n.prototype.setItem = function(t, r) {
        this[t] = String(r)
    }
    ,
    n.prototype.removeItem = function(t) {
        delete this[t]
    }
    ,
    n.prototype.clear = function() {
        const t = this;
        Object.keys(t).forEach(function(r) {
            t[r] = void 0,
            delete t[r]
        })
    }
    ,
    n.prototype.key = function(t) {
        return t = t || 0,
        Object.keys(this)[t]
    }
    ,
    n.prototype.__defineGetter__("length", function() {
        return Object.keys(this).length
    }),
    typeof tA < "u" && tA.localStorage ? Ww.exports = tA.localStorage : typeof window < "u" && window.localStorage ? Ww.exports = window.localStorage : Ww.exports = new e
}
)();
function u1e(n) {
    var e;
    return [n[0], Of((e = n[1]) != null ? e : "")]
}
let d1e = class {
    constructor() {
        this.localStorage = Ww.exports
    }
    async getKeys() {
        return Object.keys(this.localStorage)
    }
    async getEntries() {
        return Object.entries(this.localStorage).map(u1e)
    }
    async getItem(e) {
        const t = this.localStorage.getItem(e);
        if (t !== null)
            return Of(t)
    }
    async setItem(e, t) {
        this.localStorage.setItem(e, Tc(t))
    }
    async removeItem(e) {
        this.localStorage.removeItem(e)
    }
}
;
const f1e = "wc_storage_version"
  , bO = 1
  , h1e = async (n, e, t) => {
    const r = f1e
      , s = await e.getItem(r);
    if (s && s >= bO) {
        t(e);
        return
    }
    const i = await n.getKeys();
    if (!i.length) {
        t(e);
        return
    }
    const o = [];
    for (; i.length; ) {
        const a = i.shift();
        if (!a)
            continue;
        const l = a.toLowerCase();
        if (l.includes("wc@") || l.includes("walletconnect") || l.includes("wc_") || l.includes("wallet_connect")) {
            const u = await n.getItem(a);
            await e.setItem(a, u),
            o.push(a)
        }
    }
    await e.setItem(r, bO),
    t(e),
    p1e(n, o)
}
  , p1e = async (n, e) => {
    e.length && e.forEach(async t => {
        await n.removeItem(t)
    }
    )
}
;
let m1e = class {
    constructor() {
        this.initialized = !1,
        this.setInitialized = t => {
            this.storage = t,
            this.initialized = !0
        }
        ;
        const e = new d1e;
        this.storage = e;
        try {
            const t = new c1e;
            h1e(e, t, this.setInitialized)
        } catch {
            this.initialized = !0
        }
    }
    async getKeys() {
        return await this.initialize(),
        this.storage.getKeys()
    }
    async getEntries() {
        return await this.initialize(),
        this.storage.getEntries()
    }
    async getItem(e) {
        return await this.initialize(),
        this.storage.getItem(e)
    }
    async setItem(e, t) {
        return await this.initialize(),
        this.storage.setItem(e, t)
    }
    async removeItem(e) {
        return await this.initialize(),
        this.storage.removeItem(e)
    }
    async initialize() {
        this.initialized || await new Promise(e => {
            const t = setInterval( () => {
                this.initialized && (clearInterval(t),
                e())
            }
            , 20)
        }
        )
    }
}
;
var g1e = Object.defineProperty
  , y1e = (n, e, t) => e in n ? g1e(n, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : n[e] = t
  , wO = (n, e, t) => y1e(n, typeof e != "symbol" ? e + "" : e, t);
let b1e = class extends Xf {
    constructor(e) {
        super(),
        this.opts = e,
        wO(this, "protocol", "wc"),
        wO(this, "version", 2)
    }
}
;
var w1e = Object.defineProperty
  , v1e = (n, e, t) => e in n ? w1e(n, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : n[e] = t
  , x1e = (n, e, t) => v1e(n, e + "", t);
let E1e = class extends Xf {
    constructor(e, t) {
        super(),
        this.core = e,
        this.logger = t,
        x1e(this, "records", new Map)
    }
}
  , S1e = class {
    constructor(e, t) {
        this.logger = e,
        this.core = t
    }
}
  , A1e = class extends Xf {
    constructor(e, t) {
        super(),
        this.relayer = e,
        this.logger = t
    }
}
  , C1e = class extends Xf {
    constructor(e) {
        super()
    }
}
  , _1e = class {
    constructor(e, t, r, s) {
        this.core = e,
        this.logger = t,
        this.name = r
    }
}
  , k1e = class extends Xf {
    constructor(e, t) {
        super(),
        this.relayer = e,
        this.logger = t
    }
}
  , N1e = class extends Xf {
    constructor(e, t) {
        super(),
        this.core = e,
        this.logger = t
    }
}
  , D1e = class {
    constructor(e, t, r) {
        this.core = e,
        this.logger = t,
        this.store = r
    }
}
  , T1e = class {
    constructor(e, t) {
        this.projectId = e,
        this.logger = t
    }
}
  , I1e = class {
    constructor(e, t, r) {
        this.core = e,
        this.logger = t,
        this.telemetryEnabled = r
    }
}
;
var M1e = Object.defineProperty
  , B1e = (n, e, t) => e in n ? M1e(n, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : n[e] = t
  , vO = (n, e, t) => B1e(n, typeof e != "symbol" ? e + "" : e, t);
let R1e = class {
    constructor(e) {
        this.opts = e,
        vO(this, "protocol", "wc"),
        vO(this, "version", 2)
    }
}
  , O1e = class {
    constructor(e) {
        this.client = e
    }
}
;
const P1e = "PARSE_ERROR"
  , j1e = "INVALID_REQUEST"
  , L1e = "METHOD_NOT_FOUND"
  , F1e = "INVALID_PARAMS"
  , JH = "INTERNAL_ERROR"
  , W_ = "SERVER_ERROR"
  , U1e = [-32700, -32600, -32601, -32602, -32603]
  , Ig = {
    [P1e]: {
        code: -32700,
        message: "Parse error"
    },
    [j1e]: {
        code: -32600,
        message: "Invalid Request"
    },
    [L1e]: {
        code: -32601,
        message: "Method not found"
    },
    [F1e]: {
        code: -32602,
        message: "Invalid params"
    },
    [JH]: {
        code: -32603,
        message: "Internal error"
    },
    [W_]: {
        code: -32e3,
        message: "Server error"
    }
}
  , eV = W_;
function z1e(n) {
    return U1e.includes(n)
}
function xO(n) {
    return Object.keys(Ig).includes(n) ? Ig[n] : Ig[eV]
}
function $1e(n) {
    const e = Object.values(Ig).find(t => t.code === n);
    return e || Ig[eV]
}
function tV(n, e, t) {
    return n.message.includes("getaddrinfo ENOTFOUND") || n.message.includes("connect ECONNREFUSED") ? new Error(`Unavailable ${t} RPC url at ${e}`) : n
}
var nA = {}, Pl = {}, EO;
function H1e() {
    if (EO)
        return Pl;
    EO = 1,
    Object.defineProperty(Pl, "__esModule", {
        value: !0
    }),
    Pl.isBrowserCryptoAvailable = Pl.getSubtleCrypto = Pl.getBrowerCrypto = void 0;
    function n() {
        return To?.crypto || To?.msCrypto || {}
    }
    Pl.getBrowerCrypto = n;
    function e() {
        const r = n();
        return r.subtle || r.webkitSubtle
    }
    Pl.getSubtleCrypto = e;
    function t() {
        return !!n() && !!e()
    }
    return Pl.isBrowserCryptoAvailable = t,
    Pl
}
var jl = {}, SO;
function V1e() {
    if (SO)
        return jl;
    SO = 1,
    Object.defineProperty(jl, "__esModule", {
        value: !0
    }),
    jl.isBrowser = jl.isNode = jl.isReactNative = void 0;
    function n() {
        return typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative"
    }
    jl.isReactNative = n;
    function e() {
        return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u"
    }
    jl.isNode = e;
    function t() {
        return !n() && !e()
    }
    return jl.isBrowser = t,
    jl
}
var AO;
function q1e() {
    return AO || (AO = 1,
    (function(n) {
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        const e = Ly;
        e.__exportStar(H1e(), n),
        e.__exportStar(V1e(), n)
    }
    )(nA)),
    nA
}
var G1e = q1e();
function Oa(n=3) {
    const e = Date.now() * Math.pow(10, n)
      , t = Math.floor(Math.random() * Math.pow(10, n));
    return e + t
}
function Fu(n=6) {
    return BigInt(Oa(n))
}
function ta(n, e, t) {
    return {
        id: t || Oa(),
        jsonrpc: "2.0",
        method: n,
        params: e
    }
}
function iy(n, e) {
    return {
        id: n,
        jsonrpc: "2.0",
        result: e
    }
}
function Ex(n, e, t) {
    return {
        id: n,
        jsonrpc: "2.0",
        error: W1e(e)
    }
}
function W1e(n, e) {
    return typeof n > "u" ? xO(JH) : (typeof n == "string" && (n = Object.assign(Object.assign({}, xO(W_)), {
        message: n
    })),
    z1e(n.code) && (n = $1e(n.code)),
    n)
}
let Y1e = class {
}
  , K1e = class extends Y1e {
    constructor() {
        super()
    }
}
  , X1e = class extends K1e {
    constructor(e) {
        super()
    }
}
;
const Q1e = "^https?:"
  , Z1e = "^wss?:";
function J1e(n) {
    const e = n.match(new RegExp(/^\w+:/,"gi"));
    if (!(!e || !e.length))
        return e[0]
}
function nV(n, e) {
    const t = J1e(n);
    return typeof t > "u" ? !1 : new RegExp(e).test(t)
}
function CO(n) {
    return nV(n, Q1e)
}
function _O(n) {
    return nV(n, Z1e)
}
function ewe(n) {
    return new RegExp("wss?://localhost(:d{2,5})?").test(n)
}
function rV(n) {
    return typeof n == "object" && "id"in n && "jsonrpc"in n && n.jsonrpc === "2.0"
}
function Y_(n) {
    return rV(n) && "method"in n
}
function Sx(n) {
    return rV(n) && (Pa(n) || _o(n))
}
function Pa(n) {
    return "result"in n
}
function _o(n) {
    return "error"in n
}
let K_ = class extends X1e {
    constructor(e) {
        super(e),
        this.events = new no.EventEmitter,
        this.hasRegisteredEventListeners = !1,
        this.connection = this.setConnection(e),
        this.connection.connected && this.registerEventListeners()
    }
    async connect(e=this.connection) {
        await this.open(e)
    }
    async disconnect() {
        await this.close()
    }
    on(e, t) {
        this.events.on(e, t)
    }
    once(e, t) {
        this.events.once(e, t)
    }
    off(e, t) {
        this.events.off(e, t)
    }
    removeListener(e, t) {
        this.events.removeListener(e, t)
    }
    async request(e, t) {
        return this.requestStrict(ta(e.method, e.params || [], e.id || Fu().toString()), t)
    }
    async requestStrict(e, t) {
        return new Promise(async (r, s) => {
            if (!this.connection.connected)
                try {
                    await this.open()
                } catch (i) {
                    s(i)
                }
            this.events.on(`${e.id}`, i => {
                _o(i) ? s(i.error) : r(i.result)
            }
            );
            try {
                await this.connection.send(e, t)
            } catch (i) {
                s(i)
            }
        }
        )
    }
    setConnection(e=this.connection) {
        return e
    }
    onPayload(e) {
        this.events.emit("payload", e),
        Sx(e) ? this.events.emit(`${e.id}`, e) : this.events.emit("message", {
            type: e.method,
            data: e.params
        })
    }
    onClose(e) {
        e && e.code === 3e3 && this.events.emit("error", new Error(`WebSocket connection closed abnormally with code: ${e.code} ${e.reason ? `(${e.reason})` : ""}`)),
        this.events.emit("disconnect")
    }
    async open(e=this.connection) {
        this.connection === e && this.connection.connected || (this.connection.connected && this.close(),
        typeof e == "string" && (await this.connection.open(e),
        e = this.connection),
        this.connection = this.setConnection(e),
        await this.connection.open(),
        this.registerEventListeners(),
        this.events.emit("connect"))
    }
    async close() {
        await this.connection.close()
    }
    registerEventListeners() {
        this.hasRegisteredEventListeners || (this.connection.on("payload", e => this.onPayload(e)),
        this.connection.on("close", e => this.onClose(e)),
        this.connection.on("error", e => this.events.emit("error", e)),
        this.connection.on("register_error", e => this.onClose()),
        this.hasRegisteredEventListeners = !0)
    }
}
;
const twe = () => typeof WebSocket < "u" ? WebSocket : typeof global < "u" && typeof global.WebSocket < "u" ? global.WebSocket : typeof window < "u" && typeof window.WebSocket < "u" ? window.WebSocket : typeof self < "u" && typeof self.WebSocket < "u" ? self.WebSocket : require("ws")
  , nwe = () => typeof WebSocket < "u" || typeof global < "u" && typeof global.WebSocket < "u" || typeof window < "u" && typeof window.WebSocket < "u" || typeof self < "u" && typeof self.WebSocket < "u"
  , kO = n => n.split("?")[0]
  , NO = 10
  , rwe = twe();
let swe = class {
    constructor(e) {
        if (this.url = e,
        this.events = new no.EventEmitter,
        this.registering = !1,
        !_O(e))
            throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
        this.url = e
    }
    get connected() {
        return typeof this.socket < "u"
    }
    get connecting() {
        return this.registering
    }
    on(e, t) {
        this.events.on(e, t)
    }
    once(e, t) {
        this.events.once(e, t)
    }
    off(e, t) {
        this.events.off(e, t)
    }
    removeListener(e, t) {
        this.events.removeListener(e, t)
    }
    async open(e=this.url) {
        await this.register(e)
    }
    async close() {
        return new Promise( (e, t) => {
            if (typeof this.socket > "u") {
                t(new Error("Connection already closed"));
                return
            }
            this.socket.onclose = r => {
                this.onClose(r),
                e()
            }
            ,
            this.socket.close()
        }
        )
    }
    async send(e) {
        typeof this.socket > "u" && (this.socket = await this.register());
        try {
            this.socket.send(Tc(e))
        } catch (t) {
            this.onError(e.id, t)
        }
    }
    register(e=this.url) {
        if (!_O(e))
            throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
        if (this.registering) {
            const t = this.events.getMaxListeners();
            return (this.events.listenerCount("register_error") >= t || this.events.listenerCount("open") >= t) && this.events.setMaxListeners(t + 1),
            new Promise( (r, s) => {
                this.events.once("register_error", i => {
                    this.resetMaxListeners(),
                    s(i)
                }
                ),
                this.events.once("open", () => {
                    if (this.resetMaxListeners(),
                    typeof this.socket > "u")
                        return s(new Error("WebSocket connection is missing or invalid"));
                    r(this.socket)
                }
                )
            }
            )
        }
        return this.url = e,
        this.registering = !0,
        new Promise( (t, r) => {
            const s = G1e.isReactNative() ? void 0 : {
                rejectUnauthorized: !ewe(e)
            }
              , i = new rwe(e,[],s);
            nwe() ? i.onerror = o => {
                const a = o;
                r(this.emitError(a.error))
            }
            : i.on("error", o => {
                r(this.emitError(o))
            }
            ),
            i.onopen = () => {
                this.onOpen(i),
                t(i)
            }
        }
        )
    }
    onOpen(e) {
        e.onmessage = t => this.onPayload(t),
        e.onclose = t => this.onClose(t),
        this.socket = e,
        this.registering = !1,
        this.events.emit("open")
    }
    onClose(e) {
        this.socket = void 0,
        this.registering = !1,
        this.events.emit("close", e)
    }
    onPayload(e) {
        if (typeof e.data > "u")
            return;
        const t = typeof e.data == "string" ? Of(e.data) : e.data;
        this.events.emit("payload", t)
    }
    onError(e, t) {
        const r = this.parseError(t)
          , s = r.message || r.toString()
          , i = Ex(e, s);
        this.events.emit("payload", i)
    }
    parseError(e, t=this.url) {
        return tV(e, kO(t), "WS")
    }
    resetMaxListeners() {
        this.events.getMaxListeners() > NO && this.events.setMaxListeners(NO)
    }
    emitError(e) {
        const t = this.parseError(new Error(e?.message || `WebSocket connection failed for host: ${kO(this.url)}`));
        return this.events.emit("register_error", t),
        t
    }
}
;
var iwe = {};
const sV = "wc"
  , iV = 2
  , vC = "core"
  , rl = `${sV}@2:${vC}:`
  , owe = {
    logger: "error"
}
  , awe = {
    database: ":memory:"
}
  , lwe = "crypto"
  , DO = "client_ed25519_seed"
  , cwe = je.ONE_DAY
  , uwe = "keychain"
  , dwe = "0.3"
  , fwe = "messages"
  , hwe = "0.3"
  , pwe = je.SIX_HOURS
  , mwe = "publisher"
  , oV = "irn"
  , gwe = "error"
  , aV = "wss://relay.walletconnect.org"
  , ywe = "relayer"
  , Or = {
    message: "relayer_message",
    message_ack: "relayer_message_ack",
    connect: "relayer_connect",
    disconnect: "relayer_disconnect",
    error: "relayer_error",
    connection_stalled: "relayer_connection_stalled",
    transport_closed: "relayer_transport_closed",
    publish: "relayer_publish"
}
  , bwe = "_subscription"
  , wo = {
    payload: "payload",
    connect: "connect",
    disconnect: "disconnect",
    error: "error"
}
  , wwe = .1
  , xC = "2.23.0"
  , Gn = {
    link_mode: "link_mode",
    relay: "relay"
}
  , Yw = {
    inbound: "inbound",
    outbound: "outbound"
}
  , vwe = "0.3"
  , xwe = "WALLETCONNECT_CLIENT_ID"
  , TO = "WALLETCONNECT_LINK_MODE_APPS"
  , $i = {
    created: "subscription_created",
    deleted: "subscription_deleted",
    expired: "subscription_expired",
    disabled: "subscription_disabled",
    sync: "subscription_sync",
    resubscribed: "subscription_resubscribed"
}
  , Ewe = "subscription"
  , Swe = "0.3"
  , Awe = "pairing"
  , Cwe = "0.3"
  , Km = {
    wc_pairingDelete: {
        req: {
            ttl: je.ONE_DAY,
            prompt: !1,
            tag: 1e3
        },
        res: {
            ttl: je.ONE_DAY,
            prompt: !1,
            tag: 1001
        }
    },
    wc_pairingPing: {
        req: {
            ttl: je.THIRTY_SECONDS,
            prompt: !1,
            tag: 1002
        },
        res: {
            ttl: je.THIRTY_SECONDS,
            prompt: !1,
            tag: 1003
        }
    },
    unregistered_method: {
        req: {
            ttl: je.ONE_DAY,
            prompt: !1,
            tag: 0
        },
        res: {
            ttl: je.ONE_DAY,
            prompt: !1,
            tag: 0
        }
    }
}
  , Jd = {
    create: "pairing_create",
    expire: "pairing_expire",
    delete: "pairing_delete",
    ping: "pairing_ping"
}
  , Wo = {
    created: "history_created",
    updated: "history_updated",
    deleted: "history_deleted",
    sync: "history_sync"
}
  , _we = "history"
  , kwe = "0.3"
  , Nwe = "expirer"
  , Eo = {
    created: "expirer_created",
    deleted: "expirer_deleted",
    expired: "expirer_expired",
    sync: "expirer_sync"
}
  , Dwe = "0.3"
  , Twe = "verify-api"
  , Iwe = "https://verify.walletconnect.com"
  , lV = "https://verify.walletconnect.org"
  , Mg = lV
  , Mwe = `${Mg}/v3`
  , Bwe = [Iwe, lV]
  , Rwe = "echo"
  , Owe = "https://echo.walletconnect.com"
  , Ba = {
    pairing_started: "pairing_started",
    pairing_uri_validation_success: "pairing_uri_validation_success",
    pairing_uri_not_expired: "pairing_uri_not_expired",
    store_new_pairing: "store_new_pairing",
    subscribing_pairing_topic: "subscribing_pairing_topic",
    subscribe_pairing_topic_success: "subscribe_pairing_topic_success",
    existing_pairing: "existing_pairing",
    pairing_not_expired: "pairing_not_expired",
    emit_inactive_pairing: "emit_inactive_pairing",
    emit_session_proposal: "emit_session_proposal",
    subscribing_to_pairing_topic: "subscribing_to_pairing_topic"
}
  , Vl = {
    no_wss_connection: "no_wss_connection",
    no_internet_connection: "no_internet_connection",
    malformed_pairing_uri: "malformed_pairing_uri",
    active_pairing_already_exists: "active_pairing_already_exists",
    subscribe_pairing_topic_failure: "subscribe_pairing_topic_failure",
    pairing_expired: "pairing_expired",
    proposal_expired: "proposal_expired",
    proposal_listener_not_found: "proposal_listener_not_found"
}
  , Yo = {
    session_approve_started: "session_approve_started",
    proposal_not_expired: "proposal_not_expired",
    session_namespaces_validation_success: "session_namespaces_validation_success",
    create_session_topic: "create_session_topic",
    subscribing_session_topic: "subscribing_session_topic",
    subscribe_session_topic_success: "subscribe_session_topic_success",
    publishing_session_approve: "publishing_session_approve",
    session_approve_publish_success: "session_approve_publish_success",
    store_session: "store_session",
    publishing_session_settle: "publishing_session_settle",
    session_settle_publish_success: "session_settle_publish_success",
    session_request_response_started: "session_request_response_started",
    session_request_response_validation_success: "session_request_response_validation_success",
    session_request_response_publish_started: "session_request_response_publish_started"
}
  , Bd = {
    no_internet_connection: "no_internet_connection",
    no_wss_connection: "no_wss_connection",
    proposal_expired: "proposal_expired",
    subscribe_session_topic_failure: "subscribe_session_topic_failure",
    session_approve_publish_failure: "session_approve_publish_failure",
    session_settle_publish_failure: "session_settle_publish_failure",
    session_approve_namespace_validation_failure: "session_approve_namespace_validation_failure",
    proposal_not_found: "proposal_not_found",
    session_request_response_validation_failure: "session_request_response_validation_failure",
    session_request_response_publish_failure: "session_request_response_publish_failure"
}
  , Rd = {
    authenticated_session_approve_started: "authenticated_session_approve_started",
    create_authenticated_session_topic: "create_authenticated_session_topic",
    cacaos_verified: "cacaos_verified",
    store_authenticated_session: "store_authenticated_session",
    subscribing_authenticated_session_topic: "subscribing_authenticated_session_topic",
    subscribe_authenticated_session_topic_success: "subscribe_authenticated_session_topic_success",
    publishing_authenticated_session_approve: "publishing_authenticated_session_approve"
}
  , Xm = {
    no_internet_connection: "no_internet_connection",
    invalid_cacao: "invalid_cacao",
    subscribe_authenticated_session_topic_failure: "subscribe_authenticated_session_topic_failure",
    authenticated_session_approve_publish_failure: "authenticated_session_approve_publish_failure",
    authenticated_session_pending_request_not_found: "authenticated_session_pending_request_not_found"
}
  , Pwe = .1
  , jwe = "event-client"
  , Lwe = 86400
  , Fwe = "https://pulse.walletconnect.org/batch";
function Uwe(n, e) {
    if (n.length >= 255)
        throw new TypeError("Alphabet too long");
    for (var t = new Uint8Array(256), r = 0; r < t.length; r++)
        t[r] = 255;
    for (var s = 0; s < n.length; s++) {
        var i = n.charAt(s)
          , o = i.charCodeAt(0);
        if (t[o] !== 255)
            throw new TypeError(i + " is ambiguous");
        t[o] = s
    }
    var a = n.length
      , l = n.charAt(0)
      , u = Math.log(a) / Math.log(256)
      , d = Math.log(256) / Math.log(a);
    function h(w) {
        if (w instanceof Uint8Array || (ArrayBuffer.isView(w) ? w = new Uint8Array(w.buffer,w.byteOffset,w.byteLength) : Array.isArray(w) && (w = Uint8Array.from(w))),
        !(w instanceof Uint8Array))
            throw new TypeError("Expected Uint8Array");
        if (w.length === 0)
            return "";
        for (var b = 0, v = 0, S = 0, N = w.length; S !== N && w[S] === 0; )
            S++,
            b++;
        for (var _ = (N - S) * d + 1 >>> 0, I = new Uint8Array(_); S !== N; ) {
            for (var k = w[S], B = 0, P = _ - 1; (k !== 0 || B < v) && P !== -1; P--,
            B++)
                k += 256 * I[P] >>> 0,
                I[P] = k % a >>> 0,
                k = k / a >>> 0;
            if (k !== 0)
                throw new Error("Non-zero carry");
            v = B,
            S++
        }
        for (var M = _ - v; M !== _ && I[M] === 0; )
            M++;
        for (var R = l.repeat(b); M < _; ++M)
            R += n.charAt(I[M]);
        return R
    }
    function p(w) {
        if (typeof w != "string")
            throw new TypeError("Expected String");
        if (w.length === 0)
            return new Uint8Array;
        var b = 0;
        if (w[b] !== " ") {
            for (var v = 0, S = 0; w[b] === l; )
                v++,
                b++;
            for (var N = (w.length - b) * u + 1 >>> 0, _ = new Uint8Array(N); w[b]; ) {
                var I = t[w.charCodeAt(b)];
                if (I === 255)
                    return;
                for (var k = 0, B = N - 1; (I !== 0 || k < S) && B !== -1; B--,
                k++)
                    I += a * _[B] >>> 0,
                    _[B] = I % 256 >>> 0,
                    I = I / 256 >>> 0;
                if (I !== 0)
                    throw new Error("Non-zero carry");
                S = k,
                b++
            }
            if (w[b] !== " ") {
                for (var P = N - S; P !== N && _[P] === 0; )
                    P++;
                for (var M = new Uint8Array(v + (N - P)), R = v; P !== N; )
                    M[R++] = _[P++];
                return M
            }
        }
    }
    function g(w) {
        var b = p(w);
        if (b)
            return b;
        throw new Error(`Non-${e} character`)
    }
    return {
        encode: h,
        decodeUnsafe: p,
        decode: g
    }
}
var zwe = Uwe
  , $we = zwe;
const cV = n => {
    if (n instanceof Uint8Array && n.constructor.name === "Uint8Array")
        return n;
    if (n instanceof ArrayBuffer)
        return new Uint8Array(n);
    if (ArrayBuffer.isView(n))
        return new Uint8Array(n.buffer,n.byteOffset,n.byteLength);
    throw new Error("Unknown type, must be binary type")
}
  , Hwe = n => new TextEncoder().encode(n)
  , Vwe = n => new TextDecoder().decode(n);
class qwe {
    constructor(e, t, r) {
        this.name = e,
        this.prefix = t,
        this.baseEncode = r
    }
    encode(e) {
        if (e instanceof Uint8Array)
            return `${this.prefix}${this.baseEncode(e)}`;
        throw Error("Unknown type, must be binary type")
    }
}
class Gwe {
    constructor(e, t, r) {
        if (this.name = e,
        this.prefix = t,
        t.codePointAt(0) === void 0)
            throw new Error("Invalid prefix character");
        this.prefixCodePoint = t.codePointAt(0),
        this.baseDecode = r
    }
    decode(e) {
        if (typeof e == "string") {
            if (e.codePointAt(0) !== this.prefixCodePoint)
                throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
            return this.baseDecode(e.slice(this.prefix.length))
        } else
            throw Error("Can only multibase decode strings")
    }
    or(e) {
        return uV(this, e)
    }
}
class Wwe {
    constructor(e) {
        this.decoders = e
    }
    or(e) {
        return uV(this, e)
    }
    decode(e) {
        const t = e[0]
          , r = this.decoders[t];
        if (r)
            return r.decode(e);
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)
    }
}
const uV = (n, e) => new Wwe({
    ...n.decoders || {
        [n.prefix]: n
    },
    ...e.decoders || {
        [e.prefix]: e
    }
});
class Ywe {
    constructor(e, t, r, s) {
        this.name = e,
        this.prefix = t,
        this.baseEncode = r,
        this.baseDecode = s,
        this.encoder = new qwe(e,t,r),
        this.decoder = new Gwe(e,t,s)
    }
    encode(e) {
        return this.encoder.encode(e)
    }
    decode(e) {
        return this.decoder.decode(e)
    }
}
const Ax = ({name: n, prefix: e, encode: t, decode: r}) => new Ywe(n,e,t,r)
  , Ky = ({prefix: n, name: e, alphabet: t}) => {
    const {encode: r, decode: s} = $we(t, e);
    return Ax({
        prefix: n,
        name: e,
        encode: r,
        decode: i => cV(s(i))
    })
}
  , Kwe = (n, e, t, r) => {
    const s = {};
    for (let d = 0; d < e.length; ++d)
        s[e[d]] = d;
    let i = n.length;
    for (; n[i - 1] === "="; )
        --i;
    const o = new Uint8Array(i * t / 8 | 0);
    let a = 0
      , l = 0
      , u = 0;
    for (let d = 0; d < i; ++d) {
        const h = s[n[d]];
        if (h === void 0)
            throw new SyntaxError(`Non-${r} character`);
        l = l << t | h,
        a += t,
        a >= 8 && (a -= 8,
        o[u++] = 255 & l >> a)
    }
    if (a >= t || 255 & l << 8 - a)
        throw new SyntaxError("Unexpected end of data");
    return o
}
  , Xwe = (n, e, t) => {
    const r = e[e.length - 1] === "="
      , s = (1 << t) - 1;
    let i = ""
      , o = 0
      , a = 0;
    for (let l = 0; l < n.length; ++l)
        for (a = a << 8 | n[l],
        o += 8; o > t; )
            o -= t,
            i += e[s & a >> o];
    if (o && (i += e[s & a << t - o]),
    r)
        for (; i.length * t & 7; )
            i += "=";
    return i
}
  , Cs = ({name: n, prefix: e, bitsPerChar: t, alphabet: r}) => Ax({
    prefix: e,
    name: n,
    encode(s) {
        return Xwe(s, r, t)
    },
    decode(s) {
        return Kwe(s, r, t, n)
    }
})
  , Qwe = Ax({
    prefix: "\0",
    name: "identity",
    encode: n => Vwe(n),
    decode: n => Hwe(n)
});
var Zwe = Object.freeze({
    __proto__: null,
    identity: Qwe
});
const Jwe = Cs({
    prefix: "0",
    name: "base2",
    alphabet: "01",
    bitsPerChar: 1
});
var e2e = Object.freeze({
    __proto__: null,
    base2: Jwe
});
const t2e = Cs({
    prefix: "7",
    name: "base8",
    alphabet: "01234567",
    bitsPerChar: 3
});
var n2e = Object.freeze({
    __proto__: null,
    base8: t2e
});
const r2e = Ky({
    prefix: "9",
    name: "base10",
    alphabet: "0123456789"
});
var s2e = Object.freeze({
    __proto__: null,
    base10: r2e
});
const i2e = Cs({
    prefix: "f",
    name: "base16",
    alphabet: "0123456789abcdef",
    bitsPerChar: 4
})
  , o2e = Cs({
    prefix: "F",
    name: "base16upper",
    alphabet: "0123456789ABCDEF",
    bitsPerChar: 4
});
var a2e = Object.freeze({
    __proto__: null,
    base16: i2e,
    base16upper: o2e
});
const l2e = Cs({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
})
  , c2e = Cs({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
})
  , u2e = Cs({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
})
  , d2e = Cs({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
})
  , f2e = Cs({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
})
  , h2e = Cs({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
})
  , p2e = Cs({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
})
  , m2e = Cs({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
})
  , g2e = Cs({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
});
var y2e = Object.freeze({
    __proto__: null,
    base32: l2e,
    base32upper: c2e,
    base32pad: u2e,
    base32padupper: d2e,
    base32hex: f2e,
    base32hexupper: h2e,
    base32hexpad: p2e,
    base32hexpadupper: m2e,
    base32z: g2e
});
const b2e = Ky({
    prefix: "k",
    name: "base36",
    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
})
  , w2e = Ky({
    prefix: "K",
    name: "base36upper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});
var v2e = Object.freeze({
    __proto__: null,
    base36: b2e,
    base36upper: w2e
});
const x2e = Ky({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
})
  , E2e = Ky({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});
var S2e = Object.freeze({
    __proto__: null,
    base58btc: x2e,
    base58flickr: E2e
});
const A2e = Cs({
    prefix: "m",
    name: "base64",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6
})
  , C2e = Cs({
    prefix: "M",
    name: "base64pad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6
})
  , _2e = Cs({
    prefix: "u",
    name: "base64url",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6
})
  , k2e = Cs({
    prefix: "U",
    name: "base64urlpad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6
});
var N2e = Object.freeze({
    __proto__: null,
    base64: A2e,
    base64pad: C2e,
    base64url: _2e,
    base64urlpad: k2e
});
const dV = Array.from("")
  , D2e = dV.reduce( (n, e, t) => (n[t] = e,
n), [])
  , T2e = dV.reduce( (n, e, t) => (n[e.codePointAt(0)] = t,
n), []);
function I2e(n) {
    return n.reduce( (e, t) => (e += D2e[t],
    e), "")
}
function M2e(n) {
    const e = [];
    for (const t of n) {
        const r = T2e[t.codePointAt(0)];
        if (r === void 0)
            throw new Error(`Non-base256emoji character: ${t}`);
        e.push(r)
    }
    return new Uint8Array(e)
}
const B2e = Ax({
    prefix: "",
    name: "base256emoji",
    encode: I2e,
    decode: M2e
});
var R2e = Object.freeze({
    __proto__: null,
    base256emoji: B2e
})
  , O2e = fV
  , IO = 128
  , P2e = -128
  , j2e = Math.pow(2, 31);
function fV(n, e, t) {
    e = e || [],
    t = t || 0;
    for (var r = t; n >= j2e; )
        e[t++] = n & 255 | IO,
        n /= 128;
    for (; n & P2e; )
        e[t++] = n & 255 | IO,
        n >>>= 7;
    return e[t] = n | 0,
    fV.bytes = t - r + 1,
    e
}
var L2e = EC
  , F2e = 128
  , MO = 127;
function EC(n, r) {
    var t = 0, r = r || 0, s = 0, i = r, o, a = n.length;
    do {
        if (i >= a)
            throw EC.bytes = 0,
            new RangeError("Could not decode varint");
        o = n[i++],
        t += s < 28 ? (o & MO) << s : (o & MO) * Math.pow(2, s),
        s += 7
    } while (o >= F2e);
    return EC.bytes = i - r,
    t
}
var U2e = Math.pow(2, 7)
  , z2e = Math.pow(2, 14)
  , $2e = Math.pow(2, 21)
  , H2e = Math.pow(2, 28)
  , V2e = Math.pow(2, 35)
  , q2e = Math.pow(2, 42)
  , G2e = Math.pow(2, 49)
  , W2e = Math.pow(2, 56)
  , Y2e = Math.pow(2, 63)
  , K2e = function(n) {
    return n < U2e ? 1 : n < z2e ? 2 : n < $2e ? 3 : n < H2e ? 4 : n < V2e ? 5 : n < q2e ? 6 : n < G2e ? 7 : n < W2e ? 8 : n < Y2e ? 9 : 10
}
  , X2e = {
    encode: O2e,
    decode: L2e,
    encodingLength: K2e
}
  , hV = X2e;
const BO = (n, e, t=0) => (hV.encode(n, e, t),
e)
  , RO = n => hV.encodingLength(n)
  , SC = (n, e) => {
    const t = e.byteLength
      , r = RO(n)
      , s = r + RO(t)
      , i = new Uint8Array(s + t);
    return BO(n, i, 0),
    BO(t, i, r),
    i.set(e, s),
    new Q2e(n,t,e,i)
}
;
class Q2e {
    constructor(e, t, r, s) {
        this.code = e,
        this.size = t,
        this.digest = r,
        this.bytes = s
    }
}
const pV = ({name: n, code: e, encode: t}) => new Z2e(n,e,t);
class Z2e {
    constructor(e, t, r) {
        this.name = e,
        this.code = t,
        this.encode = r
    }
    digest(e) {
        if (e instanceof Uint8Array) {
            const t = this.encode(e);
            return t instanceof Uint8Array ? SC(this.code, t) : t.then(r => SC(this.code, r))
        } else
            throw Error("Unknown type, must be binary type")
    }
}
const mV = n => async e => new Uint8Array(await crypto.subtle.digest(n, e))
  , J2e = pV({
    name: "sha2-256",
    code: 18,
    encode: mV("SHA-256")
})
  , eve = pV({
    name: "sha2-512",
    code: 19,
    encode: mV("SHA-512")
});
var tve = Object.freeze({
    __proto__: null,
    sha256: J2e,
    sha512: eve
});
const gV = 0
  , nve = "identity"
  , yV = cV
  , rve = n => SC(gV, yV(n))
  , sve = {
    code: gV,
    name: nve,
    encode: yV,
    digest: rve
};
var ive = Object.freeze({
    __proto__: null,
    identity: sve
});
new TextEncoder,
new TextDecoder;
const OO = {
    ...Zwe,
    ...e2e,
    ...n2e,
    ...s2e,
    ...a2e,
    ...y2e,
    ...v2e,
    ...S2e,
    ...N2e,
    ...R2e
};
({
    ...tve,
    ...ive
});
function bV(n) {
    return globalThis.Buffer != null ? new Uint8Array(n.buffer,n.byteOffset,n.byteLength) : n
}
function ove(n=0) {
    return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? bV(globalThis.Buffer.allocUnsafe(n)) : new Uint8Array(n)
}
function wV(n, e, t, r) {
    return {
        name: n,
        prefix: e,
        encoder: {
            name: n,
            prefix: e,
            encode: t
        },
        decoder: {
            decode: r
        }
    }
}
const PO = wV("utf8", "u", n => "u" + new TextDecoder("utf8").decode(n), n => new TextEncoder().encode(n.substring(1)))
  , rA = wV("ascii", "a", n => {
    let e = "a";
    for (let t = 0; t < n.length; t++)
        e += String.fromCharCode(n[t]);
    return e
}
, n => {
    n = n.substring(1);
    const e = ove(n.length);
    for (let t = 0; t < n.length; t++)
        e[t] = n.charCodeAt(t);
    return e
}
)
  , ave = {
    utf8: PO,
    "utf-8": PO,
    hex: OO.base16,
    latin1: rA,
    ascii: rA,
    binary: rA,
    ...OO
};
function lve(n, e="utf8") {
    const t = ave[e];
    if (!t)
        throw new Error(`Unsupported encoding "${e}"`);
    return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? bV(globalThis.Buffer.from(n, "utf-8")) : t.decoder.decode(`${t.prefix}${n}`)
}
var cve = Object.defineProperty
  , uve = (n, e, t) => e in n ? cve(n, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : n[e] = t
  , Ta = (n, e, t) => uve(n, typeof e != "symbol" ? e + "" : e, t);
class dve {
    constructor(e, t) {
        this.core = e,
        this.logger = t,
        Ta(this, "keychain", new Map),
        Ta(this, "name", uwe),
        Ta(this, "version", dwe),
        Ta(this, "initialized", !1),
        Ta(this, "storagePrefix", rl),
        Ta(this, "init", async () => {
            if (!this.initialized) {
                const r = await this.getKeyChain();
                typeof r < "u" && (this.keychain = r),
                this.initialized = !0
            }
        }
        ),
        Ta(this, "has", r => (this.isInitialized(),
        this.keychain.has(r))),
        Ta(this, "set", async (r, s) => {
            this.isInitialized(),
            this.keychain.set(r, s),
            await this.persist()
        }
        ),
        Ta(this, "get", r => {
            this.isInitialized();
            const s = this.keychain.get(r);
            if (typeof s > "u") {
                const {message: i} = Fe("NO_MATCHING_KEY", `${this.name}: ${r}`);
                throw new Error(i)
            }
            return s
        }
        ),
        Ta(this, "del", async r => {
            this.isInitialized(),
            this.keychain.delete(r),
            await this.persist()
        }
        ),
        this.core = e,
        this.logger = ro(t, this.name)
    }
    get context() {
        return Ii(this.logger)
    }
    get storageKey() {
        return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name
    }
    async setKeyChain(e) {
        await this.core.storage.setItem(this.storageKey, iC(e))
    }
    async getKeyChain() {
        const e = await this.core.storage.getItem(this.storageKey);
        return typeof e < "u" ? oC(e) : void 0
    }
    async persist() {
        await this.setKeyChain(this.keychain)
    }
    isInitialized() {
        if (!this.initialized) {
            const {message: e} = Fe("NOT_INITIALIZED", this.name);
            throw new Error(e)
        }
    }
}
var fve = Object.defineProperty
  , hve = (n, e, t) => e in n ? fve(n, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : n[e] = t
  , Kr = (n, e, t) => hve(n, typeof e != "symbol" ? e + "" : e, t);
class pve {
    constructor(e, t, r) {
        this.core = e,
        this.logger = t,
        Kr(this, "name", lwe),
        Kr(this, "keychain"),
        Kr(this, "randomSessionIdentifier", yC()),
        Kr(this, "initialized", !1),
        Kr(this, "clientId"),
        Kr(this, "init", async () => {
            this.initialized || (await this.keychain.init(),
            this.initialized = !0)
        }
        ),
        Kr(this, "hasKeys", s => (this.isInitialized(),
        this.keychain.has(s))),
        Kr(this, "getClientId", async () => {
            if (this.isInitialized(),
            this.clientId)
                return this.clientId;
            const s = await this.getClientSeed()
              , i = iR(s)
              , o = O$(i.publicKey);
            return this.clientId = o,
            o
        }
        ),
        Kr(this, "generateKeyPair", () => {
            this.isInitialized();
            const s = gye();
            return this.setPrivateKey(s.publicKey, s.privateKey)
        }
        ),
        Kr(this, "signJWT", async s => {
            this.isInitialized();
            const i = await this.getClientSeed()
              , o = iR(i)
              , a = this.randomSessionIdentifier;
            return await Phe(a, s, cwe, o)
        }
        ),
        Kr(this, "generateSharedKey", (s, i, o) => {
            this.isInitialized();
            const a = this.getPrivateKey(s)
              , l = yye(a, i);
            return this.setSymKey(l, o)
        }
        ),
        Kr(this, "setSymKey", async (s, i) => {
            this.isInitialized();
            const o = i || qw(s);
            return await this.keychain.set(o, s),
            o
        }
        ),
        Kr(this, "deleteKeyPair", async s => {
            this.isInitialized(),
            await this.keychain.del(s)
        }
        ),
        Kr(this, "deleteSymKey", async s => {
            this.isInitialized(),
            await this.keychain.del(s)
        }
        ),
        Kr(this, "encode", async (s, i, o) => {
            this.isInitialized();
            const a = WH(o)
              , l = Tc(i);
            if (eO(a))
                return vye(l, o?.encoding);
            if (JR(a)) {
                const p = a.senderPublicKey
                  , g = a.receiverPublicKey;
                s = await this.generateSharedKey(p, g)
            }
            const u = this.getSymKey(s)
              , {type: d, senderPublicKey: h} = a;
            return bye({
                type: d,
                symKey: u,
                message: l,
                senderPublicKey: h,
                encoding: o?.encoding
            })
        }
        ),
        Kr(this, "decode", async (s, i, o) => {
            this.isInitialized();
            const a = Eye(i, o);
            if (eO(a)) {
                const l = xye(i, o?.encoding);
                return Of(l)
            }
            if (JR(a)) {
                const l = a.receiverPublicKey
                  , u = a.senderPublicKey;
                s = await this.generateSharedKey(l, u)
            }
            try {
                const l = this.getSymKey(s)
                  , u = wye({
                    symKey: l,
                    encoded: i,
                    encoding: o?.encoding
                });
                return Of(u)
            } catch (l) {
                this.logger.error(`Failed to decode message from topic: '${s}', clientId: '${await this.getClientId()}'`),
                this.logger.error(l)
            }
        }
        ),
        Kr(this, "getPayloadType", (s, i=xi) => {
            const o = sy({
                encoded: s,
                encoding: i
            });
            return jf(o.type)
        }
        ),
        Kr(this, "getPayloadSenderPublicKey", (s, i=xi) => {
            const o = sy({
                encoded: s,
                encoding: i
            });
            return o.senderPublicKey ? Ni(o.senderPublicKey, ni) : void 0
        }
        ),
        this.core = e,
        this.logger = ro(t, this.name),
        this.keychain = r || new dve(this.core,this.logger)
    }
    get context() {
        return Ii(this.logger)
    }
    async setPrivateKey(e, t) {
        return await this.keychain.set(e, t),
        e
    }
    getPrivateKey(e) {
        return this.keychain.get(e)
    }
    async getClientSeed() {
        let e = "";
        try {
            e = this.keychain.get(DO)
        } catch {
            e = yC(),
            await this.keychain.set(DO, e)
        }
        return lve(e, "base16")
    }
    getSymKey(e) {
        return this.keychain.get(e)
    }
    isInitialized() {
        if (!this.initialized) {
            const {message: e} = Fe("NOT_INITIALIZED", this.name);
            throw new Error(e)
        }
    }
}
var mve = Object.defineProperty
  , gve = Object.defineProperties
  , yve = Object.getOwnPropertyDescriptors
  , jO = Object.getOwnPropertySymbols
  , bve = Object.prototype.hasOwnProperty
  , wve = Object.prototype.propertyIsEnumerable
  , AC = (n, e, t) => e in n ? mve(n, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : n[e] = t
  , vve = (n, e) => {
    for (var t in e || (e = {}))
        bve.call(e, t) && AC(n, t, e[t]);
    if (jO)
        for (var t of jO(e))
            wve.call(e, t) && AC(n, t, e[t]);
    return n
}
  , xve = (n, e) => gve(n, yve(e))
  , Fi = (n, e, t) => AC(n, typeof e != "symbol" ? e + "" : e, t);
class Eve extends S1e {
    constructor(e, t) {
        super(e, t),
        this.logger = e,
        this.core = t,
        Fi(this, "messages", new Map),
        Fi(this, "messagesWithoutClientAck", new Map),
        Fi(this, "name", fwe),
        Fi(this, "version", hwe),
        Fi(this, "initialized", !1),
        Fi(this, "storagePrefix", rl),
        Fi(this, "init", async () => {
            if (!this.initialized) {
                this.logger.trace("Initialized");
                try {
                    const r = await this.getRelayerMessages();
                    typeof r < "u" && (this.messages = r);
                    const s = await this.getRelayerMessagesWithoutClientAck();
                    typeof s < "u" && (this.messagesWithoutClientAck = s),
                    this.logger.debug(`Successfully Restored records for ${this.name}`),
                    this.logger.trace({
                        type: "method",
                        method: "restore",
                        size: this.messages.size
                    })
                } catch (r) {
                    this.logger.debug(`Failed to Restore records for ${this.name}`),
                    this.logger.error(r)
                } finally {
                    this.initialized = !0
                }
            }
        }
        ),
        Fi(this, "set", async (r, s, i) => {
            this.isInitialized();
            const o = Co(s);
            let a = this.messages.get(r);
            if (typeof a > "u" && (a = {}),
            typeof a[o] < "u")
                return o;
            if (a[o] = s,
            this.messages.set(r, a),
            i === Yw.inbound) {
                const l = this.messagesWithoutClientAck.get(r) || {};
                this.messagesWithoutClientAck.set(r, xve(vve({}, l), {
                    [o]: s
                }))
            }
            return await this.persist(),
            o
        }
        ),
        Fi(this, "get", r => {
            this.isInitialized();
            let s = this.messages.get(r);
            return typeof s > "u" && (s = {}),
            s
        }
        ),
        Fi(this, "getWithoutAck", r => {
            this.isInitialized();
            const s = {};
            for (const i of r) {
                const o = this.messagesWithoutClientAck.get(i) || {};
                s[i] = Object.values(o)
            }
            return s
        }
        ),
        Fi(this, "has", (r, s) => {
            this.isInitialized();
            const i = this.get(r)
              , o = Co(s);
            return typeof i[o] < "u"
        }
        ),
        Fi(this, "ack", async (r, s) => {
            this.isInitialized();
            const i = this.messagesWithoutClientAck.get(r);
            if (typeof i > "u")
                return;
            const o = Co(s);
            delete i[o],
            Object.keys(i).length === 0 ? this.messagesWithoutClientAck.delete(r) : this.messagesWithoutClientAck.set(r, i),
            await this.persist()
        }
        ),
        Fi(this, "del", async r => {
            this.isInitialized(),
            this.messages.delete(r),
            this.messagesWithoutClientAck.delete(r),
            await this.persist()
        }
        ),
        this.logger = ro(e, this.name),
        this.core = t
    }
    get context() {
        return Ii(this.logger)
    }
    get storageKey() {
        return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name
    }
    get storageKeyWithoutClientAck() {
        return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name + "_withoutClientAck"
    }
    async setRelayerMessages(e) {
        await this.core.storage.setItem(this.storageKey, iC(e))
    }
    async setRelayerMessagesWithoutClientAck(e) {
        await this.core.storage.setItem(this.storageKeyWithoutClientAck, iC(e))
    }
    async getRelayerMessages() {
        const e = await this.core.storage.getItem(this.storageKey);
        return typeof e < "u" ? oC(e) : void 0
    }
    async getRelayerMessagesWithoutClientAck() {
        const e = await this.core.storage.getItem(this.storageKeyWithoutClientAck);
        return typeof e < "u" ? oC(e) : void 0
    }
    async persist() {
        await this.setRelayerMessages(this.messages),
        await this.setRelayerMessagesWithoutClientAck(this.messagesWithoutClientAck)
    }
    isInitialized() {
        if (!this.initialized) {
            const {message: e} = Fe("NOT_INITIALIZED", this.name);
            throw new Error(e)
        }
    }
}
var Sve = Object.defineProperty
  , Ave = Object.defineProperties
  , Cve = Object.getOwnPropertyDescriptors
  , LO = Object.getOwnPropertySymbols
  , _ve = Object.prototype.hasOwnProperty
  , kve = Object.prototype.propertyIsEnumerable
  , CC = (n, e, t) => e in n ? Sve(n, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : n[e] = t
  , Zh = (n, e) => {
    for (var t in e || (e = {}))
        _ve.call(e, t) && CC(n, t, e[t]);
    if (LO)
        for (var t of LO(e))
            kve.call(e, t) && CC(n, t, e[t]);
    return n
}
  , FO = (n, e) => Ave(n, Cve(e))
  , vo = (n, e, t) => CC(n, typeof e != "symbol" ? e + "" : e, t);
class Nve extends A1e {
    constructor(e, t) {
        super(e, t),
        this.relayer = e,
        this.logger = t,
        vo(this, "events", new no.EventEmitter),
        vo(this, "name", mwe),
        vo(this, "queue", new Map),
        vo(this, "publishTimeout", je.toMiliseconds(je.ONE_MINUTE)),
        vo(this, "initialPublishTimeout", je.toMiliseconds(je.ONE_SECOND * 15)),
        vo(this, "needsTransportRestart", !1),
        vo(this, "publish", async (r, s, i) => {
            var o, a, l, u, d;
            this.logger.debug("Publishing Payload"),
            this.logger.trace({
                type: "method",
                method: "publish",
                params: {
                    topic: r,
                    message: s,
                    opts: i
                }
            });
            const h = i?.ttl || pwe
              , p = i?.prompt || !1
              , g = i?.tag || 0
              , w = i?.id || Fu().toString()
              , b = wp(W2().protocol)
              , v = {
                id: w,
                method: i?.publishMethod || b.publish,
                params: Zh({
                    topic: r,
                    message: s,
                    ttl: h,
                    prompt: p,
                    tag: g,
                    attestation: i?.attestation
                }, i?.tvf)
            }
              , S = `Failed to publish payload, please try again. id:${w} tag:${g}`;
            try {
                ts((o = v.params) == null ? void 0 : o.prompt) && ((a = v.params) == null || delete a.prompt),
                ts((l = v.params) == null ? void 0 : l.tag) && ((u = v.params) == null || delete u.tag);
                const N = new Promise(async _ => {
                    const I = ({id: B}) => {
                        var P;
                        ((P = v.id) == null ? void 0 : P.toString()) === B.toString() && (this.removeRequestFromQueue(B),
                        this.relayer.events.removeListener(Or.publish, I),
                        _())
                    }
                    ;
                    this.relayer.events.on(Or.publish, I);
                    const k = Wa(new Promise( (B, P) => {
                        this.rpcPublish(v, i).then(B).catch(M => {
                            this.logger.warn(M, M?.message),
                            P(M)
                        }
                        )
                    }
                    ), this.initialPublishTimeout, `Failed initial publish, retrying.... id:${w} tag:${g}`);
                    try {
                        await k,
                        this.events.removeListener(Or.publish, I)
                    } catch (B) {
                        this.queue.set(w, {
                            request: v,
                            opts: i,
                            attempt: 1
                        }),
                        this.logger.warn(B, B?.message)
                    }
                }
                );
                this.logger.trace({
                    type: "method",
                    method: "publish",
                    params: {
                        id: w,
                        topic: r,
                        message: s,
                        opts: i
                    }
                }),
                await Wa(N, this.publishTimeout, S)
            } catch (N) {
                if (this.logger.debug("Failed to Publish Payload"),
                this.logger.error(N),
                (d = i?.internal) != null && d.throwOnFailedPublish)
                    throw N
            } finally {
                this.queue.delete(w)
            }
        }
        ),
        vo(this, "publishCustom", async r => {
            var s, i, o, a, l;
            this.logger.debug("Publishing custom payload"),
            this.logger.trace({
                type: "method",
                method: "publishCustom",
                params: r
            });
            const {payload: u, opts: d={}} = r
              , {attestation: h, tvf: p, publishMethod: g, prompt: w, tag: b, ttl: v=je.FIVE_MINUTES} = d
              , S = d.id || Fu().toString()
              , N = wp(W2().protocol)
              , _ = g || N.publish
              , I = {
                id: S,
                method: _,
                params: Zh(FO(Zh({}, u), {
                    ttl: v,
                    prompt: w,
                    tag: b,
                    attestation: h
                }), p)
            }
              , k = `Failed to publish custom payload, please try again. id:${S} tag:${b}`;
            try {
                ts((s = I.params) == null ? void 0 : s.prompt) && ((i = I.params) == null || delete i.prompt),
                ts((o = I.params) == null ? void 0 : o.tag) && ((a = I.params) == null || delete a.tag);
                const B = new Promise(async P => {
                    const M = ({id: L}) => {
                        var q;
                        ((q = I.id) == null ? void 0 : q.toString()) === L.toString() && (this.removeRequestFromQueue(L),
                        this.relayer.events.removeListener(Or.publish, M),
                        P())
                    }
                    ;
                    this.relayer.events.on(Or.publish, M);
                    const R = Wa(new Promise( (L, q) => {
                        this.rpcPublish(I, d).then(L).catch(H => {
                            this.logger.warn(H, H?.message),
                            q(H)
                        }
                        )
                    }
                    ), this.initialPublishTimeout, `Failed initial custom payload publish, retrying.... method:${_} id:${S} tag:${b}`);
                    try {
                        await R,
                        this.events.removeListener(Or.publish, M)
                    } catch (L) {
                        this.queue.set(S, {
                            request: I,
                            opts: d,
                            attempt: 1
                        }),
                        this.logger.warn(L, L?.message)
                    }
                }
                );
                this.logger.trace({
                    type: "method",
                    method: "publish",
                    params: {
                        id: S,
                        payload: u,
                        opts: d
                    }
                }),
                await Wa(B, this.publishTimeout, k)
            } catch (B) {
                if (this.logger.debug("Failed to Publish Payload"),
                this.logger.error(B),
                (l = d?.internal) != null && l.throwOnFailedPublish)
                    throw B
            } finally {
                this.queue.delete(S)
            }
        }
        ),
        vo(this, "on", (r, s) => {
            this.events.on(r, s)
        }
        ),
        vo(this, "once", (r, s) => {
            this.events.once(r, s)
        }
        ),
        vo(this, "off", (r, s) => {
            this.events.off(r, s)
        }
        ),
        vo(this, "removeListener", (r, s) => {
            this.events.removeListener(r, s)
        }
        ),
        this.relayer = e,
        this.logger = ro(t, this.name),
        this.registerEventListeners()
    }
    get context() {
        return Ii(this.logger)
    }
    async rpcPublish(e, t) {
        this.logger.debug("Outgoing Relay Payload"),
        this.logger.trace({
            type: "message",
            direction: "outgoing",
            request: e
        });
        const r = await this.relayer.request(e);
        return this.relayer.events.emit(Or.publish, Zh(Zh({}, e), t)),
        this.logger.debug("Successfully Published Payload"),
        r
    }
    removeRequestFromQueue(e) {
        this.queue.delete(e)
    }
    checkQueue() {
        this.queue.forEach(async (e, t) => {
            var r;
            const s = e.attempt + 1;
            this.queue.set(t, FO(Zh({}, e), {
                attempt: s
            })),
            this.logger.warn({}, `Publisher: queue->publishing: ${e.request.id}, tag: ${(r = e.request.params) == null ? void 0 : r.tag}, attempt: ${s}`),
            await this.rpcPublish(e.request, e.opts),
            this.logger.warn({}, `Publisher: queue->published: ${e.request.id}`)
        }
        )
    }
    registerEventListeners() {
        this.relayer.core.heartbeat.on(Qf.pulse, () => {
            if (this.needsTransportRestart) {
                this.needsTransportRestart = !1,
                this.relayer.events.emit(Or.connection_stalled);
                return
            }
            this.checkQueue()
        }
        ),
        this.relayer.on(Or.message_ack, e => {
            this.removeRequestFromQueue(e.id.toString())
        }
        )
    }
}
var Dve = Object.defineProperty
  , Tve = (n, e, t) => e in n ? Dve(n, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : n[e] = t
  , Jh = (n, e, t) => Tve(n, typeof e != "symbol" ? e + "" : e, t);
class Ive {
    constructor() {
        Jh(this, "map", new Map),
        Jh(this, "set", (e, t) => {
            const r = this.get(e);
            this.exists(e, t) || this.map.set(e, [...r, t])
        }
        ),
        Jh(this, "get", e => this.map.get(e) || []),
        Jh(this, "exists", (e, t) => this.get(e).includes(t)),
        Jh(this, "delete", (e, t) => {
            if (typeof t > "u") {
                this.map.delete(e);
                return
            }
            if (!this.map.has(e))
                return;
            const r = this.get(e);
            if (!this.exists(e, t))
                return;
            const s = r.filter(i => i !== t);
            if (!s.length) {
                this.map.delete(e);
                return
            }
            this.map.set(e, s)
        }
        ),
        Jh(this, "clear", () => {
            this.map.clear()
        }
        )
    }
    get topics() {
        return Array.from(this.map.keys())
    }
}
var Mve = Object.defineProperty
  , Bve = Object.defineProperties
  , Rve = Object.getOwnPropertyDescriptors
  , UO = Object.getOwnPropertySymbols
  , Ove = Object.prototype.hasOwnProperty
  , Pve = Object.prototype.propertyIsEnumerable
  , _C = (n, e, t) => e in n ? Mve(n, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : n[e] = t
  , Qm = (n, e) => {
    for (var t in e || (e = {}))
        Ove.call(e, t) && _C(n, t, e[t]);
    if (UO)
        for (var t of UO(e))
            Pve.call(e, t) && _C(n, t, e[t]);
    return n
}
  , sA = (n, e) => Bve(n, Rve(e))
  , jn = (n, e, t) => _C(n, typeof e != "symbol" ? e + "" : e, t);
class jve extends k1e {
    constructor(e, t) {
        super(e, t),
        this.relayer = e,
        this.logger = t,
        jn(this, "subscriptions", new Map),
        jn(this, "topicMap", new Ive),
        jn(this, "events", new no.EventEmitter),
        jn(this, "name", Ewe),
        jn(this, "version", Swe),
        jn(this, "pending", new Map),
        jn(this, "cached", []),
        jn(this, "initialized", !1),
        jn(this, "storagePrefix", rl),
        jn(this, "subscribeTimeout", je.toMiliseconds(je.ONE_MINUTE)),
        jn(this, "initialSubscribeTimeout", je.toMiliseconds(je.ONE_SECOND * 15)),
        jn(this, "clientId"),
        jn(this, "batchSubscribeTopicsLimit", 500),
        jn(this, "init", async () => {
            this.initialized || (this.logger.trace("Initialized"),
            this.registerEventListeners(),
            await this.restore()),
            this.initialized = !0
        }
        ),
        jn(this, "subscribe", async (r, s) => {
            var i;
            this.isInitialized(),
            this.logger.debug("Subscribing Topic"),
            this.logger.trace({
                type: "method",
                method: "subscribe",
                params: {
                    topic: r,
                    opts: s
                }
            });
            try {
                const o = W2(s)
                  , a = {
                    topic: r,
                    relay: o,
                    transportType: s?.transportType
                };
                (i = s?.internal) != null && i.skipSubscribe || this.pending.set(r, a);
                const l = await this.rpcSubscribe(r, o, s);
                return typeof l == "string" && (this.onSubscribe(l, a),
                this.logger.debug("Successfully Subscribed Topic"),
                this.logger.trace({
                    type: "method",
                    method: "subscribe",
                    params: {
                        topic: r,
                        opts: s
                    }
                })),
                l
            } catch (o) {
                throw this.logger.debug("Failed to Subscribe Topic"),
                this.logger.error(o),
                o
            }
        }
        ),
        jn(this, "unsubscribe", async (r, s) => {
            this.isInitialized(),
            typeof s?.id < "u" ? await this.unsubscribeById(r, s.id, s) : await this.unsubscribeByTopic(r, s)
        }
        ),
        jn(this, "isSubscribed", r => new Promise(s => {
            s(this.topicMap.topics.includes(r))
        }
        )),
        jn(this, "isKnownTopic", r => new Promise(s => {
            s(this.topicMap.topics.includes(r) || this.pending.has(r) || this.cached.some(i => i.topic === r))
        }
        )),
        jn(this, "on", (r, s) => {
            this.events.on(r, s)
        }
        ),
        jn(this, "once", (r, s) => {
            this.events.once(r, s)
        }
        ),
        jn(this, "off", (r, s) => {
            this.events.off(r, s)
        }
        ),
        jn(this, "removeListener", (r, s) => {
            this.events.removeListener(r, s)
        }
        ),
        jn(this, "start", async () => {
            await this.onConnect()
        }
        ),
        jn(this, "stop", async () => {
            await this.onDisconnect()
        }
        ),
        jn(this, "restart", async () => {
            await this.restore(),
            await this.onRestart()
        }
        ),
        jn(this, "checkPending", async () => {
            if (this.pending.size === 0 && (!this.initialized || !this.relayer.connected))
                return;
            const r = [];
            this.pending.forEach(s => {
                r.push(s)
            }
            ),
            await this.batchSubscribe(r)
        }
        ),
        jn(this, "registerEventListeners", () => {
            this.relayer.core.heartbeat.on(Qf.pulse, async () => {
                await this.checkPending()
            }
            ),
            this.events.on($i.created, async r => {
                const s = $i.created;
                this.logger.info(`Emitting ${s}`),
                this.logger.debug({
                    type: "event",
                    event: s,
                    data: r
                }),
                await this.persist()
            }
            ),
            this.events.on($i.deleted, async r => {
                const s = $i.deleted;
                this.logger.info(`Emitting ${s}`),
                this.logger.debug({
                    type: "event",
                    event: s,
                    data: r
                }),
                await this.persist()
            }
            )
        }
        ),
        this.relayer = e,
        this.logger = ro(t, this.name),
        this.clientId = ""
    }
    get context() {
        return Ii(this.logger)
    }
    get storageKey() {
        return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name
    }
    get length() {
        return this.subscriptions.size
    }
    get ids() {
        return Array.from(this.subscriptions.keys())
    }
    get values() {
        return Array.from(this.subscriptions.values())
    }
    get topics() {
        return this.topicMap.topics
    }
    get hasAnyTopics() {
        return this.topicMap.topics.length > 0 || this.pending.size > 0 || this.cached.length > 0 || this.subscriptions.size > 0
    }
    hasSubscription(e, t) {
        let r = !1;
        try {
            r = this.getSubscription(e).topic === t
        } catch {}
        return r
    }
    reset() {
        this.cached = [],
        this.initialized = !0
    }
    onDisable() {
        this.values.length > 0 && (this.cached = this.values),
        this.subscriptions.clear(),
        this.topicMap.clear()
    }
    async unsubscribeByTopic(e, t) {
        const r = this.topicMap.get(e);
        await Promise.all(r.map(async s => await this.unsubscribeById(e, s, t)))
    }
    async unsubscribeById(e, t, r) {
        this.logger.debug("Unsubscribing Topic"),
        this.logger.trace({
            type: "method",
            method: "unsubscribe",
            params: {
                topic: e,
                id: t,
                opts: r
            }
        });
        try {
            const s = W2(r);
            await this.restartToComplete({
                topic: e,
                id: t,
                relay: s
            }),
            await this.rpcUnsubscribe(e, t, s);
            const i = Yn("USER_DISCONNECTED", `${this.name}, ${e}`);
            await this.onUnsubscribe(e, t, i),
            this.logger.debug("Successfully Unsubscribed Topic"),
            this.logger.trace({
                type: "method",
                method: "unsubscribe",
                params: {
                    topic: e,
                    id: t,
                    opts: r
                }
            })
        } catch (s) {
            throw this.logger.debug("Failed to Unsubscribe Topic"),
            this.logger.error(s),
            s
        }
    }
    async rpcSubscribe(e, t, r) {
        var s, i;
        const o = await this.getSubscriptionId(e);
        if ((s = r?.internal) != null && s.skipSubscribe)
            return o;
        (!r || r?.transportType === Gn.relay) && await this.restartToComplete({
            topic: e,
            id: e,
            relay: t
        });
        const a = {
            method: wp(t.protocol).subscribe,
            params: {
                topic: e
            }
        };
        this.logger.debug("Outgoing Relay Payload"),
        this.logger.trace({
            type: "payload",
            direction: "outgoing",
            request: a
        });
        const l = (i = r?.internal) == null ? void 0 : i.throwOnFailedPublish;
        try {
            if (r?.transportType === Gn.link_mode)
                return setTimeout( () => {
                    (this.relayer.connected || this.relayer.connecting) && this.relayer.request(a).catch(h => this.logger.warn(h))
                }
                , je.toMiliseconds(je.ONE_SECOND)),
                o;
            const u = new Promise(async h => {
                const p = g => {
                    g.topic === e && (this.events.removeListener($i.created, p),
                    h(g.id))
                }
                ;
                this.events.on($i.created, p);
                try {
                    const g = await Wa(new Promise( (w, b) => {
                        this.relayer.request(a).catch(v => {
                            this.logger.warn(v, v?.message),
                            b(v)
                        }
                        ).then(w)
                    }
                    ), this.initialSubscribeTimeout, `Subscribing to ${e} failed, please try again`);
                    this.events.removeListener($i.created, p),
                    h(g)
                } catch {}
            }
            )
              , d = await Wa(u, this.subscribeTimeout, `Subscribing to ${e} failed, please try again`);
            if (!d && l)
                throw new Error(`Subscribing to ${e} failed, please try again`);
            return d ? o : null
        } catch (u) {
            if (this.logger.debug("Outgoing Relay Subscribe Payload stalled"),
            this.relayer.events.emit(Or.connection_stalled),
            l)
                throw u
        }
        return null
    }
    async rpcBatchSubscribe(e) {
        if (!e.length)
            return;
        const t = e[0].relay
          , r = {
            method: wp(t.protocol).batchSubscribe,
            params: {
                topics: e.map(s => s.topic)
            }
        };
        this.logger.debug("Outgoing Relay Payload"),
        this.logger.trace({
            type: "payload",
            direction: "outgoing",
            request: r
        });
        try {
            await await Wa(new Promise(s => {
                this.relayer.request(r).catch(i => this.logger.warn(i)).then(s)
            }
            ), this.subscribeTimeout, "rpcBatchSubscribe failed, please try again")
        } catch {
            this.relayer.events.emit(Or.connection_stalled)
        }
    }
    async rpcBatchFetchMessages(e) {
        if (!e.length)
            return;
        const t = e[0].relay
          , r = {
            method: wp(t.protocol).batchFetchMessages,
            params: {
                topics: e.map(i => i.topic)
            }
        };
        this.logger.debug("Outgoing Relay Payload"),
        this.logger.trace({
            type: "payload",
            direction: "outgoing",
            request: r
        });
        let s;
        try {
            s = await await Wa(new Promise( (i, o) => {
                this.relayer.request(r).catch(a => {
                    this.logger.warn(a),
                    o(a)
                }
                ).then(i)
            }
            ), this.subscribeTimeout, "rpcBatchFetchMessages failed, please try again")
        } catch {
            this.relayer.events.emit(Or.connection_stalled)
        }
        return s
    }
    rpcUnsubscribe(e, t, r) {
        const s = {
            method: wp(r.protocol).unsubscribe,
            params: {
                topic: e,
                id: t
            }
        };
        return this.logger.debug("Outgoing Relay Payload"),
        this.logger.trace({
            type: "payload",
            direction: "outgoing",
            request: s
        }),
        this.relayer.request(s)
    }
    onSubscribe(e, t) {
        this.setSubscription(e, sA(Qm({}, t), {
            id: e
        })),
        this.pending.delete(t.topic)
    }
    onBatchSubscribe(e) {
        e.length && e.forEach(t => {
            this.setSubscription(t.id, Qm({}, t)),
            this.pending.delete(t.topic)
        }
        )
    }
    async onUnsubscribe(e, t, r) {
        this.events.removeAllListeners(t),
        this.hasSubscription(t, e) && this.deleteSubscription(t, r),
        await this.relayer.messages.del(e)
    }
    async setRelayerSubscriptions(e) {
        await this.relayer.core.storage.setItem(this.storageKey, e)
    }
    async getRelayerSubscriptions() {
        return await this.relayer.core.storage.getItem(this.storageKey)
    }
    setSubscription(e, t) {
        this.logger.debug("Setting subscription"),
        this.logger.trace({
            type: "method",
            method: "setSubscription",
            id: e,
            subscription: t
        }),
        this.addSubscription(e, t)
    }
    addSubscription(e, t) {
        this.subscriptions.set(e, Qm({}, t)),
        this.topicMap.set(t.topic, e),
        this.events.emit($i.created, t)
    }
    getSubscription(e) {
        this.logger.debug("Getting subscription"),
        this.logger.trace({
            type: "method",
            method: "getSubscription",
            id: e
        });
        const t = this.subscriptions.get(e);
        if (!t) {
            const {message: r} = Fe("NO_MATCHING_KEY", `${this.name}: ${e}`);
            throw new Error(r)
        }
        return t
    }
    deleteSubscription(e, t) {
        this.logger.debug("Deleting subscription"),
        this.logger.trace({
            type: "method",
            method: "deleteSubscription",
            id: e,
            reason: t
        });
        const r = this.getSubscription(e);
        this.subscriptions.delete(e),
        this.topicMap.delete(r.topic, e),
        this.events.emit($i.deleted, sA(Qm({}, r), {
            reason: t
        }))
    }
    async persist() {
        await this.setRelayerSubscriptions(this.values),
        this.events.emit($i.sync)
    }
    async onRestart() {
        if (this.cached.length) {
            const e = [...this.cached]
              , t = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
            for (let r = 0; r < t; r++) {
                const s = e.splice(0, this.batchSubscribeTopicsLimit);
                await this.batchSubscribe(s)
            }
        }
        this.events.emit($i.resubscribed)
    }
    async restore() {
        try {
            const e = await this.getRelayerSubscriptions();
            if (typeof e > "u" || !e.length)
                return;
            if (this.subscriptions.size && !e.every(t => {
                var r;
                return t.topic === ((r = this.subscriptions.get(t.id)) == null ? void 0 : r.topic)
            }
            )) {
                const {message: t} = Fe("RESTORE_WILL_OVERRIDE", this.name);
                throw this.logger.error(t),
                this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`),
                new Error(t)
            }
            this.cached = e,
            this.logger.debug(`Successfully Restored subscriptions for ${this.name}`),
            this.logger.trace({
                type: "method",
                method: "restore",
                subscriptions: this.values
            })
        } catch (e) {
            this.logger.debug(`Failed to Restore subscriptions for ${this.name}`),
            this.logger.error(e)
        }
    }
    async batchSubscribe(e) {
        e.length && (await this.rpcBatchSubscribe(e),
        this.onBatchSubscribe(await Promise.all(e.map(async t => sA(Qm({}, t), {
            id: await this.getSubscriptionId(t.topic)
        })))))
    }
    async batchFetchMessages(e) {
        if (!e.length)
            return;
        this.logger.trace(`Fetching batch messages for ${e.length} subscriptions`);
        const t = await this.rpcBatchFetchMessages(e);
        t && t.messages && (await P0e(je.toMiliseconds(je.ONE_SECOND)),
        await this.relayer.handleBatchMessageEvents(t.messages))
    }
    async onConnect() {
        await this.restart(),
        this.reset()
    }
    onDisconnect() {
        this.onDisable()
    }
    isInitialized() {
        if (!this.initialized) {
            const {message: e} = Fe("NOT_INITIALIZED", this.name);
            throw new Error(e)
        }
    }
    async restartToComplete(e) {
        !this.relayer.connected && !this.relayer.connecting && (this.cached.push(e),
        await this.relayer.transportOpen())
    }
    async getClientId() {
        return this.clientId || (this.clientId = await this.relayer.core.crypto.getClientId()),
        this.clientId
    }
    async getSubscriptionId(e) {
        return Co(e + await this.getClientId())
    }
}
var Lve = Object.defineProperty
  , zO = Object.getOwnPropertySymbols
  , Fve = Object.prototype.hasOwnProperty
  , Uve = Object.prototype.propertyIsEnumerable
  , kC = (n, e, t) => e in n ? Lve(n, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : n[e] = t
  , $O = (n, e) => {
    for (var t in e || (e = {}))
        Fve.call(e, t) && kC(n, t, e[t]);
    if (zO)
        for (var t of zO(e))
            Uve.call(e, t) && kC(n, t, e[t]);
    return n
}
  , pn = (n, e, t) => kC(n, typeof e != "symbol" ? e + "" : e, t);
class zve extends C1e {
    constructor(e) {
        var t;
        super(e),
        pn(this, "protocol", "wc"),
        pn(this, "version", 2),
        pn(this, "core"),
        pn(this, "logger"),
        pn(this, "events", new no.EventEmitter),
        pn(this, "provider"),
        pn(this, "messages"),
        pn(this, "subscriber"),
        pn(this, "publisher"),
        pn(this, "name", ywe),
        pn(this, "transportExplicitlyClosed", !1),
        pn(this, "initialized", !1),
        pn(this, "connectionAttemptInProgress", !1),
        pn(this, "relayUrl"),
        pn(this, "projectId"),
        pn(this, "packageName"),
        pn(this, "bundleId"),
        pn(this, "hasExperiencedNetworkDisruption", !1),
        pn(this, "pingTimeout"),
        pn(this, "heartBeatTimeout", je.toMiliseconds(je.THIRTY_SECONDS + je.FIVE_SECONDS)),
        pn(this, "reconnectTimeout"),
        pn(this, "connectPromise"),
        pn(this, "reconnectInProgress", !1),
        pn(this, "requestsInFlight", []),
        pn(this, "connectTimeout", je.toMiliseconds(je.ONE_SECOND * 15)),
        pn(this, "request", async r => {
            var s, i;
            this.logger.debug("Publishing Request Payload");
            const o = r.id || Fu().toString();
            await this.toEstablishConnection();
            try {
                this.logger.trace({
                    id: o,
                    method: r.method,
                    topic: (s = r.params) == null ? void 0 : s.topic
                }, "relayer.request - publishing...");
                const a = `${o}:${((i = r.params) == null ? void 0 : i.tag) || ""}`;
                this.requestsInFlight.push(a);
                const l = await this.provider.request(r);
                return this.requestsInFlight = this.requestsInFlight.filter(u => u !== a),
                l
            } catch (a) {
                throw this.logger.debug(`Failed to Publish Request: ${o}`),
                a
            }
        }
        ),
        pn(this, "resetPingTimeout", () => {
            z2() && (clearTimeout(this.pingTimeout),
            this.pingTimeout = setTimeout( () => {
                var r, s, i, o;
                try {
                    this.logger.debug({}, "pingTimeout: Connection stalled, terminating..."),
                    (o = (i = (s = (r = this.provider) == null ? void 0 : r.connection) == null ? void 0 : s.socket) == null ? void 0 : i.terminate) == null || o.call(i)
                } catch (a) {
                    this.logger.warn(a, a?.message)
                }
            }
            , this.heartBeatTimeout))
        }
        ),
        pn(this, "onPayloadHandler", r => {
            this.onProviderPayload(r),
            this.resetPingTimeout()
        }
        ),
        pn(this, "onConnectHandler", () => {
            this.logger.warn({}, "Relayer connected "),
            this.startPingTimeout(),
            this.events.emit(Or.connect)
        }
        ),
        pn(this, "onDisconnectHandler", () => {
            this.logger.warn({}, "Relayer disconnected "),
            this.requestsInFlight = [],
            this.onProviderDisconnect()
        }
        ),
        pn(this, "onProviderErrorHandler", r => {
            this.logger.fatal(`Fatal socket error: ${r.message}`),
            this.events.emit(Or.error, r),
            this.logger.fatal("Fatal socket error received, closing transport"),
            this.transportClose()
        }
        ),
        pn(this, "registerProviderListeners", () => {
            this.provider.on(wo.payload, this.onPayloadHandler),
            this.provider.on(wo.connect, this.onConnectHandler),
            this.provider.on(wo.disconnect, this.onDisconnectHandler),
            this.provider.on(wo.error, this.onProviderErrorHandler)
        }
        ),
        this.core = e.core,
        this.logger = G_({
            logger: (t = e.logger) != null ? t : gwe,
            name: this.name
        }),
        this.messages = new Eve(this.logger,e.core),
        this.subscriber = new jve(this,this.logger),
        this.publisher = new Nve(this,this.logger),
        this.projectId = e?.projectId,
        this.relayUrl = e?.relayUrl || aV,
        v0e() ? this.packageName = xR() : x0e() && (this.bundleId = xR()),
        this.provider = {}
    }
    async init() {
        this.logger.trace("Initialized"),
        this.registerEventListeners(),
        await Promise.all([this.messages.init(), this.subscriber.init()]),
        this.initialized = !0,
        this.transportOpen().catch(e => this.logger.warn(e, e?.message))
    }
    get context() {
        return Ii(this.logger)
    }
    get connected() {
        var e, t, r;
        return ((r = (t = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : t.socket) == null ? void 0 : r.readyState) === 1 || !1
    }
    get connecting() {
        var e, t, r;
        return ((r = (t = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : t.socket) == null ? void 0 : r.readyState) === 0 || this.connectPromise !== void 0 || !1
    }
    async publish(e, t, r) {
        this.isInitialized(),
        await this.publisher.publish(e, t, r),
        await this.recordMessageEvent({
            topic: e,
            message: t,
            publishedAt: Date.now(),
            transportType: Gn.relay
        }, Yw.outbound)
    }
    async publishCustom(e) {
        this.isInitialized(),
        await this.publisher.publishCustom(e)
    }
    async subscribe(e, t) {
        var r, s, i;
        this.isInitialized(),
        (!(t != null && t.transportType) || t?.transportType === "relay") && await this.toEstablishConnection();
        const o = typeof ((r = t?.internal) == null ? void 0 : r.throwOnFailedPublish) > "u" ? !0 : (s = t?.internal) == null ? void 0 : s.throwOnFailedPublish;
        let a = ((i = this.subscriber.topicMap.get(e)) == null ? void 0 : i[0]) || "", l;
        const u = d => {
            d.topic === e && (this.subscriber.off($i.created, u),
            l())
        }
        ;
        return await Promise.all([new Promise(d => {
            l = d,
            this.subscriber.on($i.created, u)
        }
        ), new Promise(async (d, h) => {
            a = await this.subscriber.subscribe(e, $O({
                internal: {
                    throwOnFailedPublish: o
                }
            }, t)).catch(p => {
                o && h(p)
            }
            ) || a,
            d()
        }
        )]),
        a
    }
    async unsubscribe(e, t) {
        this.isInitialized(),
        await this.subscriber.unsubscribe(e, t)
    }
    on(e, t) {
        this.events.on(e, t)
    }
    once(e, t) {
        this.events.once(e, t)
    }
    off(e, t) {
        this.events.off(e, t)
    }
    removeListener(e, t) {
        this.events.removeListener(e, t)
    }
    async transportDisconnect() {
        this.provider.disconnect && (this.hasExperiencedNetworkDisruption || this.connected) ? await Wa(this.provider.disconnect(), 2e3, "provider.disconnect()").catch( () => this.onProviderDisconnect()) : this.onProviderDisconnect()
    }
    async transportClose() {
        this.transportExplicitlyClosed = !0,
        await this.transportDisconnect()
    }
    async transportOpen(e) {
        if (!this.subscriber.hasAnyTopics) {
            this.logger.info("Starting WS connection skipped because the client has no topics to work with.");
            return
        }
        if (this.connectPromise ? (this.logger.debug({}, "Waiting for existing connection attempt to resolve..."),
        await this.connectPromise,
        this.logger.debug({}, "Existing connection attempt resolved")) : (this.connectPromise = new Promise(async (t, r) => {
            await this.connect(e).then(t).catch(r).finally( () => {
                this.connectPromise = void 0
            }
            )
        }
        ),
        await this.connectPromise),
        !this.connected)
            throw new Error(`Couldn't establish socket connection to the relay server: ${this.relayUrl}`)
    }
    async restartTransport(e) {
        this.logger.debug({}, "Restarting transport..."),
        !this.connectionAttemptInProgress && (this.relayUrl = e || this.relayUrl,
        await this.confirmOnlineStateOrThrow(),
        await this.transportClose(),
        await this.transportOpen())
    }
    async confirmOnlineStateOrThrow() {
        if (!await hO())
            throw new Error("No internet connection detected. Please restart your network and try again.")
    }
    async handleBatchMessageEvents(e) {
        if (e?.length === 0) {
            this.logger.trace("Batch message events is empty. Ignoring...");
            return
        }
        const t = e.sort( (r, s) => r.publishedAt - s.publishedAt);
        this.logger.debug(`Batch of ${t.length} message events sorted`);
        for (const r of t)
            try {
                await this.onMessageEvent(r)
            } catch (s) {
                this.logger.warn(s, "Error while processing batch message event: " + s?.message)
            }
        this.logger.trace(`Batch of ${t.length} message events processed`)
    }
    async onLinkMessageEvent(e, t) {
        const {topic: r} = e;
        if (!t.sessionExists) {
            const s = Br(je.FIVE_MINUTES)
              , i = {
                topic: r,
                expiry: s,
                relay: {
                    protocol: "irn"
                },
                active: !1
            };
            await this.core.pairing.pairings.set(r, i)
        }
        this.events.emit(Or.message, e),
        await this.recordMessageEvent(e, Yw.inbound)
    }
    async connect(e) {
        await this.confirmOnlineStateOrThrow(),
        e && e !== this.relayUrl && (this.relayUrl = e,
        await this.transportDisconnect()),
        this.connectionAttemptInProgress = !0,
        this.transportExplicitlyClosed = !1;
        let t = 1;
        for (; t < 6; ) {
            try {
                if (this.transportExplicitlyClosed)
                    break;
                this.logger.debug({}, `Connecting to ${this.relayUrl}, attempt: ${t}...`),
                await this.createProvider(),
                await new Promise(async (r, s) => {
                    const i = () => {
                        s(new Error("Connection interrupted while trying to connect"))
                    }
                    ;
                    this.provider.once(wo.disconnect, i),
                    await Wa(new Promise( (o, a) => {
                        this.provider.connect().then(o).catch(a)
                    }
                    ), this.connectTimeout, `Socket stalled when trying to connect to ${this.relayUrl}`).catch(o => {
                        s(o)
                    }
                    ).finally( () => {
                        this.provider.off(wo.disconnect, i),
                        clearTimeout(this.reconnectTimeout)
                    }
                    ),
                    await new Promise(async (o, a) => {
                        const l = () => {
                            s(new Error("Connection interrupted while trying to subscribe"))
                        }
                        ;
                        this.provider.once(wo.disconnect, l),
                        await this.subscriber.start().then(o).catch(a).finally( () => {
                            this.provider.off(wo.disconnect, l)
                        }
                        )
                    }
                    ),
                    this.hasExperiencedNetworkDisruption = !1,
                    r()
                }
                )
            } catch (r) {
                await this.subscriber.stop();
                const s = r;
                this.logger.warn({}, s.message),
                this.hasExperiencedNetworkDisruption = !0
            } finally {
                this.connectionAttemptInProgress = !1
            }
            if (this.connected) {
                this.logger.debug({}, `Connected to ${this.relayUrl} successfully on attempt: ${t}`);
                break
            }
            await new Promise(r => setTimeout(r, je.toMiliseconds(t * 1))),
            t++
        }
    }
    startPingTimeout() {
        var e, t, r, s, i;
        if (z2())
            try {
                (t = (e = this.provider) == null ? void 0 : e.connection) != null && t.socket && ((i = (s = (r = this.provider) == null ? void 0 : r.connection) == null ? void 0 : s.socket) == null || i.on("ping", () => {
                    this.resetPingTimeout()
                }
                )),
                this.resetPingTimeout()
            } catch (o) {
                this.logger.warn(o, o?.message)
            }
    }
    async createProvider() {
        this.provider.connection && this.unregisterProviderListeners();
        const e = await this.core.crypto.signJWT(this.relayUrl);
        this.provider = new K_(new swe(_0e({
            sdkVersion: xC,
            protocol: this.protocol,
            version: this.version,
            relayUrl: this.relayUrl,
            projectId: this.projectId,
            auth: e,
            useOnCloseEvent: !0,
            bundleId: this.bundleId,
            packageName: this.packageName
        }))),
        this.registerProviderListeners()
    }
    async recordMessageEvent(e, t) {
        const {topic: r, message: s} = e;
        await this.messages.set(r, s, t)
    }
    async shouldIgnoreMessageEvent(e) {
        const {topic: t, message: r} = e;
        if (!r || r.length === 0)
            return this.logger.warn(`Ignoring invalid/empty message: ${r}`),
            !0;
        if (!await this.subscriber.isKnownTopic(t))
            return this.logger.warn(`Ignoring message for unknown topic ${t}`),
            !0;
        const s = this.messages.has(t, r);
        return s && this.logger.warn(`Ignoring duplicate message: ${r}`),
        s
    }
    async onProviderPayload(e) {
        if (this.logger.debug("Incoming Relay Payload"),
        this.logger.trace({
            type: "payload",
            direction: "incoming",
            payload: e
        }),
        Y_(e)) {
            if (!e.method.endsWith(bwe))
                return;
            const t = e.params
              , {topic: r, message: s, publishedAt: i, attestation: o} = t.data
              , a = {
                topic: r,
                message: s,
                publishedAt: i,
                transportType: Gn.relay,
                attestation: o
            };
            this.logger.debug("Emitting Relayer Payload"),
            this.logger.trace($O({
                type: "event",
                event: t.id
            }, a)),
            this.events.emit(t.id, a),
            await this.acknowledgePayload(e),
            await this.onMessageEvent(a)
        } else
            Sx(e) && this.events.emit(Or.message_ack, e)
    }
    async onMessageEvent(e) {
        await this.shouldIgnoreMessageEvent(e) || (await this.recordMessageEvent(e, Yw.inbound),
        this.events.emit(Or.message, e))
    }
    async acknowledgePayload(e) {
        const t = iy(e.id, !0);
        await this.provider.connection.send(t)
    }
    unregisterProviderListeners() {
        this.provider.off(wo.payload, this.onPayloadHandler),
        this.provider.off(wo.connect, this.onConnectHandler),
        this.provider.off(wo.disconnect, this.onDisconnectHandler),
        this.provider.off(wo.error, this.onProviderErrorHandler),
        clearTimeout(this.pingTimeout)
    }
    async registerEventListeners() {
        let e = await hO();
        Ebe(async t => {
            e !== t && (e = t,
            t ? await this.transportOpen().catch(r => this.logger.error(r, r?.message)) : (this.hasExperiencedNetworkDisruption = !0,
            await this.transportDisconnect(),
            this.transportExplicitlyClosed = !1))
        }
        ),
        this.core.heartbeat.on(Qf.pulse, async () => {
            if (!this.transportExplicitlyClosed && !this.connected && Cbe())
                try {
                    await this.confirmOnlineStateOrThrow(),
                    await this.transportOpen()
                } catch (t) {
                    this.logger.warn(t, t?.message)
                }
        }
        )
    }
    async onProviderDisconnect() {
        clearTimeout(this.pingTimeout),
        this.events.emit(Or.disconnect),
        this.connectionAttemptInProgress = !1,
        !this.reconnectInProgress && (this.reconnectInProgress = !0,
        await this.subscriber.stop(),
        this.subscriber.hasAnyTopics && (this.transportExplicitlyClosed || (this.reconnectTimeout = setTimeout(async () => {
            await this.transportOpen().catch(e => this.logger.error(e, e?.message)),
            this.reconnectTimeout = void 0,
            this.reconnectInProgress = !1
        }
        , je.toMiliseconds(wwe)))))
    }
    isInitialized() {
        if (!this.initialized) {
            const {message: e} = Fe("NOT_INITIALIZED", this.name);
            throw new Error(e)
        }
    }
    async toEstablishConnection() {
        if (await this.confirmOnlineStateOrThrow(),
        !this.connected) {
            if (this.connectPromise) {
                await this.connectPromise;
                return
            }
            await this.connect()
        }
    }
}
function $ve(n, e) {
    return n === e || Number.isNaN(n) && Number.isNaN(e)
}
function HO(n) {
    return Object.getOwnPropertySymbols(n).filter(e => Object.prototype.propertyIsEnumerable.call(n, e))
}
function VO(n) {
    return n == null ? n === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(n)
}
const Hve = "[object RegExp]"
  , Vve = "[object String]"
  , qve = "[object Number]"
  , Gve = "[object Boolean]"
  , qO = "[object Arguments]"
  , Wve = "[object Symbol]"
  , Yve = "[object Date]"
  , Kve = "[object Map]"
  , Xve = "[object Set]"
  , Qve = "[object Array]"
  , Zve = "[object Function]"
  , Jve = "[object ArrayBuffer]"
  , iA = "[object Object]"
  , exe = "[object Error]"
  , txe = "[object DataView]"
  , nxe = "[object Uint8Array]"
  , rxe = "[object Uint8ClampedArray]"
  , sxe = "[object Uint16Array]"
  , ixe = "[object Uint32Array]"
  , oxe = "[object BigUint64Array]"
  , axe = "[object Int8Array]"
  , lxe = "[object Int16Array]"
  , cxe = "[object Int32Array]"
  , uxe = "[object BigInt64Array]"
  , dxe = "[object Float32Array]"
  , fxe = "[object Float64Array]";
function hxe() {}
function GO(n) {
    if (!n || typeof n != "object")
        return !1;
    const e = Object.getPrototypeOf(n);
    return e === null || e === Object.prototype || Object.getPrototypeOf(e) === null ? Object.prototype.toString.call(n) === "[object Object]" : !1
}
function pxe(n, e, t) {
    return vg(n, e, void 0, void 0, void 0, void 0, t)
}
function vg(n, e, t, r, s, i, o) {
    const a = o(n, e, t, r, s, i);
    if (a !== void 0)
        return a;
    if (typeof n == typeof e)
        switch (typeof n) {
        case "bigint":
        case "string":
        case "boolean":
        case "symbol":
        case "undefined":
            return n === e;
        case "number":
            return n === e || Object.is(n, e);
        case "function":
            return n === e;
        case "object":
            return Bg(n, e, i, o)
        }
    return Bg(n, e, i, o)
}
function Bg(n, e, t, r) {
    if (Object.is(n, e))
        return !0;
    let s = VO(n)
      , i = VO(e);
    if (s === qO && (s = iA),
    i === qO && (i = iA),
    s !== i)
        return !1;
    switch (s) {
    case Vve:
        return n.toString() === e.toString();
    case qve:
        {
            const l = n.valueOf()
              , u = e.valueOf();
            return $ve(l, u)
        }
    case Gve:
    case Yve:
    case Wve:
        return Object.is(n.valueOf(), e.valueOf());
    case Hve:
        return n.source === e.source && n.flags === e.flags;
    case Zve:
        return n === e
    }
    t = t ?? new Map;
    const o = t.get(n)
      , a = t.get(e);
    if (o != null && a != null)
        return o === e;
    t.set(n, e),
    t.set(e, n);
    try {
        switch (s) {
        case Kve:
            {
                if (n.size !== e.size)
                    return !1;
                for (const [l,u] of n.entries())
                    if (!e.has(l) || !vg(u, e.get(l), l, n, e, t, r))
                        return !1;
                return !0
            }
        case Xve:
            {
                if (n.size !== e.size)
                    return !1;
                const l = Array.from(n.values())
                  , u = Array.from(e.values());
                for (let d = 0; d < l.length; d++) {
                    const h = l[d]
                      , p = u.findIndex(g => vg(h, g, void 0, n, e, t, r));
                    if (p === -1)
                        return !1;
                    u.splice(p, 1)
                }
                return !0
            }
        case Qve:
        case nxe:
        case rxe:
        case sxe:
        case ixe:
        case oxe:
        case axe:
        case lxe:
        case cxe:
        case uxe:
        case dxe:
        case fxe:
            {
                if (typeof Buffer < "u" && Buffer.isBuffer(n) !== Buffer.isBuffer(e) || n.length !== e.length)
                    return !1;
                for (let l = 0; l < n.length; l++)
                    if (!vg(n[l], e[l], l, n, e, t, r))
                        return !1;
                return !0
            }
        case Jve:
            return n.byteLength !== e.byteLength ? !1 : Bg(new Uint8Array(n), new Uint8Array(e), t, r);
        case txe:
            return n.byteLength !== e.byteLength || n.byteOffset !== e.byteOffset ? !1 : Bg(new Uint8Array(n), new Uint8Array(e), t, r);
        case exe:
            return n.name === e.name && n.message === e.message;
        case iA:
            {
                if (!(Bg(n.constructor, e.constructor, t, r) || GO(n) && GO(e)))
                    return !1;
                const l = [...Object.keys(n), ...HO(n)]
                  , u = [...Object.keys(e), ...HO(e)];
                if (l.length !== u.length)
                    return !1;
                for (let d = 0; d < l.length; d++) {
                    const h = l[d]
                      , p = n[h];
                    if (!Object.hasOwn(e, h))
                        return !1;
                    const g = e[h];
                    if (!vg(p, g, h, n, e, t, r))
                        return !1
                }
                return !0
            }
        default:
            return !1
        }
    } finally {
        t.delete(n),
        t.delete(e)
    }
}
function mxe(n, e) {
    return pxe(n, e, hxe)
}
var gxe = Object.defineProperty
  , WO = Object.getOwnPropertySymbols
  , yxe = Object.prototype.hasOwnProperty
  , bxe = Object.prototype.propertyIsEnumerable
  , NC = (n, e, t) => e in n ? gxe(n, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : n[e] = t
  , YO = (n, e) => {
    for (var t in e || (e = {}))
        yxe.call(e, t) && NC(n, t, e[t]);
    if (WO)
        for (var t of WO(e))
            bxe.call(e, t) && NC(n, t, e[t]);
    return n
}
  , pi = (n, e, t) => NC(n, typeof e != "symbol" ? e + "" : e, t);
class Jf extends _1e {
    constructor(e, t, r, s=rl, i=void 0) {
        super(e, t, r, s),
        this.core = e,
        this.logger = t,
        this.name = r,
        pi(this, "map", new Map),
        pi(this, "version", vwe),
        pi(this, "cached", []),
        pi(this, "initialized", !1),
        pi(this, "getKey"),
        pi(this, "storagePrefix", rl),
        pi(this, "recentlyDeleted", []),
        pi(this, "recentlyDeletedLimit", 200),
        pi(this, "init", async () => {
            this.initialized || (this.logger.trace("Initialized"),
            await this.restore(),
            this.cached.forEach(o => {
                this.getKey && o !== null && !ts(o) ? this.map.set(this.getKey(o), o) : Jye(o) ? this.map.set(o.id, o) : ebe(o) && this.map.set(o.topic, o)
            }
            ),
            this.cached = [],
            this.initialized = !0)
        }
        ),
        pi(this, "set", async (o, a) => {
            this.isInitialized(),
            this.map.has(o) ? await this.update(o, a) : (this.logger.debug("Setting value"),
            this.logger.trace({
                type: "method",
                method: "set",
                key: o,
                value: a
            }),
            this.map.set(o, a),
            await this.persist())
        }
        ),
        pi(this, "get", o => (this.isInitialized(),
        this.logger.debug("Getting value"),
        this.logger.trace({
            type: "method",
            method: "get",
            key: o
        }),
        this.getData(o))),
        pi(this, "getAll", o => (this.isInitialized(),
        o ? this.values.filter(a => Object.keys(o).every(l => mxe(a[l], o[l]))) : this.values)),
        pi(this, "update", async (o, a) => {
            this.isInitialized(),
            this.logger.debug("Updating value"),
            this.logger.trace({
                type: "method",
                method: "update",
                key: o,
                update: a
            });
            const l = YO(YO({}, this.getData(o)), a);
            this.map.set(o, l),
            await this.persist()
        }
        ),
        pi(this, "delete", async (o, a) => {
            this.isInitialized(),
            this.map.has(o) && (this.logger.debug("Deleting value"),
            this.logger.trace({
                type: "method",
                method: "delete",
                key: o,
                reason: a
            }),
            this.map.delete(o),
            this.addToRecentlyDeleted(o),
            await this.persist())
        }
        ),
        this.logger = ro(t, this.name),
        this.storagePrefix = s,
        this.getKey = i
    }
    get context() {
        return Ii(this.logger)
    }
    get storageKey() {
        return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name
    }
    get length() {
        return this.map.size
    }
    get keys() {
        return Array.from(this.map.keys())
    }
    get values() {
        return Array.from(this.map.values())
    }
    addToRecentlyDeleted(e) {
        this.recentlyDeleted.push(e),
        this.recentlyDeleted.length >= this.recentlyDeletedLimit && this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2)
    }
    async setDataStore(e) {
        await this.core.storage.setItem(this.storageKey, e)
    }
    async getDataStore() {
        return await this.core.storage.getItem(this.storageKey)
    }
    getData(e) {
        const t = this.map.get(e);
        if (!t) {
            if (this.recentlyDeleted.includes(e)) {
                const {message: s} = Fe("MISSING_OR_INVALID", `Record was recently deleted - ${this.name}: ${e}`);
                throw this.logger.error(s),
                new Error(s)
            }
            const {message: r} = Fe("NO_MATCHING_KEY", `${this.name}: ${e}`);
            throw this.logger.error(r),
            new Error(r)
        }
        return t
    }
    async persist() {
        await this.setDataStore(this.values)
    }
    async restore() {
        try {
            const e = await this.getDataStore();
            if (typeof e > "u" || !e.length)
                return;
            if (this.map.size) {
                const {message: t} = Fe("RESTORE_WILL_OVERRIDE", this.name);
                throw this.logger.error(t),
                new Error(t)
            }
            this.cached = e,
            this.logger.debug(`Successfully Restored value for ${this.name}`),
            this.logger.trace({
                type: "method",
                method: "restore",
                value: this.values
            })
        } catch (e) {
            this.logger.debug(`Failed to Restore value for ${this.name}`),
            this.logger.error(e)
        }
    }
    isInitialized() {
        if (!this.initialized) {
            const {message: e} = Fe("NOT_INITIALIZED", this.name);
            throw new Error(e)
        }
    }
}
var wxe = Object.defineProperty
  , vxe = (n, e, t) => e in n ? wxe(n, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : n[e] = t
  , tn = (n, e, t) => vxe(n, typeof e != "symbol" ? e + "" : e, t);
class xxe {
    constructor(e, t) {
        this.core = e,
        this.logger = t,
        tn(this, "name", Awe),
        tn(this, "version", Cwe),
        tn(this, "events", new y_),
        tn(this, "pairings"),
        tn(this, "initialized", !1),
        tn(this, "storagePrefix", rl),
        tn(this, "ignoredPayloadTypes", [yc]),
        tn(this, "registeredMethods", []),
        tn(this, "init", async () => {
            this.initialized || (await this.pairings.init(),
            await this.cleanup(),
            this.registerRelayerEvents(),
            this.registerExpirerEvents(),
            this.initialized = !0,
            this.logger.trace("Initialized"))
        }
        ),
        tn(this, "register", ({methods: r}) => {
            this.isInitialized(),
            this.registeredMethods = [...new Set([...this.registeredMethods, ...r])]
        }
        ),
        tn(this, "create", async r => {
            this.isInitialized();
            const s = yC()
              , i = await this.core.crypto.setSymKey(s)
              , o = Br(je.FIVE_MINUTES)
              , a = {
                protocol: oV
            }
              , l = {
                topic: i,
                expiry: o,
                relay: a,
                active: !1,
                methods: r?.methods
            }
              , u = sO({
                protocol: this.core.protocol,
                version: this.core.version,
                topic: i,
                symKey: s,
                relay: a,
                expiryTimestamp: o,
                methods: r?.methods
            });
            return this.events.emit(Jd.create, l),
            this.core.expirer.set(i, o),
            await this.pairings.set(i, l),
            await this.core.relayer.subscribe(i, {
                transportType: r?.transportType,
                internal: r?.internal
            }),
            {
                topic: i,
                uri: u
            }
        }
        ),
        tn(this, "pair", async r => {
            this.isInitialized();
            const s = this.core.eventClient.createEvent({
                properties: {
                    topic: r?.uri,
                    trace: [Ba.pairing_started]
                }
            });
            this.isValidPair(r, s);
            const {topic: i, symKey: o, relay: a, expiryTimestamp: l, methods: u} = rO(r.uri);
            s.props.properties.topic = i,
            s.addTrace(Ba.pairing_uri_validation_success),
            s.addTrace(Ba.pairing_uri_not_expired);
            let d;
            if (this.pairings.keys.includes(i)) {
                if (d = this.pairings.get(i),
                s.addTrace(Ba.existing_pairing),
                d.active)
                    throw s.setError(Vl.active_pairing_already_exists),
                    new Error(`Pairing already exists: ${i}. Please try again with a new connection URI.`);
                s.addTrace(Ba.pairing_not_expired)
            }
            const h = l || Br(je.FIVE_MINUTES)
              , p = {
                topic: i,
                relay: a,
                expiry: h,
                active: !1,
                methods: u
            };
            this.core.expirer.set(i, h),
            await this.pairings.set(i, p),
            s.addTrace(Ba.store_new_pairing),
            r.activatePairing && await this.activate({
                topic: i
            }),
            this.events.emit(Jd.create, p),
            s.addTrace(Ba.emit_inactive_pairing),
            this.core.crypto.keychain.has(i) || await this.core.crypto.setSymKey(o, i),
            s.addTrace(Ba.subscribing_pairing_topic);
            try {
                await this.core.relayer.confirmOnlineStateOrThrow()
            } catch {
                s.setError(Vl.no_internet_connection)
            }
            try {
                await this.core.relayer.subscribe(i, {
                    relay: a
                })
            } catch (g) {
                throw s.setError(Vl.subscribe_pairing_topic_failure),
                g
            }
            return s.addTrace(Ba.subscribe_pairing_topic_success),
            p
        }
        ),
        tn(this, "activate", async ({topic: r}) => {
            this.isInitialized();
            const s = Br(je.FIVE_MINUTES);
            this.core.expirer.set(r, s),
            await this.pairings.update(r, {
                active: !0,
                expiry: s
            })
        }
        ),
        tn(this, "ping", async r => {
            this.isInitialized(),
            await this.isValidPing(r),
            this.logger.warn("ping() is deprecated and will be removed in the next major release.");
            const {topic: s} = r;
            if (this.pairings.keys.includes(s)) {
                const i = await this.sendRequest(s, "wc_pairingPing", {})
                  , {done: o, resolve: a, reject: l} = $d();
                this.events.once(An("pairing_ping", i), ({error: u}) => {
                    u ? l(u) : a()
                }
                ),
                await o()
            }
        }
        ),
        tn(this, "updateExpiry", async ({topic: r, expiry: s}) => {
            this.isInitialized(),
            await this.pairings.update(r, {
                expiry: s
            })
        }
        ),
        tn(this, "updateMetadata", async ({topic: r, metadata: s}) => {
            this.isInitialized(),
            await this.pairings.update(r, {
                peerMetadata: s
            })
        }
        ),
        tn(this, "getPairings", () => (this.isInitialized(),
        this.pairings.values)),
        tn(this, "disconnect", async r => {
            this.isInitialized(),
            await this.isValidDisconnect(r);
            const {topic: s} = r;
            this.pairings.keys.includes(s) && (await this.sendRequest(s, "wc_pairingDelete", Yn("USER_DISCONNECTED")),
            await this.deletePairing(s))
        }
        ),
        tn(this, "formatUriFromPairing", r => {
            this.isInitialized();
            const {topic: s, relay: i, expiry: o, methods: a} = r
              , l = this.core.crypto.keychain.get(s);
            return sO({
                protocol: this.core.protocol,
                version: this.core.version,
                topic: s,
                symKey: l,
                relay: i,
                expiryTimestamp: o,
                methods: a
            })
        }
        ),
        tn(this, "sendRequest", async (r, s, i) => {
            const o = ta(s, i)
              , a = await this.core.crypto.encode(r, o)
              , l = Km[s].req;
            return this.core.history.set(r, o),
            this.core.relayer.publish(r, a, l),
            o.id
        }
        ),
        tn(this, "sendResult", async (r, s, i) => {
            const o = iy(r, i)
              , a = await this.core.crypto.encode(s, o)
              , l = (await this.core.history.get(s, r)).request.method
              , u = Km[l].res;
            await this.core.relayer.publish(s, a, u),
            await this.core.history.resolve(o)
        }
        ),
        tn(this, "sendError", async (r, s, i) => {
            const o = Ex(r, i)
              , a = await this.core.crypto.encode(s, o)
              , l = (await this.core.history.get(s, r)).request.method
              , u = Km[l] ? Km[l].res : Km.unregistered_method.res;
            await this.core.relayer.publish(s, a, u),
            await this.core.history.resolve(o)
        }
        ),
        tn(this, "deletePairing", async (r, s) => {
            await this.core.relayer.unsubscribe(r),
            await Promise.all([this.pairings.delete(r, Yn("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(r), s ? Promise.resolve() : this.core.expirer.del(r)])
        }
        ),
        tn(this, "cleanup", async () => {
            const r = this.pairings.getAll().filter(s => Ua(s.expiry));
            await Promise.all(r.map(s => this.deletePairing(s.topic)))
        }
        ),
        tn(this, "onRelayEventRequest", async r => {
            const {topic: s, payload: i} = r;
            switch (i.method) {
            case "wc_pairingPing":
                return await this.onPairingPingRequest(s, i);
            case "wc_pairingDelete":
                return await this.onPairingDeleteRequest(s, i);
            default:
                return await this.onUnknownRpcMethodRequest(s, i)
            }
        }
        ),
        tn(this, "onRelayEventResponse", async r => {
            const {topic: s, payload: i} = r
              , o = (await this.core.history.get(s, i.id)).request.method;
            switch (o) {
            case "wc_pairingPing":
                return this.onPairingPingResponse(s, i);
            default:
                return this.onUnknownRpcMethodResponse(o)
            }
        }
        ),
        tn(this, "onPairingPingRequest", async (r, s) => {
            const {id: i} = s;
            try {
                this.isValidPing({
                    topic: r
                }),
                await this.sendResult(i, r, !0),
                this.events.emit(Jd.ping, {
                    id: i,
                    topic: r
                })
            } catch (o) {
                await this.sendError(i, r, o),
                this.logger.error(o)
            }
        }
        ),
        tn(this, "onPairingPingResponse", (r, s) => {
            const {id: i} = s;
            setTimeout( () => {
                Pa(s) ? this.events.emit(An("pairing_ping", i), {}) : _o(s) && this.events.emit(An("pairing_ping", i), {
                    error: s.error
                })
            }
            , 500)
        }
        ),
        tn(this, "onPairingDeleteRequest", async (r, s) => {
            const {id: i} = s;
            try {
                this.isValidDisconnect({
                    topic: r
                }),
                await this.deletePairing(r),
                this.events.emit(Jd.delete, {
                    id: i,
                    topic: r
                })
            } catch (o) {
                await this.sendError(i, r, o),
                this.logger.error(o)
            }
        }
        ),
        tn(this, "onUnknownRpcMethodRequest", async (r, s) => {
            const {id: i, method: o} = s;
            try {
                if (this.registeredMethods.includes(o))
                    return;
                const a = Yn("WC_METHOD_UNSUPPORTED", o);
                await this.sendError(i, r, a),
                this.logger.error(a)
            } catch (a) {
                await this.sendError(i, r, a),
                this.logger.error(a)
            }
        }
        ),
        tn(this, "onUnknownRpcMethodResponse", r => {
            this.registeredMethods.includes(r) || this.logger.error(Yn("WC_METHOD_UNSUPPORTED", r))
        }
        ),
        tn(this, "isValidPair", (r, s) => {
            var i;
            if (!yi(r)) {
                const {message: a} = Fe("MISSING_OR_INVALID", `pair() params: ${r}`);
                throw s.setError(Vl.malformed_pairing_uri),
                new Error(a)
            }
            if (!Zye(r.uri)) {
                const {message: a} = Fe("MISSING_OR_INVALID", `pair() uri: ${r.uri}`);
                throw s.setError(Vl.malformed_pairing_uri),
                new Error(a)
            }
            const o = rO(r?.uri);
            if (!((i = o?.relay) != null && i.protocol)) {
                const {message: a} = Fe("MISSING_OR_INVALID", "pair() uri#relay-protocol");
                throw s.setError(Vl.malformed_pairing_uri),
                new Error(a)
            }
            if (!(o != null && o.symKey)) {
                const {message: a} = Fe("MISSING_OR_INVALID", "pair() uri#symKey");
                throw s.setError(Vl.malformed_pairing_uri),
                new Error(a)
            }
            if (o != null && o.expiryTimestamp && je.toMiliseconds(o?.expiryTimestamp) < Date.now()) {
                s.setError(Vl.pairing_expired);
                const {message: a} = Fe("EXPIRED", "pair() URI has expired. Please try again with a new connection URI.");
                throw new Error(a)
            }
        }
        ),
        tn(this, "isValidPing", async r => {
            if (!yi(r)) {
                const {message: i} = Fe("MISSING_OR_INVALID", `ping() params: ${r}`);
                throw new Error(i)
            }
            const {topic: s} = r;
            await this.isValidPairingTopic(s)
        }
        ),
        tn(this, "isValidDisconnect", async r => {
            if (!yi(r)) {
                const {message: i} = Fe("MISSING_OR_INVALID", `disconnect() params: ${r}`);
                throw new Error(i)
            }
            const {topic: s} = r;
            await this.isValidPairingTopic(s)
        }
        ),
        tn(this, "isValidPairingTopic", async r => {
            if (!Lr(r, !1)) {
                const {message: s} = Fe("MISSING_OR_INVALID", `pairing topic should be a string: ${r}`);
                throw new Error(s)
            }
            if (!this.pairings.keys.includes(r)) {
                const {message: s} = Fe("NO_MATCHING_KEY", `pairing topic doesn't exist: ${r}`);
                throw new Error(s)
            }
            if (Ua(this.pairings.get(r).expiry)) {
                await this.deletePairing(r);
                const {message: s} = Fe("EXPIRED", `pairing topic: ${r}`);
                throw new Error(s)
            }
        }
        ),
        this.core = e,
        this.logger = ro(t, this.name),
        this.pairings = new Jf(this.core,this.logger,this.name,this.storagePrefix)
    }
    get context() {
        return Ii(this.logger)
    }
    isInitialized() {
        if (!this.initialized) {
            const {message: e} = Fe("NOT_INITIALIZED", this.name);
            throw new Error(e)
        }
    }
    registerRelayerEvents() {
        this.core.relayer.on(Or.message, async e => {
            const {topic: t, message: r, transportType: s} = e;
            if (this.pairings.keys.includes(t) && s !== Gn.link_mode && !this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(r)))
                try {
                    const i = await this.core.crypto.decode(t, r);
                    Y_(i) ? (this.core.history.set(t, i),
                    await this.onRelayEventRequest({
                        topic: t,
                        payload: i
                    })) : Sx(i) && (await this.core.history.resolve(i),
                    await this.onRelayEventResponse({
                        topic: t,
                        payload: i
                    }),
                    this.core.history.delete(t, i.id)),
                    await this.core.relayer.messages.ack(t, r)
                } catch (i) {
                    this.logger.error(i)
                }
        }
        )
    }
    registerExpirerEvents() {
        this.core.expirer.on(Eo.expired, async e => {
            const {topic: t} = K$(e.target);
            t && this.pairings.keys.includes(t) && (await this.deletePairing(t, !0),
            this.events.emit(Jd.expire, {
                topic: t
            }))
        }
        )
    }
}
var Exe = Object.defineProperty
  , Sxe = (n, e, t) => e in n ? Exe(n, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : n[e] = t
  , us = (n, e, t) => Sxe(n, typeof e != "symbol" ? e + "" : e, t);
class Axe extends E1e {
    constructor(e, t) {
        super(e, t),
        this.core = e,
        this.logger = t,
        us(this, "records", new Map),
        us(this, "events", new no.EventEmitter),
        us(this, "name", _we),
        us(this, "version", kwe),
        us(this, "cached", []),
        us(this, "initialized", !1),
        us(this, "storagePrefix", rl),
        us(this, "init", async () => {
            this.initialized || (this.logger.trace("Initialized"),
            await this.restore(),
            this.cached.forEach(r => this.records.set(r.id, r)),
            this.cached = [],
            this.registerEventListeners(),
            this.initialized = !0)
        }
        ),
        us(this, "set", (r, s, i) => {
            if (this.isInitialized(),
            this.logger.debug("Setting JSON-RPC request history record"),
            this.logger.trace({
                type: "method",
                method: "set",
                topic: r,
                request: s,
                chainId: i
            }),
            this.records.has(s.id))
                return;
            const o = {
                id: s.id,
                topic: r,
                request: {
                    method: s.method,
                    params: s.params || null
                },
                chainId: i,
                expiry: Br(je.THIRTY_DAYS)
            };
            this.records.set(o.id, o),
            this.persist(),
            this.events.emit(Wo.created, o)
        }
        ),
        us(this, "resolve", async r => {
            if (this.isInitialized(),
            this.logger.debug("Updating JSON-RPC response history record"),
            this.logger.trace({
                type: "method",
                method: "update",
                response: r
            }),
            !this.records.has(r.id))
                return;
            const s = await this.getRecord(r.id);
            typeof s.response > "u" && (s.response = _o(r) ? {
                error: r.error
            } : {
                result: r.result
            },
            this.records.set(s.id, s),
            this.persist(),
            this.events.emit(Wo.updated, s))
        }
        ),
        us(this, "get", async (r, s) => (this.isInitialized(),
        this.logger.debug("Getting record"),
        this.logger.trace({
            type: "method",
            method: "get",
            topic: r,
            id: s
        }),
        await this.getRecord(s))),
        us(this, "delete", (r, s) => {
            this.isInitialized(),
            this.logger.debug("Deleting record"),
            this.logger.trace({
                type: "method",
                method: "delete",
                id: s
            }),
            this.values.forEach(i => {
                if (i.topic === r) {
                    if (typeof s < "u" && i.id !== s)
                        return;
                    this.records.delete(i.id),
                    this.events.emit(Wo.deleted, i)
                }
            }
            ),
            this.persist()
        }
        ),
        us(this, "exists", async (r, s) => (this.isInitialized(),
        this.records.has(s) ? (await this.getRecord(s)).topic === r : !1)),
        us(this, "on", (r, s) => {
            this.events.on(r, s)
        }
        ),
        us(this, "once", (r, s) => {
            this.events.once(r, s)
        }
        ),
        us(this, "off", (r, s) => {
            this.events.off(r, s)
        }
        ),
        us(this, "removeListener", (r, s) => {
            this.events.removeListener(r, s)
        }
        ),
        this.logger = ro(t, this.name)
    }
    get context() {
        return Ii(this.logger)
    }
    get storageKey() {
        return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name
    }
    get size() {
        return this.records.size
    }
    get keys() {
        return Array.from(this.records.keys())
    }
    get values() {
        return Array.from(this.records.values())
    }
    get pending() {
        const e = [];
        return this.values.forEach(t => {
            if (typeof t.response < "u")
                return;
            const r = {
                topic: t.topic,
                request: ta(t.request.method, t.request.params, t.id),
                chainId: t.chainId
            };
            return e.push(r)
        }
        ),
        e
    }
    async setJsonRpcRecords(e) {
        await this.core.storage.setItem(this.storageKey, e)
    }
    async getJsonRpcRecords() {
        return await this.core.storage.getItem(this.storageKey)
    }
    getRecord(e) {
        this.isInitialized();
        const t = this.records.get(e);
        if (!t) {
            const {message: r} = Fe("NO_MATCHING_KEY", `${this.name}: ${e}`);
            throw new Error(r)
        }
        return t
    }
    async persist() {
        await this.setJsonRpcRecords(this.values),
        this.events.emit(Wo.sync)
    }
    async restore() {
        try {
            const e = await this.getJsonRpcRecords();
            if (typeof e > "u" || !e.length)
                return;
            if (this.records.size) {
                const {message: t} = Fe("RESTORE_WILL_OVERRIDE", this.name);
                throw this.logger.error(t),
                new Error(t)
            }
            this.cached = e,
            this.logger.debug(`Successfully Restored records for ${this.name}`),
            this.logger.trace({
                type: "method",
                method: "restore",
                records: this.values
            })
        } catch (e) {
            this.logger.debug(`Failed to Restore records for ${this.name}`),
            this.logger.error(e)
        }
    }
    registerEventListeners() {
        this.events.on(Wo.created, e => {
            const t = Wo.created;
            this.logger.info(`Emitting ${t}`),
            this.logger.debug({
                type: "event",
                event: t,
                record: e
            })
        }
        ),
        this.events.on(Wo.updated, e => {
            const t = Wo.updated;
            this.logger.info(`Emitting ${t}`),
            this.logger.debug({
                type: "event",
                event: t,
                record: e
            })
        }
        ),
        this.events.on(Wo.deleted, e => {
            const t = Wo.deleted;
            this.logger.info(`Emitting ${t}`),
            this.logger.debug({
                type: "event",
                event: t,
                record: e
            })
        }
        ),
        this.core.heartbeat.on(Qf.pulse, () => {
            this.cleanup()
        }
        )
    }
    cleanup() {
        try {
            this.isInitialized();
            let e = !1;
            this.records.forEach(t => {
                je.toMiliseconds(t.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${t.id}`),
                this.records.delete(t.id),
                this.events.emit(Wo.deleted, t, !1),
                e = !0)
            }
            ),
            e && this.persist()
        } catch (e) {
            this.logger.warn(e)
        }
    }
    isInitialized() {
        if (!this.initialized) {
            const {message: e} = Fe("NOT_INITIALIZED", this.name);
            throw new Error(e)
        }
    }
}
var Cxe = Object.defineProperty
  , _xe = (n, e, t) => e in n ? Cxe(n, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : n[e] = t
  , Ps = (n, e, t) => _xe(n, typeof e != "symbol" ? e + "" : e, t);
class kxe extends N1e {
    constructor(e, t) {
        super(e, t),
        this.core = e,
        this.logger = t,
        Ps(this, "expirations", new Map),
        Ps(this, "events", new no.EventEmitter),
        Ps(this, "name", Nwe),
        Ps(this, "version", Dwe),
        Ps(this, "cached", []),
        Ps(this, "initialized", !1),
        Ps(this, "storagePrefix", rl),
        Ps(this, "init", async () => {
            this.initialized || (this.logger.trace("Initialized"),
            await this.restore(),
            this.cached.forEach(r => this.expirations.set(r.target, r)),
            this.cached = [],
            this.registerEventListeners(),
            this.initialized = !0)
        }
        ),
        Ps(this, "has", r => {
            try {
                const s = this.formatTarget(r);
                return typeof this.getExpiration(s) < "u"
            } catch {
                return !1
            }
        }
        ),
        Ps(this, "set", (r, s) => {
            this.isInitialized();
            const i = this.formatTarget(r)
              , o = {
                target: i,
                expiry: s
            };
            this.expirations.set(i, o),
            this.checkExpiry(i, o),
            this.events.emit(Eo.created, {
                target: i,
                expiration: o
            })
        }
        ),
        Ps(this, "get", r => {
            this.isInitialized();
            const s = this.formatTarget(r);
            return this.getExpiration(s)
        }
        ),
        Ps(this, "del", r => {
            if (this.isInitialized(),
            this.has(r)) {
                const s = this.formatTarget(r)
                  , i = this.getExpiration(s);
                this.expirations.delete(s),
                this.events.emit(Eo.deleted, {
                    target: s,
                    expiration: i
                })
            }
        }
        ),
        Ps(this, "on", (r, s) => {
            this.events.on(r, s)
        }
        ),
        Ps(this, "once", (r, s) => {
            this.events.once(r, s)
        }
        ),
        Ps(this, "off", (r, s) => {
            this.events.off(r, s)
        }
        ),
        Ps(this, "removeListener", (r, s) => {
            this.events.removeListener(r, s)
        }
        ),
        this.logger = ro(t, this.name)
    }
    get context() {
        return Ii(this.logger)
    }
    get storageKey() {
        return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name
    }
    get length() {
        return this.expirations.size
    }
    get keys() {
        return Array.from(this.expirations.keys())
    }
    get values() {
        return Array.from(this.expirations.values())
    }
    formatTarget(e) {
        if (typeof e == "string")
            return k0e(e);
        if (typeof e == "number")
            return N0e(e);
        const {message: t} = Fe("UNKNOWN_TYPE", `Target type: ${typeof e}`);
        throw new Error(t)
    }
    async setExpirations(e) {
        await this.core.storage.setItem(this.storageKey, e)
    }
    async getExpirations() {
        return await this.core.storage.getItem(this.storageKey)
    }
    async persist() {
        await this.setExpirations(this.values),
        this.events.emit(Eo.sync)
    }
    async restore() {
        try {
            const e = await this.getExpirations();
            if (typeof e > "u" || !e.length)
                return;
            if (this.expirations.size) {
                const {message: t} = Fe("RESTORE_WILL_OVERRIDE", this.name);
                throw this.logger.error(t),
                new Error(t)
            }
            this.cached = e,
            this.logger.debug(`Successfully Restored expirations for ${this.name}`),
            this.logger.trace({
                type: "method",
                method: "restore",
                expirations: this.values
            })
        } catch (e) {
            this.logger.debug(`Failed to Restore expirations for ${this.name}`),
            this.logger.error(e)
        }
    }
    getExpiration(e) {
        const t = this.expirations.get(e);
        if (!t) {
            const {message: r} = Fe("NO_MATCHING_KEY", `${this.name}: ${e}`);
            throw this.logger.warn(r),
            new Error(r)
        }
        return t
    }
    checkExpiry(e, t) {
        const {expiry: r} = t;
        je.toMiliseconds(r) - Date.now() <= 0 && this.expire(e, t)
    }
    expire(e, t) {
        this.expirations.delete(e),
        this.events.emit(Eo.expired, {
            target: e,
            expiration: t
        })
    }
    checkExpirations() {
        this.core.relayer.connected && this.expirations.forEach( (e, t) => this.checkExpiry(t, e))
    }
    registerEventListeners() {
        this.core.heartbeat.on(Qf.pulse, () => this.checkExpirations()),
        this.events.on(Eo.created, e => {
            const t = Eo.created;
            this.logger.info(`Emitting ${t}`),
            this.logger.debug({
                type: "event",
                event: t,
                data: e
            }),
            this.persist()
        }
        ),
        this.events.on(Eo.expired, e => {
            const t = Eo.expired;
            this.logger.info(`Emitting ${t}`),
            this.logger.debug({
                type: "event",
                event: t,
                data: e
            }),
            this.persist()
        }
        ),
        this.events.on(Eo.deleted, e => {
            const t = Eo.deleted;
            this.logger.info(`Emitting ${t}`),
            this.logger.debug({
                type: "event",
                event: t,
                data: e
            }),
            this.persist()
        }
        )
    }
    isInitialized() {
        if (!this.initialized) {
            const {message: e} = Fe("NOT_INITIALIZED", this.name);
            throw new Error(e)
        }
    }
}
var Nxe = Object.defineProperty
  , Dxe = (n, e, t) => e in n ? Nxe(n, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : n[e] = t
  , Mr = (n, e, t) => Dxe(n, typeof e != "symbol" ? e + "" : e, t);
class Txe extends D1e {
    constructor(e, t, r) {
        super(e, t, r),
        this.core = e,
        this.logger = t,
        this.store = r,
        Mr(this, "name", Twe),
        Mr(this, "abortController"),
        Mr(this, "isDevEnv"),
        Mr(this, "verifyUrlV3", Mwe),
        Mr(this, "storagePrefix", rl),
        Mr(this, "version", iV),
        Mr(this, "publicKey"),
        Mr(this, "fetchPromise"),
        Mr(this, "init", async () => {
            var s;
            this.isDevEnv || (this.publicKey = await this.store.getItem(this.storeKey),
            this.publicKey && je.toMiliseconds((s = this.publicKey) == null ? void 0 : s.expiresAt) < Date.now() && (this.logger.debug("verify v2 public key expired"),
            await this.removePublicKey()))
        }
        ),
        Mr(this, "register", async s => {
            if (!I0() || this.isDevEnv)
                return;
            const i = window.location.origin
              , {id: o, decryptedId: a} = s
              , l = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${i}&id=${o}&decryptedId=${a}`;
            try {
                const u = Dc.getDocument()
                  , d = this.startAbortTimer(je.ONE_SECOND * 5)
                  , h = await new Promise( (p, g) => {
                    const w = () => {
                        window.removeEventListener("message", v),
                        u.body.removeChild(b),
                        g("attestation aborted")
                    }
                    ;
                    this.abortController.signal.addEventListener("abort", w);
                    const b = u.createElement("iframe");
                    b.src = l,
                    b.style.display = "none",
                    b.addEventListener("error", w, {
                        signal: this.abortController.signal
                    });
                    const v = S => {
                        if (S.data && typeof S.data == "string")
                            try {
                                const N = JSON.parse(S.data);
                                if (N.type === "verify_attestation") {
                                    if (rC(N.attestation).payload.id !== o)
                                        return;
                                    clearInterval(d),
                                    u.body.removeChild(b),
                                    this.abortController.signal.removeEventListener("abort", w),
                                    window.removeEventListener("message", v),
                                    p(N.attestation === null ? "" : N.attestation)
                                }
                            } catch (N) {
                                this.logger.warn(N)
                            }
                    }
                    ;
                    u.body.appendChild(b),
                    window.addEventListener("message", v, {
                        signal: this.abortController.signal
                    })
                }
                );
                return this.logger.debug(h, "jwt attestation"),
                h
            } catch (u) {
                this.logger.warn(u)
            }
            return ""
        }
        ),
        Mr(this, "resolve", async s => {
            if (this.isDevEnv)
                return "";
            const {attestationId: i, hash: o, encryptedId: a} = s;
            if (i === "") {
                this.logger.debug("resolve: attestationId is empty, skipping");
                return
            }
            if (i) {
                if (rC(i).payload.id !== a)
                    return;
                const u = await this.isValidJwtAttestation(i);
                if (u) {
                    if (!u.isVerified) {
                        this.logger.warn("resolve: jwt attestation: origin url not verified");
                        return
                    }
                    return u
                }
            }
            if (!o)
                return;
            const l = this.getVerifyUrl(s?.verifyUrl);
            return this.fetchAttestation(o, l)
        }
        ),
        Mr(this, "fetchAttestation", async (s, i) => {
            this.logger.debug(`resolving attestation: ${s} from url: ${i}`);
            const o = this.startAbortTimer(je.ONE_SECOND * 5)
              , a = await fetch(`${i}/attestation/${s}?v2Supported=true`, {
                signal: this.abortController.signal
            });
            return clearTimeout(o),
            a.status === 200 ? await a.json() : void 0
        }
        ),
        Mr(this, "getVerifyUrl", s => {
            let i = s || Mg;
            return Bwe.includes(i) || (this.logger.info(`verify url: ${i}, not included in trusted list, assigning default: ${Mg}`),
            i = Mg),
            i
        }
        ),
        Mr(this, "fetchPublicKey", async () => {
            try {
                this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);
                const s = this.startAbortTimer(je.FIVE_SECONDS)
                  , i = await fetch(`${this.verifyUrlV3}/public-key`, {
                    signal: this.abortController.signal
                });
                return clearTimeout(s),
                await i.json()
            } catch (s) {
                this.logger.warn(s)
            }
        }
        ),
        Mr(this, "persistPublicKey", async s => {
            this.logger.debug(s, "persisting public key to local storage"),
            await this.store.setItem(this.storeKey, s),
            this.publicKey = s
        }
        ),
        Mr(this, "removePublicKey", async () => {
            this.logger.debug("removing verify v2 public key from storage"),
            await this.store.removeItem(this.storeKey),
            this.publicKey = void 0
        }
        ),
        Mr(this, "isValidJwtAttestation", async s => {
            const i = await this.getPublicKey();
            try {
                if (i)
                    return this.validateAttestation(s, i)
            } catch (a) {
                this.logger.error(a),
                this.logger.warn("error validating attestation")
            }
            const o = await this.fetchAndPersistPublicKey();
            try {
                if (o)
                    return this.validateAttestation(s, o)
            } catch (a) {
                this.logger.error(a),
                this.logger.warn("error validating attestation")
            }
        }
        ),
        Mr(this, "getPublicKey", async () => this.publicKey ? this.publicKey : await this.fetchAndPersistPublicKey()),
        Mr(this, "fetchAndPersistPublicKey", async () => {
            if (this.fetchPromise)
                return await this.fetchPromise,
                this.publicKey;
            this.fetchPromise = new Promise(async i => {
                const o = await this.fetchPublicKey();
                o && (await this.persistPublicKey(o),
                i(o))
            }
            );
            const s = await this.fetchPromise;
            return this.fetchPromise = void 0,
            s
        }
        ),
        Mr(this, "validateAttestation", (s, i) => {
            const o = Aye(s, i.publicKey)
              , a = {
                hasExpired: je.toMiliseconds(o.exp) < Date.now(),
                payload: o
            };
            if (a.hasExpired)
                throw this.logger.warn("resolve: jwt attestation expired"),
                new Error("JWT attestation expired");
            return {
                origin: a.payload.origin,
                isScam: a.payload.isScam,
                isVerified: a.payload.isVerified
            }
        }
        ),
        this.logger = ro(t, this.name),
        this.abortController = new AbortController,
        this.isDevEnv = O_(),
        this.init()
    }
    get storeKey() {
        return this.storagePrefix + this.version + this.core.customStoragePrefix + "//verify:public:key"
    }
    get context() {
        return Ii(this.logger)
    }
    startAbortTimer(e) {
        return this.abortController = new AbortController,
        setTimeout( () => this.abortController.abort(), je.toMiliseconds(e))
    }
}
var Ixe = Object.defineProperty
  , Mxe = (n, e, t) => e in n ? Ixe(n, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : n[e] = t
  , KO = (n, e, t) => Mxe(n, typeof e != "symbol" ? e + "" : e, t);
class Bxe extends T1e {
    constructor(e, t) {
        super(e, t),
        this.projectId = e,
        this.logger = t,
        KO(this, "context", Rwe),
        KO(this, "registerDeviceToken", async r => {
            const {clientId: s, token: i, notificationType: o, enableEncrypted: a=!1} = r
              , l = `${Owe}/${this.projectId}/clients`;
            await fetch(l, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    client_id: s,
                    type: o,
                    token: i,
                    always_raw: a
                })
            })
        }
        ),
        this.logger = ro(t, this.context)
    }
}
var Rxe = Object.defineProperty
  , XO = Object.getOwnPropertySymbols
  , Oxe = Object.prototype.hasOwnProperty
  , Pxe = Object.prototype.propertyIsEnumerable
  , DC = (n, e, t) => e in n ? Rxe(n, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : n[e] = t
  , Zm = (n, e) => {
    for (var t in e || (e = {}))
        Oxe.call(e, t) && DC(n, t, e[t]);
    if (XO)
        for (var t of XO(e))
            Pxe.call(e, t) && DC(n, t, e[t]);
    return n
}
  , Xr = (n, e, t) => DC(n, typeof e != "symbol" ? e + "" : e, t);
class jxe extends I1e {
    constructor(e, t, r=!0) {
        super(e, t, r),
        this.core = e,
        this.logger = t,
        Xr(this, "context", jwe),
        Xr(this, "storagePrefix", rl),
        Xr(this, "storageVersion", Pwe),
        Xr(this, "events", new Map),
        Xr(this, "shouldPersist", !1),
        Xr(this, "init", async () => {
            if (!O_())
                try {
                    const s = {
                        eventId: SR(),
                        timestamp: Date.now(),
                        domain: this.getAppDomain(),
                        props: {
                            event: "INIT",
                            type: "",
                            properties: {
                                client_id: await this.core.crypto.getClientId(),
                                user_agent: W$(this.core.relayer.protocol, this.core.relayer.version, xC)
                            }
                        }
                    };
                    await this.sendEvent([s])
                } catch (s) {
                    this.logger.warn(s)
                }
        }
        ),
        Xr(this, "createEvent", s => {
            const {event: i="ERROR", type: o="", properties: {topic: a, trace: l}} = s
              , u = SR()
              , d = this.core.projectId || ""
              , h = Date.now()
              , p = Zm({
                eventId: u,
                timestamp: h,
                props: {
                    event: i,
                    type: o,
                    properties: {
                        topic: a,
                        trace: l
                    }
                },
                bundleId: d,
                domain: this.getAppDomain()
            }, this.setMethods(u));
            return this.telemetryEnabled && (this.events.set(u, p),
            this.shouldPersist = !0),
            p
        }
        ),
        Xr(this, "getEvent", s => {
            const {eventId: i, topic: o} = s;
            if (i)
                return this.events.get(i);
            const a = Array.from(this.events.values()).find(l => l.props.properties.topic === o);
            if (a)
                return Zm(Zm({}, a), this.setMethods(a.eventId))
        }
        ),
        Xr(this, "deleteEvent", s => {
            const {eventId: i} = s;
            this.events.delete(i),
            this.shouldPersist = !0
        }
        ),
        Xr(this, "setEventListeners", () => {
            this.core.heartbeat.on(Qf.pulse, async () => {
                this.shouldPersist && await this.persist(),
                this.events.forEach(s => {
                    je.fromMiliseconds(Date.now()) - je.fromMiliseconds(s.timestamp) > Lwe && (this.events.delete(s.eventId),
                    this.shouldPersist = !0)
                }
                )
            }
            )
        }
        ),
        Xr(this, "setMethods", s => ({
            addTrace: i => this.addTrace(s, i),
            setError: i => this.setError(s, i)
        })),
        Xr(this, "addTrace", (s, i) => {
            const o = this.events.get(s);
            o && (o.props.properties.trace.push(i),
            this.events.set(s, o),
            this.shouldPersist = !0)
        }
        ),
        Xr(this, "setError", (s, i) => {
            const o = this.events.get(s);
            o && (o.props.type = i,
            o.timestamp = Date.now(),
            this.events.set(s, o),
            this.shouldPersist = !0)
        }
        ),
        Xr(this, "persist", async () => {
            await this.core.storage.setItem(this.storageKey, Array.from(this.events.values())),
            this.shouldPersist = !1
        }
        ),
        Xr(this, "restore", async () => {
            try {
                const s = await this.core.storage.getItem(this.storageKey) || [];
                if (!s.length)
                    return;
                s.forEach(i => {
                    this.events.set(i.eventId, Zm(Zm({}, i), this.setMethods(i.eventId)))
                }
                )
            } catch (s) {
                this.logger.warn(s)
            }
        }
        ),
        Xr(this, "submit", async () => {
            if (!this.telemetryEnabled || this.events.size === 0)
                return;
            const s = [];
            for (const [i,o] of this.events)
                o.props.type && s.push(o);
            if (s.length !== 0)
                try {
                    if ((await this.sendEvent(s)).ok)
                        for (const i of s)
                            this.events.delete(i.eventId),
                            this.shouldPersist = !0
                } catch (i) {
                    this.logger.warn(i)
                }
        }
        ),
        Xr(this, "sendEvent", async s => {
            const i = this.getAppDomain() ? "" : "&sp=desktop";
            return await fetch(`${Fwe}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${xC}${i}`, {
                method: "POST",
                body: JSON.stringify(s)
            })
        }
        ),
        Xr(this, "getAppDomain", () => G$().url),
        this.logger = ro(t, this.context),
        this.telemetryEnabled = r,
        r ? this.restore().then(async () => {
            await this.submit(),
            this.setEventListeners()
        }
        ) : this.persist()
    }
    get storageKey() {
        return this.storagePrefix + this.storageVersion + this.core.customStoragePrefix + "//" + this.context
    }
}
var Lxe = Object.defineProperty
  , QO = Object.getOwnPropertySymbols
  , Fxe = Object.prototype.hasOwnProperty
  , Uxe = Object.prototype.propertyIsEnumerable
  , TC = (n, e, t) => e in n ? Lxe(n, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : n[e] = t
  , ZO = (n, e) => {
    for (var t in e || (e = {}))
        Fxe.call(e, t) && TC(n, t, e[t]);
    if (QO)
        for (var t of QO(e))
            Uxe.call(e, t) && TC(n, t, e[t]);
    return n
}
  , Fn = (n, e, t) => TC(n, typeof e != "symbol" ? e + "" : e, t);
let zxe = class vV extends b1e {
    constructor(e) {
        var t;
        super(e),
        Fn(this, "protocol", sV),
        Fn(this, "version", iV),
        Fn(this, "name", vC),
        Fn(this, "relayUrl"),
        Fn(this, "projectId"),
        Fn(this, "customStoragePrefix"),
        Fn(this, "events", new no.EventEmitter),
        Fn(this, "logger"),
        Fn(this, "heartbeat"),
        Fn(this, "relayer"),
        Fn(this, "crypto"),
        Fn(this, "storage"),
        Fn(this, "history"),
        Fn(this, "expirer"),
        Fn(this, "pairing"),
        Fn(this, "verify"),
        Fn(this, "echoClient"),
        Fn(this, "linkModeSupportedApps"),
        Fn(this, "eventClient"),
        Fn(this, "initialized", !1),
        Fn(this, "logChunkController"),
        Fn(this, "on", (a, l) => this.events.on(a, l)),
        Fn(this, "once", (a, l) => this.events.once(a, l)),
        Fn(this, "off", (a, l) => this.events.off(a, l)),
        Fn(this, "removeListener", (a, l) => this.events.removeListener(a, l)),
        Fn(this, "dispatchEnvelope", ({topic: a, message: l, sessionExists: u}) => {
            if (!a || !l)
                return;
            const d = {
                topic: a,
                message: l,
                publishedAt: Date.now(),
                transportType: Gn.link_mode
            };
            this.relayer.onLinkMessageEvent(d, {
                sessionExists: u
            })
        }
        );
        const r = this.getGlobalCore(e?.customStoragePrefix);
        if (r)
            try {
                return this.customStoragePrefix = r.customStoragePrefix,
                this.logger = r.logger,
                this.heartbeat = r.heartbeat,
                this.crypto = r.crypto,
                this.history = r.history,
                this.expirer = r.expirer,
                this.storage = r.storage,
                this.relayer = r.relayer,
                this.pairing = r.pairing,
                this.verify = r.verify,
                this.echoClient = r.echoClient,
                this.linkModeSupportedApps = r.linkModeSupportedApps,
                this.eventClient = r.eventClient,
                this.initialized = r.initialized,
                this.logChunkController = r.logChunkController,
                r
            } catch (a) {
                console.warn("Failed to copy global core", a)
            }
        this.projectId = e?.projectId,
        this.relayUrl = e?.relayUrl || aV,
        this.customStoragePrefix = e != null && e.customStoragePrefix ? `:${e.customStoragePrefix}` : "";
        const s = i0e({
            level: typeof e?.logger == "string" && e.logger ? e.logger : owe.logger,
            name: vC
        })
          , {logger: i, chunkLoggerController: o} = V$({
            opts: s,
            maxSizeInBytes: e?.maxLogBlobSizeInBytes,
            loggerOverride: e?.logger
        });
        this.logChunkController = o,
        (t = this.logChunkController) != null && t.downloadLogsBlobInBrowser && (window.downloadLogsBlobInBrowser = async () => {
            var a, l;
            (a = this.logChunkController) != null && a.downloadLogsBlobInBrowser && ((l = this.logChunkController) == null || l.downloadLogsBlobInBrowser({
                clientId: await this.crypto.getClientId()
            }))
        }
        ),
        this.logger = ro(i, this.name),
        this.heartbeat = new Obe,
        this.crypto = new pve(this,this.logger,e?.keychain),
        this.history = new Axe(this,this.logger),
        this.expirer = new kxe(this,this.logger),
        this.storage = e != null && e.storage ? e.storage : new m1e(ZO(ZO({}, awe), e?.storageOptions)),
        this.relayer = new zve({
            core: this,
            logger: this.logger,
            relayUrl: this.relayUrl,
            projectId: this.projectId
        }),
        this.pairing = new xxe(this,this.logger),
        this.verify = new Txe(this,this.logger,this.storage),
        this.echoClient = new Bxe(this.projectId || "",this.logger),
        this.linkModeSupportedApps = [],
        this.eventClient = new jxe(this,this.logger,e?.telemetryEnabled),
        this.setGlobalCore(this)
    }
    static async init(e) {
        const t = new vV(e);
        await t.initialize();
        const r = await t.crypto.getClientId();
        return await t.storage.setItem(xwe, r),
        t
    }
    get context() {
        return Ii(this.logger)
    }
    async start() {
        this.initialized || await this.initialize()
    }
    async getLogsBlob() {
        var e;
        return (e = this.logChunkController) == null ? void 0 : e.logsToBlob({
            clientId: await this.crypto.getClientId()
        })
    }
    async addLinkModeSupportedApp(e) {
        this.linkModeSupportedApps.includes(e) || (this.linkModeSupportedApps.push(e),
        await this.storage.setItem(TO, this.linkModeSupportedApps))
    }
    async initialize() {
        this.logger.trace("Initialized");
        try {
            await this.crypto.init(),
            await this.history.init(),
            await this.expirer.init(),
            await this.relayer.init(),
            await this.heartbeat.init(),
            await this.pairing.init(),
            this.linkModeSupportedApps = await this.storage.getItem(TO) || [],
            this.initialized = !0,
            this.logger.info("Core Initialization Success")
        } catch (e) {
            throw this.logger.warn(e, `Core Initialization Failure at epoch ${Date.now()}`),
            this.logger.error(e.message),
            e
        }
    }
    getGlobalCore(e="") {
        try {
            if (this.isGlobalCoreDisabled())
                return;
            const t = `_walletConnectCore_${e}`
              , r = `${t}_count`;
            return globalThis[r] = (globalThis[r] || 0) + 1,
            globalThis[r] > 1 && console.warn(`WalletConnect Core is already initialized. This is probably a mistake and can lead to unexpected behavior. Init() was called ${globalThis[r]} times.`),
            globalThis[t]
        } catch (t) {
            console.warn("Failed to get global WalletConnect core", t);
            return
        }
    }
    setGlobalCore(e) {
        var t;
        try {
            if (this.isGlobalCoreDisabled())
                return;
            const r = `_walletConnectCore_${((t = e.opts) == null ? void 0 : t.customStoragePrefix) || ""}`;
            globalThis[r] = e
        } catch (r) {
            console.warn("Failed to set global WalletConnect core", r)
        }
    }
    isGlobalCoreDisabled() {
        try {
            return typeof process < "u" && iwe.DISABLE_GLOBAL_CORE === "true"
        } catch {
            return !0
        }
    }
}
;
const $xe = zxe
  , xV = "wc"
  , EV = 2
  , SV = "client"
  , X_ = `${xV}@${EV}:${SV}:`
  , oA = {
    name: SV,
    logger: "error"
}
  , JO = "WALLETCONNECT_DEEPLINK_CHOICE"
  , Hxe = "proposal"
  , e7 = "Proposal expired"
  , Vxe = "session"
  , ep = je.SEVEN_DAYS
  , qxe = "engine"
  , ds = {
    wc_sessionPropose: {
        req: {
            ttl: je.FIVE_MINUTES,
            prompt: !0,
            tag: 1100
        },
        res: {
            ttl: je.FIVE_MINUTES,
            prompt: !1,
            tag: 1101
        },
        reject: {
            ttl: je.FIVE_MINUTES,
            prompt: !1,
            tag: 1120
        },
        autoReject: {
            ttl: je.FIVE_MINUTES,
            prompt: !1,
            tag: 1121
        }
    },
    wc_sessionSettle: {
        req: {
            ttl: je.FIVE_MINUTES,
            prompt: !1,
            tag: 1102
        },
        res: {
            ttl: je.FIVE_MINUTES,
            prompt: !1,
            tag: 1103
        }
    },
    wc_sessionUpdate: {
        req: {
            ttl: je.ONE_DAY,
            prompt: !1,
            tag: 1104
        },
        res: {
            ttl: je.ONE_DAY,
            prompt: !1,
            tag: 1105
        }
    },
    wc_sessionExtend: {
        req: {
            ttl: je.ONE_DAY,
            prompt: !1,
            tag: 1106
        },
        res: {
            ttl: je.ONE_DAY,
            prompt: !1,
            tag: 1107
        }
    },
    wc_sessionRequest: {
        req: {
            ttl: je.FIVE_MINUTES,
            prompt: !0,
            tag: 1108
        },
        res: {
            ttl: je.FIVE_MINUTES,
            prompt: !1,
            tag: 1109
        }
    },
    wc_sessionEvent: {
        req: {
            ttl: je.FIVE_MINUTES,
            prompt: !0,
            tag: 1110
        },
        res: {
            ttl: je.FIVE_MINUTES,
            prompt: !1,
            tag: 1111
        }
    },
    wc_sessionDelete: {
        req: {
            ttl: je.ONE_DAY,
            prompt: !1,
            tag: 1112
        },
        res: {
            ttl: je.ONE_DAY,
            prompt: !1,
            tag: 1113
        }
    },
    wc_sessionPing: {
        req: {
            ttl: je.ONE_DAY,
            prompt: !1,
            tag: 1114
        },
        res: {
            ttl: je.ONE_DAY,
            prompt: !1,
            tag: 1115
        }
    },
    wc_sessionAuthenticate: {
        req: {
            ttl: je.ONE_HOUR,
            prompt: !0,
            tag: 1116
        },
        res: {
            ttl: je.ONE_HOUR,
            prompt: !1,
            tag: 1117
        },
        reject: {
            ttl: je.FIVE_MINUTES,
            prompt: !1,
            tag: 1118
        },
        autoReject: {
            ttl: je.FIVE_MINUTES,
            prompt: !1,
            tag: 1119
        }
    }
}
  , aA = {
    min: je.FIVE_MINUTES,
    max: je.SEVEN_DAYS
}
  , Ia = {
    idle: "IDLE",
    active: "ACTIVE"
}
  , Gxe = {
    eth_sendTransaction: {
        key: ""
    },
    eth_sendRawTransaction: {
        key: ""
    },
    wallet_sendCalls: {
        key: ""
    },
    solana_signTransaction: {
        key: "signature"
    },
    solana_signAllTransactions: {
        key: "transactions"
    },
    solana_signAndSendTransaction: {
        key: "signature"
    },
    sui_signAndExecuteTransaction: {
        key: "digest"
    },
    sui_signTransaction: {
        key: ""
    },
    hedera_signAndExecuteTransaction: {
        key: "transactionId"
    },
    hedera_executeTransaction: {
        key: "transactionId"
    },
    near_signTransaction: {
        key: ""
    },
    near_signTransactions: {
        key: ""
    },
    tron_signTransaction: {
        key: "txID"
    },
    xrpl_signTransaction: {
        key: ""
    },
    xrpl_signTransactionFor: {
        key: ""
    },
    algo_signTxn: {
        key: ""
    },
    sendTransfer: {
        key: "txid"
    },
    stacks_stxTransfer: {
        key: "txId"
    },
    polkadot_signTransaction: {
        key: ""
    },
    cosmos_signDirect: {
        key: ""
    }
}
  , Wxe = "request"
  , Yxe = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest", "wc_sessionAuthenticate"]
  , Kxe = "wc"
  , Xxe = "auth"
  , Qxe = "authKeys"
  , Zxe = "pairingTopics"
  , Jxe = "requests"
  , Cx = `${Kxe}@${1.5}:${Xxe}:`
  , Kw = `${Cx}:PUB_KEY`;
var e3e = Object.defineProperty
  , t3e = Object.defineProperties
  , n3e = Object.getOwnPropertyDescriptors
  , t7 = Object.getOwnPropertySymbols
  , r3e = Object.prototype.hasOwnProperty
  , s3e = Object.prototype.propertyIsEnumerable
  , IC = (n, e, t) => e in n ? e3e(n, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : n[e] = t
  , gn = (n, e) => {
    for (var t in e || (e = {}))
        r3e.call(e, t) && IC(n, t, e[t]);
    if (t7)
        for (var t of t7(e))
            s3e.call(e, t) && IC(n, t, e[t]);
    return n
}
  , fs = (n, e) => t3e(n, n3e(e))
  , Be = (n, e, t) => IC(n, typeof e != "symbol" ? e + "" : e, t);
class i3e extends O1e {
    constructor(e) {
        super(e),
        Be(this, "name", qxe),
        Be(this, "events", new y_),
        Be(this, "initialized", !1),
        Be(this, "requestQueue", {
            state: Ia.idle,
            queue: []
        }),
        Be(this, "sessionRequestQueue", {
            state: Ia.idle,
            queue: []
        }),
        Be(this, "emittedSessionRequests", new j0e({
            limit: 500
        })),
        Be(this, "requestQueueDelay", je.ONE_SECOND),
        Be(this, "expectedPairingMethodMap", new Map),
        Be(this, "recentlyDeletedMap", new Map),
        Be(this, "recentlyDeletedLimit", 200),
        Be(this, "relayMessageCache", []),
        Be(this, "pendingSessions", new Map),
        Be(this, "init", async () => {
            this.initialized || (await this.cleanup(),
            this.registerRelayerEvents(),
            this.registerExpirerEvents(),
            this.registerPairingEvents(),
            await this.registerLinkModeListeners(),
            this.client.core.pairing.register({
                methods: Object.keys(ds)
            }),
            this.initialized = !0,
            setTimeout(async () => {
                await this.processPendingMessageEvents(),
                this.sessionRequestQueue.queue = this.getPendingSessionRequests(),
                this.processSessionRequestQueue()
            }
            , je.toMiliseconds(this.requestQueueDelay)))
        }
        ),
        Be(this, "connect", async t => {
            var r;
            this.isInitialized(),
            await this.confirmOnlineStateOrThrow();
            const s = fs(gn({}, t), {
                requiredNamespaces: t.requiredNamespaces || {},
                optionalNamespaces: t.optionalNamespaces || {}
            });
            await this.isValidConnect(s),
            s.optionalNamespaces = Wye(s.requiredNamespaces, s.optionalNamespaces),
            s.requiredNamespaces = {};
            const {pairingTopic: i, requiredNamespaces: o, optionalNamespaces: a, sessionProperties: l, scopedProperties: u, relays: d, authentication: h, walletPay: p} = s
              , g = ((r = h?.[0]) == null ? void 0 : r.ttl) || ds.wc_sessionPropose.req.ttl || je.FIVE_MINUTES;
            this.validateRequestExpiry(g);
            let w = i, b, v = !1;
            try {
                if (w) {
                    const R = this.client.core.pairing.pairings.get(w);
                    this.client.logger.warn("connect() with existing pairing topic is deprecated and will be removed in the next major release."),
                    v = R.active
                }
            } catch (R) {
                throw this.client.logger.error(`connect() -> pairing.get(${w}) failed`),
                R
            }
            if (!w || !v) {
                const {topic: R, uri: L} = await this.client.core.pairing.create({
                    internal: {
                        skipSubscribe: !0
                    }
                });
                w = R,
                b = L
            }
            if (!w) {
                const {message: R} = Fe("NO_MATCHING_KEY", `connect() pairing topic: ${w}`);
                throw new Error(R)
            }
            const S = await this.client.core.crypto.generateKeyPair()
              , N = Br(g)
              , _ = gn(fs(gn(gn({
                requiredNamespaces: o,
                optionalNamespaces: a,
                relays: d ?? [{
                    protocol: oV
                }],
                proposer: {
                    publicKey: S,
                    metadata: this.client.metadata
                },
                expiryTimestamp: N,
                pairingTopic: w
            }, l && {
                sessionProperties: l
            }), u && {
                scopedProperties: u
            }), {
                id: Oa()
            }), (h || p) && {
                requests: {
                    authentication: h?.map(R => {
                        const {domain: L, chains: q, nonce: H, uri: j, exp: A, nbf: E, type: C, statement: O, requestId: z, resources: G, signatureTypes: Y} = R;
                        return {
                            domain: L,
                            chains: q,
                            nonce: H,
                            type: C ?? "caip122",
                            aud: j,
                            version: "1",
                            iat: new Date().toISOString(),
                            exp: A,
                            nbf: E,
                            statement: O,
                            requestId: z,
                            resources: G,
                            signatureTypes: Y
                        }
                    }
                    ),
                    walletPay: p
                }
            })
              , I = An("session_connect", _.id)
              , {reject: k, resolve: B, done: P} = $d(g, e7)
              , M = ({id: R}) => {
                R === _.id && (this.client.events.off("proposal_expire", M),
                this.pendingSessions.delete(_.id),
                this.events.emit(I, {
                    error: {
                        message: e7,
                        code: 0
                    }
                }))
            }
            ;
            return this.client.events.on("proposal_expire", M),
            this.events.once(I, ({error: R, session: L}) => {
                this.client.events.off("proposal_expire", M),
                R ? k(R) : L && B(L)
            }
            ),
            await this.setProposal(_.id, _),
            await this.sendProposeSession({
                proposal: _,
                publishOpts: {
                    internal: {
                        throwOnFailedPublish: !0
                    },
                    tvf: {
                        correlationId: _.id
                    }
                }
            }).catch(R => {
                throw this.deleteProposal(_.id),
                R
            }
            ),
            {
                uri: b,
                approval: P
            }
        }
        ),
        Be(this, "pair", async t => {
            this.isInitialized(),
            await this.confirmOnlineStateOrThrow();
            try {
                return await this.client.core.pairing.pair(t)
            } catch (r) {
                throw this.client.logger.error("pair() failed"),
                r
            }
        }
        ),
        Be(this, "approve", async t => {
            var r, s, i;
            const o = this.client.core.eventClient.createEvent({
                properties: {
                    topic: (r = t?.id) == null ? void 0 : r.toString(),
                    trace: [Yo.session_approve_started]
                }
            });
            try {
                this.isInitialized(),
                await this.confirmOnlineStateOrThrow()
            } catch (L) {
                throw o.setError(Bd.no_internet_connection),
                L
            }
            try {
                await this.isValidProposalId(t?.id)
            } catch (L) {
                throw this.client.logger.error(`approve() -> proposal.get(${t?.id}) failed`),
                o.setError(Bd.proposal_not_found),
                L
            }
            try {
                await this.isValidApprove(t)
            } catch (L) {
                throw this.client.logger.error("approve() -> isValidApprove() failed"),
                o.setError(Bd.session_approve_namespace_validation_failure),
                L
            }
            const {id: a, relayProtocol: l, namespaces: u, sessionProperties: d, scopedProperties: h, sessionConfig: p, proposalRequestsResponses: g} = t
              , w = this.client.proposal.get(a);
            this.client.core.eventClient.deleteEvent({
                eventId: o.eventId
            });
            const {pairingTopic: b, proposer: v, requiredNamespaces: S, optionalNamespaces: N} = w;
            let _ = (s = this.client.core.eventClient) == null ? void 0 : s.getEvent({
                topic: b
            });
            _ || (_ = (i = this.client.core.eventClient) == null ? void 0 : i.createEvent({
                type: Yo.session_approve_started,
                properties: {
                    topic: b,
                    trace: [Yo.session_approve_started, Yo.session_namespaces_validation_success]
                }
            }));
            const I = await this.client.core.crypto.generateKeyPair()
              , k = v.publicKey
              , B = await this.client.core.crypto.generateSharedKey(I, k)
              , P = fs(gn(gn(gn({
                relay: {
                    protocol: l ?? "irn"
                },
                namespaces: u,
                controller: {
                    publicKey: I,
                    metadata: this.client.metadata
                },
                expiry: Br(ep)
            }, d && {
                sessionProperties: d
            }), h && {
                scopedProperties: h
            }), p && {
                sessionConfig: p
            }), {
                proposalRequestsResponses: g
            })
              , M = Gn.relay;
            _.addTrace(Yo.subscribing_session_topic);
            try {
                await this.client.core.relayer.subscribe(B, {
                    transportType: M,
                    internal: {
                        skipSubscribe: !0
                    }
                })
            } catch (L) {
                throw _.setError(Bd.subscribe_session_topic_failure),
                L
            }
            _.addTrace(Yo.subscribe_session_topic_success);
            const R = fs(gn({}, P), {
                topic: B,
                requiredNamespaces: S,
                optionalNamespaces: N,
                pairingTopic: b,
                acknowledged: !1,
                self: P.controller,
                peer: {
                    publicKey: v.publicKey,
                    metadata: v.metadata
                },
                controller: I,
                transportType: Gn.relay,
                authentication: g?.authentication,
                walletPayResult: g?.walletPay
            });
            await this.client.session.set(B, R),
            _.addTrace(Yo.store_session);
            try {
                await this.sendApproveSession({
                    sessionTopic: B,
                    proposal: w,
                    pairingProposalResponse: {
                        relay: {
                            protocol: l ?? "irn"
                        },
                        responderPublicKey: I
                    },
                    sessionSettleRequest: P,
                    publishOpts: {
                        internal: {
                            throwOnFailedPublish: !0
                        },
                        tvf: gn({
                            correlationId: a
                        }, this.getTVFApproveParams(R))
                    }
                }),
                _.addTrace(Yo.session_approve_publish_success)
            } catch (L) {
                throw this.client.logger.error(L),
                this.client.session.delete(B, Yn("USER_DISCONNECTED")),
                await this.client.core.relayer.unsubscribe(B),
                L
            }
            return this.client.core.eventClient.deleteEvent({
                eventId: _.eventId
            }),
            await this.client.core.pairing.updateMetadata({
                topic: b,
                metadata: v.metadata
            }),
            await this.deleteProposal(a),
            await this.client.core.pairing.activate({
                topic: b
            }),
            await this.setExpiry(B, Br(ep)),
            {
                topic: B,
                acknowledged: () => Promise.resolve(this.client.session.get(B))
            }
        }
        ),
        Be(this, "reject", async t => {
            this.isInitialized(),
            await this.confirmOnlineStateOrThrow();
            try {
                await this.isValidReject(t)
            } catch (o) {
                throw this.client.logger.error("reject() -> isValidReject() failed"),
                o
            }
            const {id: r, reason: s} = t;
            let i;
            try {
                i = this.client.proposal.get(r).pairingTopic
            } catch (o) {
                throw this.client.logger.error(`reject() -> proposal.get(${r}) failed`),
                o
            }
            i && await this.sendError({
                id: r,
                topic: i,
                error: s,
                rpcOpts: ds.wc_sessionPropose.reject
            }),
            await this.deleteProposal(r)
        }
        ),
        Be(this, "update", async t => {
            this.isInitialized(),
            await this.confirmOnlineStateOrThrow();
            try {
                await this.isValidUpdate(t)
            } catch (h) {
                throw this.client.logger.error("update() -> isValidUpdate() failed"),
                h
            }
            const {topic: r, namespaces: s} = t
              , {done: i, resolve: o, reject: a} = $d(je.FIVE_MINUTES, "Session update request expired without receiving any acknowledgement")
              , l = Oa()
              , u = Fu().toString()
              , d = this.client.session.get(r).namespaces;
            return this.events.once(An("session_update", l), ({error: h}) => {
                h ? a(h) : o()
            }
            ),
            await this.client.session.update(r, {
                namespaces: s
            }),
            await this.sendRequest({
                topic: r,
                method: "wc_sessionUpdate",
                params: {
                    namespaces: s
                },
                throwOnFailedPublish: !0,
                clientRpcId: l,
                relayRpcId: u
            }).catch(h => {
                this.client.logger.error(h),
                this.client.session.update(r, {
                    namespaces: d
                }),
                a(h)
            }
            ),
            {
                acknowledged: i
            }
        }
        ),
        Be(this, "extend", async t => {
            this.isInitialized(),
            await this.confirmOnlineStateOrThrow();
            try {
                await this.isValidExtend(t)
            } catch (l) {
                throw this.client.logger.error("extend() -> isValidExtend() failed"),
                l
            }
            const {topic: r} = t
              , s = Oa()
              , {done: i, resolve: o, reject: a} = $d(je.FIVE_MINUTES, "Session extend request expired without receiving any acknowledgement");
            return this.events.once(An("session_extend", s), ({error: l}) => {
                l ? a(l) : o()
            }
            ),
            await this.setExpiry(r, Br(ep)),
            this.sendRequest({
                topic: r,
                method: "wc_sessionExtend",
                params: {},
                clientRpcId: s,
                throwOnFailedPublish: !0
            }).catch(l => {
                a(l)
            }
            ),
            {
                acknowledged: i
            }
        }
        ),
        Be(this, "request", async t => {
            this.isInitialized();
            try {
                await this.isValidRequest(t)
            } catch (v) {
                throw this.client.logger.error("request() -> isValidRequest() failed"),
                v
            }
            const {chainId: r, request: s, topic: i, expiry: o=ds.wc_sessionRequest.req.ttl} = t
              , a = this.client.session.get(i);
            a?.transportType === Gn.relay && await this.confirmOnlineStateOrThrow();
            const l = Oa()
              , u = Fu().toString()
              , {done: d, resolve: h, reject: p} = $d(o, "Request expired. Please try again.");
            this.events.once(An("session_request", l), ({error: v, result: S}) => {
                v ? p(v) : h(S)
            }
            );
            const g = "wc_sessionRequest"
              , w = this.getAppLinkIfEnabled(a.peer.metadata, a.transportType);
            if (w)
                return await this.sendRequest({
                    clientRpcId: l,
                    relayRpcId: u,
                    topic: i,
                    method: g,
                    params: {
                        request: fs(gn({}, s), {
                            expiryTimestamp: Br(o)
                        }),
                        chainId: r
                    },
                    expiry: o,
                    throwOnFailedPublish: !0,
                    appLink: w
                }).catch(v => p(v)),
                this.client.events.emit("session_request_sent", {
                    topic: i,
                    request: s,
                    chainId: r,
                    id: l
                }),
                await d();
            const b = {
                request: fs(gn({}, s), {
                    expiryTimestamp: Br(o)
                }),
                chainId: r
            };
            return await Promise.all([new Promise(async v => {
                await this.sendRequest({
                    clientRpcId: l,
                    relayRpcId: u,
                    topic: i,
                    method: g,
                    params: b,
                    expiry: o,
                    throwOnFailedPublish: !0,
                    tvf: this.getTVFParams(l, b)
                }).catch(S => p(S)),
                this.client.events.emit("session_request_sent", {
                    topic: i,
                    request: s,
                    chainId: r,
                    id: l
                }),
                v()
            }
            ), new Promise(async v => {
                var S;
                if (!((S = a.sessionConfig) != null && S.disableDeepLink)) {
                    const N = await M0e(this.client.core.storage, JO);
                    await D0e({
                        id: l,
                        topic: i,
                        wcDeepLink: N
                    })
                }
                v()
            }
            ), d()]).then(v => v[2])
        }
        ),
        Be(this, "respond", async t => {
            var r, s;
            this.isInitialized();
            const i = this.client.core.eventClient.createEvent({
                properties: {
                    topic: t?.topic || ((s = (r = t?.response) == null ? void 0 : r.id) == null ? void 0 : s.toString()),
                    trace: [Yo.session_request_response_started]
                }
            });
            try {
                await this.isValidRespond(t)
            } catch (h) {
                throw i.addTrace(h?.message),
                i.setError(Bd.session_request_response_validation_failure),
                h
            }
            i.addTrace(Yo.session_request_response_validation_success);
            const {topic: o, response: a} = t
              , {id: l} = a
              , u = this.client.session.get(o);
            u.transportType === Gn.relay && await this.confirmOnlineStateOrThrow();
            const d = this.getAppLinkIfEnabled(u.peer.metadata, u.transportType);
            try {
                i.addTrace(Yo.session_request_response_publish_started),
                Pa(a) ? await this.sendResult({
                    id: l,
                    topic: o,
                    result: a.result,
                    throwOnFailedPublish: !0,
                    appLink: d
                }) : _o(a) && await this.sendError({
                    id: l,
                    topic: o,
                    error: a.error,
                    appLink: d
                }),
                this.cleanupAfterResponse(t)
            } catch (h) {
                throw i.addTrace(h?.message),
                i.setError(Bd.session_request_response_publish_failure),
                h
            }
        }
        ),
        Be(this, "ping", async t => {
            this.isInitialized(),
            await this.confirmOnlineStateOrThrow();
            try {
                await this.isValidPing(t)
            } catch (s) {
                throw this.client.logger.error("ping() -> isValidPing() failed"),
                s
            }
            const {topic: r} = t;
            if (this.client.session.keys.includes(r)) {
                const s = Oa()
                  , i = Fu().toString()
                  , {done: o, resolve: a, reject: l} = $d(je.FIVE_MINUTES, "Ping request expired without receiving any acknowledgement");
                this.events.once(An("session_ping", s), ({error: u}) => {
                    u ? l(u) : a()
                }
                ),
                await Promise.all([this.sendRequest({
                    topic: r,
                    method: "wc_sessionPing",
                    params: {},
                    throwOnFailedPublish: !0,
                    clientRpcId: s,
                    relayRpcId: i
                }), o()])
            } else
                this.client.core.pairing.pairings.keys.includes(r) && (this.client.logger.warn("ping() on pairing topic is deprecated and will be removed in the next major release."),
                await this.client.core.pairing.ping({
                    topic: r
                }))
        }
        ),
        Be(this, "emit", async t => {
            this.isInitialized(),
            await this.confirmOnlineStateOrThrow(),
            await this.isValidEmit(t);
            const {topic: r, event: s, chainId: i} = t
              , o = Fu().toString()
              , a = Oa();
            await this.sendRequest({
                topic: r,
                method: "wc_sessionEvent",
                params: {
                    event: s,
                    chainId: i
                },
                throwOnFailedPublish: !0,
                relayRpcId: o,
                clientRpcId: a
            })
        }
        ),
        Be(this, "disconnect", async t => {
            this.isInitialized(),
            await this.confirmOnlineStateOrThrow(),
            await this.isValidDisconnect(t);
            const {topic: r} = t;
            if (this.client.session.keys.includes(r))
                await this.sendRequest({
                    topic: r,
                    method: "wc_sessionDelete",
                    params: Yn("USER_DISCONNECTED"),
                    throwOnFailedPublish: !0
                }),
                await this.deleteSession({
                    topic: r,
                    emitEvent: !1
                });
            else if (this.client.core.pairing.pairings.keys.includes(r))
                await this.client.core.pairing.disconnect({
                    topic: r
                });
            else {
                const {message: s} = Fe("MISMATCHED_TOPIC", `Session or pairing topic not found: ${r}`);
                throw new Error(s)
            }
        }
        ),
        Be(this, "find", t => (this.isInitialized(),
        this.client.session.getAll().filter(r => Xye(r, t)))),
        Be(this, "getPendingSessionRequests", () => this.client.pendingRequest.getAll()),
        Be(this, "authenticate", async (t, r) => {
            var s;
            this.isInitialized(),
            this.isValidAuthenticate(t);
            const i = r && this.client.core.linkModeSupportedApps.includes(r) && ((s = this.client.metadata.redirect) == null ? void 0 : s.linkMode)
              , o = i ? Gn.link_mode : Gn.relay;
            o === Gn.relay && await this.confirmOnlineStateOrThrow();
            const {chains: a, statement: l="", uri: u, domain: d, nonce: h, type: p, exp: g, nbf: w, methods: b=[], expiry: v} = t
              , S = [...t.resources || []]
              , {topic: N, uri: _} = await this.client.core.pairing.create({
                methods: ["wc_sessionAuthenticate"],
                transportType: o
            });
            this.client.logger.info({
                message: "Generated new pairing",
                pairing: {
                    topic: N,
                    uri: _
                }
            });
            const I = await this.client.core.crypto.generateKeyPair()
              , k = qw(I);
            if (await Promise.all([this.client.auth.authKeys.set(Kw, {
                responseTopic: k,
                publicKey: I
            }), this.client.auth.pairingTopics.set(k, {
                topic: k,
                pairingTopic: N
            })]),
            await this.client.core.relayer.subscribe(k, {
                transportType: o
            }),
            this.client.logger.info(`sending request to new pairing topic: ${N}`),
            b.length > 0) {
                const {namespace: G} = gc(a[0]);
                let Y = Xme(G, "request", b);
                Vw(S) && (Y = Zme(Y, S.pop())),
                S.push(Y)
            }
            const B = v && v > ds.wc_sessionAuthenticate.req.ttl ? v : ds.wc_sessionAuthenticate.req.ttl
              , P = {
                authPayload: {
                    type: p ?? "caip122",
                    chains: a,
                    statement: l,
                    aud: u,
                    domain: d,
                    version: "1",
                    nonce: h,
                    iat: new Date().toISOString(),
                    exp: g,
                    nbf: w,
                    resources: S
                },
                requester: {
                    publicKey: I,
                    metadata: this.client.metadata
                },
                expiryTimestamp: Br(B)
            }
              , M = {
                eip155: {
                    chains: a,
                    methods: [...new Set(["personal_sign", ...b])],
                    events: ["chainChanged", "accountsChanged"]
                }
            }
              , R = {
                requiredNamespaces: {},
                optionalNamespaces: M,
                relays: [{
                    protocol: "irn"
                }],
                pairingTopic: N,
                proposer: {
                    publicKey: I,
                    metadata: this.client.metadata
                },
                expiryTimestamp: Br(ds.wc_sessionPropose.req.ttl),
                id: Oa()
            }
              , {done: L, resolve: q, reject: H} = $d(B, "Request expired")
              , j = Oa()
              , A = An("session_connect", R.id)
              , E = An("session_request", j)
              , C = async ({error: G, session: Y}) => {
                this.events.off(E, O),
                G ? H(G) : Y && q({
                    session: Y
                })
            }
              , O = async G => {
                var Y, $, D;
                if (await this.deletePendingAuthRequest(j, {
                    message: "fulfilled",
                    code: 0
                }),
                G.error) {
                    const ae = Yn("WC_METHOD_UNSUPPORTED", "wc_sessionAuthenticate");
                    return G.error.code === ae.code ? void 0 : (this.events.off(A, C),
                    H(G.error.message))
                }
                await this.deleteProposal(R.id),
                this.events.off(A, C);
                const {cacaos: U, responder: W} = G.result
                  , Q = []
                  , J = [];
                for (const ae of U) {
                    await RR({
                        cacao: ae,
                        projectId: this.client.core.projectId
                    }) || (this.client.logger.error(ae, "Signature verification failed"),
                    H(Yn("SESSION_SETTLEMENT_FAILED", "Signature verification failed")));
                    const {p: xe} = ae
                      , ue = Vw(xe.resources)
                      , ce = [aC(xe.iss)]
                      , me = H2(xe.iss);
                    if (ue) {
                        const Ee = OR(ue)
                          , Oe = PR(ue);
                        Q.push(...Ee),
                        ce.push(...Oe)
                    }
                    for (const Ee of ce)
                        J.push(`${Ee}:${me}`)
                }
                const ne = await this.client.core.crypto.generateSharedKey(I, W.publicKey);
                let ie;
                Q.length > 0 && (ie = {
                    topic: ne,
                    acknowledged: !0,
                    self: {
                        publicKey: I,
                        metadata: this.client.metadata
                    },
                    peer: W,
                    controller: W.publicKey,
                    expiry: Br(ep),
                    requiredNamespaces: {},
                    optionalNamespaces: {},
                    relay: {
                        protocol: "irn"
                    },
                    pairingTopic: N,
                    namespaces: lO([...new Set(Q)], [...new Set(J)]),
                    transportType: o
                },
                await this.client.core.relayer.subscribe(ne, {
                    transportType: o
                }),
                await this.client.session.set(ne, ie),
                N && await this.client.core.pairing.updateMetadata({
                    topic: N,
                    metadata: W.metadata
                }),
                ie = this.client.session.get(ne)),
                (Y = this.client.metadata.redirect) != null && Y.linkMode && ($ = W.metadata.redirect) != null && $.linkMode && (D = W.metadata.redirect) != null && D.universal && r && (this.client.core.addLinkModeSupportedApp(W.metadata.redirect.universal),
                this.client.session.update(ne, {
                    transportType: Gn.link_mode
                })),
                q({
                    auths: U,
                    session: ie
                })
            }
            ;
            this.events.once(A, C),
            this.events.once(E, O);
            let z;
            try {
                if (i) {
                    const G = ta("wc_sessionAuthenticate", P, j);
                    this.client.core.history.set(N, G);
                    const Y = await this.client.core.crypto.encode("", G, {
                        type: Wy,
                        encoding: Pu
                    });
                    z = X1(r, N, Y)
                } else
                    await Promise.all([this.sendRequest({
                        topic: N,
                        method: "wc_sessionAuthenticate",
                        params: P,
                        expiry: t.expiry,
                        throwOnFailedPublish: !0,
                        clientRpcId: j
                    }), this.sendRequest({
                        topic: N,
                        method: "wc_sessionPropose",
                        params: R,
                        expiry: ds.wc_sessionPropose.req.ttl,
                        throwOnFailedPublish: !0,
                        clientRpcId: R.id
                    })])
            } catch (G) {
                throw this.events.off(A, C),
                this.events.off(E, O),
                G
            }
            return await this.setProposal(R.id, R),
            await this.setAuthRequest(j, {
                request: fs(gn({}, P), {
                    verifyContext: {}
                }),
                pairingTopic: N,
                transportType: o
            }),
            {
                uri: z ?? _,
                response: L
            }
        }
        ),
        Be(this, "approveSessionAuthenticate", async t => {
            const {id: r, auths: s} = t
              , i = this.client.core.eventClient.createEvent({
                properties: {
                    topic: r.toString(),
                    trace: [Rd.authenticated_session_approve_started]
                }
            });
            try {
                this.isInitialized()
            } catch (v) {
                throw i.setError(Xm.no_internet_connection),
                v
            }
            const o = this.getPendingAuthRequest(r);
            if (!o)
                throw i.setError(Xm.authenticated_session_pending_request_not_found),
                new Error(`Could not find pending auth request with id ${r}`);
            const a = o.transportType || Gn.relay;
            a === Gn.relay && await this.confirmOnlineStateOrThrow();
            const l = o.requester.publicKey
              , u = await this.client.core.crypto.generateKeyPair()
              , d = qw(l)
              , h = {
                type: yc,
                receiverPublicKey: l,
                senderPublicKey: u
            }
              , p = []
              , g = [];
            for (const v of s) {
                if (!await RR({
                    cacao: v,
                    projectId: this.client.core.projectId
                })) {
                    i.setError(Xm.invalid_cacao);
                    const k = Yn("SESSION_SETTLEMENT_FAILED", "Signature verification failed");
                    throw await this.sendError({
                        id: r,
                        topic: d,
                        error: k,
                        encodeOpts: h
                    }),
                    new Error(k.message)
                }
                i.addTrace(Rd.cacaos_verified);
                const {p: S} = v
                  , N = Vw(S.resources)
                  , _ = [aC(S.iss)]
                  , I = H2(S.iss);
                if (N) {
                    const k = OR(N)
                      , B = PR(N);
                    p.push(...k),
                    _.push(...B)
                }
                for (const k of _)
                    g.push(`${k}:${I}`)
            }
            const w = await this.client.core.crypto.generateSharedKey(u, l);
            i.addTrace(Rd.create_authenticated_session_topic);
            let b;
            if (p?.length > 0) {
                b = {
                    topic: w,
                    acknowledged: !0,
                    self: {
                        publicKey: u,
                        metadata: this.client.metadata
                    },
                    peer: {
                        publicKey: l,
                        metadata: o.requester.metadata
                    },
                    controller: l,
                    expiry: Br(ep),
                    authentication: s,
                    requiredNamespaces: {},
                    optionalNamespaces: {},
                    relay: {
                        protocol: "irn"
                    },
                    pairingTopic: o.pairingTopic,
                    namespaces: lO([...new Set(p)], [...new Set(g)]),
                    transportType: a
                },
                i.addTrace(Rd.subscribing_authenticated_session_topic);
                try {
                    await this.client.core.relayer.subscribe(w, {
                        transportType: a
                    })
                } catch (v) {
                    throw i.setError(Xm.subscribe_authenticated_session_topic_failure),
                    v
                }
                i.addTrace(Rd.subscribe_authenticated_session_topic_success),
                await this.client.session.set(w, b),
                i.addTrace(Rd.store_authenticated_session),
                await this.client.core.pairing.updateMetadata({
                    topic: o.pairingTopic,
                    metadata: o.requester.metadata
                })
            }
            i.addTrace(Rd.publishing_authenticated_session_approve);
            try {
                await this.sendResult({
                    topic: d,
                    id: r,
                    result: {
                        cacaos: s,
                        responder: {
                            publicKey: u,
                            metadata: this.client.metadata
                        }
                    },
                    encodeOpts: h,
                    throwOnFailedPublish: !0,
                    appLink: this.getAppLinkIfEnabled(o.requester.metadata, a)
                })
            } catch (v) {
                throw i.setError(Xm.authenticated_session_approve_publish_failure),
                v
            }
            return await this.client.auth.requests.delete(r, {
                message: "fulfilled",
                code: 0
            }),
            await this.client.core.pairing.activate({
                topic: o.pairingTopic
            }),
            this.client.core.eventClient.deleteEvent({
                eventId: i.eventId
            }),
            {
                session: b
            }
        }
        ),
        Be(this, "rejectSessionAuthenticate", async t => {
            this.isInitialized();
            const {id: r, reason: s} = t
              , i = this.getPendingAuthRequest(r);
            if (!i)
                throw new Error(`Could not find pending auth request with id ${r}`);
            i.transportType === Gn.relay && await this.confirmOnlineStateOrThrow();
            const o = i.requester.publicKey
              , a = await this.client.core.crypto.generateKeyPair()
              , l = qw(o)
              , u = {
                type: yc,
                receiverPublicKey: o,
                senderPublicKey: a
            };
            await this.sendError({
                id: r,
                topic: l,
                error: s,
                encodeOpts: u,
                rpcOpts: ds.wc_sessionAuthenticate.reject,
                appLink: this.getAppLinkIfEnabled(i.requester.metadata, i.transportType)
            }),
            await this.client.auth.requests.delete(r, {
                message: "rejected",
                code: 0
            }),
            await this.deleteProposal(r)
        }
        ),
        Be(this, "formatAuthMessage", t => {
            this.isInitialized();
            const {request: r, iss: s} = t;
            return fH(r, s)
        }
        ),
        Be(this, "processRelayMessageCache", () => {
            setTimeout(async () => {
                if (this.relayMessageCache.length !== 0)
                    for (; this.relayMessageCache.length > 0; )
                        try {
                            const t = this.relayMessageCache.shift();
                            t && await this.onRelayMessage(t)
                        } catch (t) {
                            this.client.logger.error(t)
                        }
            }
            , 50)
        }
        ),
        Be(this, "cleanupDuplicatePairings", async t => {
            if (t.pairingTopic)
                try {
                    const r = this.client.core.pairing.pairings.get(t.pairingTopic)
                      , s = this.client.core.pairing.pairings.getAll().filter(i => {
                        var o, a;
                        return ((o = i.peerMetadata) == null ? void 0 : o.url) && ((a = i.peerMetadata) == null ? void 0 : a.url) === t.peer.metadata.url && i.topic && i.topic !== r.topic
                    }
                    );
                    if (s.length === 0)
                        return;
                    this.client.logger.info(`Cleaning up ${s.length} duplicate pairing(s)`),
                    await Promise.all(s.map(i => this.client.core.pairing.disconnect({
                        topic: i.topic
                    }))),
                    this.client.logger.info("Duplicate pairings clean up finished")
                } catch (r) {
                    this.client.logger.error(r)
                }
        }
        ),
        Be(this, "deleteSession", async t => {
            var r;
            const {topic: s, expirerHasDeleted: i=!1, emitEvent: o=!0, id: a=0} = t
              , {self: l} = this.client.session.get(s);
            await this.client.core.relayer.unsubscribe(s),
            await this.client.session.delete(s, Yn("USER_DISCONNECTED")),
            this.addToRecentlyDeleted(s, "session"),
            this.client.core.crypto.keychain.has(l.publicKey) && await this.client.core.crypto.deleteKeyPair(l.publicKey),
            this.client.core.crypto.keychain.has(s) && await this.client.core.crypto.deleteSymKey(s),
            i || this.client.core.expirer.del(s),
            this.client.core.storage.removeItem(JO).catch(u => this.client.logger.warn(u)),
            s === ((r = this.sessionRequestQueue.queue[0]) == null ? void 0 : r.topic) && (this.sessionRequestQueue.state = Ia.idle),
            await Promise.all(this.getPendingSessionRequests().filter(u => u.topic === s).map(u => this.deletePendingSessionRequest(u.id, Yn("USER_DISCONNECTED")))),
            o && this.client.events.emit("session_delete", {
                id: a,
                topic: s
            })
        }
        ),
        Be(this, "deleteProposal", async (t, r) => {
            if (r)
                try {
                    const s = this.client.proposal.get(t);
                    this.client.core.eventClient.getEvent({
                        topic: s.pairingTopic
                    })?.setError(Bd.proposal_expired)
                } catch {}
            await Promise.all([this.client.proposal.delete(t, Yn("USER_DISCONNECTED")), r ? Promise.resolve() : this.client.core.expirer.del(t)]),
            this.addToRecentlyDeleted(t, "proposal")
        }
        ),
        Be(this, "deletePendingSessionRequest", async (t, r, s=!1) => {
            await Promise.all([this.client.pendingRequest.delete(t, r), s ? Promise.resolve() : this.client.core.expirer.del(t)]),
            this.addToRecentlyDeleted(t, "request"),
            this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter(i => i.id !== t),
            s && (this.sessionRequestQueue.state = Ia.idle,
            this.client.events.emit("session_request_expire", {
                id: t
            }))
        }
        ),
        Be(this, "deletePendingAuthRequest", async (t, r, s=!1) => {
            await Promise.all([this.client.auth.requests.delete(t, r), s ? Promise.resolve() : this.client.core.expirer.del(t)])
        }
        ),
        Be(this, "setExpiry", async (t, r) => {
            this.client.session.keys.includes(t) && (this.client.core.expirer.set(t, r),
            await this.client.session.update(t, {
                expiry: r
            }))
        }
        ),
        Be(this, "setProposal", async (t, r) => {
            this.client.core.expirer.set(t, Br(ds.wc_sessionPropose.req.ttl)),
            await this.client.proposal.set(t, r)
        }
        ),
        Be(this, "setAuthRequest", async (t, r) => {
            const {request: s, pairingTopic: i, transportType: o=Gn.relay} = r;
            this.client.core.expirer.set(t, s.expiryTimestamp),
            await this.client.auth.requests.set(t, {
                authPayload: s.authPayload,
                requester: s.requester,
                expiryTimestamp: s.expiryTimestamp,
                id: t,
                pairingTopic: i,
                verifyContext: s.verifyContext,
                transportType: o
            })
        }
        ),
        Be(this, "setPendingSessionRequest", async t => {
            const {id: r, topic: s, params: i, verifyContext: o} = t
              , a = i.request.expiryTimestamp || Br(ds.wc_sessionRequest.req.ttl);
            this.client.core.expirer.set(r, a),
            await this.client.pendingRequest.set(r, {
                id: r,
                topic: s,
                params: i,
                verifyContext: o
            })
        }
        ),
        Be(this, "sendRequest", async t => {
            const {topic: r, method: s, params: i, expiry: o, relayRpcId: a, clientRpcId: l, throwOnFailedPublish: u, appLink: d, tvf: h, publishOpts: p={}} = t
              , g = ta(s, i, l);
            let w;
            const b = !!d;
            try {
                const N = b ? Pu : xi;
                w = await this.client.core.crypto.encode(r, g, {
                    encoding: N
                })
            } catch (N) {
                throw await this.cleanup(),
                this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${r} failed`),
                N
            }
            let v;
            if (Yxe.includes(s)) {
                const N = Co(JSON.stringify(g))
                  , _ = Co(w);
                v = await this.client.core.verify.register({
                    id: _,
                    decryptedId: N
                })
            }
            const S = gn(gn({}, ds[s].req), p);
            if (S.attestation = v,
            o && (S.ttl = o),
            a && (S.id = a),
            this.client.core.history.set(r, g),
            b) {
                const N = X1(d, r, w);
                await global.Linking.openURL(N, this.client.name)
            } else
                S.tvf = fs(gn({}, h), {
                    correlationId: g.id
                }),
                u ? (S.internal = fs(gn({}, S.internal), {
                    throwOnFailedPublish: !0
                }),
                await this.client.core.relayer.publish(r, w, S)) : this.client.core.relayer.publish(r, w, S).catch(N => this.client.logger.error(N));
            return g.id
        }
        ),
        Be(this, "sendProposeSession", async t => {
            const {proposal: r, publishOpts: s} = t
              , i = ta("wc_sessionPropose", r, r.id);
            this.client.core.history.set(r.pairingTopic, i);
            const o = await this.client.core.crypto.encode(r.pairingTopic, i, {
                encoding: xi
            })
              , a = Co(JSON.stringify(i))
              , l = Co(o)
              , u = await this.client.core.verify.register({
                id: l,
                decryptedId: a
            });
            await this.client.core.relayer.publishCustom({
                payload: {
                    pairingTopic: r.pairingTopic,
                    sessionProposal: o
                },
                opts: fs(gn({}, s), {
                    publishMethod: "wc_proposeSession",
                    attestation: u
                })
            })
        }
        ),
        Be(this, "sendApproveSession", async t => {
            const {sessionTopic: r, pairingProposalResponse: s, proposal: i, sessionSettleRequest: o, publishOpts: a} = t
              , l = iy(i.id, s)
              , u = await this.client.core.crypto.encode(i.pairingTopic, l, {
                encoding: xi
            })
              , d = ta("wc_sessionSettle", o, a?.id)
              , h = await this.client.core.crypto.encode(r, d, {
                encoding: xi
            });
            this.client.core.history.set(r, d),
            await this.client.core.relayer.publishCustom({
                payload: {
                    sessionTopic: r,
                    pairingTopic: i.pairingTopic,
                    sessionProposalResponse: u,
                    sessionSettlementRequest: h
                },
                opts: fs(gn({}, a), {
                    publishMethod: "wc_approveSession"
                })
            })
        }
        ),
        Be(this, "sendResult", async t => {
            const {id: r, topic: s, result: i, throwOnFailedPublish: o, encodeOpts: a, appLink: l} = t
              , u = iy(r, i);
            let d;
            const h = l && typeof (global == null ? void 0 : global.Linking) < "u";
            try {
                const w = h ? Pu : xi;
                d = await this.client.core.crypto.encode(s, u, fs(gn({}, a || {}), {
                    encoding: w
                }))
            } catch (w) {
                throw await this.cleanup(),
                this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${s} failed`),
                w
            }
            let p, g;
            try {
                p = await this.client.core.history.get(s, r);
                const w = p.request;
                try {
                    g = this.getTVFParams(r, w.params, i)
                } catch (b) {
                    this.client.logger.warn(`sendResult() -> getTVFParams() failed: ${b?.message}`)
                }
            } catch (w) {
                throw this.client.logger.error(`sendResult() -> history.get(${s}, ${r}) failed`),
                w
            }
            if (h) {
                const w = X1(l, s, d);
                await global.Linking.openURL(w, this.client.name)
            } else {
                const w = p.request.method
                  , b = ds[w].res;
                b.tvf = fs(gn({}, g), {
                    correlationId: r
                }),
                o ? (b.internal = fs(gn({}, b.internal), {
                    throwOnFailedPublish: !0
                }),
                await this.client.core.relayer.publish(s, d, b)) : this.client.core.relayer.publish(s, d, b).catch(v => this.client.logger.error(v))
            }
            await this.client.core.history.resolve(u)
        }
        ),
        Be(this, "sendError", async t => {
            const {id: r, topic: s, error: i, encodeOpts: o, rpcOpts: a, appLink: l} = t
              , u = Ex(r, i);
            let d;
            const h = l && typeof (global == null ? void 0 : global.Linking) < "u";
            try {
                const g = h ? Pu : xi;
                d = await this.client.core.crypto.encode(s, u, fs(gn({}, o || {}), {
                    encoding: g
                }))
            } catch (g) {
                throw await this.cleanup(),
                this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${s} failed`),
                g
            }
            let p;
            try {
                p = await this.client.core.history.get(s, r)
            } catch (g) {
                throw this.client.logger.error(`sendError() -> history.get(${s}, ${r}) failed`),
                g
            }
            if (h) {
                const g = X1(l, s, d);
                await global.Linking.openURL(g, this.client.name)
            } else {
                const g = p.request.method
                  , w = a || ds[g].res;
                this.client.core.relayer.publish(s, d, w)
            }
            await this.client.core.history.resolve(u)
        }
        ),
        Be(this, "cleanup", async () => {
            const t = []
              , r = [];
            this.client.session.getAll().forEach(s => {
                let i = !1;
                Ua(s.expiry) && (i = !0),
                this.client.core.crypto.keychain.has(s.topic) || (i = !0),
                i && t.push(s.topic)
            }
            ),
            this.client.proposal.getAll().forEach(s => {
                Ua(s.expiryTimestamp) && r.push(s.id)
            }
            ),
            await Promise.all([...t.map(s => this.deleteSession({
                topic: s
            })), ...r.map(s => this.deleteProposal(s))])
        }
        ),
        Be(this, "onProviderMessageEvent", async t => {
            !this.initialized || this.relayMessageCache.length > 0 ? this.relayMessageCache.push(t) : await this.onRelayMessage(t)
        }
        ),
        Be(this, "onRelayEventRequest", async t => {
            this.requestQueue.queue.push(t),
            await this.processRequestsQueue()
        }
        ),
        Be(this, "processRequestsQueue", async () => {
            if (this.requestQueue.state === Ia.active) {
                this.client.logger.info("Request queue already active, skipping...");
                return
            }
            for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0; ) {
                this.requestQueue.state = Ia.active;
                const t = this.requestQueue.queue.shift();
                if (t)
                    try {
                        await this.processRequest(t)
                    } catch (r) {
                        this.client.logger.warn(r)
                    }
            }
            this.requestQueue.state = Ia.idle
        }
        ),
        Be(this, "processRequest", async t => {
            const {topic: r, payload: s, attestation: i, transportType: o, encryptedId: a} = t
              , l = s.method;
            if (!this.shouldIgnorePairingRequest({
                topic: r,
                requestMethod: l
            }))
                switch (l) {
                case "wc_sessionPropose":
                    return await this.onSessionProposeRequest({
                        topic: r,
                        payload: s,
                        attestation: i,
                        encryptedId: a
                    });
                case "wc_sessionSettle":
                    return await this.onSessionSettleRequest(r, s);
                case "wc_sessionUpdate":
                    return await this.onSessionUpdateRequest(r, s);
                case "wc_sessionExtend":
                    return await this.onSessionExtendRequest(r, s);
                case "wc_sessionPing":
                    return await this.onSessionPingRequest(r, s);
                case "wc_sessionDelete":
                    return await this.onSessionDeleteRequest(r, s);
                case "wc_sessionRequest":
                    return await this.onSessionRequest({
                        topic: r,
                        payload: s,
                        attestation: i,
                        encryptedId: a,
                        transportType: o
                    });
                case "wc_sessionEvent":
                    return await this.onSessionEventRequest(r, s);
                case "wc_sessionAuthenticate":
                    return await this.onSessionAuthenticateRequest({
                        topic: r,
                        payload: s,
                        attestation: i,
                        encryptedId: a,
                        transportType: o
                    });
                default:
                    return this.client.logger.info(`Unsupported request method ${l}`)
                }
        }
        ),
        Be(this, "onRelayEventResponse", async t => {
            const {topic: r, payload: s, transportType: i} = t
              , o = (await this.client.core.history.get(r, s.id)).request.method;
            switch (o) {
            case "wc_sessionPropose":
                return this.onSessionProposeResponse(r, s, i);
            case "wc_sessionSettle":
                return this.onSessionSettleResponse(r, s);
            case "wc_sessionUpdate":
                return this.onSessionUpdateResponse(r, s);
            case "wc_sessionExtend":
                return this.onSessionExtendResponse(r, s);
            case "wc_sessionPing":
                return this.onSessionPingResponse(r, s);
            case "wc_sessionRequest":
                return this.onSessionRequestResponse(r, s);
            case "wc_sessionAuthenticate":
                return this.onSessionAuthenticateResponse(r, s);
            default:
                return this.client.logger.info(`Unsupported response method ${o}`)
            }
        }
        ),
        Be(this, "onRelayEventUnknownPayload", t => {
            const {topic: r} = t
              , {message: s} = Fe("MISSING_OR_INVALID", `Decoded payload on topic ${r} is not identifiable as a JSON-RPC request or a response.`);
            throw new Error(s)
        }
        ),
        Be(this, "shouldIgnorePairingRequest", t => {
            const {topic: r, requestMethod: s} = t
              , i = this.expectedPairingMethodMap.get(r);
            return !i || i.includes(s) ? !1 : !!(i.includes("wc_sessionAuthenticate") && this.client.events.listenerCount("session_authenticate") > 0)
        }
        ),
        Be(this, "onSessionProposeRequest", async t => {
            const {topic: r, payload: s, attestation: i, encryptedId: o} = t
              , {params: a, id: l} = s;
            try {
                const u = this.client.core.eventClient.getEvent({
                    topic: r
                });
                this.client.events.listenerCount("session_proposal") === 0 && (console.warn("No listener for session_proposal event"),
                u?.setError(Vl.proposal_listener_not_found)),
                this.isValidConnect(gn({}, s.params));
                const d = a.expiryTimestamp || Br(ds.wc_sessionPropose.req.ttl)
                  , h = gn({
                    id: l,
                    pairingTopic: r,
                    expiryTimestamp: d,
                    attestation: i,
                    encryptedId: o
                }, a);
                await this.setProposal(l, h);
                const p = await this.getVerifyContext({
                    attestationId: i,
                    hash: Co(JSON.stringify(s)),
                    encryptedId: o,
                    metadata: h.proposer.metadata
                });
                u?.addTrace(Ba.emit_session_proposal),
                this.client.events.emit("session_proposal", {
                    id: l,
                    params: h,
                    verifyContext: p
                })
            } catch (u) {
                await this.sendError({
                    id: l,
                    topic: r,
                    error: u,
                    rpcOpts: ds.wc_sessionPropose.autoReject
                }),
                this.client.logger.error(u)
            }
        }
        ),
        Be(this, "onSessionProposeResponse", async (t, r, s) => {
            const {id: i} = r;
            if (Pa(r)) {
                const {result: o} = r;
                this.client.logger.trace({
                    type: "method",
                    method: "onSessionProposeResponse",
                    result: o
                });
                const a = this.client.proposal.get(i);
                this.client.logger.trace({
                    type: "method",
                    method: "onSessionProposeResponse",
                    proposal: a
                });
                const l = a.proposer.publicKey;
                this.client.logger.trace({
                    type: "method",
                    method: "onSessionProposeResponse",
                    selfPublicKey: l
                });
                const u = o.responderPublicKey;
                this.client.logger.trace({
                    type: "method",
                    method: "onSessionProposeResponse",
                    peerPublicKey: u
                });
                const d = await this.client.core.crypto.generateSharedKey(l, u);
                this.pendingSessions.set(i, {
                    sessionTopic: d,
                    pairingTopic: t,
                    proposalId: i,
                    publicKey: l
                });
                const h = await this.client.core.relayer.subscribe(d, {
                    transportType: s
                });
                this.client.logger.trace({
                    type: "method",
                    method: "onSessionProposeResponse",
                    subscriptionId: h
                }),
                await this.client.core.pairing.activate({
                    topic: t
                })
            } else if (_o(r)) {
                await this.deleteProposal(i);
                const o = An("session_connect", i);
                if (this.events.listenerCount(o) === 0)
                    throw new Error(`emitting ${o} without any listeners, 954`);
                this.events.emit(o, {
                    error: r.error
                })
            }
        }
        ),
        Be(this, "onSessionSettleRequest", async (t, r) => {
            const {id: s, params: i} = r;
            try {
                this.isValidSessionSettleRequest(i);
                const {relay: o, controller: a, expiry: l, namespaces: u, sessionProperties: d, scopedProperties: h, sessionConfig: p, proposalRequestsResponses: g} = r.params
                  , w = [...this.pendingSessions.values()].find(S => S.sessionTopic === t);
                if (!w)
                    return this.client.logger.error(`Pending session not found for topic ${t}`);
                const b = this.client.proposal.get(w.proposalId)
                  , v = fs(gn(gn(gn({
                    topic: t,
                    relay: o,
                    expiry: l,
                    namespaces: u,
                    acknowledged: !0,
                    pairingTopic: w.pairingTopic,
                    requiredNamespaces: b.requiredNamespaces,
                    optionalNamespaces: b.optionalNamespaces,
                    controller: a.publicKey,
                    self: {
                        publicKey: w.publicKey,
                        metadata: this.client.metadata
                    },
                    peer: {
                        publicKey: a.publicKey,
                        metadata: a.metadata
                    }
                }, d && {
                    sessionProperties: d
                }), h && {
                    scopedProperties: h
                }), p && {
                    sessionConfig: p
                }), {
                    transportType: Gn.relay,
                    authentication: g?.authentication,
                    walletPayResult: g?.walletPay
                });
                await this.client.session.set(v.topic, v),
                await this.setExpiry(v.topic, v.expiry),
                await this.client.core.pairing.updateMetadata({
                    topic: w.pairingTopic,
                    metadata: v.peer.metadata
                }),
                this.pendingSessions.delete(w.proposalId),
                this.deleteProposal(w.proposalId, !1),
                this.cleanupDuplicatePairings(v),
                await this.sendResult({
                    id: r.id,
                    topic: t,
                    throwOnFailedPublish: !0,
                    result: !0
                }),
                this.client.events.emit("session_connect", {
                    session: v
                }),
                this.events.emit(An("session_connect", w.proposalId), {
                    session: v
                })
            } catch (o) {
                await this.sendError({
                    id: s,
                    topic: t,
                    error: o
                }),
                this.client.logger.error(o)
            }
        }
        ),
        Be(this, "onSessionSettleResponse", async (t, r) => {
            const {id: s} = r;
            Pa(r) ? (await this.client.session.update(t, {
                acknowledged: !0
            }),
            this.events.emit(An("session_approve", s), {})) : _o(r) && (await this.client.session.delete(t, Yn("USER_DISCONNECTED")),
            this.events.emit(An("session_approve", s), {
                error: r.error
            }))
        }
        ),
        Be(this, "onSessionUpdateRequest", async (t, r) => {
            const {params: s, id: i} = r;
            try {
                const o = `${t}_session_update`
                  , a = Ym.get(o);
                if (a && this.isRequestOutOfSync(a, i)) {
                    this.client.logger.warn(`Discarding out of sync request - ${i}`),
                    this.sendError({
                        id: i,
                        topic: t,
                        error: Yn("INVALID_UPDATE_REQUEST")
                    });
                    return
                }
                this.isValidUpdate(gn({
                    topic: t
                }, s));
                try {
                    Ym.set(o, i),
                    await this.client.session.update(t, {
                        namespaces: s.namespaces
                    }),
                    await this.sendResult({
                        id: i,
                        topic: t,
                        result: !0
                    })
                } catch (l) {
                    throw Ym.delete(o),
                    l
                }
                this.client.events.emit("session_update", {
                    id: i,
                    topic: t,
                    params: s
                })
            } catch (o) {
                await this.sendError({
                    id: i,
                    topic: t,
                    error: o
                }),
                this.client.logger.error(o)
            }
        }
        ),
        Be(this, "isRequestOutOfSync", (t, r) => r.toString().slice(0, -3) < t.toString().slice(0, -3)),
        Be(this, "onSessionUpdateResponse", (t, r) => {
            const {id: s} = r
              , i = An("session_update", s);
            if (this.events.listenerCount(i) === 0)
                throw new Error(`emitting ${i} without any listeners`);
            Pa(r) ? this.events.emit(An("session_update", s), {}) : _o(r) && this.events.emit(An("session_update", s), {
                error: r.error
            })
        }
        ),
        Be(this, "onSessionExtendRequest", async (t, r) => {
            const {id: s} = r;
            try {
                this.isValidExtend({
                    topic: t
                }),
                await this.setExpiry(t, Br(ep)),
                await this.sendResult({
                    id: s,
                    topic: t,
                    result: !0
                }),
                this.client.events.emit("session_extend", {
                    id: s,
                    topic: t
                })
            } catch (i) {
                await this.sendError({
                    id: s,
                    topic: t,
                    error: i
                }),
                this.client.logger.error(i)
            }
        }
        ),
        Be(this, "onSessionExtendResponse", (t, r) => {
            const {id: s} = r
              , i = An("session_extend", s);
            if (this.events.listenerCount(i) === 0)
                throw new Error(`emitting ${i} without any listeners`);
            Pa(r) ? this.events.emit(An("session_extend", s), {}) : _o(r) && this.events.emit(An("session_extend", s), {
                error: r.error
            })
        }
        ),
        Be(this, "onSessionPingRequest", async (t, r) => {
            const {id: s} = r;
            try {
                this.isValidPing({
                    topic: t
                }),
                await this.sendResult({
                    id: s,
                    topic: t,
                    result: !0,
                    throwOnFailedPublish: !0
                }),
                this.client.events.emit("session_ping", {
                    id: s,
                    topic: t
                })
            } catch (i) {
                await this.sendError({
                    id: s,
                    topic: t,
                    error: i
                }),
                this.client.logger.error(i)
            }
        }
        ),
        Be(this, "onSessionPingResponse", (t, r) => {
            const {id: s} = r
              , i = An("session_ping", s);
            setTimeout( () => {
                if (this.events.listenerCount(i) === 0)
                    throw new Error(`emitting ${i} without any listeners 2176`);
                Pa(r) ? this.events.emit(An("session_ping", s), {}) : _o(r) && this.events.emit(An("session_ping", s), {
                    error: r.error
                })
            }
            , 500)
        }
        ),
        Be(this, "onSessionDeleteRequest", async (t, r) => {
            const {id: s} = r;
            try {
                await this.isValidDisconnect({
                    topic: t,
                    reason: r.params
                }),
                this.cleanupPendingSentRequestsForTopic({
                    topic: t,
                    error: Yn("USER_DISCONNECTED")
                }),
                await this.deleteSession({
                    topic: t,
                    id: s
                })
            } catch (i) {
                this.client.logger.error(i)
            }
        }
        ),
        Be(this, "onSessionRequest", async t => {
            var r, s, i;
            const {topic: o, payload: a, attestation: l, encryptedId: u, transportType: d} = t
              , {id: h, params: p} = a;
            try {
                await this.isValidRequest(gn({
                    topic: o
                }, p));
                const g = this.client.session.get(o)
                  , w = await this.getVerifyContext({
                    attestationId: l,
                    hash: Co(JSON.stringify(ta("wc_sessionRequest", p, h))),
                    encryptedId: u,
                    metadata: g.peer.metadata,
                    transportType: d
                })
                  , b = {
                    id: h,
                    topic: o,
                    params: p,
                    verifyContext: w
                };
                await this.setPendingSessionRequest(b),
                d === Gn.link_mode && (r = g.peer.metadata.redirect) != null && r.universal && this.client.core.addLinkModeSupportedApp((s = g.peer.metadata.redirect) == null ? void 0 : s.universal),
                (i = this.client.signConfig) != null && i.disableRequestQueue ? this.emitSessionRequest(b) : (this.addSessionRequestToSessionRequestQueue(b),
                this.processSessionRequestQueue())
            } catch (g) {
                await this.sendError({
                    id: h,
                    topic: o,
                    error: g
                }),
                this.client.logger.error(g)
            }
        }
        ),
        Be(this, "onSessionRequestResponse", (t, r) => {
            const {id: s} = r
              , i = An("session_request", s);
            if (this.events.listenerCount(i) === 0)
                throw new Error(`emitting ${i} without any listeners`);
            Pa(r) ? this.events.emit(An("session_request", s), {
                result: r.result
            }) : _o(r) && this.events.emit(An("session_request", s), {
                error: r.error
            })
        }
        ),
        Be(this, "onSessionEventRequest", async (t, r) => {
            const {id: s, params: i} = r;
            try {
                const o = `${t}_session_event_${i.event.name}`
                  , a = Ym.get(o);
                if (a && this.isRequestOutOfSync(a, s)) {
                    this.client.logger.info(`Discarding out of sync request - ${s}`);
                    return
                }
                this.isValidEmit(gn({
                    topic: t
                }, i)),
                this.client.events.emit("session_event", {
                    id: s,
                    topic: t,
                    params: i
                }),
                Ym.set(o, s)
            } catch (o) {
                await this.sendError({
                    id: s,
                    topic: t,
                    error: o
                }),
                this.client.logger.error(o)
            }
        }
        ),
        Be(this, "onSessionAuthenticateResponse", (t, r) => {
            const {id: s} = r;
            this.client.logger.trace({
                type: "method",
                method: "onSessionAuthenticateResponse",
                topic: t,
                payload: r
            }),
            Pa(r) ? this.events.emit(An("session_request", s), {
                result: r.result
            }) : _o(r) && this.events.emit(An("session_request", s), {
                error: r.error
            })
        }
        ),
        Be(this, "onSessionAuthenticateRequest", async t => {
            var r;
            const {topic: s, payload: i, attestation: o, encryptedId: a, transportType: l} = t;
            try {
                const {requester: u, authPayload: d, expiryTimestamp: h} = i.params
                  , p = await this.getVerifyContext({
                    attestationId: o,
                    hash: Co(JSON.stringify(i)),
                    encryptedId: a,
                    metadata: u.metadata,
                    transportType: l
                })
                  , g = {
                    requester: u,
                    pairingTopic: s,
                    id: i.id,
                    authPayload: d,
                    verifyContext: p,
                    expiryTimestamp: h
                };
                await this.setAuthRequest(i.id, {
                    request: g,
                    pairingTopic: s,
                    transportType: l
                }),
                l === Gn.link_mode && (r = u.metadata.redirect) != null && r.universal && this.client.core.addLinkModeSupportedApp(u.metadata.redirect.universal),
                this.client.events.emit("session_authenticate", {
                    topic: s,
                    params: i.params,
                    id: i.id,
                    verifyContext: p
                })
            } catch (u) {
                this.client.logger.error(u);
                const d = i.params.requester.publicKey
                  , h = await this.client.core.crypto.generateKeyPair()
                  , p = this.getAppLinkIfEnabled(i.params.requester.metadata, l)
                  , g = {
                    type: yc,
                    receiverPublicKey: d,
                    senderPublicKey: h
                };
                await this.sendError({
                    id: i.id,
                    topic: s,
                    error: u,
                    encodeOpts: g,
                    rpcOpts: ds.wc_sessionAuthenticate.autoReject,
                    appLink: p
                })
            }
        }
        ),
        Be(this, "addSessionRequestToSessionRequestQueue", t => {
            this.sessionRequestQueue.queue.push(t)
        }
        ),
        Be(this, "cleanupAfterResponse", t => {
            this.deletePendingSessionRequest(t.response.id, {
                message: "fulfilled",
                code: 0
            }),
            setTimeout( () => {
                this.sessionRequestQueue.state = Ia.idle,
                this.processSessionRequestQueue()
            }
            , je.toMiliseconds(this.requestQueueDelay))
        }
        ),
        Be(this, "cleanupPendingSentRequestsForTopic", ({topic: t, error: r}) => {
            const s = this.client.core.history.pending;
            s.length > 0 && s.filter(i => i.topic === t && i.request.method === "wc_sessionRequest").forEach(i => {
                this.events.emit(An("session_request", i.request.id), {
                    error: r
                })
            }
            )
        }
        ),
        Be(this, "processSessionRequestQueue", () => {
            if (this.sessionRequestQueue.state === Ia.active) {
                this.client.logger.info("session request queue is already active.");
                return
            }
            const t = this.sessionRequestQueue.queue[0];
            if (!t) {
                this.client.logger.info("session request queue is empty.");
                return
            }
            try {
                this.emitSessionRequest(t)
            } catch (r) {
                this.client.logger.error(r)
            }
        }
        ),
        Be(this, "emitSessionRequest", t => {
            if (this.emittedSessionRequests.has(t.id)) {
                this.client.logger.warn({
                    id: t.id
                }, `Skipping emitting \`session_request\` event for duplicate request. id: ${t.id}`);
                return
            }
            this.sessionRequestQueue.state = Ia.active,
            this.emittedSessionRequests.add(t.id),
            this.client.events.emit("session_request", t)
        }
        ),
        Be(this, "onPairingCreated", t => {
            if (t.methods && this.expectedPairingMethodMap.set(t.topic, t.methods),
            t.active)
                return;
            const r = this.client.proposal.getAll().find(s => s.pairingTopic === t.topic);
            r && this.onSessionProposeRequest({
                topic: t.topic,
                payload: ta("wc_sessionPropose", fs(gn({}, r), {
                    requiredNamespaces: r.requiredNamespaces,
                    optionalNamespaces: r.optionalNamespaces,
                    relays: r.relays,
                    proposer: r.proposer,
                    sessionProperties: r.sessionProperties,
                    scopedProperties: r.scopedProperties
                }), r.id),
                attestation: r.attestation,
                encryptedId: r.encryptedId
            })
        }
        ),
        Be(this, "isValidConnect", async t => {
            if (!yi(t)) {
                const {message: u} = Fe("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(t)}`);
                throw new Error(u)
            }
            const {pairingTopic: r, requiredNamespaces: s, optionalNamespaces: i, sessionProperties: o, scopedProperties: a, relays: l} = t;
            if (ts(r) || await this.isValidPairingTopic(r),
            !lbe(l)) {
                const {message: u} = Fe("MISSING_OR_INVALID", `connect() relays: ${l}`);
                throw new Error(u)
            }
            if (s && !ts(s) && Za(s) !== 0) {
                const u = "requiredNamespaces are deprecated and are automatically assigned to optionalNamespaces";
                ["fatal", "error", "silent"].includes(this.client.logger.level) ? console.warn(u) : this.client.logger.warn(u),
                this.validateNamespaces(s, "requiredNamespaces")
            }
            if (i && !ts(i) && Za(i) !== 0 && this.validateNamespaces(i, "optionalNamespaces"),
            o && !ts(o) && this.validateSessionProps(o, "sessionProperties"),
            a && !ts(a)) {
                this.validateSessionProps(a, "scopedProperties");
                const u = Object.keys(s || {}).concat(Object.keys(i || {}));
                if (!Object.keys(a).every(d => u.includes(d.split(":")[0])))
                    throw new Error(`Scoped properties must be a subset of required/optional namespaces, received: ${JSON.stringify(a)}, required/optional namespaces: ${JSON.stringify(u)}`)
            }
        }
        ),
        Be(this, "validateNamespaces", (t, r) => {
            const s = abe(t, "connect()", r);
            if (s)
                throw new Error(s.message)
        }
        ),
        Be(this, "isValidApprove", async t => {
            if (!yi(t))
                throw new Error(Fe("MISSING_OR_INVALID", `approve() params: ${t}`).message);
            const {id: r, namespaces: s, relayProtocol: i, sessionProperties: o, scopedProperties: a} = t;
            this.checkRecentlyDeleted(r),
            await this.isValidProposalId(r);
            const l = this.client.proposal.get(r)
              , u = Z5(s, "approve()");
            if (u)
                throw new Error(u.message);
            const d = dO(l.requiredNamespaces, s, "approve()");
            if (d)
                throw new Error(d.message);
            if (!Lr(i, !0)) {
                const {message: h} = Fe("MISSING_OR_INVALID", `approve() relayProtocol: ${i}`);
                throw new Error(h)
            }
            if (o && !ts(o) && this.validateSessionProps(o, "sessionProperties"),
            a && !ts(a)) {
                this.validateSessionProps(a, "scopedProperties");
                const h = new Set(Object.keys(s));
                if (!Object.keys(a).every(p => h.has(p.split(":")[0])))
                    throw new Error(`Scoped properties must be a subset of approved namespaces, received: ${JSON.stringify(a)}, approved namespaces: ${Array.from(h).join(", ")}`)
            }
        }
        ),
        Be(this, "isValidReject", async t => {
            if (!yi(t)) {
                const {message: i} = Fe("MISSING_OR_INVALID", `reject() params: ${t}`);
                throw new Error(i)
            }
            const {id: r, reason: s} = t;
            if (this.checkRecentlyDeleted(r),
            await this.isValidProposalId(r),
            !ube(s)) {
                const {message: i} = Fe("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(s)}`);
                throw new Error(i)
            }
        }
        ),
        Be(this, "isValidSessionSettleRequest", t => {
            if (!yi(t)) {
                const {message: u} = Fe("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${t}`);
                throw new Error(u)
            }
            const {relay: r, controller: s, namespaces: i, expiry: o} = t;
            if (!XH(r)) {
                const {message: u} = Fe("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
                throw new Error(u)
            }
            const a = tbe(s, "onSessionSettleRequest()");
            if (a)
                throw new Error(a.message);
            const l = Z5(i, "onSessionSettleRequest()");
            if (l)
                throw new Error(l.message);
            if (Ua(o)) {
                const {message: u} = Fe("EXPIRED", "onSessionSettleRequest()");
                throw new Error(u)
            }
        }
        ),
        Be(this, "isValidUpdate", async t => {
            if (!yi(t)) {
                const {message: l} = Fe("MISSING_OR_INVALID", `update() params: ${t}`);
                throw new Error(l)
            }
            const {topic: r, namespaces: s} = t;
            this.checkRecentlyDeleted(r),
            await this.isValidSessionTopic(r);
            const i = this.client.session.get(r)
              , o = Z5(s, "update()");
            if (o)
                throw new Error(o.message);
            const a = dO(i.requiredNamespaces, s, "update()");
            if (a)
                throw new Error(a.message)
        }
        ),
        Be(this, "isValidExtend", async t => {
            if (!yi(t)) {
                const {message: s} = Fe("MISSING_OR_INVALID", `extend() params: ${t}`);
                throw new Error(s)
            }
            const {topic: r} = t;
            this.checkRecentlyDeleted(r),
            await this.isValidSessionTopic(r)
        }
        ),
        Be(this, "isValidRequest", async t => {
            if (!yi(t)) {
                const {message: l} = Fe("MISSING_OR_INVALID", `request() params: ${t}`);
                throw new Error(l)
            }
            const {topic: r, request: s, chainId: i, expiry: o} = t;
            this.checkRecentlyDeleted(r),
            await this.isValidSessionTopic(r);
            const {namespaces: a} = this.client.session.get(r);
            if (!uO(a, i)) {
                const {message: l} = Fe("MISSING_OR_INVALID", `request() chainId: ${i}`);
                throw new Error(l)
            }
            if (!dbe(s)) {
                const {message: l} = Fe("MISSING_OR_INVALID", `request() ${JSON.stringify(s)}`);
                throw new Error(l)
            }
            if (!pbe(a, i, s.method)) {
                const {message: l} = Fe("MISSING_OR_INVALID", `request() method: ${s.method}`);
                throw new Error(l)
            }
            this.validateRequestExpiry(o)
        }
        ),
        Be(this, "isValidRespond", async t => {
            var r;
            if (!yi(t)) {
                const {message: a} = Fe("MISSING_OR_INVALID", `respond() params: ${t}`);
                throw new Error(a)
            }
            const {topic: s, response: i} = t;
            try {
                await this.isValidSessionTopic(s)
            } catch (a) {
                throw (r = t?.response) != null && r.id && this.cleanupAfterResponse(t),
                a
            }
            if (!fbe(i)) {
                const {message: a} = Fe("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(i)}`);
                throw new Error(a)
            }
            const o = this.client.pendingRequest.get(i.id);
            if (o.topic !== s) {
                const {message: a} = Fe("MISMATCHED_TOPIC", `Request response topic mismatch. reqId: ${i.id}, expected topic: ${o.topic}, received topic: ${s}`);
                throw new Error(a)
            }
        }
        ),
        Be(this, "isValidPing", async t => {
            if (!yi(t)) {
                const {message: s} = Fe("MISSING_OR_INVALID", `ping() params: ${t}`);
                throw new Error(s)
            }
            const {topic: r} = t;
            await this.isValidSessionOrPairingTopic(r)
        }
        ),
        Be(this, "isValidEmit", async t => {
            if (!yi(t)) {
                const {message: a} = Fe("MISSING_OR_INVALID", `emit() params: ${t}`);
                throw new Error(a)
            }
            const {topic: r, event: s, chainId: i} = t;
            await this.isValidSessionTopic(r);
            const {namespaces: o} = this.client.session.get(r);
            if (!uO(o, i)) {
                const {message: a} = Fe("MISSING_OR_INVALID", `emit() chainId: ${i}`);
                throw new Error(a)
            }
            if (!hbe(s)) {
                const {message: a} = Fe("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s)}`);
                throw new Error(a)
            }
            if (!mbe(o, i, s.name)) {
                const {message: a} = Fe("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s)}`);
                throw new Error(a)
            }
        }
        ),
        Be(this, "isValidDisconnect", async t => {
            if (!yi(t)) {
                const {message: s} = Fe("MISSING_OR_INVALID", `disconnect() params: ${t}`);
                throw new Error(s)
            }
            const {topic: r} = t;
            await this.isValidSessionOrPairingTopic(r)
        }
        ),
        Be(this, "isValidAuthenticate", t => {
            const {chains: r, uri: s, domain: i, nonce: o} = t;
            if (!Array.isArray(r) || r.length === 0)
                throw new Error("chains is required and must be a non-empty array");
            if (!Lr(s, !1))
                throw new Error("uri is required parameter");
            if (!Lr(i, !1))
                throw new Error("domain is required parameter");
            if (!Lr(o, !1))
                throw new Error("nonce is required parameter");
            if ([...new Set(r.map(l => gc(l).namespace))].length > 1)
                throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");
            const {namespace: a} = gc(r[0]);
            if (a !== "eip155")
                throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.")
        }
        ),
        Be(this, "getVerifyContext", async t => {
            const {attestationId: r, hash: s, encryptedId: i, metadata: o, transportType: a} = t
              , l = {
                verified: {
                    verifyUrl: o.verifyUrl || Mg,
                    validation: "UNKNOWN",
                    origin: o.url || ""
                }
            };
            try {
                if (a === Gn.link_mode) {
                    const d = this.getAppLinkIfEnabled(o, a);
                    return l.verified.validation = d && new URL(d).origin === new URL(o.url).origin ? "VALID" : "INVALID",
                    l
                }
                const u = await this.client.core.verify.resolve({
                    attestationId: r,
                    hash: s,
                    encryptedId: i,
                    verifyUrl: o.verifyUrl
                });
                u && (l.verified.origin = u.origin,
                l.verified.isScam = u.isScam,
                l.verified.validation = u.origin === new URL(o.url).origin ? "VALID" : "INVALID")
            } catch (u) {
                this.client.logger.warn(u)
            }
            return this.client.logger.debug(`Verify context: ${JSON.stringify(l)}`),
            l
        }
        ),
        Be(this, "validateSessionProps", (t, r) => {
            Object.values(t).forEach( (s, i) => {
                if (s == null) {
                    const {message: o} = Fe("MISSING_OR_INVALID", `${r} must contain an existing value for each key. Received: ${s} for key ${Object.keys(t)[i]}`);
                    throw new Error(o)
                }
            }
            )
        }
        ),
        Be(this, "getPendingAuthRequest", t => {
            const r = this.client.auth.requests.get(t);
            return typeof r == "object" ? r : void 0
        }
        ),
        Be(this, "addToRecentlyDeleted", (t, r) => {
            if (this.recentlyDeletedMap.set(t, r),
            this.recentlyDeletedMap.size >= this.recentlyDeletedLimit) {
                let s = 0;
                const i = this.recentlyDeletedLimit / 2;
                for (const o of this.recentlyDeletedMap.keys()) {
                    if (s++ >= i)
                        break;
                    this.recentlyDeletedMap.delete(o)
                }
            }
        }
        ),
        Be(this, "checkRecentlyDeleted", t => {
            const r = this.recentlyDeletedMap.get(t);
            if (r) {
                const {message: s} = Fe("MISSING_OR_INVALID", `Record was recently deleted - ${r}: ${t}`);
                throw new Error(s)
            }
        }
        ),
        Be(this, "isLinkModeEnabled", (t, r) => {
            var s, i, o, a, l, u, d, h, p;
            return !t || r !== Gn.link_mode ? !1 : ((i = (s = this.client.metadata) == null ? void 0 : s.redirect) == null ? void 0 : i.linkMode) === !0 && ((a = (o = this.client.metadata) == null ? void 0 : o.redirect) == null ? void 0 : a.universal) !== void 0 && ((u = (l = this.client.metadata) == null ? void 0 : l.redirect) == null ? void 0 : u.universal) !== "" && ((d = t?.redirect) == null ? void 0 : d.universal) !== void 0 && ((h = t?.redirect) == null ? void 0 : h.universal) !== "" && ((p = t?.redirect) == null ? void 0 : p.linkMode) === !0 && this.client.core.linkModeSupportedApps.includes(t.redirect.universal) && typeof (global == null ? void 0 : global.Linking) < "u"
        }
        ),
        Be(this, "getAppLinkIfEnabled", (t, r) => {
            var s;
            return this.isLinkModeEnabled(t, r) ? (s = t?.redirect) == null ? void 0 : s.universal : void 0
        }
        ),
        Be(this, "handleLinkModeMessage", ({url: t}) => {
            if (!t || !t.includes("wc_ev") || !t.includes("topic"))
                return;
            const r = ER(t, "topic") || ""
              , s = decodeURIComponent(ER(t, "wc_ev") || "")
              , i = this.client.session.keys.includes(r);
            i && this.client.session.update(r, {
                transportType: Gn.link_mode
            }),
            this.client.core.dispatchEnvelope({
                topic: r,
                message: s,
                sessionExists: i
            })
        }
        ),
        Be(this, "registerLinkModeListeners", async () => {
            var t;
            if (O_() || ld() && (t = this.client.metadata.redirect) != null && t.linkMode) {
                const r = global == null ? void 0 : global.Linking;
                if (typeof r < "u") {
                    r.addEventListener("url", this.handleLinkModeMessage, this.client.name);
                    const s = await r.getInitialURL();
                    s && setTimeout( () => {
                        this.handleLinkModeMessage({
                            url: s
                        })
                    }
                    , 50)
                }
            }
        }
        ),
        Be(this, "getTVFApproveParams", t => {
            try {
                const r = YH(t.namespaces)
                  , s = $ye(t.namespaces)
                  , i = Hye(t.namespaces)
                  , o = t.sessionProperties
                  , a = t.scopedProperties;
                return {
                    approvedChains: r,
                    approvedMethods: s,
                    approvedEvents: i,
                    sessionProperties: o,
                    scopedProperties: a
                }
            } catch (r) {
                return this.client.logger.warn(r, "Error getting TVF approve params"),
                {}
            }
        }
        ),
        Be(this, "getTVFParams", (t, r, s) => {
            var i, o, a;
            if (!((i = r.request) != null && i.method))
                return {};
            const l = {
                correlationId: t,
                rpcMethods: [r.request.method],
                chainId: r.chainId
            };
            try {
                const u = this.extractTxHashesFromResult(r.request, s);
                l.txHashes = u,
                l.contractAddresses = this.isValidContractData(r.request.params) ? [(a = (o = r.request.params) == null ? void 0 : o[0]) == null ? void 0 : a.to] : []
            } catch (u) {
                this.client.logger.warn(u, "Error getting TVF params")
            }
            return l
        }
        ),
        Be(this, "isValidContractData", t => {
            var r;
            if (!t)
                return !1;
            try {
                const s = t?.data || ((r = t?.[0]) == null ? void 0 : r.data);
                if (!s.startsWith("0x"))
                    return !1;
                const i = s.slice(2);
                return /^[0-9a-fA-F]*$/.test(i) ? i.length % 2 === 0 : !1
            } catch {}
            return !1
        }
        ),
        Be(this, "extractTxHashesFromResult", (t, r) => {
            var s;
            try {
                if (!r)
                    return [];
                const i = t.method
                  , o = Gxe[i];
                if (i === "sui_signTransaction")
                    return [Ime(r.transactionBytes)];
                if (i === "near_signTransaction")
                    return [TR(r)];
                if (i === "near_signTransactions")
                    return r.map(l => TR(l));
                if (i === "xrpl_signTransactionFor" || i === "xrpl_signTransaction")
                    return [(s = r.tx_json) == null ? void 0 : s.hash];
                if (i === "polkadot_signTransaction")
                    return [Bbe({
                        transaction: t.params.transactionPayload,
                        signature: r.signature
                    })];
                if (i === "algo_signTxn")
                    return Oo(r) ? r.map(l => IR(l)) : [IR(r)];
                if (i === "cosmos_signDirect")
                    return [Bme(r)];
                if (i === "wallet_sendCalls")
                    return Rme(r);
                if (typeof r == "string")
                    return [r];
                const a = r[o.key];
                if (Oo(a))
                    return i === "solana_signAllTransactions" ? a.map(l => Tme(l)) : a;
                if (typeof a == "string")
                    return [a]
            } catch (i) {
                this.client.logger.warn(i, "Error extracting tx hashes from result")
            }
            return []
        }
        )
    }
    async processPendingMessageEvents() {
        try {
            const e = this.client.session.keys
              , t = this.client.core.relayer.messages.getWithoutAck(e);
            for (const [r,s] of Object.entries(t))
                for (const i of s)
                    try {
                        await this.onProviderMessageEvent({
                            topic: r,
                            message: i,
                            publishedAt: Date.now()
                        })
                    } catch {
                        this.client.logger.warn(`Error processing pending message event for topic: ${r}, message: ${i}`)
                    }
        } catch (e) {
            this.client.logger.warn(e, "processPendingMessageEvents failed")
        }
    }
    isInitialized() {
        if (!this.initialized) {
            const {message: e} = Fe("NOT_INITIALIZED", this.name);
            throw new Error(e)
        }
    }
    async confirmOnlineStateOrThrow() {
        await this.client.core.relayer.confirmOnlineStateOrThrow()
    }
    registerRelayerEvents() {
        this.client.core.relayer.on(Or.message, e => {
            this.onProviderMessageEvent(e)
        }
        )
    }
    async onRelayMessage(e) {
        const {topic: t, message: r, attestation: s, transportType: i} = e
          , {publicKey: o} = this.client.auth.authKeys.keys.includes(Kw) ? this.client.auth.authKeys.get(Kw) : {
            publicKey: void 0
        };
        try {
            const a = await this.client.core.crypto.decode(t, r, {
                receiverPublicKey: o,
                encoding: i === Gn.link_mode ? Pu : xi
            });
            Y_(a) ? (this.client.core.history.set(t, a),
            await this.onRelayEventRequest({
                topic: t,
                payload: a,
                attestation: s,
                transportType: i,
                encryptedId: Co(r)
            })) : Sx(a) ? (await this.client.core.history.resolve(a),
            await this.onRelayEventResponse({
                topic: t,
                payload: a,
                transportType: i
            }),
            this.client.core.history.delete(t, a.id)) : (this.client.logger.error(`onRelayMessage() -> unknown payload: ${JSON.stringify(a)}`),
            await this.onRelayEventUnknownPayload({
                topic: t,
                payload: a,
                transportType: i
            })),
            await this.client.core.relayer.messages.ack(t, r)
        } catch (a) {
            this.client.logger.error(`onRelayMessage() -> failed to process an inbound message: ${r}`),
            this.client.logger.error(a)
        }
    }
    registerExpirerEvents() {
        this.client.core.expirer.on(Eo.expired, async e => {
            const {topic: t, id: r} = K$(e.target);
            if (r && this.client.pendingRequest.keys.includes(r))
                return await this.deletePendingSessionRequest(r, Fe("EXPIRED"), !0);
            if (r && this.client.auth.requests.keys.includes(r))
                return await this.deletePendingAuthRequest(r, Fe("EXPIRED"), !0);
            t ? this.client.session.keys.includes(t) && (await this.deleteSession({
                topic: t,
                expirerHasDeleted: !0
            }),
            this.client.events.emit("session_expire", {
                topic: t
            })) : r && (await this.deleteProposal(r, !0),
            this.client.events.emit("proposal_expire", {
                id: r
            }))
        }
        )
    }
    registerPairingEvents() {
        this.client.core.pairing.events.on(Jd.create, e => this.onPairingCreated(e)),
        this.client.core.pairing.events.on(Jd.delete, e => {
            this.addToRecentlyDeleted(e.topic, "pairing")
        }
        )
    }
    isValidPairingTopic(e) {
        if (!Lr(e, !1)) {
            const {message: t} = Fe("MISSING_OR_INVALID", `pairing topic should be a string: ${e}`);
            throw new Error(t)
        }
        if (!this.client.core.pairing.pairings.keys.includes(e)) {
            const {message: t} = Fe("NO_MATCHING_KEY", `pairing topic doesn't exist: ${e}`);
            throw new Error(t)
        }
        if (Ua(this.client.core.pairing.pairings.get(e).expiry)) {
            const {message: t} = Fe("EXPIRED", `pairing topic: ${e}`);
            throw new Error(t)
        }
    }
    async isValidSessionTopic(e) {
        if (!Lr(e, !1)) {
            const {message: t} = Fe("MISSING_OR_INVALID", `session topic should be a string: ${e}`);
            throw new Error(t)
        }
        if (this.checkRecentlyDeleted(e),
        !this.client.session.keys.includes(e)) {
            const {message: t} = Fe("NO_MATCHING_KEY", `session topic doesn't exist: ${e}`);
            throw new Error(t)
        }
        if (Ua(this.client.session.get(e).expiry)) {
            await this.deleteSession({
                topic: e
            });
            const {message: t} = Fe("EXPIRED", `session topic: ${e}`);
            throw new Error(t)
        }
        if (!this.client.core.crypto.keychain.has(e)) {
            const {message: t} = Fe("MISSING_OR_INVALID", `session topic does not exist in keychain: ${e}`);
            throw await this.deleteSession({
                topic: e
            }),
            new Error(t)
        }
    }
    async isValidSessionOrPairingTopic(e) {
        if (this.checkRecentlyDeleted(e),
        this.client.session.keys.includes(e))
            await this.isValidSessionTopic(e);
        else if (this.client.core.pairing.pairings.keys.includes(e))
            this.isValidPairingTopic(e);
        else if (Lr(e, !1)) {
            const {message: t} = Fe("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${e}`);
            throw new Error(t)
        } else {
            const {message: t} = Fe("MISSING_OR_INVALID", `session or pairing topic should be a string: ${e}`);
            throw new Error(t)
        }
    }
    async isValidProposalId(e) {
        if (!cbe(e)) {
            const {message: t} = Fe("MISSING_OR_INVALID", `proposal id should be a number: ${e}`);
            throw new Error(t)
        }
        if (!this.client.proposal.keys.includes(e)) {
            const {message: t} = Fe("NO_MATCHING_KEY", `proposal id doesn't exist: ${e}`);
            throw new Error(t)
        }
        if (Ua(this.client.proposal.get(e).expiryTimestamp)) {
            await this.deleteProposal(e);
            const {message: t} = Fe("EXPIRED", `proposal id: ${e}`);
            throw new Error(t)
        }
    }
    validateRequestExpiry(e) {
        if (e && !bbe(e, aA)) {
            const {message: t} = Fe("MISSING_OR_INVALID", `request() expiry: ${e}. Expiry must be a number (in seconds) between ${aA.min} and ${aA.max}`);
            throw new Error(t)
        }
    }
}
class o3e extends Jf {
    constructor(e, t) {
        super(e, t, Hxe, X_),
        this.core = e,
        this.logger = t
    }
}
let a3e = class extends Jf {
    constructor(e, t) {
        super(e, t, Vxe, X_),
        this.core = e,
        this.logger = t
    }
}
;
class l3e extends Jf {
    constructor(e, t) {
        super(e, t, Wxe, X_, r => r.id),
        this.core = e,
        this.logger = t
    }
}
class c3e extends Jf {
    constructor(e, t) {
        super(e, t, Qxe, Cx, () => Kw),
        this.core = e,
        this.logger = t
    }
}
class u3e extends Jf {
    constructor(e, t) {
        super(e, t, Zxe, Cx),
        this.core = e,
        this.logger = t
    }
}
class d3e extends Jf {
    constructor(e, t) {
        super(e, t, Jxe, Cx, r => r.id),
        this.core = e,
        this.logger = t
    }
}
var f3e = Object.defineProperty
  , h3e = (n, e, t) => e in n ? f3e(n, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : n[e] = t
  , lA = (n, e, t) => h3e(n, typeof e != "symbol" ? e + "" : e, t);
class p3e {
    constructor(e, t) {
        this.core = e,
        this.logger = t,
        lA(this, "authKeys"),
        lA(this, "pairingTopics"),
        lA(this, "requests"),
        this.authKeys = new c3e(this.core,this.logger),
        this.pairingTopics = new u3e(this.core,this.logger),
        this.requests = new d3e(this.core,this.logger)
    }
    async init() {
        await this.authKeys.init(),
        await this.pairingTopics.init(),
        await this.requests.init()
    }
}
var m3e = Object.defineProperty
  , g3e = (n, e, t) => e in n ? m3e(n, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : n[e] = t
  , nn = (n, e, t) => g3e(n, typeof e != "symbol" ? e + "" : e, t);
class Q_ extends R1e {
    constructor(e) {
        super(e),
        nn(this, "protocol", xV),
        nn(this, "version", EV),
        nn(this, "name", oA.name),
        nn(this, "metadata"),
        nn(this, "core"),
        nn(this, "logger"),
        nn(this, "events", new no.EventEmitter),
        nn(this, "engine"),
        nn(this, "session"),
        nn(this, "proposal"),
        nn(this, "pendingRequest"),
        nn(this, "auth"),
        nn(this, "signConfig"),
        nn(this, "on", (r, s) => this.events.on(r, s)),
        nn(this, "once", (r, s) => this.events.once(r, s)),
        nn(this, "off", (r, s) => this.events.off(r, s)),
        nn(this, "removeListener", (r, s) => this.events.removeListener(r, s)),
        nn(this, "removeAllListeners", r => this.events.removeAllListeners(r)),
        nn(this, "connect", async r => {
            try {
                return await this.engine.connect(r)
            } catch (s) {
                throw this.logger.error(s.message),
                s
            }
        }
        ),
        nn(this, "pair", async r => {
            try {
                return await this.engine.pair(r)
            } catch (s) {
                throw this.logger.error(s.message),
                s
            }
        }
        ),
        nn(this, "approve", async r => {
            try {
                return await this.engine.approve(r)
            } catch (s) {
                throw this.logger.error(s.message),
                s
            }
        }
        ),
        nn(this, "reject", async r => {
            try {
                return await this.engine.reject(r)
            } catch (s) {
                throw this.logger.error(s.message),
                s
            }
        }
        ),
        nn(this, "update", async r => {
            try {
                return await this.engine.update(r)
            } catch (s) {
                throw this.logger.error(s.message),
                s
            }
        }
        ),
        nn(this, "extend", async r => {
            try {
                return await this.engine.extend(r)
            } catch (s) {
                throw this.logger.error(s.message),
                s
            }
        }
        ),
        nn(this, "request", async r => {
            try {
                return await this.engine.request(r)
            } catch (s) {
                throw this.logger.error(s.message),
                s
            }
        }
        ),
        nn(this, "respond", async r => {
            try {
                return await this.engine.respond(r)
            } catch (s) {
                throw this.logger.error(s.message),
                s
            }
        }
        ),
        nn(this, "ping", async r => {
            try {
                return await this.engine.ping(r)
            } catch (s) {
                throw this.logger.error(s.message),
                s
            }
        }
        ),
        nn(this, "emit", async r => {
            try {
                return await this.engine.emit(r)
            } catch (s) {
                throw this.logger.error(s.message),
                s
            }
        }
        ),
        nn(this, "disconnect", async r => {
            try {
                return await this.engine.disconnect(r)
            } catch (s) {
                throw this.logger.error(s.message),
                s
            }
        }
        ),
        nn(this, "find", r => {
            try {
                return this.engine.find(r)
            } catch (s) {
                throw this.logger.error(s.message),
                s
            }
        }
        ),
        nn(this, "getPendingSessionRequests", () => {
            try {
                return this.engine.getPendingSessionRequests()
            } catch (r) {
                throw this.logger.error(r.message),
                r
            }
        }
        ),
        nn(this, "authenticate", async (r, s) => {
            try {
                return await this.engine.authenticate(r, s)
            } catch (i) {
                throw this.logger.error(i.message),
                i
            }
        }
        ),
        nn(this, "formatAuthMessage", r => {
            try {
                return this.engine.formatAuthMessage(r)
            } catch (s) {
                throw this.logger.error(s.message),
                s
            }
        }
        ),
        nn(this, "approveSessionAuthenticate", async r => {
            try {
                return await this.engine.approveSessionAuthenticate(r)
            } catch (s) {
                throw this.logger.error(s.message),
                s
            }
        }
        ),
        nn(this, "rejectSessionAuthenticate", async r => {
            try {
                return await this.engine.rejectSessionAuthenticate(r)
            } catch (s) {
                throw this.logger.error(s.message),
                s
            }
        }
        ),
        this.name = e?.name || oA.name,
        this.metadata = S0e(e?.metadata),
        this.signConfig = e?.signConfig;
        const t = G_({
            logger: e?.logger || oA.logger,
            name: this.name
        });
        this.logger = t,
        this.core = e?.core || new $xe(e),
        this.session = new a3e(this.core,this.logger),
        this.proposal = new o3e(this.core,this.logger),
        this.pendingRequest = new l3e(this.core,this.logger),
        this.engine = new i3e(this),
        this.auth = new p3e(this.core,this.logger)
    }
    static async init(e) {
        const t = new Q_(e);
        return await t.initialize(),
        t
    }
    get context() {
        return Ii(this.logger)
    }
    get pairing() {
        return this.core.pairing.pairings
    }
    async initialize() {
        this.logger.trace("Initialized");
        try {
            await this.core.start(),
            await this.session.init(),
            await this.proposal.init(),
            await this.pendingRequest.init(),
            await this.auth.init(),
            await this.engine.init(),
            this.logger.info("SignClient Initialization Success")
        } catch (e) {
            throw this.logger.info("SignClient Initialization Failure"),
            this.logger.error(e.message),
            e
        }
    }
}
const y3e = Q_;
var J1 = {
    exports: {}
}, n7;
function b3e() {
    return n7 || (n7 = 1,
    (function(n, e) {
        var t = typeof globalThis < "u" && globalThis || typeof self < "u" && self || typeof To < "u" && To
          , r = (function() {
            function i() {
                this.fetch = !1,
                this.DOMException = t.DOMException
            }
            return i.prototype = t,
            new i
        }
        )();
        (function(i) {
            (function(o) {
                var a = typeof i < "u" && i || typeof self < "u" && self || typeof To < "u" && To || {}
                  , l = {
                    searchParams: "URLSearchParams"in a,
                    iterable: "Symbol"in a && "iterator"in Symbol,
                    blob: "FileReader"in a && "Blob"in a && (function() {
                        try {
                            return new Blob,
                            !0
                        } catch {
                            return !1
                        }
                    }
                    )(),
                    formData: "FormData"in a,
                    arrayBuffer: "ArrayBuffer"in a
                };
                function u(E) {
                    return E && DataView.prototype.isPrototypeOf(E)
                }
                if (l.arrayBuffer)
                    var d = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]"]
                      , h = ArrayBuffer.isView || function(E) {
                        return E && d.indexOf(Object.prototype.toString.call(E)) > -1
                    }
                    ;
                function p(E) {
                    if (typeof E != "string" && (E = String(E)),
                    /[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(E) || E === "")
                        throw new TypeError('Invalid character in header field name: "' + E + '"');
                    return E.toLowerCase()
                }
                function g(E) {
                    return typeof E != "string" && (E = String(E)),
                    E
                }
                function w(E) {
                    var C = {
                        next: function() {
                            var O = E.shift();
                            return {
                                done: O === void 0,
                                value: O
                            }
                        }
                    };
                    return l.iterable && (C[Symbol.iterator] = function() {
                        return C
                    }
                    ),
                    C
                }
                function b(E) {
                    this.map = {},
                    E instanceof b ? E.forEach(function(C, O) {
                        this.append(O, C)
                    }, this) : Array.isArray(E) ? E.forEach(function(C) {
                        if (C.length != 2)
                            throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + C.length);
                        this.append(C[0], C[1])
                    }, this) : E && Object.getOwnPropertyNames(E).forEach(function(C) {
                        this.append(C, E[C])
                    }, this)
                }
                b.prototype.append = function(E, C) {
                    E = p(E),
                    C = g(C);
                    var O = this.map[E];
                    this.map[E] = O ? O + ", " + C : C
                }
                ,
                b.prototype.delete = function(E) {
                    delete this.map[p(E)]
                }
                ,
                b.prototype.get = function(E) {
                    return E = p(E),
                    this.has(E) ? this.map[E] : null
                }
                ,
                b.prototype.has = function(E) {
                    return this.map.hasOwnProperty(p(E))
                }
                ,
                b.prototype.set = function(E, C) {
                    this.map[p(E)] = g(C)
                }
                ,
                b.prototype.forEach = function(E, C) {
                    for (var O in this.map)
                        this.map.hasOwnProperty(O) && E.call(C, this.map[O], O, this)
                }
                ,
                b.prototype.keys = function() {
                    var E = [];
                    return this.forEach(function(C, O) {
                        E.push(O)
                    }),
                    w(E)
                }
                ,
                b.prototype.values = function() {
                    var E = [];
                    return this.forEach(function(C) {
                        E.push(C)
                    }),
                    w(E)
                }
                ,
                b.prototype.entries = function() {
                    var E = [];
                    return this.forEach(function(C, O) {
                        E.push([O, C])
                    }),
                    w(E)
                }
                ,
                l.iterable && (b.prototype[Symbol.iterator] = b.prototype.entries);
                function v(E) {
                    if (!E._noBody) {
                        if (E.bodyUsed)
                            return Promise.reject(new TypeError("Already read"));
                        E.bodyUsed = !0
                    }
                }
                function S(E) {
                    return new Promise(function(C, O) {
                        E.onload = function() {
                            C(E.result)
                        }
                        ,
                        E.onerror = function() {
                            O(E.error)
                        }
                    }
                    )
                }
                function N(E) {
                    var C = new FileReader
                      , O = S(C);
                    return C.readAsArrayBuffer(E),
                    O
                }
                function _(E) {
                    var C = new FileReader
                      , O = S(C)
                      , z = /charset=([A-Za-z0-9_-]+)/.exec(E.type)
                      , G = z ? z[1] : "utf-8";
                    return C.readAsText(E, G),
                    O
                }
                function I(E) {
                    for (var C = new Uint8Array(E), O = new Array(C.length), z = 0; z < C.length; z++)
                        O[z] = String.fromCharCode(C[z]);
                    return O.join("")
                }
                function k(E) {
                    if (E.slice)
                        return E.slice(0);
                    var C = new Uint8Array(E.byteLength);
                    return C.set(new Uint8Array(E)),
                    C.buffer
                }
                function B() {
                    return this.bodyUsed = !1,
                    this._initBody = function(E) {
                        this.bodyUsed = this.bodyUsed,
                        this._bodyInit = E,
                        E ? typeof E == "string" ? this._bodyText = E : l.blob && Blob.prototype.isPrototypeOf(E) ? this._bodyBlob = E : l.formData && FormData.prototype.isPrototypeOf(E) ? this._bodyFormData = E : l.searchParams && URLSearchParams.prototype.isPrototypeOf(E) ? this._bodyText = E.toString() : l.arrayBuffer && l.blob && u(E) ? (this._bodyArrayBuffer = k(E.buffer),
                        this._bodyInit = new Blob([this._bodyArrayBuffer])) : l.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(E) || h(E)) ? this._bodyArrayBuffer = k(E) : this._bodyText = E = Object.prototype.toString.call(E) : (this._noBody = !0,
                        this._bodyText = ""),
                        this.headers.get("content-type") || (typeof E == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : l.searchParams && URLSearchParams.prototype.isPrototypeOf(E) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"))
                    }
                    ,
                    l.blob && (this.blob = function() {
                        var E = v(this);
                        if (E)
                            return E;
                        if (this._bodyBlob)
                            return Promise.resolve(this._bodyBlob);
                        if (this._bodyArrayBuffer)
                            return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                        if (this._bodyFormData)
                            throw new Error("could not read FormData body as blob");
                        return Promise.resolve(new Blob([this._bodyText]))
                    }
                    ),
                    this.arrayBuffer = function() {
                        if (this._bodyArrayBuffer) {
                            var E = v(this);
                            return E || (ArrayBuffer.isView(this._bodyArrayBuffer) ? Promise.resolve(this._bodyArrayBuffer.buffer.slice(this._bodyArrayBuffer.byteOffset, this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength)) : Promise.resolve(this._bodyArrayBuffer))
                        } else {
                            if (l.blob)
                                return this.blob().then(N);
                            throw new Error("could not read as ArrayBuffer")
                        }
                    }
                    ,
                    this.text = function() {
                        var E = v(this);
                        if (E)
                            return E;
                        if (this._bodyBlob)
                            return _(this._bodyBlob);
                        if (this._bodyArrayBuffer)
                            return Promise.resolve(I(this._bodyArrayBuffer));
                        if (this._bodyFormData)
                            throw new Error("could not read FormData body as text");
                        return Promise.resolve(this._bodyText)
                    }
                    ,
                    l.formData && (this.formData = function() {
                        return this.text().then(L)
                    }
                    ),
                    this.json = function() {
                        return this.text().then(JSON.parse)
                    }
                    ,
                    this
                }
                var P = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];
                function M(E) {
                    var C = E.toUpperCase();
                    return P.indexOf(C) > -1 ? C : E
                }
                function R(E, C) {
                    if (!(this instanceof R))
                        throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
                    C = C || {};
                    var O = C.body;
                    if (E instanceof R) {
                        if (E.bodyUsed)
                            throw new TypeError("Already read");
                        this.url = E.url,
                        this.credentials = E.credentials,
                        C.headers || (this.headers = new b(E.headers)),
                        this.method = E.method,
                        this.mode = E.mode,
                        this.signal = E.signal,
                        !O && E._bodyInit != null && (O = E._bodyInit,
                        E.bodyUsed = !0)
                    } else
                        this.url = String(E);
                    if (this.credentials = C.credentials || this.credentials || "same-origin",
                    (C.headers || !this.headers) && (this.headers = new b(C.headers)),
                    this.method = M(C.method || this.method || "GET"),
                    this.mode = C.mode || this.mode || null,
                    this.signal = C.signal || this.signal || (function() {
                        if ("AbortController"in a) {
                            var Y = new AbortController;
                            return Y.signal
                        }
                    }
                    )(),
                    this.referrer = null,
                    (this.method === "GET" || this.method === "HEAD") && O)
                        throw new TypeError("Body not allowed for GET or HEAD requests");
                    if (this._initBody(O),
                    (this.method === "GET" || this.method === "HEAD") && (C.cache === "no-store" || C.cache === "no-cache")) {
                        var z = /([?&])_=[^&]*/;
                        if (z.test(this.url))
                            this.url = this.url.replace(z, "$1_=" + new Date().getTime());
                        else {
                            var G = /\?/;
                            this.url += (G.test(this.url) ? "&" : "?") + "_=" + new Date().getTime()
                        }
                    }
                }
                R.prototype.clone = function() {
                    return new R(this,{
                        body: this._bodyInit
                    })
                }
                ;
                function L(E) {
                    var C = new FormData;
                    return E.trim().split("&").forEach(function(O) {
                        if (O) {
                            var z = O.split("=")
                              , G = z.shift().replace(/\+/g, " ")
                              , Y = z.join("=").replace(/\+/g, " ");
                            C.append(decodeURIComponent(G), decodeURIComponent(Y))
                        }
                    }),
                    C
                }
                function q(E) {
                    var C = new b
                      , O = E.replace(/\r?\n[\t ]+/g, " ");
                    return O.split("\r").map(function(z) {
                        return z.indexOf(`
`) === 0 ? z.substr(1, z.length) : z
                    }).forEach(function(z) {
                        var G = z.split(":")
                          , Y = G.shift().trim();
                        if (Y) {
                            var $ = G.join(":").trim();
                            try {
                                C.append(Y, $)
                            } catch (D) {
                                console.warn("Response " + D.message)
                            }
                        }
                    }),
                    C
                }
                B.call(R.prototype);
                function H(E, C) {
                    if (!(this instanceof H))
                        throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
                    if (C || (C = {}),
                    this.type = "default",
                    this.status = C.status === void 0 ? 200 : C.status,
                    this.status < 200 || this.status > 599)
                        throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
                    this.ok = this.status >= 200 && this.status < 300,
                    this.statusText = C.statusText === void 0 ? "" : "" + C.statusText,
                    this.headers = new b(C.headers),
                    this.url = C.url || "",
                    this._initBody(E)
                }
                B.call(H.prototype),
                H.prototype.clone = function() {
                    return new H(this._bodyInit,{
                        status: this.status,
                        statusText: this.statusText,
                        headers: new b(this.headers),
                        url: this.url
                    })
                }
                ,
                H.error = function() {
                    var E = new H(null,{
                        status: 200,
                        statusText: ""
                    });
                    return E.ok = !1,
                    E.status = 0,
                    E.type = "error",
                    E
                }
                ;
                var j = [301, 302, 303, 307, 308];
                H.redirect = function(E, C) {
                    if (j.indexOf(C) === -1)
                        throw new RangeError("Invalid status code");
                    return new H(null,{
                        status: C,
                        headers: {
                            location: E
                        }
                    })
                }
                ,
                o.DOMException = a.DOMException;
                try {
                    new o.DOMException
                } catch {
                    o.DOMException = function(C, O) {
                        this.message = C,
                        this.name = O;
                        var z = Error(C);
                        this.stack = z.stack
                    }
                    ,
                    o.DOMException.prototype = Object.create(Error.prototype),
                    o.DOMException.prototype.constructor = o.DOMException
                }
                function A(E, C) {
                    return new Promise(function(O, z) {
                        var G = new R(E,C);
                        if (G.signal && G.signal.aborted)
                            return z(new o.DOMException("Aborted","AbortError"));
                        var Y = new XMLHttpRequest;
                        function $() {
                            Y.abort()
                        }
                        Y.onload = function() {
                            var W = {
                                statusText: Y.statusText,
                                headers: q(Y.getAllResponseHeaders() || "")
                            };
                            G.url.indexOf("file://") === 0 && (Y.status < 200 || Y.status > 599) ? W.status = 200 : W.status = Y.status,
                            W.url = "responseURL"in Y ? Y.responseURL : W.headers.get("X-Request-URL");
                            var Q = "response"in Y ? Y.response : Y.responseText;
                            setTimeout(function() {
                                O(new H(Q,W))
                            }, 0)
                        }
                        ,
                        Y.onerror = function() {
                            setTimeout(function() {
                                z(new TypeError("Network request failed"))
                            }, 0)
                        }
                        ,
                        Y.ontimeout = function() {
                            setTimeout(function() {
                                z(new TypeError("Network request timed out"))
                            }, 0)
                        }
                        ,
                        Y.onabort = function() {
                            setTimeout(function() {
                                z(new o.DOMException("Aborted","AbortError"))
                            }, 0)
                        }
                        ;
                        function D(W) {
                            try {
                                return W === "" && a.location.href ? a.location.href : W
                            } catch {
                                return W
                            }
                        }
                        if (Y.open(G.method, D(G.url), !0),
                        G.credentials === "include" ? Y.withCredentials = !0 : G.credentials === "omit" && (Y.withCredentials = !1),
                        "responseType"in Y && (l.blob ? Y.responseType = "blob" : l.arrayBuffer && (Y.responseType = "arraybuffer")),
                        C && typeof C.headers == "object" && !(C.headers instanceof b || a.Headers && C.headers instanceof a.Headers)) {
                            var U = [];
                            Object.getOwnPropertyNames(C.headers).forEach(function(W) {
                                U.push(p(W)),
                                Y.setRequestHeader(W, g(C.headers[W]))
                            }),
                            G.headers.forEach(function(W, Q) {
                                U.indexOf(Q) === -1 && Y.setRequestHeader(Q, W)
                            })
                        } else
                            G.headers.forEach(function(W, Q) {
                                Y.setRequestHeader(Q, W)
                            });
                        G.signal && (G.signal.addEventListener("abort", $),
                        Y.onreadystatechange = function() {
                            Y.readyState === 4 && G.signal.removeEventListener("abort", $)
                        }
                        ),
                        Y.send(typeof G._bodyInit > "u" ? null : G._bodyInit)
                    }
                    )
                }
                return A.polyfill = !0,
                a.fetch || (a.fetch = A,
                a.Headers = b,
                a.Request = R,
                a.Response = H),
                o.Headers = b,
                o.Request = R,
                o.Response = H,
                o.fetch = A,
                Object.defineProperty(o, "__esModule", {
                    value: !0
                }),
                o
            }
            )({})
        }
        )(r),
        r.fetch.ponyfill = !0,
        delete r.fetch.polyfill;
        var s = t.fetch ? t : r;
        e = s.fetch,
        e.default = s.fetch,
        e.fetch = s.fetch,
        e.Headers = s.Headers,
        e.Request = s.Request,
        e.Response = s.Response,
        n.exports = e
    }
    )(J1, J1.exports)),
    J1.exports
}
var w3e = b3e();
const r7 = Fo(w3e);
var v3e = Object.defineProperty
  , x3e = Object.defineProperties
  , E3e = Object.getOwnPropertyDescriptors
  , s7 = Object.getOwnPropertySymbols
  , S3e = Object.prototype.hasOwnProperty
  , A3e = Object.prototype.propertyIsEnumerable
  , i7 = (n, e, t) => e in n ? v3e(n, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : n[e] = t
  , o7 = (n, e) => {
    for (var t in e || (e = {}))
        S3e.call(e, t) && i7(n, t, e[t]);
    if (s7)
        for (var t of s7(e))
            A3e.call(e, t) && i7(n, t, e[t]);
    return n
}
  , a7 = (n, e) => x3e(n, E3e(e));
const C3e = {
    Accept: "application/json",
    "Content-Type": "application/json"
}
  , _3e = "POST"
  , l7 = {
    headers: C3e,
    method: _3e
}
  , c7 = 10;
let AV = class {
    constructor(e, t=!1) {
        if (this.url = e,
        this.disableProviderPing = t,
        this.events = new no.EventEmitter,
        this.isAvailable = !1,
        this.registering = !1,
        !CO(e))
            throw new Error(`Provided URL is not compatible with HTTP connection: ${e}`);
        this.url = e,
        this.disableProviderPing = t
    }
    get connected() {
        return this.isAvailable
    }
    get connecting() {
        return this.registering
    }
    on(e, t) {
        this.events.on(e, t)
    }
    once(e, t) {
        this.events.once(e, t)
    }
    off(e, t) {
        this.events.off(e, t)
    }
    removeListener(e, t) {
        this.events.removeListener(e, t)
    }
    async open(e=this.url) {
        await this.register(e)
    }
    async close() {
        if (!this.isAvailable)
            throw new Error("Connection already closed");
        this.onClose()
    }
    async send(e) {
        this.isAvailable || await this.register();
        try {
            const t = Tc(e)
              , r = await (await r7(this.url, a7(o7({}, l7), {
                body: t
            }))).json();
            this.onPayload({
                data: r
            })
        } catch (t) {
            this.onError(e.id, t)
        }
    }
    async register(e=this.url) {
        if (!CO(e))
            throw new Error(`Provided URL is not compatible with HTTP connection: ${e}`);
        if (this.registering) {
            const t = this.events.getMaxListeners();
            return (this.events.listenerCount("register_error") >= t || this.events.listenerCount("open") >= t) && this.events.setMaxListeners(t + 1),
            new Promise( (r, s) => {
                this.events.once("register_error", i => {
                    this.resetMaxListeners(),
                    s(i)
                }
                ),
                this.events.once("open", () => {
                    if (this.resetMaxListeners(),
                    typeof this.isAvailable > "u")
                        return s(new Error("HTTP connection is missing or invalid"));
                    r()
                }
                )
            }
            )
        }
        this.url = e,
        this.registering = !0;
        try {
            if (!this.disableProviderPing) {
                const t = Tc({
                    id: 1,
                    jsonrpc: "2.0",
                    method: "test",
                    params: []
                });
                await r7(e, a7(o7({}, l7), {
                    body: t
                }))
            }
            this.onOpen()
        } catch (t) {
            const r = this.parseError(t);
            throw this.events.emit("register_error", r),
            this.onClose(),
            r
        }
    }
    onOpen() {
        this.isAvailable = !0,
        this.registering = !1,
        this.events.emit("open")
    }
    onClose() {
        this.isAvailable = !1,
        this.registering = !1,
        this.events.emit("close")
    }
    onPayload(e) {
        if (typeof e.data > "u")
            return;
        const t = typeof e.data == "string" ? Of(e.data) : e.data;
        this.events.emit("payload", t)
    }
    onError(e, t) {
        const r = this.parseError(t)
          , s = r.message || r.toString()
          , i = Ex(e, s);
        this.events.emit("payload", i)
    }
    parseError(e, t=this.url) {
        return tV(e, t, "HTTP")
    }
    resetMaxListeners() {
        this.events.getMaxListeners() > c7 && this.events.setMaxListeners(c7)
    }
}
;
function Z_(n) {
    return n == null || typeof n != "object" && typeof n != "function"
}
function CV(n) {
    return Object.getOwnPropertySymbols(n).filter(e => Object.prototype.propertyIsEnumerable.call(n, e))
}
function _V(n) {
    return n == null ? n === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(n)
}
const k3e = "[object RegExp]"
  , kV = "[object String]"
  , NV = "[object Number]"
  , DV = "[object Boolean]"
  , TV = "[object Arguments]"
  , N3e = "[object Symbol]"
  , D3e = "[object Date]"
  , T3e = "[object Map]"
  , I3e = "[object Set]"
  , M3e = "[object Array]"
  , B3e = "[object ArrayBuffer]"
  , R3e = "[object Object]"
  , O3e = "[object DataView]"
  , P3e = "[object Uint8Array]"
  , j3e = "[object Uint8ClampedArray]"
  , L3e = "[object Uint16Array]"
  , F3e = "[object Uint32Array]"
  , U3e = "[object Int8Array]"
  , z3e = "[object Int16Array]"
  , $3e = "[object Int32Array]"
  , H3e = "[object Float32Array]"
  , V3e = "[object Float64Array]";
function J_(n) {
    return ArrayBuffer.isView(n) && !(n instanceof DataView)
}
function q3e(n, e) {
    return xp(n, void 0, n, new Map, e)
}
function xp(n, e, t, r=new Map, s=void 0) {
    const i = s?.(n, e, t, r);
    if (i != null)
        return i;
    if (Z_(n))
        return n;
    if (r.has(n))
        return r.get(n);
    if (Array.isArray(n)) {
        const o = new Array(n.length);
        r.set(n, o);
        for (let a = 0; a < n.length; a++)
            o[a] = xp(n[a], a, t, r, s);
        return Object.hasOwn(n, "index") && (o.index = n.index),
        Object.hasOwn(n, "input") && (o.input = n.input),
        o
    }
    if (n instanceof Date)
        return new Date(n.getTime());
    if (n instanceof RegExp) {
        const o = new RegExp(n.source,n.flags);
        return o.lastIndex = n.lastIndex,
        o
    }
    if (n instanceof Map) {
        const o = new Map;
        r.set(n, o);
        for (const [a,l] of n)
            o.set(a, xp(l, a, t, r, s));
        return o
    }
    if (n instanceof Set) {
        const o = new Set;
        r.set(n, o);
        for (const a of n)
            o.add(xp(a, void 0, t, r, s));
        return o
    }
    if (typeof Buffer < "u" && Buffer.isBuffer(n))
        return n.subarray();
    if (J_(n)) {
        const o = new (Object.getPrototypeOf(n)).constructor(n.length);
        r.set(n, o);
        for (let a = 0; a < n.length; a++)
            o[a] = xp(n[a], a, t, r, s);
        return o
    }
    if (n instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && n instanceof SharedArrayBuffer)
        return n.slice(0);
    if (n instanceof DataView) {
        const o = new DataView(n.buffer.slice(0),n.byteOffset,n.byteLength);
        return r.set(n, o),
        ef(o, n, t, r, s),
        o
    }
    if (typeof File < "u" && n instanceof File) {
        const o = new File([n],n.name,{
            type: n.type
        });
        return r.set(n, o),
        ef(o, n, t, r, s),
        o
    }
    if (n instanceof Blob) {
        const o = new Blob([n],{
            type: n.type
        });
        return r.set(n, o),
        ef(o, n, t, r, s),
        o
    }
    if (n instanceof Error) {
        const o = new n.constructor;
        return r.set(n, o),
        o.message = n.message,
        o.name = n.name,
        o.stack = n.stack,
        o.cause = n.cause,
        ef(o, n, t, r, s),
        o
    }
    if (typeof n == "object" && G3e(n)) {
        const o = Object.create(Object.getPrototypeOf(n));
        return r.set(n, o),
        ef(o, n, t, r, s),
        o
    }
    return n
}
function ef(n, e, t=n, r, s) {
    const i = [...Object.keys(e), ...CV(e)];
    for (let o = 0; o < i.length; o++) {
        const a = i[o]
          , l = Object.getOwnPropertyDescriptor(n, a);
        (l == null || l.writable) && (n[a] = xp(e[a], a, t, r, s))
    }
}
function G3e(n) {
    switch (_V(n)) {
    case TV:
    case M3e:
    case B3e:
    case O3e:
    case DV:
    case D3e:
    case H3e:
    case V3e:
    case U3e:
    case z3e:
    case $3e:
    case T3e:
    case NV:
    case R3e:
    case k3e:
    case I3e:
    case kV:
    case N3e:
    case P3e:
    case j3e:
    case L3e:
    case F3e:
        return !0;
    default:
        return !1
    }
}
function W3e(n, e) {
    return q3e(n, (t, r, s, i) => {
        if (typeof n == "object")
            switch (Object.prototype.toString.call(n)) {
            case NV:
            case kV:
            case DV:
                {
                    const o = new n.constructor(n?.valueOf());
                    return ef(o, n),
                    o
                }
            case TV:
                {
                    const o = {};
                    return ef(o, n),
                    o.length = n.length,
                    o[Symbol.iterator] = n[Symbol.iterator],
                    o
                }
            default:
                return
            }
    }
    )
}
function u7(n) {
    return W3e(n)
}
function d7(n) {
    return n !== null && typeof n == "object" && _V(n) === "[object Arguments]"
}
function f7(n) {
    return typeof n == "object" && n !== null
}
function Y3e() {}
function K3e(n) {
    return J_(n)
}
function X3e(n) {
    if (typeof n != "object" || n == null)
        return !1;
    if (Object.getPrototypeOf(n) === null)
        return !0;
    if (Object.prototype.toString.call(n) !== "[object Object]") {
        const t = n[Symbol.toStringTag];
        return t == null || !Object.getOwnPropertyDescriptor(n, Symbol.toStringTag)?.writable ? !1 : n.toString() === `[object ${t}]`
    }
    let e = n;
    for (; Object.getPrototypeOf(e) !== null; )
        e = Object.getPrototypeOf(e);
    return Object.getPrototypeOf(n) === e
}
function Q3e(n) {
    if (Z_(n))
        return n;
    if (Array.isArray(n) || J_(n) || n instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && n instanceof SharedArrayBuffer)
        return n.slice(0);
    const e = Object.getPrototypeOf(n)
      , t = e.constructor;
    if (n instanceof Date || n instanceof Map || n instanceof Set)
        return new t(n);
    if (n instanceof RegExp) {
        const r = new t(n);
        return r.lastIndex = n.lastIndex,
        r
    }
    if (n instanceof DataView)
        return new t(n.buffer.slice(0));
    if (n instanceof Error) {
        const r = new t(n.message);
        return r.stack = n.stack,
        r.name = n.name,
        r.cause = n.cause,
        r
    }
    if (typeof File < "u" && n instanceof File)
        return new t([n],n.name,{
            type: n.type,
            lastModified: n.lastModified
        });
    if (typeof n == "object") {
        const r = Object.create(e);
        return Object.assign(r, n)
    }
    return n
}
function Z3e(n, ...e) {
    const t = e.slice(0, -1)
      , r = e[e.length - 1];
    let s = n;
    for (let i = 0; i < t.length; i++) {
        const o = t[i];
        s = MC(s, o, r, new Map)
    }
    return s
}
function MC(n, e, t, r) {
    if (Z_(n) && (n = Object(n)),
    e == null || typeof e != "object")
        return n;
    if (r.has(e))
        return Q3e(r.get(e));
    if (r.set(e, n),
    Array.isArray(e)) {
        e = e.slice();
        for (let i = 0; i < e.length; i++)
            e[i] = e[i] ?? void 0
    }
    const s = [...Object.keys(e), ...CV(e)];
    for (let i = 0; i < s.length; i++) {
        const o = s[i];
        let a = e[o]
          , l = n[o];
        if (d7(a) && (a = {
            ...a
        }),
        d7(l) && (l = {
            ...l
        }),
        typeof Buffer < "u" && Buffer.isBuffer(a) && (a = u7(a)),
        Array.isArray(a))
            if (typeof l == "object" && l != null) {
                const d = []
                  , h = Reflect.ownKeys(l);
                for (let p = 0; p < h.length; p++) {
                    const g = h[p];
                    d[g] = l[g]
                }
                l = d
            } else
                l = [];
        const u = t(l, a, o, n, e, r);
        u != null ? n[o] = u : Array.isArray(a) || f7(l) && f7(a) ? n[o] = MC(l, a, t, r) : l == null && X3e(a) ? n[o] = MC({}, a, t, r) : l == null && K3e(a) ? n[o] = u7(a) : (l === void 0 || a !== void 0) && (n[o] = a)
    }
    return n
}
function J3e(n, ...e) {
    return Z3e(n, ...e, Y3e)
}
const h7 = "error"
  , eEe = "wss://relay.walletconnect.org"
  , tEe = "wc"
  , IV = "universal_provider"
  , ew = `${tEe}@2:${IV}:`
  , MV = "https://rpc.walletconnect.org/v1/"
  , BV = "generic"
  , nEe = `${MV}bundler`
  , Rp = "call_status"
  , rEe = 86400
  , ek = {
    DEFAULT_CHAIN_CHANGED: "default_chain_changed"
};
var sEe = Object.defineProperty
  , iEe = Object.defineProperties
  , oEe = Object.getOwnPropertyDescriptors
  , p7 = Object.getOwnPropertySymbols
  , aEe = Object.prototype.hasOwnProperty
  , lEe = Object.prototype.propertyIsEnumerable
  , m7 = (n, e, t) => e in n ? sEe(n, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : n[e] = t
  , tw = (n, e) => {
    for (var t in e || (e = {}))
        aEe.call(e, t) && m7(n, t, e[t]);
    if (p7)
        for (var t of p7(e))
            lEe.call(e, t) && m7(n, t, e[t]);
    return n
}
  , cEe = (n, e) => iEe(n, oEe(e));
function RV(n, e, t) {
    var r;
    const s = gc(n);
    return ((r = e.rpcMap) == null ? void 0 : r[s.reference]) || `${MV}?chainId=${s.namespace}:${s.reference}&projectId=${t}`
}
function uEe(n) {
    return n.includes(":") ? n.split(":")[1] : n
}
function OV(n) {
    return n.map(e => `${e.split(":")[0]}:${e.split(":")[1]}`)
}
function dEe(n, e) {
    const t = Object.keys(e.namespaces).filter(s => s.includes(n));
    if (!t.length)
        return [];
    const r = [];
    return t.forEach(s => {
        const i = e.namespaces[s].accounts;
        r.push(...i)
    }
    ),
    r
}
function g7(n) {
    return Object.fromEntries(Object.entries(n).filter( ([e,t]) => {
        var r, s;
        return ((r = t?.chains) == null ? void 0 : r.length) && ((s = t?.chains) == null ? void 0 : s.length) > 0
    }
    ))
}
function nw(n={}, e={}) {
    const t = g7(y7(n))
      , r = g7(y7(e));
    return J3e(t, r)
}
function y7(n) {
    var e, t, r, s, i;
    const o = {};
    if (!Za(n))
        return o;
    for (const [a,l] of Object.entries(n)) {
        const u = xx(a) ? [a] : l.chains
          , d = l.methods || []
          , h = l.events || []
          , p = l.rpcMap || {}
          , g = vp(a);
        o[g] = cEe(tw(tw({}, o[g]), l), {
            chains: Qa(u, (e = o[g]) == null ? void 0 : e.chains),
            methods: Qa(d, (t = o[g]) == null ? void 0 : t.methods),
            events: Qa(h, (r = o[g]) == null ? void 0 : r.events)
        }),
        (Za(p) || Za(((s = o[g]) == null ? void 0 : s.rpcMap) || {})) && (o[g].rpcMap = tw(tw({}, p), (i = o[g]) == null ? void 0 : i.rpcMap))
    }
    return o
}
function b7(n) {
    return n.includes(":") ? n.split(":")[2] : n
}
function w7(n) {
    const e = {};
    for (const [t,r] of Object.entries(n)) {
        const s = r.methods || []
          , i = r.events || []
          , o = r.accounts || []
          , a = xx(t) ? [t] : r.chains ? r.chains : OV(r.accounts);
        e[t] = {
            chains: a,
            methods: s,
            events: i,
            accounts: o
        }
    }
    return e
}
function cA(n) {
    return typeof n == "number" ? n : n.includes("0x") ? parseInt(n, 16) : (n = n.includes(":") ? n.split(":")[1] : n,
    isNaN(Number(n)) ? n : Number(n))
}
function fEe(n) {
    try {
        const e = JSON.parse(n);
        return typeof e == "object" && e !== null && !Array.isArray(e)
    } catch {
        return !1
    }
}
const PV = {}
  , Op = n => PV[n]
  , uA = (n, e) => {
    PV[n] = e
}
;
var hEe = Object.defineProperty
  , v7 = Object.getOwnPropertySymbols
  , pEe = Object.prototype.hasOwnProperty
  , mEe = Object.prototype.propertyIsEnumerable
  , x7 = (n, e, t) => e in n ? hEe(n, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : n[e] = t
  , E7 = (n, e) => {
    for (var t in e || (e = {}))
        pEe.call(e, t) && x7(n, t, e[t]);
    if (v7)
        for (var t of v7(e))
            mEe.call(e, t) && x7(n, t, e[t]);
    return n
}
;
const S7 = "eip155"
  , gEe = ["atomic", "flow-control", "paymasterService", "sessionKeys", "auxiliaryFunds"]
  , yEe = n => n && n.startsWith("0x") ? BigInt(n).toString(10) : n
  , dA = n => n && n.startsWith("0x") ? n : `0x${BigInt(n).toString(16)}`
  , A7 = n => Object.keys(n).filter(e => gEe.includes(e)).reduce( (e, t) => (e[t] = bEe(n[t]),
e), {})
  , bEe = n => typeof n == "string" && fEe(n) ? JSON.parse(n) : n
  , wEe = (n, e, t) => {
    const {sessionProperties: r={}, scopedProperties: s={}} = n
      , i = {};
    if (!Za(s) && !Za(r))
        return;
    const o = A7(r);
    for (const a of t) {
        const l = yEe(a);
        if (!l)
            continue;
        i[dA(l)] = o;
        const u = s?.[`${S7}:${l}`];
        if (u) {
            const d = u?.[`${S7}:${l}:${e}`];
            i[dA(l)] = E7(E7({}, i[dA(l)]), A7(d || u))
        }
    }
    for (const [a,l] of Object.entries(i))
        Object.keys(l).length === 0 && delete i[a];
    return Object.keys(i).length > 0 ? i : void 0
}
;
var vEe = Object.defineProperty
  , xEe = (n, e, t) => e in n ? vEe(n, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : n[e] = t
  , EEe = (n, e, t) => xEe(n, e + "", t);
let fA, SEe = class jV {
    constructor(e) {
        EEe(this, "storage"),
        this.storage = e
    }
    async getItem(e) {
        return await this.storage.getItem(e)
    }
    async setItem(e, t) {
        return await this.storage.setItem(e, t)
    }
    async removeItem(e) {
        return await this.storage.removeItem(e)
    }
    static getStorage(e) {
        return fA || (fA = new jV(e)),
        fA
    }
}
;
var AEe = Object.defineProperty
  , CEe = Object.defineProperties
  , _Ee = Object.getOwnPropertyDescriptors
  , C7 = Object.getOwnPropertySymbols
  , kEe = Object.prototype.hasOwnProperty
  , NEe = Object.prototype.propertyIsEnumerable
  , _7 = (n, e, t) => e in n ? AEe(n, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : n[e] = t
  , DEe = (n, e) => {
    for (var t in e || (e = {}))
        kEe.call(e, t) && _7(n, t, e[t]);
    if (C7)
        for (var t of C7(e))
            NEe.call(e, t) && _7(n, t, e[t]);
    return n
}
  , TEe = (n, e) => CEe(n, _Ee(e));
async function IEe(n, e) {
    const t = gc(n.result.capabilities.caip345.caip2)
      , r = n.result.capabilities.caip345.transactionHashes
      , s = await Promise.allSettled(r.map(h => MEe(t.reference, h, e)))
      , i = s.filter(h => h.status === "fulfilled").map(h => h.value).filter(h => h);
    s.filter(h => h.status === "rejected").forEach(h => console.warn("Failed to fetch transaction receipt:", h.reason));
    const o = !i.length || i.some(h => !h)
      , a = i.every(h => h?.status === "0x1")
      , l = i.every(h => h?.status === "0x0")
      , u = i.some(h => h?.status === "0x0");
    let d;
    return o ? d = 100 : a ? d = 200 : l ? d = 500 : u && (d = 600),
    {
        id: n.result.id,
        version: n.request.version,
        atomic: n.request.atomicRequired,
        chainId: n.request.chainId,
        capabilities: n.result.capabilities,
        receipts: i,
        status: d
    }
}
async function MEe(n, e, t) {
    return await t(parseInt(n)).request(ta("eth_getTransactionReceipt", [e]))
}
async function BEe({sendCalls: n, storage: e}) {
    const t = await e.getItem(Rp);
    await e.setItem(Rp, TEe(DEe({}, t), {
        [n.result.id]: {
            request: n.request,
            result: n.result,
            expiry: Br(rEe)
        }
    }))
}
async function REe({resultId: n, storage: e}) {
    const t = await e.getItem(Rp);
    if (t) {
        delete t[n],
        await e.setItem(Rp, t);
        for (const r in t)
            Ua(t[r].expiry) && delete t[r];
        await e.setItem(Rp, t)
    }
}
async function OEe({resultId: n, storage: e}) {
    const t = await e.getItem(Rp)
      , r = t?.[n];
    if (r && !Ua(r.expiry))
        return r;
    await REe({
        resultId: n,
        storage: e
    })
}
var PEe = Object.defineProperty
  , jEe = Object.defineProperties
  , LEe = Object.getOwnPropertyDescriptors
  , k7 = Object.getOwnPropertySymbols
  , FEe = Object.prototype.hasOwnProperty
  , UEe = Object.prototype.propertyIsEnumerable
  , BC = (n, e, t) => e in n ? PEe(n, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : n[e] = t
  , hA = (n, e) => {
    for (var t in e || (e = {}))
        FEe.call(e, t) && BC(n, t, e[t]);
    if (k7)
        for (var t of k7(e))
            UEe.call(e, t) && BC(n, t, e[t]);
    return n
}
  , pA = (n, e) => jEe(n, LEe(e))
  , Od = (n, e, t) => BC(n, typeof e != "symbol" ? e + "" : e, t);
let zEe = class {
    constructor(e) {
        Od(this, "name", "eip155"),
        Od(this, "client"),
        Od(this, "chainId"),
        Od(this, "namespace"),
        Od(this, "httpProviders"),
        Od(this, "events"),
        Od(this, "storage"),
        this.namespace = e.namespace,
        this.events = Op("events"),
        this.client = Op("client"),
        this.httpProviders = this.createHttpProviders(),
        this.chainId = parseInt(this.getDefaultChain()),
        this.storage = SEe.getStorage(this.client.core.storage)
    }
    async request(e) {
        switch (e.request.method) {
        case "eth_requestAccounts":
            return this.getAccounts();
        case "eth_accounts":
            return this.getAccounts();
        case "wallet_switchEthereumChain":
            return await this.handleSwitchChain(e);
        case "eth_chainId":
            return parseInt(this.getDefaultChain());
        case "wallet_getCapabilities":
            return await this.getCapabilities(e);
        case "wallet_getCallsStatus":
            return await this.getCallStatus(e);
        case "wallet_sendCalls":
            return await this.sendCalls(e)
        }
        return this.namespace.methods.includes(e.request.method) ? await this.client.request(e) : this.getHttpProvider().request(e.request)
    }
    updateNamespace(e) {
        this.namespace = Object.assign(this.namespace, e)
    }
    setDefaultChain(e, t) {
        this.httpProviders[e] || this.setHttpProvider(parseInt(e), t);
        const r = this.chainId;
        this.chainId = parseInt(e),
        this.events.emit(ek.DEFAULT_CHAIN_CHANGED, {
            currentCaipChainId: `${this.name}:${e}`,
            previousCaipChainId: `${this.name}:${r}`
        })
    }
    requestAccounts() {
        return this.getAccounts()
    }
    getDefaultChain() {
        if (this.chainId)
            return this.chainId.toString();
        if (this.namespace.defaultChain)
            return this.namespace.defaultChain;
        const e = this.namespace.chains[0];
        if (!e)
            throw new Error("ChainId not found");
        return e.split(":")[1]
    }
    createHttpProvider(e, t) {
        const r = t || RV(`${this.name}:${e}`, this.namespace, this.client.core.projectId);
        if (!r)
            throw new Error(`No RPC url provided for chainId: ${e}`);
        return new K_(new AV(r,Op("disableProviderPing")))
    }
    setHttpProvider(e, t) {
        const r = this.createHttpProvider(e, t);
        r && (this.httpProviders[e] = r)
    }
    createHttpProviders() {
        const e = {};
        return this.namespace.chains.forEach(t => {
            var r;
            const s = parseInt(uEe(t));
            e[s] = this.createHttpProvider(s, (r = this.namespace.rpcMap) == null ? void 0 : r[t])
        }
        ),
        e
    }
    getAccounts() {
        const e = this.namespace.accounts;
        return e ? [...new Set(e.filter(t => t.split(":")[1] === this.chainId.toString()).map(t => t.split(":")[2]))] : []
    }
    getHttpProvider(e) {
        const t = e || this.chainId;
        return this.httpProviders[t] || (this.httpProviders = pA(hA({}, this.httpProviders), {
            [t]: this.createHttpProvider(t)
        }),
        this.httpProviders[t])
    }
    async handleSwitchChain(e) {
        var t, r;
        let s = e.request.params ? (t = e.request.params[0]) == null ? void 0 : t.chainId : "0x0";
        s = s.startsWith("0x") ? s : `0x${s}`;
        const i = parseInt(s, 16);
        if (this.isChainApproved(i))
            this.setDefaultChain(`${i}`);
        else if (this.namespace.methods.includes("wallet_switchEthereumChain"))
            await this.client.request({
                topic: e.topic,
                request: {
                    method: e.request.method,
                    params: [{
                        chainId: s
                    }]
                },
                chainId: (r = this.namespace.chains) == null ? void 0 : r[0]
            }),
            this.setDefaultChain(`${i}`);
        else
            throw new Error(`Failed to switch to chain 'eip155:${i}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`);
        return null
    }
    isChainApproved(e) {
        return this.namespace.chains.includes(`${this.name}:${e}`)
    }
    async getCapabilities(e) {
        var t, r, s, i, o;
        const a = (r = (t = e.request) == null ? void 0 : t.params) == null ? void 0 : r[0]
          , l = ((i = (s = e.request) == null ? void 0 : s.params) == null ? void 0 : i[1]) || [];
        if (!a)
            throw new Error("Missing address parameter in `wallet_getCapabilities` request");
        const u = this.client.session.get(e.topic)
          , d = ((o = u?.sessionProperties) == null ? void 0 : o.capabilities) || {}
          , h = `${a}${l.join(",")}`
          , p = d?.[h];
        if (p)
            return p;
        let g;
        try {
            g = wEe(u, a, l)
        } catch (b) {
            console.warn("Failed to extract capabilities from session", b)
        }
        if (g)
            return g;
        const w = await this.client.request(e);
        try {
            await this.client.session.update(e.topic, {
                sessionProperties: pA(hA({}, u.sessionProperties || {}), {
                    capabilities: pA(hA({}, d || {}), {
                        [h]: w
                    })
                })
            })
        } catch (b) {
            console.warn("Failed to update session with capabilities", b)
        }
        return w
    }
    async getCallStatus(e) {
        var t, r, s;
        const i = this.client.session.get(e.topic)
          , o = (t = i.sessionProperties) == null ? void 0 : t.bundler_name;
        if (o) {
            const u = this.getBundlerUrl(e.chainId, o);
            try {
                return await this.getUserOperationReceipt(u, e)
            } catch (d) {
                console.warn("Failed to fetch call status from bundler", d, u)
            }
        }
        const a = (r = i.sessionProperties) == null ? void 0 : r.bundler_url;
        if (a)
            try {
                return await this.getUserOperationReceipt(a, e)
            } catch (u) {
                console.warn("Failed to fetch call status from custom bundler", u, a)
            }
        const l = await OEe({
            resultId: (s = e.request.params) == null ? void 0 : s[0],
            storage: this.storage
        });
        if (l)
            try {
                return await IEe(l, this.getHttpProvider.bind(this))
            } catch (u) {
                console.warn("Failed to fetch call status from stored send calls", u, l)
            }
        if (this.namespace.methods.includes(e.request.method))
            return await this.client.request(e);
        throw new Error("Fetching call status not approved by the wallet.")
    }
    async getUserOperationReceipt(e, t) {
        var r;
        const s = new URL(e)
          , i = await fetch(s, {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify(ta("eth_getUserOperationReceipt", [(r = t.request.params) == null ? void 0 : r[0]]))
        });
        if (!i.ok)
            throw new Error(`Failed to fetch user operation receipt - ${i.status}`);
        return await i.json()
    }
    getBundlerUrl(e, t) {
        return `${nEe}?projectId=${this.client.core.projectId}&chainId=${e}&bundler=${t}`
    }
    async sendCalls(e) {
        var t, r, s;
        const i = await this.client.request(e)
          , o = (t = e.request.params) == null ? void 0 : t[0]
          , a = i?.id
          , l = i?.capabilities || {}
          , u = (r = l?.caip345) == null ? void 0 : r.caip2
          , d = (s = l?.caip345) == null ? void 0 : s.transactionHashes;
        return !a || !u || !(d != null && d.length) || await BEe({
            sendCalls: {
                request: o,
                result: i
            },
            storage: this.storage
        }),
        i
    }
}
;
var $Ee = Object.defineProperty
  , HEe = (n, e, t) => e in n ? $Ee(n, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : n[e] = t
  , tp = (n, e, t) => HEe(n, typeof e != "symbol" ? e + "" : e, t);
class VEe {
    constructor(e) {
        tp(this, "name", BV),
        tp(this, "client"),
        tp(this, "httpProviders"),
        tp(this, "events"),
        tp(this, "namespace"),
        tp(this, "chainId"),
        this.namespace = e.namespace,
        this.events = Op("events"),
        this.client = Op("client"),
        this.chainId = this.getDefaultChain(),
        this.name = this.getNamespaceName(),
        this.httpProviders = this.createHttpProviders()
    }
    updateNamespace(e) {
        this.namespace.chains = [...new Set((this.namespace.chains || []).concat(e.chains || []))],
        this.namespace.accounts = [...new Set((this.namespace.accounts || []).concat(e.accounts || []))],
        this.namespace.methods = [...new Set((this.namespace.methods || []).concat(e.methods || []))],
        this.namespace.events = [...new Set((this.namespace.events || []).concat(e.events || []))],
        this.httpProviders = this.createHttpProviders()
    }
    requestAccounts() {
        return this.getAccounts()
    }
    request(e) {
        return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider(e.chainId).request(e.request)
    }
    setDefaultChain(e, t) {
        this.httpProviders[e] || this.setHttpProvider(e, t);
        const r = this.chainId;
        this.chainId = e,
        this.events.emit(ek.DEFAULT_CHAIN_CHANGED, {
            currentCaipChainId: `${this.name}:${e}`,
            previousCaipChainId: `${this.name}:${r}`
        })
    }
    getDefaultChain() {
        if (this.chainId)
            return this.chainId;
        if (this.namespace.defaultChain)
            return this.namespace.defaultChain;
        const e = this.namespace.chains[0];
        if (!e)
            throw new Error("ChainId not found");
        return e.split(":")[1]
    }
    getNamespaceName() {
        const e = this.namespace.chains[0];
        if (!e)
            throw new Error("ChainId not found");
        return gc(e).namespace
    }
    getAccounts() {
        const e = this.namespace.accounts;
        return e ? [...new Set(e.filter(t => t.split(":")[1] === this.chainId.toString()).map(t => t.split(":")[2]))] : []
    }
    createHttpProviders() {
        var e, t;
        const r = {};
        return (t = (e = this.namespace) == null ? void 0 : e.accounts) == null || t.forEach(s => {
            var i, o;
            const a = gc(s)
              , l = (o = (i = this.namespace) == null ? void 0 : i.rpcMap) == null ? void 0 : o[`${a.namespace}:${a.reference}`];
            r[a.reference] = this.createHttpProvider(s, l)
        }
        ),
        r
    }
    getHttpProvider(e) {
        const t = gc(e).reference
          , r = this.httpProviders[t];
        if (typeof r > "u")
            throw new Error(`JSON-RPC provider for ${e} not found`);
        return r
    }
    setHttpProvider(e, t) {
        const r = this.createHttpProvider(e, t);
        r && (this.httpProviders[e] = r)
    }
    createHttpProvider(e, t) {
        const r = t || RV(e, this.namespace, this.client.core.projectId);
        if (!r)
            throw new Error(`No RPC url provided for chainId: ${e}`);
        return new K_(new AV(r,Op("disableProviderPing")))
    }
}
var qEe = Object.defineProperty
  , GEe = Object.defineProperties
  , WEe = Object.getOwnPropertyDescriptors
  , N7 = Object.getOwnPropertySymbols
  , YEe = Object.prototype.hasOwnProperty
  , KEe = Object.prototype.propertyIsEnumerable
  , RC = (n, e, t) => e in n ? qEe(n, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : n[e] = t
  , Jm = (n, e) => {
    for (var t in e || (e = {}))
        YEe.call(e, t) && RC(n, t, e[t]);
    if (N7)
        for (var t of N7(e))
            KEe.call(e, t) && RC(n, t, e[t]);
    return n
}
  , rw = (n, e) => GEe(n, WEe(e))
  , Ui = (n, e, t) => RC(n, typeof e != "symbol" ? e + "" : e, t);
let XEe = class LV {
    constructor(e) {
        Ui(this, "client"),
        Ui(this, "namespaces"),
        Ui(this, "optionalNamespaces"),
        Ui(this, "sessionProperties"),
        Ui(this, "scopedProperties"),
        Ui(this, "events", new y_),
        Ui(this, "rpcProviders", {}),
        Ui(this, "session"),
        Ui(this, "providerOpts"),
        Ui(this, "logger"),
        Ui(this, "uri"),
        Ui(this, "disableProviderPing", !1),
        Ui(this, "connectParams");
        var t, r;
        this.providerOpts = e,
        this.logger = G_({
            logger: (t = e.logger) != null ? t : h7,
            name: (r = this.providerOpts.name) != null ? r : IV
        }),
        this.disableProviderPing = e?.disableProviderPing || !1
    }
    static async init(e) {
        const t = new LV(e);
        return await t.initialize(),
        t
    }
    async request(e, t, r) {
        const [s,i] = this.validateChain(t);
        if (!this.session)
            throw new Error("Please call connect() before request()");
        return await this.getProvider(s).request({
            request: Jm({}, e),
            chainId: `${s}:${i}`,
            topic: this.session.topic,
            expiry: r
        })
    }
    sendAsync(e, t, r, s) {
        const i = new Date().getTime();
        this.request(e, r, s).then(o => t(null, iy(i, o))).catch(o => t(o, void 0))
    }
    async enable() {
        if (!this.client)
            throw new Error("Sign Client not initialized");
        return this.session || await this.connect({
            namespaces: this.namespaces,
            optionalNamespaces: this.optionalNamespaces,
            sessionProperties: this.sessionProperties,
            scopedProperties: this.scopedProperties
        }),
        await this.requestAccounts()
    }
    async disconnect() {
        var e;
        if (!this.session)
            throw new Error("Please call connect() before enable()");
        await this.client.disconnect({
            topic: (e = this.session) == null ? void 0 : e.topic,
            reason: Yn("USER_DISCONNECTED")
        }),
        await this.cleanup()
    }
    async connect(e) {
        if (!this.client)
            throw new Error("Sign Client not initialized");
        if (this.connectParams = e,
        this.setNamespaces(e),
        this.cleanupPendingPairings(),
        !e.skipPairing)
            return await this.pair(e.pairingTopic)
    }
    async authenticate(e, t) {
        if (!this.client)
            throw new Error("Sign Client not initialized");
        this.setNamespaces(e),
        await this.cleanupPendingPairings();
        const {uri: r, response: s} = await this.client.authenticate(e, t);
        r && (this.uri = r,
        this.events.emit("display_uri", r));
        const i = await s();
        if (this.session = i.session,
        this.session) {
            const o = w7(this.session.namespaces);
            this.namespaces = nw(this.namespaces, o),
            await this.persist("namespaces", this.namespaces),
            this.onConnect()
        }
        return i
    }
    on(e, t) {
        this.events.on(e, t)
    }
    once(e, t) {
        this.events.once(e, t)
    }
    removeListener(e, t) {
        this.events.removeListener(e, t)
    }
    off(e, t) {
        this.events.off(e, t)
    }
    get isWalletConnect() {
        return !0
    }
    async pair(e) {
        var t, r;
        const {uri: s, approval: i} = await this.client.connect({
            pairingTopic: e,
            requiredNamespaces: this.namespaces,
            optionalNamespaces: this.optionalNamespaces,
            sessionProperties: this.sessionProperties,
            scopedProperties: this.scopedProperties,
            authentication: (t = this.connectParams) == null ? void 0 : t.authentication,
            walletPay: (r = this.connectParams) == null ? void 0 : r.walletPay
        });
        s && (this.uri = s,
        this.events.emit("display_uri", s));
        const o = await i();
        this.session = o;
        const a = w7(o.namespaces);
        return this.namespaces = nw(this.namespaces, a),
        await this.persist("namespaces", this.namespaces),
        await this.persist("optionalNamespaces", this.optionalNamespaces),
        this.onConnect(),
        this.session
    }
    setDefaultChain(e, t) {
        try {
            if (!this.session)
                return;
            const [r,s] = this.validateChain(e);
            this.getProvider(r).setDefaultChain(s, t)
        } catch (r) {
            if (!/Please call connect/.test(r.message))
                throw r
        }
    }
    async cleanupPendingPairings(e={}) {
        try {
            this.logger.info("Cleaning up inactive pairings...");
            const t = this.client.pairing.getAll();
            if (!Oo(t))
                return;
            for (const r of t)
                e.deletePairings ? this.client.core.expirer.set(r.topic, 0) : await this.client.core.relayer.subscriber.unsubscribe(r.topic);
            this.logger.info(`Inactive pairings cleared: ${t.length}`)
        } catch (t) {
            this.logger.warn(t, "Failed to cleanup pending pairings")
        }
    }
    abortPairingAttempt() {
        this.logger.warn("abortPairingAttempt is deprecated. This is now a no-op.")
    }
    async checkStorage() {
        this.namespaces = await this.getFromStore("namespaces") || {},
        this.optionalNamespaces = await this.getFromStore("optionalNamespaces") || {},
        this.session && this.createProviders()
    }
    async initialize() {
        this.logger.trace("Initialized"),
        await this.createClient(),
        await this.checkStorage(),
        this.registerEventListeners()
    }
    async createClient() {
        var e, t;
        if (this.client = this.providerOpts.client || await y3e.init({
            core: this.providerOpts.core,
            logger: this.providerOpts.logger || h7,
            relayUrl: this.providerOpts.relayUrl || eEe,
            projectId: this.providerOpts.projectId,
            metadata: this.providerOpts.metadata,
            storageOptions: this.providerOpts.storageOptions,
            storage: this.providerOpts.storage,
            name: this.providerOpts.name,
            customStoragePrefix: this.providerOpts.customStoragePrefix,
            telemetryEnabled: this.providerOpts.telemetryEnabled
        }),
        this.providerOpts.session)
            try {
                this.session = this.client.session.get(this.providerOpts.session.topic)
            } catch (r) {
                throw this.logger.error(r, "Failed to get session"),
                new Error(`The provided session: ${(t = (e = this.providerOpts) == null ? void 0 : e.session) == null ? void 0 : t.topic} doesn't exist in the Sign client`)
            }
        else {
            const r = this.client.session.getAll();
            this.session = r[0]
        }
        this.logger.trace("SignClient Initialized")
    }
    createProviders() {
        if (!this.client)
            throw new Error("Sign Client not initialized");
        if (!this.session)
            throw new Error("Session not initialized. Please call connect() before enable()");
        const e = [...new Set(Object.keys(this.session.namespaces).map(t => vp(t)))];
        uA("client", this.client),
        uA("events", this.events),
        uA("disableProviderPing", this.disableProviderPing),
        e.forEach(t => {
            if (!this.session)
                return;
            const r = dEe(t, this.session);
            if (r?.length === 0)
                return;
            const s = OV(r)
              , i = nw(this.namespaces, this.optionalNamespaces)
              , o = rw(Jm({}, i[t]), {
                accounts: r,
                chains: s
            });
            switch (t) {
            case "eip155":
                this.rpcProviders[t] = new zEe({
                    namespace: o
                });
                break;
            default:
                this.rpcProviders[t] = new VEe({
                    namespace: o
                })
            }
        }
        )
    }
    registerEventListeners() {
        if (typeof this.client > "u")
            throw new Error("Sign Client is not initialized");
        this.client.on("session_ping", e => {
            var t;
            const {topic: r} = e;
            r === ((t = this.session) == null ? void 0 : t.topic) && this.events.emit("session_ping", e)
        }
        ),
        this.client.on("session_event", e => {
            var t;
            const {params: r, topic: s} = e;
            if (s !== ((t = this.session) == null ? void 0 : t.topic))
                return;
            const {event: i} = r;
            if (i.name === "accountsChanged") {
                const o = i.data;
                o && Oo(o) && this.events.emit("accountsChanged", o.map(b7))
            } else if (i.name === "chainChanged") {
                const o = r.chainId
                  , a = r.event.data
                  , l = vp(o)
                  , u = cA(o) !== cA(a) ? `${l}:${cA(a)}` : o;
                this.onChainChanged({
                    currentCaipChainId: u
                })
            } else
                this.events.emit(i.name, i.data);
            this.events.emit("session_event", e)
        }
        ),
        this.client.on("session_update", ({topic: e, params: t}) => {
            var r, s;
            if (e !== ((r = this.session) == null ? void 0 : r.topic))
                return;
            const {namespaces: i} = t
              , o = (s = this.client) == null ? void 0 : s.session.get(e);
            this.session = rw(Jm({}, o), {
                namespaces: i
            }),
            this.onSessionUpdate(),
            this.events.emit("session_update", {
                topic: e,
                params: t
            })
        }
        ),
        this.client.on("session_delete", async e => {
            var t;
            e.topic === ((t = this.session) == null ? void 0 : t.topic) && (await this.cleanup(),
            this.events.emit("session_delete", e),
            this.events.emit("disconnect", rw(Jm({}, Yn("USER_DISCONNECTED")), {
                data: e.topic
            })))
        }
        ),
        this.on(ek.DEFAULT_CHAIN_CHANGED, e => {
            this.onChainChanged(rw(Jm({}, e), {
                internal: !0
            }))
        }
        )
    }
    getProvider(e) {
        return this.rpcProviders[e] || this.rpcProviders[BV]
    }
    onSessionUpdate() {
        Object.keys(this.rpcProviders).forEach(e => {
            var t;
            this.getProvider(e).updateNamespace((t = this.session) == null ? void 0 : t.namespaces[e])
        }
        )
    }
    setNamespaces(e) {
        const {namespaces: t={}, optionalNamespaces: r={}, sessionProperties: s, scopedProperties: i} = e;
        this.optionalNamespaces = nw(t, r),
        this.sessionProperties = s,
        this.scopedProperties = i
    }
    validateChain(e) {
        const [t,r] = e?.split(":") || ["", ""];
        if (!this.namespaces || !Object.keys(this.namespaces).length)
            return [t, r];
        if (t && !Object.keys(this.namespaces || {}).map(o => vp(o)).includes(t))
            throw new Error(`Namespace '${t}' is not configured. Please call connect() first with namespace config.`);
        if (t && r)
            return [t, r];
        const s = vp(Object.keys(this.namespaces)[0])
          , i = this.rpcProviders[s].getDefaultChain();
        return [s, i]
    }
    async requestAccounts() {
        const [e] = this.validateChain();
        return await this.getProvider(e).requestAccounts()
    }
    async onChainChanged({currentCaipChainId: e, previousCaipChainId: t, internal: r=!1}) {
        if (!this.namespaces)
            return;
        const [s,i] = this.validateChain(e);
        i && (this.updateNamespaceChain(s, i),
        r ? (this.events.emit("chainChanged", i),
        this.emitAccountsChangedOnChainChange({
            namespace: s,
            currentCaipChainId: e,
            previousCaipChainId: t
        })) : this.getProvider(s).setDefaultChain(i),
        await this.persist("namespaces", this.namespaces))
    }
    emitAccountsChangedOnChainChange({namespace: e, currentCaipChainId: t, previousCaipChainId: r}) {
        var s, i;
        try {
            if (r === t)
                return;
            const o = (i = (s = this.session) == null ? void 0 : s.namespaces[e]) == null ? void 0 : i.accounts;
            if (!o)
                return;
            const a = o.filter(l => l.includes(`${t}:`)).map(b7);
            if (!Oo(a))
                return;
            this.events.emit("accountsChanged", a)
        } catch (o) {
            this.logger.warn(o, "Failed to emit accountsChanged on chain change")
        }
    }
    updateNamespaceChain(e, t) {
        if (!this.namespaces)
            return;
        const r = this.namespaces[e] ? e : `${e}:${t}`
          , s = {
            chains: [],
            methods: [],
            events: [],
            defaultChain: t
        };
        this.namespaces[r] ? this.namespaces[r] && (this.namespaces[r].defaultChain = t) : this.namespaces[r] = s
    }
    onConnect() {
        this.createProviders(),
        this.events.emit("connect", {
            session: this.session
        })
    }
    async cleanup() {
        this.connectParams = void 0,
        this.namespaces = void 0,
        this.optionalNamespaces = void 0,
        this.sessionProperties = void 0,
        await this.deleteFromStore("namespaces"),
        await this.deleteFromStore("optionalNamespaces"),
        await this.deleteFromStore("sessionProperties"),
        this.session = void 0,
        this.cleanupPendingPairings({
            deletePairings: !0
        }),
        await this.cleanupStorage()
    }
    async persist(e, t) {
        var r;
        const s = ((r = this.session) == null ? void 0 : r.topic) || "";
        await this.client.core.storage.setItem(`${ew}/${e}${s}`, t)
    }
    async getFromStore(e) {
        var t;
        const r = ((t = this.session) == null ? void 0 : t.topic) || "";
        return await this.client.core.storage.getItem(`${ew}/${e}${r}`)
    }
    async deleteFromStore(e) {
        var t;
        const r = ((t = this.session) == null ? void 0 : t.topic) || "";
        await this.client.core.storage.removeItem(`${ew}/${e}${r}`)
    }
    async cleanupStorage() {
        var e;
        try {
            if (((e = this.client) == null ? void 0 : e.session.length) > 0)
                return;
            const t = await this.client.core.storage.getKeys();
            for (const r of t)
                r.startsWith(ew) && await this.client.core.storage.removeItem(r)
        } catch (t) {
            this.logger.warn(t, "Failed to cleanup storage")
        }
    }
}
;
const QEe = XEe
  , ZEe = "wc"
  , JEe = "ethereum_provider"
  , eSe = `${ZEe}@2:${JEe}:`
  , tSe = "https://rpc.walletconnect.org/v1/"
  , OC = ["eth_sendTransaction", "personal_sign"]
  , nSe = ["eth_accounts", "eth_requestAccounts", "eth_sendRawTransaction", "eth_sign", "eth_signTransaction", "eth_signTypedData", "eth_signTypedData_v3", "eth_signTypedData_v4", "eth_sendTransaction", "personal_sign", "wallet_switchEthereumChain", "wallet_addEthereumChain", "wallet_getPermissions", "wallet_requestPermissions", "wallet_registerOnboarding", "wallet_watchAsset", "wallet_scanQRCode", "wallet_sendCalls", "wallet_getCapabilities", "wallet_getCallsStatus", "wallet_showCallsStatus"]
  , PC = ["chainChanged", "accountsChanged"]
  , rSe = ["chainChanged", "accountsChanged", "message", "disconnect", "connect"]
  , sSe = async () => {
    const {createAppKit: n} = await g_( () => import("./core-Cw94KPLQ.js").then(e => e.bt), []);
    return n
}
;
var iSe = Object.defineProperty
  , oSe = Object.defineProperties
  , aSe = Object.getOwnPropertyDescriptors
  , D7 = Object.getOwnPropertySymbols
  , lSe = Object.prototype.hasOwnProperty
  , cSe = Object.prototype.propertyIsEnumerable
  , jC = (n, e, t) => e in n ? iSe(n, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : n[e] = t
  , Hd = (n, e) => {
    for (var t in e || (e = {}))
        lSe.call(e, t) && jC(n, t, e[t]);
    if (D7)
        for (var t of D7(e))
            cSe.call(e, t) && jC(n, t, e[t]);
    return n
}
  , eg = (n, e) => oSe(n, aSe(e))
  , zi = (n, e, t) => jC(n, typeof e != "symbol" ? e + "" : e, t);
function K2(n) {
    return Number(n[0].split(":")[1])
}
function sw(n) {
    return `0x${n.toString(16)}`
}
function uSe(n) {
    const {chains: e, optionalChains: t, methods: r, optionalMethods: s, events: i, optionalEvents: o, rpcMap: a} = n;
    if (!Oo(e))
        throw new Error("Invalid chains");
    const l = {
        chains: e,
        methods: r || OC,
        events: i || PC,
        rpcMap: Hd({}, e.length ? {
            [K2(e)]: a[K2(e)]
        } : {})
    }
      , u = i?.filter(g => !PC.includes(g))
      , d = r?.filter(g => !OC.includes(g));
    if (!t && !o && !s && !(u != null && u.length) && !(d != null && d.length))
        return {
            required: e.length ? l : void 0
        };
    const h = u?.length && d?.length || !t
      , p = {
        chains: [...new Set(h ? l.chains.concat(t || []) : t)],
        methods: [...new Set(l.methods.concat(s != null && s.length ? s : nSe))],
        events: [...new Set(l.events.concat(o != null && o.length ? o : rSe))],
        rpcMap: a
    };
    return {
        required: e.length ? l : void 0,
        optional: t.length ? p : void 0
    }
}
let dSe = class FV {
    constructor() {
        zi(this, "events", new no.EventEmitter),
        zi(this, "namespace", "eip155"),
        zi(this, "accounts", []),
        zi(this, "signer"),
        zi(this, "chainId", 1),
        zi(this, "modal"),
        zi(this, "rpc"),
        zi(this, "STORAGE_KEY", eSe),
        zi(this, "on", (e, t) => (this.events.on(e, t),
        this)),
        zi(this, "once", (e, t) => (this.events.once(e, t),
        this)),
        zi(this, "removeListener", (e, t) => (this.events.removeListener(e, t),
        this)),
        zi(this, "off", (e, t) => (this.events.off(e, t),
        this)),
        zi(this, "parseAccount", e => this.isCompatibleChainId(e) ? this.parseAccountId(e).address : e),
        this.signer = {},
        this.rpc = {}
    }
    static async init(e) {
        const t = new FV;
        return await t.initialize(e),
        t
    }
    async request(e, t) {
        return await this.signer.request(e, this.formatChainId(this.chainId), t)
    }
    sendAsync(e, t, r) {
        this.signer.sendAsync(e, t, this.formatChainId(this.chainId), r)
    }
    get connected() {
        return this.signer.client ? this.signer.client.core.relayer.connected : !1
    }
    get connecting() {
        return this.signer.client ? this.signer.client.core.relayer.connecting : !1
    }
    async enable() {
        return this.session || await this.connect(),
        await this.request({
            method: "eth_requestAccounts"
        })
    }
    async connect(e) {
        var t;
        if (!this.signer.client)
            throw new Error("Provider not initialized. Call init() first");
        this.loadConnectOpts(e);
        const {required: r, optional: s} = uSe(this.rpc);
        try {
            const i = await new Promise(async (a, l) => {
                var u, d;
                this.rpc.showQrModal && ((u = this.modal) == null || u.open(),
                (d = this.modal) == null || d.subscribeState(p => {
                    !p.open && !this.signer.session && (this.signer.abortPairingAttempt(),
                    l(new Error("Connection request reset. Please try again.")))
                }
                ));
                const h = e != null && e.scopedProperties ? {
                    [this.namespace]: e.scopedProperties
                } : void 0;
                await this.signer.connect(eg(Hd({
                    namespaces: Hd({}, r && {
                        [this.namespace]: r
                    })
                }, s && {
                    optionalNamespaces: {
                        [this.namespace]: s
                    }
                }), {
                    pairingTopic: e?.pairingTopic,
                    scopedProperties: h
                })).then(p => {
                    a(p)
                }
                ).catch(p => {
                    var g;
                    (g = this.modal) == null || g.showErrorMessage("Unable to connect"),
                    l(new Error(p.message))
                }
                )
            }
            );
            if (!i)
                return;
            const o = yR(i.namespaces, [this.namespace]);
            this.setChainIds(this.rpc.chains.length ? this.rpc.chains : o),
            this.setAccounts(o),
            this.events.emit("connect", {
                chainId: sw(this.chainId)
            })
        } catch (i) {
            throw this.signer.logger.error(i),
            i
        } finally {
            (t = this.modal) == null || t.close()
        }
    }
    async authenticate(e, t) {
        var r;
        if (!this.signer.client)
            throw new Error("Provider not initialized. Call init() first");
        this.loadConnectOpts({
            chains: e?.chains
        });
        try {
            const s = await new Promise(async (o, a) => {
                var l, u;
                this.rpc.showQrModal && ((l = this.modal) == null || l.open(),
                (u = this.modal) == null || u.subscribeState(d => {
                    !d.open && !this.signer.session && (this.signer.abortPairingAttempt(),
                    a(new Error("Connection request reset. Please try again.")))
                }
                )),
                await this.signer.authenticate(eg(Hd({}, e), {
                    chains: this.rpc.chains
                }), t).then(d => {
                    o(d)
                }
                ).catch(d => {
                    var h;
                    (h = this.modal) == null || h.showErrorMessage("Unable to connect"),
                    a(new Error(d.message))
                }
                )
            }
            )
              , i = s.session;
            if (i) {
                const o = yR(i.namespaces, [this.namespace]);
                this.setChainIds(this.rpc.chains.length ? this.rpc.chains : o),
                this.setAccounts(o),
                this.events.emit("connect", {
                    chainId: sw(this.chainId)
                })
            }
            return s
        } catch (s) {
            throw this.signer.logger.error(s),
            s
        } finally {
            (r = this.modal) == null || r.close()
        }
    }
    async disconnect() {
        this.session && await this.signer.disconnect(),
        this.reset()
    }
    get isWalletConnect() {
        return !0
    }
    get session() {
        return this.signer.session
    }
    registerEventListeners() {
        this.signer.on("session_event", e => {
            const {params: t} = e
              , {event: r} = t;
            r.name === "accountsChanged" ? (this.accounts = this.parseAccounts(r.data),
            this.events.emit("accountsChanged", this.accounts)) : r.name === "chainChanged" ? this.setChainId(this.formatChainId(r.data)) : this.events.emit(r.name, r.data),
            this.events.emit("session_event", e)
        }
        ),
        this.signer.on("accountsChanged", e => {
            this.accounts = this.parseAccounts(e),
            this.events.emit("accountsChanged", this.accounts)
        }
        ),
        this.signer.on("chainChanged", e => {
            const t = parseInt(e);
            this.chainId = t,
            this.events.emit("chainChanged", sw(this.chainId)),
            this.persist()
        }
        ),
        this.signer.on("session_update", e => {
            this.events.emit("session_update", e)
        }
        ),
        this.signer.on("session_delete", e => {
            this.reset(),
            this.events.emit("session_delete", e),
            this.events.emit("disconnect", eg(Hd({}, Yn("USER_DISCONNECTED")), {
                data: e.topic,
                name: "USER_DISCONNECTED"
            }))
        }
        ),
        this.signer.on("display_uri", e => {
            this.events.emit("display_uri", e)
        }
        )
    }
    switchEthereumChain(e) {
        this.request({
            method: "wallet_switchEthereumChain",
            params: [{
                chainId: e.toString(16)
            }]
        })
    }
    isCompatibleChainId(e) {
        return typeof e == "string" ? e.startsWith(`${this.namespace}:`) : !1
    }
    formatChainId(e) {
        return `${this.namespace}:${e}`
    }
    parseChainId(e) {
        return Number(e.split(":")[1])
    }
    setChainIds(e) {
        const t = e.filter(r => this.isCompatibleChainId(r)).map(r => this.parseChainId(r));
        t.length && (this.chainId = t[0],
        this.events.emit("chainChanged", sw(this.chainId)),
        this.persist())
    }
    setChainId(e) {
        if (this.isCompatibleChainId(e)) {
            const t = this.parseChainId(e);
            this.chainId = t,
            this.switchEthereumChain(t)
        }
    }
    parseAccountId(e) {
        const [t,r,s] = e.split(":");
        return {
            chainId: `${t}:${r}`,
            address: s
        }
    }
    setAccounts(e) {
        this.accounts = e.filter(t => this.parseChainId(this.parseAccountId(t).chainId) === this.chainId).map(t => this.parseAccountId(t).address),
        this.events.emit("accountsChanged", this.accounts)
    }
    getRpcConfig(e) {
        var t, r;
        const s = (t = e?.chains) != null ? t : []
          , i = (r = e?.optionalChains) != null ? r : []
          , o = s.concat(i);
        if (!o.length)
            throw new Error("No chains specified in either `chains` or `optionalChains`");
        const a = s.length ? e?.methods || OC : []
          , l = s.length ? e?.events || PC : []
          , u = e?.optionalMethods || []
          , d = e?.optionalEvents || []
          , h = e?.rpcMap || this.buildRpcMap(o, e.projectId)
          , p = e?.qrModalOptions || void 0;
        return {
            chains: s?.map(g => this.formatChainId(g)),
            optionalChains: i.map(g => this.formatChainId(g)),
            methods: a,
            events: l,
            optionalMethods: u,
            optionalEvents: d,
            rpcMap: h,
            showQrModal: !!(e != null && e.showQrModal),
            qrModalOptions: p,
            projectId: e.projectId,
            metadata: e.metadata
        }
    }
    buildRpcMap(e, t) {
        const r = {};
        return e.forEach(s => {
            r[s] = this.getRpcUrl(s, t)
        }
        ),
        r
    }
    async initialize(e) {
        var t;
        if (this.rpc = this.getRpcConfig(e),
        this.chainId = this.rpc.chains.length ? K2(this.rpc.chains) : K2(this.rpc.optionalChains),
        this.signer = await QEe.init({
            projectId: this.rpc.projectId,
            metadata: this.rpc.metadata,
            disableProviderPing: e.disableProviderPing,
            relayUrl: e.relayUrl,
            storage: e.storage,
            storageOptions: e.storageOptions,
            customStoragePrefix: e.customStoragePrefix,
            telemetryEnabled: e.telemetryEnabled,
            logger: e.logger
        }),
        this.registerEventListeners(),
        await this.loadPersistedSession(),
        this.rpc.showQrModal) {
            let r;
            try {
                const s = await sSe()
                  , {convertWCMToAppKitOptions: i} = await Promise.resolve().then(function() {
                    return xSe
                })
                  , o = i(eg(Hd({}, this.rpc.qrModalOptions), {
                    chains: [...new Set([...this.rpc.chains, ...this.rpc.optionalChains])],
                    metadata: this.rpc.metadata,
                    projectId: this.rpc.projectId
                }));
                if (!o.networks.length)
                    throw new Error("No networks found for WalletConnect");
                r = s(eg(Hd({}, o), {
                    universalProvider: this.signer,
                    manualWCControl: !0,
                    enableMobileFullScreen: ((t = this.rpc.qrModalOptions) == null ? void 0 : t.enableMobileFullScreen) === !0
                }))
            } catch (s) {
                throw console.warn(s),
                new Error("To use QR modal, please install @reown/appkit package")
            }
            if (r)
                try {
                    this.modal = r
                } catch (s) {
                    throw this.signer.logger.error(s),
                    new Error("Could not generate WalletConnectModal Instance")
                }
        }
    }
    loadConnectOpts(e) {
        if (!e)
            return;
        const {chains: t, optionalChains: r, rpcMap: s} = e;
        t && Oo(t) && (this.rpc.chains = t.map(i => this.formatChainId(i)),
        t.forEach(i => {
            this.rpc.rpcMap[i] = s?.[i] || this.getRpcUrl(i)
        }
        )),
        r && Oo(r) && (this.rpc.optionalChains = [],
        this.rpc.optionalChains = r?.map(i => this.formatChainId(i)),
        r.forEach(i => {
            this.rpc.rpcMap[i] = s?.[i] || this.getRpcUrl(i)
        }
        ))
    }
    getRpcUrl(e, t) {
        var r;
        return ((r = this.rpc.rpcMap) == null ? void 0 : r[e]) || `${tSe}?chainId=eip155:${e}&projectId=${t || this.rpc.projectId}`
    }
    async loadPersistedSession() {
        if (this.session)
            try {
                const e = await this.signer.client.core.storage.getItem(`${this.STORAGE_KEY}/chainId`)
                  , t = this.session.namespaces[`${this.namespace}:${e}`] ? this.session.namespaces[`${this.namespace}:${e}`] : this.session.namespaces[this.namespace];
                this.setChainIds(e ? [this.formatChainId(e)] : t?.accounts),
                this.setAccounts(t?.accounts)
            } catch (e) {
                this.signer.logger.error("Failed to load persisted session, clearing state..."),
                this.signer.logger.error(e),
                await this.disconnect().catch(t => this.signer.logger.warn(t))
            }
    }
    reset() {
        this.chainId = 1,
        this.accounts = []
    }
    persist() {
        this.session && this.signer.client.core.storage.setItem(`${this.STORAGE_KEY}/chainId`, this.chainId)
    }
    parseAccounts(e) {
        return typeof e == "string" || e instanceof String ? [this.parseAccount(e)] : e.map(t => this.parseAccount(t))
    }
}
;
var fSe = Object.defineProperty
  , hSe = Object.defineProperties
  , pSe = Object.getOwnPropertyDescriptors
  , T7 = Object.getOwnPropertySymbols
  , mSe = Object.prototype.hasOwnProperty
  , gSe = Object.prototype.propertyIsEnumerable
  , I7 = (n, e, t) => e in n ? fSe(n, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : n[e] = t
  , UV = (n, e) => {
    for (var t in e || (e = {}))
        mSe.call(e, t) && I7(n, t, e[t]);
    if (T7)
        for (var t of T7(e))
            gSe.call(e, t) && I7(n, t, e[t]);
    return n
}
  , ySe = (n, e) => hSe(n, pSe(e));
function bSe(n) {
    if (n)
        return {
            "--w3m-font-family": n["--wcm-font-family"],
            "--w3m-accent": n["--wcm-accent-color"],
            "--w3m-color-mix": n["--wcm-background-color"],
            "--w3m-z-index": n["--wcm-z-index"] ? Number(n["--wcm-z-index"]) : void 0,
            "--w3m-qr-color": n["--wcm-accent-color"],
            "--w3m-font-size-master": n["--wcm-text-medium-regular-size"],
            "--w3m-border-radius-master": n["--wcm-container-border-radius"],
            "--w3m-color-mix-strength": 0
        }
}
const wSe = n => {
    const [e,t] = n.split(":");
    return zV({
        id: t,
        caipNetworkId: n,
        chainNamespace: e,
        name: "",
        nativeCurrency: {
            name: "",
            symbol: "",
            decimals: 8
        },
        rpcUrls: {
            default: {
                http: ["https://rpc.walletconnect.org/v1"]
            }
        }
    })
}
;
function vSe(n) {
    var e, t, r, s, i, o, a;
    const l = (e = n.chains) == null ? void 0 : e.map(wSe).filter(Boolean);
    if (l.length === 0)
        throw new Error("At least one chain must be specified");
    const u = l.find(h => {
        var p;
        return h.id === ((p = n.defaultChain) == null ? void 0 : p.id)
    }
    )
      , d = {
        projectId: n.projectId,
        networks: l,
        themeMode: n.themeMode,
        themeVariables: bSe(n.themeVariables),
        chainImages: n.chainImages,
        connectorImages: n.walletImages,
        defaultNetwork: u,
        metadata: ySe(UV({}, n.metadata), {
            name: ((t = n.metadata) == null ? void 0 : t.name) || "WalletConnect",
            description: ((r = n.metadata) == null ? void 0 : r.description) || "Connect to WalletConnect-compatible wallets",
            url: ((s = n.metadata) == null ? void 0 : s.url) || "https://walletconnect.org",
            icons: ((i = n.metadata) == null ? void 0 : i.icons) || ["https://walletconnect.org/walletconnect-logo.png"]
        }),
        showWallets: !0,
        featuredWalletIds: n.explorerRecommendedWalletIds === "NONE" ? [] : Array.isArray(n.explorerRecommendedWalletIds) ? n.explorerRecommendedWalletIds : [],
        excludeWalletIds: n.explorerExcludedWalletIds === "ALL" ? [] : Array.isArray(n.explorerExcludedWalletIds) ? n.explorerExcludedWalletIds : [],
        enableEIP6963: !1,
        enableInjected: !1,
        enableCoinbase: !0,
        enableWalletConnect: !0,
        features: {
            email: !1,
            socials: !1
        }
    };
    if ((o = n.mobileWallets) != null && o.length || (a = n.desktopWallets) != null && a.length) {
        const h = [...(n.mobileWallets || []).map(w => ({
            id: w.id,
            name: w.name,
            links: w.links
        })), ...(n.desktopWallets || []).map(w => ({
            id: w.id,
            name: w.name,
            links: {
                native: w.links.native,
                universal: w.links.universal
            }
        }))]
          , p = [...d.featuredWalletIds || [], ...d.excludeWalletIds || []]
          , g = h.filter(w => !p.includes(w.id));
        g.length && (d.customWallets = g)
    }
    return d
}
function zV(n) {
    return UV({
        formatters: void 0,
        fees: void 0,
        serializers: void 0
    }, n)
}
var xSe = Object.freeze({
    __proto__: null,
    convertWCMToAppKitOptions: vSe,
    defineChain: zV
});
class ESe {
    constructor() {
        this.globalState = {
            walletAddress: null,
            isWalletConnected: !1,
            connectedWalletType: null,
            providers: {}
        },
        this.listeners = [],
        this.detectProviders(),
        this.setupEventListeners(),
        this.attachUtils()
    }
    detectProviders() {
        window.ethereum && (window.ethereum.isMetaMask && (this.globalState.providers.Metamask = window.ethereum),
        window.ethereum.isTrust && (this.globalState.providers.trustwallet = window.ethereum)),
        window.solana?.isPhantom && (this.globalState.providers.Phantom = window.solana),
        window.solflare?.isSolflare && (this.globalState.providers.solflare = window.solflare),
        window.xfi && (this.globalState.providers.ctrlwallet = window.xfi),
        window.L1X && (this.globalState.providers.xwallet = window.L1X),
        (window.tronLink || window.tronWeb) && (this.globalState.providers.tronlink = window.tronLink || window.tronWeb)
    }
    updateWalletState({address: e, type: t}) {
        this.globalState.walletAddress = e || null,
        this.globalState.connectedWalletType = t || null,
        this.globalState.isWalletConnected = !!e,
        this.notifyListeners()
    }
    subscribe(e) {
        this.listeners.push(e)
    }
    unsubscribe(e) {
        this.listeners = this.listeners.filter(t => t !== e)
    }
    notifyListeners() {
        this.listeners.forEach(e => e({
            ...this.globalState
        }))
    }
    isWalletInstalled(e) {
        const t = this.getProvider(e);
        return !!t
    }
    async initWalletConnect() {
        try {
            const e = await dSe.init({
                projectId: "9be7a81a041c53d14ffcbdb2198ec1eb",
                chains: [1],
                optionalChains: [1066, 56, 137, 42161, 10],
                methods: ["eth_sendTransaction", "eth_sign", "personal_sign", "eth_signTypedData", "eth_requestAccounts", "eth_accounts", "wallet_addEthereumChain", "wallet_switchEthereumChain"],
                events: ["accountsChanged", "chainChanged", "disconnect"],
                optionalEvents: ["session_request", "session_update", "session_delete", "display_uri"],
                showQrModal: !0,
                metadata: {
                    name: "L1X App",
                    description: "L1X Decentralized Application",
                    url: window.location.origin,
                    icons: [`${window.location.origin}/l1x-logo.png`]
                },
                qrModalOptions: {
                    themeMode: "dark",
                    themeVariables: {
                        "--wcm-z-index": "9999",
                        "--wcm-accent-color": "#FF6717"
                    }
                },
                connectionTimeout: 3e4,
                retryCount: 3,
                retryDelay: 1e3
            });
            return this.globalState.providers.walletconnect = e,
            e.on("display_uri", t => {
                const r = `https://metamask.app.link/wc?uri=${encodeURIComponent(t)}`;
                window.location.href = r
            }
            ),
            e.on("connect", t => {}
            ),
            e.on("disconnect", () => {
                this.disconnectWallet()
            }
            ),
            e
        } catch (e) {
            console.error("Failed to init WalletConnect:", e)
        }
    }
    async connectWallet(e, t=null) {
        try {
            let r;
            switch (e) {
            case "Metamask":
                r = await this.connectMetamask();
                break;
            case "trustwallet":
                r = await this.connectTrustWallet();
                break;
            case "Phantom":
                r = await this.connectPhantom();
                break;
            case "solflare":
                r = await this.connectSolflare();
                break;
            case "tronlink":
                r = await this.connectTronLink();
                break;
            case "xwallet":
                r = await this.connectXWallet();
                break;
            case "ctrlwallet":
                r = await this.connectCTRLWallet();
                break;
            case "walletconnect":
                r = await this.connectWalletConnect();
                break;
            default:
                throw new Error("Unsupported wallet type")
            }
            const s = r.data
              , i = r.success;
            if (!i)
                return {
                    success: !1,
                    walletAddress: null,
                    signatureHash: null,
                    message: t,
                    type: e,
                    error: r.error
                };
            let o = null;
            return i && t && (o = await this.signMessage(e, t, s)),
            this.updateWalletState({
                address: s,
                type: e
            }),
            {
                success: !0,
                walletAddress: s,
                signatureHash: o,
                message: t || null,
                type: e,
                error: null
            }
        } catch (r) {
            return {
                success: !1,
                walletAddress: null,
                signatureHash: null,
                message: t,
                type: e,
                error: of(r)?.message
            }
        }
    }
    async signMessage(e, t, r=null) {
        const s = this.getProvider(e);
        switch (e) {
        case "Metamask":
        case "trustwallet":
        case "ctrlwallet":
        case "walletconnect":
            return await (await new Ys(s).getSigner(r || void 0)).signMessage(t);
        case "Phantom":
        case "solflare":
            {
                const i = new TextEncoder().encode(t)
                  , o = await s.signMessage(i, "utf8");
                return D0.encode(o.signature)
            }
        case "xwallet":
            return (await s.signMessage({
                message: t
            }))?.data;
        case "tronlink":
            {
                const i = window.tronWeb.toHex(t);
                return await window.tronWeb.trx.sign(i)
            }
        default:
            throw new Error(`Message signing not supported for ${e}`)
        }
    }
    async disconnectWallet() {
        try {
            const e = this.getProvider();
            return e?.disconnect ? await e.disconnect() : e?.close && await e.close(),
            this.globalState.walletAddress = null,
            this.globalState.connectedWalletType = null,
            this.globalState.isWalletConnected = !1,
            this.notifyListeners(),
            {
                success: !0,
                message: "Wallet disconnected successfully"
            }
        } catch (e) {
            return {
                success: !1,
                message: of(e)
            }
        }
    }
    async connectMetamask() {
        try {
            const e = this.globalState.providers.Metamask;
            if (!e)
                throw new Error("MetaMask not installed");
            return {
                success: !0,
                data: (await e.request({
                    method: "eth_requestAccounts"
                }))[0],
                txHash: null,
                error: null
            }
        } catch (e) {
            return {
                success: !1,
                data: null,
                txHash: null,
                error: of(e)?.message
            }
        }
    }
    async connectTrustWallet() {
        const e = this.globalState.providers.trustwallet;
        if (!e)
            throw new Error("Trust Wallet not available");
        const t = await e.request({
            method: "eth_requestAccounts"
        });
        return this.updateWalletState({
            address: t[0],
            type: "trustwallet"
        }),
        {
            success: !0,
            data: t[0],
            txHash: null,
            error: null
        }
    }
    async connectPhantom() {
        const e = this.globalState.providers.Phantom;
        if (!e)
            throw new Error("Phantom not installed");
        const t = await e.connect();
        return this.updateWalletState({
            address: t.publicKey.toString(),
            type: "Phantom"
        }),
        {
            success: !0,
            data: t.publicKey.toString(),
            txHash: null,
            error: null
        }
    }
    async connectSolflare() {
        const e = this.globalState.providers.solflare;
        if (!e)
            throw new Error("Solflare not installed");
        return await e.connect(),
        this.updateWalletState({
            address: e.publicKey.toString(),
            type: "solflare"
        }),
        {
            success: !0,
            data: e.publicKey.toString(),
            txHash: null,
            error: null
        }
    }
    async connectTronLink() {
        const e = this.globalState.providers.tronlink;
        if (!e)
            throw new Error("TronLink not available");
        e.request && await e.request({
            method: "tron_requestAccounts"
        });
        const t = e?.tronWeb?.defaultAddress?.base58 || e.defaultAddress?.base58;
        return this.updateWalletState({
            address: t,
            type: "tronlink"
        }),
        {
            success: !0,
            data: t,
            txHash: null,
            error: null
        }
    }
    async connectXWallet() {
        const e = this.globalState.providers.xwallet;
        if (!e)
            throw new Error("XWallet not available");
        const t = await e.getConnectedAccounts();
        if (!t?.length)
            throw new Error("No accounts connected");
        return this.updateWalletState({
            address: t[0].address,
            type: "xwallet"
        }),
        {
            success: !0,
            data: t[0].address,
            txHash: null,
            error: null
        }
    }
    async connectCTRLWallet() {
        const e = this.globalState.providers.ctrlwallet;
        if (!e)
            throw new Error("CtrlWallet not available");
        const t = await e.ethereum.request({
            method: "eth_requestAccounts"
        });
        return this.updateWalletState({
            address: t[0],
            type: "ctrlwallet"
        }),
        {
            success: !0,
            data: t[0],
            txHash: null,
            error: null
        }
    }
    async connectWalletConnect() {
        let e = this.globalState.providers.walletconnect;
        if (e || (e = await this.initWalletConnect()),
        !e)
            throw new Error("WalletConnect not initialized");
        await e.enable();
        const t = await e.request({
            method: "eth_accounts"
        });
        return this.updateWalletState({
            address: t[0],
            type: "walletconnect"
        }),
        {
            success: !0,
            data: t[0],
            txHash: null,
            error: null
        }
    }
    setupEventListeners() {
        const e = this.globalState.providers.Metamask;
        e && (e.on("accountsChanged", i => {
            i.length ? this.globalState.tempConnectedAddress = i[0] : this.disconnectWallet()
        }
        ),
        e.on("disconnect", () => this.disconnectWallet()));
        const t = this.globalState.providers.Phantom;
        t && t.on("disconnect", () => this.disconnectWallet());
        const r = this.globalState.providers.solflare;
        r && (r.on("disconnect", () => this.disconnectWallet()),
        r.on("accountChanged", i => this.updateWalletState({
            address: i?.toString(),
            type: "solflare"
        })));
        const s = this.globalState.providers.tronlink;
        s?.on && s.on("accountsChanged", i => {
            i?.length ? this.updateWalletState({
                address: i[0],
                type: "tronlink"
            }) : this.disconnectWallet()
        }
        )
    }
    attachUtils() {
        Object.keys(oB).forEach(e => {
            this[e] = async (...t) => {
                try {
                    const r = await oB[e](...t);
                    return r && typeof r == "object" && "success"in r ? r : {
                        success: !0,
                        data: r,
                        txHash: r?.hash || null,
                        error: null
                    }
                } catch (r) {
                    return {
                        success: !1,
                        data: null,
                        txHash: null,
                        error: of(r) || r?.message || "Something went wrong"
                    }
                }
            }
        }
        )
    }
    async switchOrAddNetwork(e, t=null) {
        const r = t || this.getConnectedWalletType();
        let s = this.getProvider(r);
        if (r === "walletconnect" && !s && (s = await this.initWalletConnect(),
        !s))
            return {
                success: !1,
                message: "Failed to initialize WalletConnect"
            };
        if (!s?.request)
            return console.error(" Provider does not have request method:", {
                activeType: r,
                provider: s,
                hasRequest: !!s?.request
            }),
            {
                success: !1,
                message: `Provider does not support network switching. Wallet type: ${r}`
            };
        const i = "0x" + Number(e.chainId).toString(16);
        try {
            await s.request({
                method: "wallet_switchEthereumChain",
                params: [{
                    chainId: i
                }]
            }),
            await new Promise(a => setTimeout(a, 500));
            let o = await s.request({
                method: "eth_chainId"
            });
            return typeof o == "number" && (o = "0x" + o.toString(16)),
            o.toLowerCase() !== i.toLowerCase() ? (console.error(" Network switch failed - chain mismatch"),
            {
                success: !1,
                message: `Network switch not confirmed. Please switch to ${e.chainName} manually in your wallet.`
            }) : {
                success: !0,
                message: `Switched to ${e.chainName}`
            }
        } catch (o) {
            if (o.code === 4902)
                try {
                    const a = {
                        ...e,
                        chainId: i
                    };
                    await s.request({
                        method: "wallet_addEthereumChain",
                        params: [a]
                    }),
                    await new Promise(u => setTimeout(u, 500));
                    let l = await s.request({
                        method: "eth_chainId"
                    });
                    return typeof l == "number" && (l = "0x" + l.toString(16)),
                    l.toLowerCase() !== i.toLowerCase() ? (console.error(" Network add succeeded but switch failed"),
                    {
                        success: !1,
                        message: `${e.chainName} was added but not switched. Please switch manually.`
                    }) : {
                        success: !0,
                        message: `${e.chainName} added and switched`
                    }
                } catch (a) {
                    return console.error(" Failed to add network:", a),
                    {
                        success: !1,
                        message: `Failed to add network: ${a.message}`
                    }
                }
            return console.error(" Failed to switch network:", o),
            {
                success: !1,
                message: `Failed to switch network: ${o.message}`
            }
        }
    }
    async getChainId() {
        const e = this.getProvider();
        if (!e)
            return null;
        if (e.request)
            try {
                const t = await e.request({
                    method: "eth_chainId"
                });
                return Number(t)
            } catch (t) {
                return console.error("Error fetching chainId:", t),
                null
            }
        return null
    }
    getActiveAddress() {
        return this.globalState.walletAddress
    }
    getActiveWalletInfo() {
        return {
            walletAddress: this.globalState.walletAddress,
            walletType: this.globalState.walletType
        }
    }
    getConnectedWalletType() {
        return this.globalState.connectedWalletType
    }
    getProvider(e=null) {
        return e ? this.globalState.providers[e] : this.globalState.providers[this.globalState.connectedWalletType]
    }
    isAnyWalletConnected() {
        return this.globalState.isWalletConnected
    }
    async setActiveWallet(e, t=null) {
        const r = this.getProvider(t);
        if (!r)
            throw new Error(`${e} provider not found`);
        let s = null
          , i = !1
          , o = null;
        if ((r.request || r.selectedAddress) && t === jr.Metamask) {
            const a = r.selectedAddress ? [r.selectedAddress] : await r.request({
                method: "eth_accounts"
            });
            a?.length || (o = `${e} wallet is not connected`),
            s = a[0]
        } else if (r.isPhantom || r.isSolflare)
            r.isConnected && r.publicKey ? s = r.publicKey.toString() : s = (await r.connect()).publicKey.toString();
        else if (r.getConnectedAccounts) {
            const a = await r.getConnectedAccounts();
            a?.length || (o = `${e} wallet is not connected`),
            s = a[0].address
        }
        return this.globalState.walletAddress = s,
        this.globalState.connectedWalletType = e,
        this.globalState.isWalletConnected = !0,
        this.notifyListeners(),
        i = !!s,
        {
            status: i,
            address: s,
            type: e,
            error: o
        }
    }
    async isWalletActive(e) {
        try {
            const t = this.getProvider(e);
            if (!t)
                return {
                    walletAddress: null,
                    isConnected: !1
                };
            if (t.request || t.selectedAddress) {
                const r = t.selectedAddress ? [t.selectedAddress] : await t.request({
                    method: "eth_accounts"
                });
                return {
                    walletAddress: r?.[0] || null,
                    isConnected: r?.length > 0
                }
            }
            if (t.isPhantom || t.isSolflare) {
                const r = t.publicKey?.toString() || null;
                return {
                    walletAddress: r,
                    isConnected: !!r
                }
            }
            if (t.getConnectedAccounts) {
                const r = await t.getConnectedAccounts();
                return {
                    walletAddress: r?.[0]?.address || null,
                    isConnected: r?.length > 0
                }
            }
            return t.tronWeb?.defaultAddress?.base58 ? {
                walletAddress: t.tronWeb.defaultAddress.base58,
                isConnected: !0
            } : {
                walletAddress: null,
                isConnected: !1
            }
        } catch (t) {
            return console.error("Error checking wallet active state:", t),
            {
                walletAddress: null,
                isConnected: !1
            }
        }
    }
}
const Ji = new ESe;
function B0() {
    const [n,e] = V.useState({
        walletAddress: Ji.getActiveAddress(),
        walletType: Ji.getConnectedWalletType()
    });
    return V.useEffect( () => {
        const t = r => {
            e({
                walletAddress: r.walletAddress,
                walletType: r.connectedWalletType
            })
        }
        ;
        return Ji.subscribe(t),
        () => {
            Ji.unsubscribe(t)
        }
    }
    , []),
    n
}
const _x = "/assets/logo-CVSMCxyJ.svg"
  , $V = "/assets/cat-CD-Cxx-p.svg"
  , SSe = "/assets/wallet-icons-DNo2ounT.svg"
  , ASe = "/assets/metamask-BaN33oZa.svg"
  , CSe = "/assets/phantom-Bn42shjE.svg"
  , M7 = {
    Metamask: "Metamask",
    Phantom: "Phantom"
}
  , B7 = "1733383380522"
  , HV = {
    Ethereum: "#627EEA",
    Avalanche: "#E84142",
    Binance: "#F3BA2F",
    "BNB Smart Chain": "#F3BA2F",
    Polygon: "#8247E5",
    Arbitrum: "#2c374b",
    Optimism: "#FF0420",
    Solana: "#000000",
    Fantom: "#1969FF",
    Cronos: "#002D74",
    Celo: "#FBCC5C",
    Gnosis: "#48A9A6",
    Harmony: "#00AEE9",
    Kava: "#FF433E",
    Moonbeam: "#53CBC9",
    Moonriver: "#FFD300",
    Aurora: "#68FF99",
    zkSync: "#8C8DF9",
    StarkNet: "#1F1F2E",
    Linea: "#7D00FF",
    Base: "#0052FF",
    Bitcoin: "#F7931A",
    Tron: "#ff0013"
}
  , VV = {
    USDC: "#2775CA",
    ETH: "#627EEA",
    BNB: "#F3BA2F",
    MATIC: "#8247E5",
    POLYGON: "#8247E5",
    SOL: "#000000",
    SOLANA: "#000000",
    OP: "#FF0420",
    AVAX: "#E84142",
    AVAX_CCHAIN: "#E84142",
    FTM: "#1969FF",
    CRO: "#002D74",
    CELO: "#FBCC5C",
    DAI: "#F4B731",
    USDT: "#26A17B",
    BUSD: "#F0B90B",
    WBTC: "#F09242",
    LDO: "#2AB3DA",
    ARB: "#2D374B",
    LINK: "#2A5ADA",
    AAVE: "#B6509E",
    UNI: "#FF007A",
    LUNA: "#172852",
    DOT: "#E6007A",
    CBBTC: "#1C64FF",
    TBTC: "#171C24",
    WSTETH: "#44BDFF",
    "USDC.e": "#2775CA",
    PYUSD: "#5884F1",
    "1SOL": "#000000",
    ALEPH: "#5884F1",
    AUDIO: "#AA21D3",
    AURY: "#000000",
    AXS: "#5884F1",
    BIT: "#37B486",
    SPWN: "#000000",
    BLOCK: "#31C1B9",
    FIDA: "#000000",
    DYDX: "#000000",
    FRAX: "#000000",
    WAVES: "#000000",
    RAY: "#000000",
    wSOL: "#000000",
    SMURFCAT: "#000000",
    BITCOIN: "#000000",
    CEL: "#F6A044",
    CTI: "#00D1AE",
    PEOPLE: "#C49F65",
    MANA: "#FF4456",
    FTT: "#84D4E2",
    "GST-SOL": "#CDCDCD",
    HAPI: "#FFF701",
    KKO: "#EA3224",
    KURO: "#CEA017",
    OM: "#56454C",
    BGB: "#00F0FF",
    USDe: "#252525",
    NEAR: "#01F197",
    OKB: "#9EC8F5",
    KAS: "#231F20",
    FDUSD: "#A2F7D5",
    MNT: "#000000",
    XRP: "#33292E",
    LEO: "#000000",
    PEPE: "#009F18",
    DOGE: "#000000",
    BTC: "#F7931A",
    SHIB: "#EA442E",
    TRUMP: "#000000",
    LTC: "#385D9A",
    BCH: "#4CCA47",
    APT: "#060502",
    TIA: "#7B2BF9",
    FIL: "#0090FF",
    VET: "#15BDFF",
    TAO: "#005EDF",
    ETC: "#68B56A",
    TRX: "#ff0013",
    S: "#0D0D13",
    ADA: "#1882AA",
    HYPE: "#1E38A3",
    JUP: "#111727",
    RENDER: "#E51D1D",
    ALGO: "#000000",
    ICP: "#000000",
    HBAR: "#000000",
    XLM: "#000000",
    WL1X: "#F7931A"
}
  , Pp = "1481a1c3-59fc-40ca-8592-f358ed7faaed"
  , Io = "c86d1659-f878-4750-b436-3c0e40b85684"
  , kx = "2512b93c-3cc4-410d-9817-eaaf3ce72742"
  , X2 = "401a081d-5595-40c9-b105-0f133ec4de27"
  , _Se = Pc.BASE_URL.app
  , tk = Pc.BASE_URL.play;
async function kSe(n) {
    return await Wr(`${_Se}/api/v1/profile/l1x_authProfileDetails`, n)
}
async function NSe() {
    return await Gr(`${tk}/api/v1/profile/l1x_getProfileDetails`)
}
async function DSe(n, e) {
    return await Wr(`${tk}/api/v1/profile/l1x_saveProfileDetails`, n, e)
}
async function TSe(n, e) {
    return await Gr(`${tk}/api/v1/game/l1x_getGameHistory?page=${n}&limit=16&gameId=${e}`)
}
const ISe = async (n, e=null) => {
    let t = e
      , r = await Ji.connectWallet(n, "Connect " + n);
    if (r?.success) {
        let s = await kSe({
            ...r,
            platform: 0,
            referrerId: t
        });
        if (s?.status === "success") {
            const i = s?.data?.profileDetails?.referralCode || s?.data?.profileDetails?.wallets?.[0]?.referralCode;
            return Hg("userInfo", {
                ...r,
                walletType: n,
                authToken: s.data.token,
                referralCode: i
            }),
            r
        } else
            T8("userInfo")
    }
    return null
}
  , Ur = Pc.BASE_URL.play;
async function MSe(n, e) {
    return await Wr(`${Ur}/api/v1/purchase/l1x_initiatePurchaseTx`, n, e)
}
async function BSe(n, e) {
    return await Wr(`${Ur}/api/v1/purchase/l1x_completePurchaseTx`, n, e)
}
async function RSe(n) {
    return await Gr(`${Ur}/api/v1/purchase/l1x_fetchDepositHistory?&page=${n}&limit=15`)
}
async function OSe(n, e) {
    return await Wr(`${Ur}/api/v1/purchase/l1x_initiateL1xsWithdrawal`, n, e)
}
async function PSe(n) {
    return await Gr(`${Ur}/api/v1/purchase/l1x_fetchWithdrawalHistory?&page=${n}&limit=15`)
}
async function jSe(n) {
    return await Gr(`${Ur}/api/v1/profile/l1x_transactionHistory?page=${n}`)
}
async function LSe() {
    return await Gr(`${Ur}/api/v1/network/l1x_fetchActiveNetworks`)
}
async function qV() {
    return await Gr(`${Ur}/api/v1/purchase/l1x_fetchConfiguration`)
}
async function FSe() {
    return await Gr(`${Ur}/api/v1/wallet/l1x_myBalance`)
}
async function GV(n, e) {
    return await Wr(`${Ur}/api/v1/l1xp/l1x_claim`, n, e)
}
async function R7(n, e) {
    return await Wr(`${Ur}/api/v1/l1xp/l1x_release`, n, e)
}
async function O7(n, e, t, r) {
    let s = `${Ur}/api/v1/game/l1x_getLeaderBoard?page=${n}&limit=${e}`;
    return t && (s = s + `&gameId=${t}`),
    r && (s = s + `&date=${r}`),
    await Gr(s)
}
async function USe(n, e, t) {
    let r = `${Ur}/api/v1/game/l1x_getTodayLeaderBoard?page=${n}&limit=${e}`;
    return r = r + `&gameId=${t}`,
    await Gr(r)
}
async function zSe(n, e, t) {
    return await Gr(`${Ur}/api/v1/game/l1x_history?page=${n}&limit=${e}&gameId=${t}`)
}
async function $Se(n, e, t) {
    return await Gr(`${Ur}/api/v1/game/plinko/l1x_history?page=${n}&limit=${e}&gameId=${t}`)
}
async function HSe(n, e) {
    return await Wr(`${Ur}/api/v1/alchemy/l1x_postInitiateAlchemyPay`, n, e)
}
async function WV(n, e) {
    return await Gr(`${Ur}/api/v1/alchemy/l1x_getOrderDetails?merchantOrderNo=${n}`)
}
async function VSe(n, e) {
    return await Wr(`${Ur}/api/v1/game/plinko/l1x_verify`, n, e)
}
async function YV(n, e) {
    return await Gr(`${Ur}/api/v1/jackpot/l1x_getJackpotWinnerHistory?page=${n}&limit=${e}`)
}
async function qSe(n, e) {
    return await Wr(`${Ur}/api/v1/game/l1x_verifyProvableFairness`, n, e)
}
function nk() {
    const n = () => window.innerWidth <= 768
      , [e,t] = V.useState(n());
    return V.useEffect( () => {
        const r = () => t(n());
        return window.addEventListener("resize", r),
        () => window.removeEventListener("resize", r)
    }
    , []),
    e
}
function KV(n) {
    var e, t, r = "";
    if (typeof n == "string" || typeof n == "number")
        r += n;
    else if (typeof n == "object")
        if (Array.isArray(n)) {
            var s = n.length;
            for (e = 0; e < s; e++)
                n[e] && (t = KV(n[e])) && (r && (r += " "),
                r += t)
        } else
            for (t in n)
                n[t] && (r && (r += " "),
                r += t);
    return r
}
function Jn() {
    for (var n, e, t = 0, r = "", s = arguments.length; t < s; t++)
        (n = arguments[t]) && (e = KV(n)) && (r && (r += " "),
        r += e);
    return r
}
function GSe(n) {
    if (typeof document > "u")
        return;
    let e = document.head || document.getElementsByTagName("head")[0]
      , t = document.createElement("style");
    t.type = "text/css",
    e.firstChild ? e.insertBefore(t, e.firstChild) : e.appendChild(t),
    t.styleSheet ? t.styleSheet.cssText = n : t.appendChild(document.createTextNode(n))
}
GSe(`:root{--toastify-color-light: #fff;--toastify-color-dark: #121212;--toastify-color-info: #3498db;--toastify-color-success: #07bc0c;--toastify-color-warning: #f1c40f;--toastify-color-error: hsl(6, 78%, 57%);--toastify-color-transparent: rgba(255, 255, 255, .7);--toastify-icon-color-info: var(--toastify-color-info);--toastify-icon-color-success: var(--toastify-color-success);--toastify-icon-color-warning: var(--toastify-color-warning);--toastify-icon-color-error: var(--toastify-color-error);--toastify-container-width: fit-content;--toastify-toast-width: 320px;--toastify-toast-offset: 16px;--toastify-toast-top: max(var(--toastify-toast-offset), env(safe-area-inset-top));--toastify-toast-right: max(var(--toastify-toast-offset), env(safe-area-inset-right));--toastify-toast-left: max(var(--toastify-toast-offset), env(safe-area-inset-left));--toastify-toast-bottom: max(var(--toastify-toast-offset), env(safe-area-inset-bottom));--toastify-toast-background: #fff;--toastify-toast-padding: 14px;--toastify-toast-min-height: 64px;--toastify-toast-max-height: 800px;--toastify-toast-bd-radius: 6px;--toastify-toast-shadow: 0px 4px 12px rgba(0, 0, 0, .1);--toastify-font-family: sans-serif;--toastify-z-index: 9999;--toastify-text-color-light: #757575;--toastify-text-color-dark: #fff;--toastify-text-color-info: #fff;--toastify-text-color-success: #fff;--toastify-text-color-warning: #fff;--toastify-text-color-error: #fff;--toastify-spinner-color: #616161;--toastify-spinner-color-empty-area: #e0e0e0;--toastify-color-progress-light: linear-gradient(to right, #4cd964, #5ac8fa, #007aff, #34aadc, #5856d6, #ff2d55);--toastify-color-progress-dark: #bb86fc;--toastify-color-progress-info: var(--toastify-color-info);--toastify-color-progress-success: var(--toastify-color-success);--toastify-color-progress-warning: var(--toastify-color-warning);--toastify-color-progress-error: var(--toastify-color-error);--toastify-color-progress-bgo: .2}.Toastify__toast-container{z-index:var(--toastify-z-index);-webkit-transform:translate3d(0,0,var(--toastify-z-index));position:fixed;width:var(--toastify-container-width);box-sizing:border-box;color:#fff;display:flex;flex-direction:column}.Toastify__toast-container--top-left{top:var(--toastify-toast-top);left:var(--toastify-toast-left)}.Toastify__toast-container--top-center{top:var(--toastify-toast-top);left:50%;transform:translate(-50%);align-items:center}.Toastify__toast-container--top-right{top:var(--toastify-toast-top);right:var(--toastify-toast-right);align-items:end}.Toastify__toast-container--bottom-left{bottom:var(--toastify-toast-bottom);left:var(--toastify-toast-left)}.Toastify__toast-container--bottom-center{bottom:var(--toastify-toast-bottom);left:50%;transform:translate(-50%);align-items:center}.Toastify__toast-container--bottom-right{bottom:var(--toastify-toast-bottom);right:var(--toastify-toast-right);align-items:end}.Toastify__toast{--y: 0;position:relative;touch-action:none;width:var(--toastify-toast-width);min-height:var(--toastify-toast-min-height);box-sizing:border-box;margin-bottom:1rem;padding:var(--toastify-toast-padding);border-radius:var(--toastify-toast-bd-radius);box-shadow:var(--toastify-toast-shadow);max-height:var(--toastify-toast-max-height);font-family:var(--toastify-font-family);z-index:0;display:flex;flex:1 auto;align-items:center;word-break:break-word}@media only screen and (max-width: 480px){.Toastify__toast-container{width:100vw;left:env(safe-area-inset-left);margin:0}.Toastify__toast-container--top-left,.Toastify__toast-container--top-center,.Toastify__toast-container--top-right{top:env(safe-area-inset-top);transform:translate(0)}.Toastify__toast-container--bottom-left,.Toastify__toast-container--bottom-center,.Toastify__toast-container--bottom-right{bottom:env(safe-area-inset-bottom);transform:translate(0)}.Toastify__toast-container--rtl{right:env(safe-area-inset-right);left:initial}.Toastify__toast{--toastify-toast-width: 100%;margin-bottom:0;border-radius:0}}.Toastify__toast-container[data-stacked=true]{width:var(--toastify-toast-width)}.Toastify__toast--stacked{position:absolute;width:100%;transform:translate3d(0,var(--y),0) scale(var(--s));transition:transform .3s}.Toastify__toast--stacked[data-collapsed] .Toastify__toast-body,.Toastify__toast--stacked[data-collapsed] .Toastify__close-button{transition:opacity .1s}.Toastify__toast--stacked[data-collapsed=false]{overflow:visible}.Toastify__toast--stacked[data-collapsed=true]:not(:last-child)>*{opacity:0}.Toastify__toast--stacked:after{content:"";position:absolute;left:0;right:0;height:calc(var(--g) * 1px);bottom:100%}.Toastify__toast--stacked[data-pos=top]{top:0}.Toastify__toast--stacked[data-pos=bot]{bottom:0}.Toastify__toast--stacked[data-pos=bot].Toastify__toast--stacked:before{transform-origin:top}.Toastify__toast--stacked[data-pos=top].Toastify__toast--stacked:before{transform-origin:bottom}.Toastify__toast--stacked:before{content:"";position:absolute;left:0;right:0;bottom:0;height:100%;transform:scaleY(3);z-index:-1}.Toastify__toast--rtl{direction:rtl}.Toastify__toast--close-on-click{cursor:pointer}.Toastify__toast-icon{margin-inline-end:10px;width:22px;flex-shrink:0;display:flex}.Toastify--animate{animation-fill-mode:both;animation-duration:.5s}.Toastify--animate-icon{animation-fill-mode:both;animation-duration:.3s}.Toastify__toast-theme--dark{background:var(--toastify-color-dark);color:var(--toastify-text-color-dark)}.Toastify__toast-theme--light,.Toastify__toast-theme--colored.Toastify__toast--default{background:var(--toastify-color-light);color:var(--toastify-text-color-light)}.Toastify__toast-theme--colored.Toastify__toast--info{color:var(--toastify-text-color-info);background:var(--toastify-color-info)}.Toastify__toast-theme--colored.Toastify__toast--success{color:var(--toastify-text-color-success);background:var(--toastify-color-success)}.Toastify__toast-theme--colored.Toastify__toast--warning{color:var(--toastify-text-color-warning);background:var(--toastify-color-warning)}.Toastify__toast-theme--colored.Toastify__toast--error{color:var(--toastify-text-color-error);background:var(--toastify-color-error)}.Toastify__progress-bar-theme--light{background:var(--toastify-color-progress-light)}.Toastify__progress-bar-theme--dark{background:var(--toastify-color-progress-dark)}.Toastify__progress-bar--info{background:var(--toastify-color-progress-info)}.Toastify__progress-bar--success{background:var(--toastify-color-progress-success)}.Toastify__progress-bar--warning{background:var(--toastify-color-progress-warning)}.Toastify__progress-bar--error{background:var(--toastify-color-progress-error)}.Toastify__progress-bar-theme--colored.Toastify__progress-bar--info,.Toastify__progress-bar-theme--colored.Toastify__progress-bar--success,.Toastify__progress-bar-theme--colored.Toastify__progress-bar--warning,.Toastify__progress-bar-theme--colored.Toastify__progress-bar--error{background:var(--toastify-color-transparent)}.Toastify__close-button{color:#fff;position:absolute;top:6px;right:6px;background:transparent;outline:none;border:none;padding:0;cursor:pointer;opacity:.7;transition:.3s ease;z-index:1}.Toastify__toast--rtl .Toastify__close-button{left:6px;right:unset}.Toastify__close-button--light{color:#000;opacity:.3}.Toastify__close-button>svg{fill:currentColor;height:16px;width:14px}.Toastify__close-button:hover,.Toastify__close-button:focus{opacity:1}@keyframes Toastify__trackProgress{0%{transform:scaleX(1)}to{transform:scaleX(0)}}.Toastify__progress-bar{position:absolute;bottom:0;left:0;width:100%;height:100%;z-index:1;opacity:.7;transform-origin:left}.Toastify__progress-bar--animated{animation:Toastify__trackProgress linear 1 forwards}.Toastify__progress-bar--controlled{transition:transform .2s}.Toastify__progress-bar--rtl{right:0;left:initial;transform-origin:right;border-bottom-left-radius:initial}.Toastify__progress-bar--wrp{position:absolute;overflow:hidden;bottom:0;left:0;width:100%;height:5px;border-bottom-left-radius:var(--toastify-toast-bd-radius);border-bottom-right-radius:var(--toastify-toast-bd-radius)}.Toastify__progress-bar--wrp[data-hidden=true]{opacity:0}.Toastify__progress-bar--bg{opacity:var(--toastify-color-progress-bgo);width:100%;height:100%}.Toastify__spinner{width:20px;height:20px;box-sizing:border-box;border:2px solid;border-radius:100%;border-color:var(--toastify-spinner-color-empty-area);border-right-color:var(--toastify-spinner-color);animation:Toastify__spin .65s linear infinite}@keyframes Toastify__bounceInRight{0%,60%,75%,90%,to{animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;transform:translate3d(3000px,0,0)}60%{opacity:1;transform:translate3d(-25px,0,0)}75%{transform:translate3d(10px,0,0)}90%{transform:translate3d(-5px,0,0)}to{transform:none}}@keyframes Toastify__bounceOutRight{20%{opacity:1;transform:translate3d(-20px,var(--y),0)}to{opacity:0;transform:translate3d(2000px,var(--y),0)}}@keyframes Toastify__bounceInLeft{0%,60%,75%,90%,to{animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;transform:translate3d(-3000px,0,0)}60%{opacity:1;transform:translate3d(25px,0,0)}75%{transform:translate3d(-10px,0,0)}90%{transform:translate3d(5px,0,0)}to{transform:none}}@keyframes Toastify__bounceOutLeft{20%{opacity:1;transform:translate3d(20px,var(--y),0)}to{opacity:0;transform:translate3d(-2000px,var(--y),0)}}@keyframes Toastify__bounceInUp{0%,60%,75%,90%,to{animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;transform:translate3d(0,3000px,0)}60%{opacity:1;transform:translate3d(0,-20px,0)}75%{transform:translate3d(0,10px,0)}90%{transform:translate3d(0,-5px,0)}to{transform:translateZ(0)}}@keyframes Toastify__bounceOutUp{20%{transform:translate3d(0,calc(var(--y) - 10px),0)}40%,45%{opacity:1;transform:translate3d(0,calc(var(--y) + 20px),0)}to{opacity:0;transform:translate3d(0,-2000px,0)}}@keyframes Toastify__bounceInDown{0%,60%,75%,90%,to{animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;transform:translate3d(0,-3000px,0)}60%{opacity:1;transform:translate3d(0,25px,0)}75%{transform:translate3d(0,-10px,0)}90%{transform:translate3d(0,5px,0)}to{transform:none}}@keyframes Toastify__bounceOutDown{20%{transform:translate3d(0,calc(var(--y) - 10px),0)}40%,45%{opacity:1;transform:translate3d(0,calc(var(--y) + 20px),0)}to{opacity:0;transform:translate3d(0,2000px,0)}}.Toastify__bounce-enter--top-left,.Toastify__bounce-enter--bottom-left{animation-name:Toastify__bounceInLeft}.Toastify__bounce-enter--top-right,.Toastify__bounce-enter--bottom-right{animation-name:Toastify__bounceInRight}.Toastify__bounce-enter--top-center{animation-name:Toastify__bounceInDown}.Toastify__bounce-enter--bottom-center{animation-name:Toastify__bounceInUp}.Toastify__bounce-exit--top-left,.Toastify__bounce-exit--bottom-left{animation-name:Toastify__bounceOutLeft}.Toastify__bounce-exit--top-right,.Toastify__bounce-exit--bottom-right{animation-name:Toastify__bounceOutRight}.Toastify__bounce-exit--top-center{animation-name:Toastify__bounceOutUp}.Toastify__bounce-exit--bottom-center{animation-name:Toastify__bounceOutDown}@keyframes Toastify__zoomIn{0%{opacity:0;transform:scale3d(.3,.3,.3)}50%{opacity:1}}@keyframes Toastify__zoomOut{0%{opacity:1}50%{opacity:0;transform:translate3d(0,var(--y),0) scale3d(.3,.3,.3)}to{opacity:0}}.Toastify__zoom-enter{animation-name:Toastify__zoomIn}.Toastify__zoom-exit{animation-name:Toastify__zoomOut}@keyframes Toastify__flipIn{0%{transform:perspective(400px) rotateX(90deg);animation-timing-function:ease-in;opacity:0}40%{transform:perspective(400px) rotateX(-20deg);animation-timing-function:ease-in}60%{transform:perspective(400px) rotateX(10deg);opacity:1}80%{transform:perspective(400px) rotateX(-5deg)}to{transform:perspective(400px)}}@keyframes Toastify__flipOut{0%{transform:translate3d(0,var(--y),0) perspective(400px)}30%{transform:translate3d(0,var(--y),0) perspective(400px) rotateX(-20deg);opacity:1}to{transform:translate3d(0,var(--y),0) perspective(400px) rotateX(90deg);opacity:0}}.Toastify__flip-enter{animation-name:Toastify__flipIn}.Toastify__flip-exit{animation-name:Toastify__flipOut}@keyframes Toastify__slideInRight{0%{transform:translate3d(110%,0,0);visibility:visible}to{transform:translate3d(0,var(--y),0)}}@keyframes Toastify__slideInLeft{0%{transform:translate3d(-110%,0,0);visibility:visible}to{transform:translate3d(0,var(--y),0)}}@keyframes Toastify__slideInUp{0%{transform:translate3d(0,110%,0);visibility:visible}to{transform:translate3d(0,var(--y),0)}}@keyframes Toastify__slideInDown{0%{transform:translate3d(0,-110%,0);visibility:visible}to{transform:translate3d(0,var(--y),0)}}@keyframes Toastify__slideOutRight{0%{transform:translate3d(0,var(--y),0)}to{visibility:hidden;transform:translate3d(110%,var(--y),0)}}@keyframes Toastify__slideOutLeft{0%{transform:translate3d(0,var(--y),0)}to{visibility:hidden;transform:translate3d(-110%,var(--y),0)}}@keyframes Toastify__slideOutDown{0%{transform:translate3d(0,var(--y),0)}to{visibility:hidden;transform:translate3d(0,500px,0)}}@keyframes Toastify__slideOutUp{0%{transform:translate3d(0,var(--y),0)}to{visibility:hidden;transform:translate3d(0,-500px,0)}}.Toastify__slide-enter--top-left,.Toastify__slide-enter--bottom-left{animation-name:Toastify__slideInLeft}.Toastify__slide-enter--top-right,.Toastify__slide-enter--bottom-right{animation-name:Toastify__slideInRight}.Toastify__slide-enter--top-center{animation-name:Toastify__slideInDown}.Toastify__slide-enter--bottom-center{animation-name:Toastify__slideInUp}.Toastify__slide-exit--top-left,.Toastify__slide-exit--bottom-left{animation-name:Toastify__slideOutLeft;animation-timing-function:ease-in;animation-duration:.3s}.Toastify__slide-exit--top-right,.Toastify__slide-exit--bottom-right{animation-name:Toastify__slideOutRight;animation-timing-function:ease-in;animation-duration:.3s}.Toastify__slide-exit--top-center{animation-name:Toastify__slideOutUp;animation-timing-function:ease-in;animation-duration:.3s}.Toastify__slide-exit--bottom-center{animation-name:Toastify__slideOutDown;animation-timing-function:ease-in;animation-duration:.3s}@keyframes Toastify__spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}
`);
var Xy = n => typeof n == "number" && !isNaN(n)
  , Lf = n => typeof n == "string"
  , Mc = n => typeof n == "function"
  , WSe = n => Lf(n) || Xy(n)
  , LC = n => Lf(n) || Mc(n) ? n : null
  , YSe = (n, e) => n === !1 || Xy(n) && n > 0 ? n : e
  , FC = n => V.isValidElement(n) || Lf(n) || Mc(n) || Xy(n);
function KSe(n, e, t=300) {
    let {scrollHeight: r, style: s} = n;
    requestAnimationFrame( () => {
        s.minHeight = "initial",
        s.height = r + "px",
        s.transition = `all ${t}ms`,
        requestAnimationFrame( () => {
            s.height = "0",
            s.padding = "0",
            s.margin = "0",
            setTimeout(e, t)
        }
        )
    }
    )
}
function XSe({enter: n, exit: e, appendPosition: t=!1, collapse: r=!0, collapseDuration: s=300}) {
    return function({children: i, position: o, preventExitTransition: a, done: l, nodeRef: u, isIn: d, playToast: h}) {
        let p = t ? `${n}--${o}` : n
          , g = t ? `${e}--${o}` : e
          , w = V.useRef(0);
        return V.useLayoutEffect( () => {
            let b = u.current
              , v = p.split(" ")
              , S = N => {
                N.target === u.current && (h(),
                b.removeEventListener("animationend", S),
                b.removeEventListener("animationcancel", S),
                w.current === 0 && N.type !== "animationcancel" && b.classList.remove(...v))
            }
            ;
            b.classList.add(...v),
            b.addEventListener("animationend", S),
            b.addEventListener("animationcancel", S)
        }
        , []),
        V.useEffect( () => {
            let b = u.current
              , v = () => {
                b.removeEventListener("animationend", v),
                r ? KSe(b, l, s) : l()
            }
            ;
            d || (a ? v() : (w.current = 1,
            b.className += ` ${g}`,
            b.addEventListener("animationend", v)))
        }
        , [d]),
        ye.createElement(ye.Fragment, null, i)
    }
}
function P7(n, e) {
    return {
        content: XV(n.content, n.props),
        containerId: n.props.containerId,
        id: n.props.toastId,
        theme: n.props.theme,
        type: n.props.type,
        data: n.props.data || {},
        isLoading: n.props.isLoading,
        icon: n.props.icon,
        reason: n.removalReason,
        status: e
    }
}
function XV(n, e, t=!1) {
    return V.isValidElement(n) && !Lf(n.type) ? V.cloneElement(n, {
        closeToast: e.closeToast,
        toastProps: e,
        data: e.data,
        isPaused: t
    }) : Mc(n) ? n({
        closeToast: e.closeToast,
        toastProps: e,
        data: e.data,
        isPaused: t
    }) : n
}
function QSe({closeToast: n, theme: e, ariaLabel: t="close"}) {
    return ye.createElement("button", {
        className: `Toastify__close-button Toastify__close-button--${e}`,
        type: "button",
        onClick: r => {
            r.stopPropagation(),
            n(!0)
        }
        ,
        "aria-label": t
    }, ye.createElement("svg", {
        "aria-hidden": "true",
        viewBox: "0 0 14 16"
    }, ye.createElement("path", {
        fillRule: "evenodd",
        d: "M7.71 8.23l3.75 3.75-1.48 1.48-3.75-3.75-3.75 3.75L1 11.98l3.75-3.75L1 4.48 2.48 3l3.75 3.75L9.98 3l1.48 1.48-3.75 3.75z"
    })))
}
function ZSe({delay: n, isRunning: e, closeToast: t, type: r="default", hide: s, className: i, controlledProgress: o, progress: a, rtl: l, isIn: u, theme: d}) {
    let h = s || o && a === 0
      , p = {
        animationDuration: `${n}ms`,
        animationPlayState: e ? "running" : "paused"
    };
    o && (p.transform = `scaleX(${a})`);
    let g = Jn("Toastify__progress-bar", o ? "Toastify__progress-bar--controlled" : "Toastify__progress-bar--animated", `Toastify__progress-bar-theme--${d}`, `Toastify__progress-bar--${r}`, {
        "Toastify__progress-bar--rtl": l
    })
      , w = Mc(i) ? i({
        rtl: l,
        type: r,
        defaultClassName: g
    }) : Jn(g, i)
      , b = {
        [o && a >= 1 ? "onTransitionEnd" : "onAnimationEnd"]: o && a < 1 ? null : () => {
            u && t()
        }
    };
    return ye.createElement("div", {
        className: "Toastify__progress-bar--wrp",
        "data-hidden": h
    }, ye.createElement("div", {
        className: `Toastify__progress-bar--bg Toastify__progress-bar-theme--${d} Toastify__progress-bar--${r}`
    }), ye.createElement("div", {
        role: "progressbar",
        "aria-hidden": h ? "true" : "false",
        "aria-label": "notification timer",
        className: w,
        style: p,
        ...b
    }))
}
var JSe = 1
  , QV = () => `${JSe++}`;
function e5e(n, e, t) {
    let r = 1
      , s = 0
      , i = []
      , o = []
      , a = e
      , l = new Map
      , u = new Set
      , d = N => (u.add(N),
    () => u.delete(N))
      , h = () => {
        o = Array.from(l.values()),
        u.forEach(N => N())
    }
      , p = ({containerId: N, toastId: _, updateId: I}) => {
        let k = N ? N !== n : n !== 1
          , B = l.has(_) && I == null;
        return k || B
    }
      , g = (N, _) => {
        l.forEach(I => {
            var k;
            (_ == null || _ === I.props.toastId) && ((k = I.toggle) == null || k.call(I, N))
        }
        )
    }
      , w = N => {
        var _, I;
        (I = (_ = N.props) == null ? void 0 : _.onClose) == null || I.call(_, N.removalReason),
        N.isActive = !1
    }
      , b = N => {
        if (N == null)
            l.forEach(w);
        else {
            let _ = l.get(N);
            _ && w(_)
        }
        h()
    }
      , v = () => {
        s -= i.length,
        i = []
    }
      , S = N => {
        var _, I;
        let {toastId: k, updateId: B} = N.props
          , P = B == null;
        N.staleId && l.delete(N.staleId),
        N.isActive = !0,
        l.set(k, N),
        h(),
        t(P7(N, P ? "added" : "updated")),
        P && ((I = (_ = N.props).onOpen) == null || I.call(_))
    }
    ;
    return {
        id: n,
        props: a,
        observe: d,
        toggle: g,
        removeToast: b,
        toasts: l,
        clearQueue: v,
        buildToast: (N, _) => {
            if (p(_))
                return;
            let {toastId: I, updateId: k, data: B, staleId: P, delay: M} = _
              , R = k == null;
            R && s++;
            let L = {
                ...a,
                style: a.toastStyle,
                key: r++,
                ...Object.fromEntries(Object.entries(_).filter( ([H,j]) => j != null)),
                toastId: I,
                updateId: k,
                data: B,
                isIn: !1,
                className: LC(_.className || a.toastClassName),
                progressClassName: LC(_.progressClassName || a.progressClassName),
                autoClose: _.isLoading ? !1 : YSe(_.autoClose, a.autoClose),
                closeToast(H) {
                    l.get(I).removalReason = H,
                    b(I)
                },
                deleteToast() {
                    let H = l.get(I);
                    if (H != null) {
                        if (t(P7(H, "removed")),
                        l.delete(I),
                        s--,
                        s < 0 && (s = 0),
                        i.length > 0) {
                            S(i.shift());
                            return
                        }
                        h()
                    }
                }
            };
            L.closeButton = a.closeButton,
            _.closeButton === !1 || FC(_.closeButton) ? L.closeButton = _.closeButton : _.closeButton === !0 && (L.closeButton = FC(a.closeButton) ? a.closeButton : !0);
            let q = {
                content: N,
                props: L,
                staleId: P
            };
            a.limit && a.limit > 0 && s > a.limit && R ? i.push(q) : Xy(M) ? setTimeout( () => {
                S(q)
            }
            , M) : S(q)
        }
        ,
        setProps(N) {
            a = N
        },
        setToggle: (N, _) => {
            let I = l.get(N);
            I && (I.toggle = _)
        }
        ,
        isToastActive: N => {
            var _;
            return (_ = l.get(N)) == null ? void 0 : _.isActive
        }
        ,
        getSnapshot: () => o
    }
}
var Zs = new Map
  , oy = []
  , UC = new Set
  , t5e = n => UC.forEach(e => e(n))
  , ZV = () => Zs.size > 0;
function n5e() {
    oy.forEach(n => eq(n.content, n.options)),
    oy = []
}
var r5e = (n, {containerId: e}) => {
    var t;
    return (t = Zs.get(e || 1)) == null ? void 0 : t.toasts.get(n)
}
;
function JV(n, e) {
    var t;
    if (e)
        return !!((t = Zs.get(e)) != null && t.isToastActive(n));
    let r = !1;
    return Zs.forEach(s => {
        s.isToastActive(n) && (r = !0)
    }
    ),
    r
}
function s5e(n) {
    if (!ZV()) {
        oy = oy.filter(e => n != null && e.options.toastId !== n);
        return
    }
    if (n == null || WSe(n))
        Zs.forEach(e => {
            e.removeToast(n)
        }
        );
    else if (n && ("containerId"in n || "id"in n)) {
        let e = Zs.get(n.containerId);
        e ? e.removeToast(n.id) : Zs.forEach(t => {
            t.removeToast(n.id)
        }
        )
    }
}
var i5e = (n={}) => {
    Zs.forEach(e => {
        e.props.limit && (!n.containerId || e.id === n.containerId) && e.clearQueue()
    }
    )
}
;
function eq(n, e) {
    FC(n) && (ZV() || oy.push({
        content: n,
        options: e
    }),
    Zs.forEach(t => {
        t.buildToast(n, e)
    }
    ))
}
function o5e(n) {
    var e;
    (e = Zs.get(n.containerId || 1)) == null || e.setToggle(n.id, n.fn)
}
function tq(n, e) {
    Zs.forEach(t => {
        (e == null || !(e != null && e.containerId) || e?.containerId === t.id) && t.toggle(n, e?.id)
    }
    )
}
function a5e(n) {
    let e = n.containerId || 1;
    return {
        subscribe(t) {
            let r = e5e(e, n, t5e);
            Zs.set(e, r);
            let s = r.observe(t);
            return n5e(),
            () => {
                s(),
                Zs.delete(e)
            }
        },
        setProps(t) {
            var r;
            (r = Zs.get(e)) == null || r.setProps(t)
        },
        getSnapshot() {
            var t;
            return (t = Zs.get(e)) == null ? void 0 : t.getSnapshot()
        }
    }
}
function l5e(n) {
    return UC.add(n),
    () => {
        UC.delete(n)
    }
}
function c5e(n) {
    return n && (Lf(n.toastId) || Xy(n.toastId)) ? n.toastId : QV()
}
function Qy(n, e) {
    return eq(n, e),
    e.toastId
}
function Nx(n, e) {
    return {
        ...e,
        type: e && e.type || n,
        toastId: c5e(e)
    }
}
function Dx(n) {
    return (e, t) => Qy(e, Nx(n, t))
}
function Ze(n, e) {
    return Qy(n, Nx("default", e))
}
Ze.loading = (n, e) => Qy(n, Nx("default", {
    isLoading: !0,
    autoClose: !1,
    closeOnClick: !1,
    closeButton: !1,
    draggable: !1,
    ...e
}));
function u5e(n, {pending: e, error: t, success: r}, s) {
    let i;
    e && (i = Lf(e) ? Ze.loading(e, s) : Ze.loading(e.render, {
        ...s,
        ...e
    }));
    let o = {
        isLoading: null,
        autoClose: null,
        closeOnClick: null,
        closeButton: null,
        draggable: null
    }
      , a = (u, d, h) => {
        if (d == null) {
            Ze.dismiss(i);
            return
        }
        let p = {
            type: u,
            ...o,
            ...s,
            data: h
        }
          , g = Lf(d) ? {
            render: d
        } : d;
        return i ? Ze.update(i, {
            ...p,
            ...g
        }) : Ze(g.render, {
            ...p,
            ...g
        }),
        h
    }
      , l = Mc(n) ? n() : n;
    return l.then(u => a("success", r, u)).catch(u => a("error", t, u)),
    l
}
Ze.promise = u5e;
Ze.success = Dx("success");
Ze.info = Dx("info");
Ze.error = Dx("error");
Ze.warning = Dx("warning");
Ze.warn = Ze.warning;
Ze.dark = (n, e) => Qy(n, Nx("default", {
    theme: "dark",
    ...e
}));
function d5e(n) {
    s5e(n)
}
Ze.dismiss = d5e;
Ze.clearWaitingQueue = i5e;
Ze.isActive = JV;
Ze.update = (n, e={}) => {
    let t = r5e(n, e);
    if (t) {
        let {props: r, content: s} = t
          , i = {
            delay: 100,
            ...r,
            ...e,
            toastId: e.toastId || n,
            updateId: QV()
        };
        i.toastId !== n && (i.staleId = n);
        let o = i.render || s;
        delete i.render,
        Qy(o, i)
    }
}
;
Ze.done = n => {
    Ze.update(n, {
        progress: 1
    })
}
;
Ze.onChange = l5e;
Ze.play = n => tq(!0, n);
Ze.pause = n => tq(!1, n);
function f5e(n) {
    var e;
    let {subscribe: t, getSnapshot: r, setProps: s} = V.useRef(a5e(n)).current;
    s(n);
    let i = (e = V.useSyncExternalStore(t, r, r)) == null ? void 0 : e.slice();
    function o(a) {
        if (!i)
            return [];
        let l = new Map;
        return n.newestOnTop && i.reverse(),
        i.forEach(u => {
            let {position: d} = u.props;
            l.has(d) || l.set(d, []),
            l.get(d).push(u)
        }
        ),
        Array.from(l, u => a(u[0], u[1]))
    }
    return {
        getToastToRender: o,
        isToastActive: JV,
        count: i?.length
    }
}
function h5e(n) {
    let[e,t] = V.useState(!1)
      , [r,s] = V.useState(!1)
      , i = V.useRef(null)
      , o = V.useRef({
        start: 0,
        delta: 0,
        removalDistance: 0,
        canCloseOnClick: !0,
        canDrag: !1,
        didMove: !1
    }).current
      , {autoClose: a, pauseOnHover: l, closeToast: u, onClick: d, closeOnClick: h} = n;
    o5e({
        id: n.toastId,
        containerId: n.containerId,
        fn: t
    }),
    V.useEffect( () => {
        if (n.pauseOnFocusLoss)
            return p(),
            () => {
                g()
            }
    }
    , [n.pauseOnFocusLoss]);
    function p() {
        document.hasFocus() || S(),
        window.addEventListener("focus", v),
        window.addEventListener("blur", S)
    }
    function g() {
        window.removeEventListener("focus", v),
        window.removeEventListener("blur", S)
    }
    function w(P) {
        if (n.draggable === !0 || n.draggable === P.pointerType) {
            N();
            let M = i.current;
            o.canCloseOnClick = !0,
            o.canDrag = !0,
            M.style.transition = "none",
            n.draggableDirection === "x" ? (o.start = P.clientX,
            o.removalDistance = M.offsetWidth * (n.draggablePercent / 100)) : (o.start = P.clientY,
            o.removalDistance = M.offsetHeight * (n.draggablePercent === 80 ? n.draggablePercent * 1.5 : n.draggablePercent) / 100)
        }
    }
    function b(P) {
        let {top: M, bottom: R, left: L, right: q} = i.current.getBoundingClientRect();
        P.nativeEvent.type !== "touchend" && n.pauseOnHover && P.clientX >= L && P.clientX <= q && P.clientY >= M && P.clientY <= R ? S() : v()
    }
    function v() {
        t(!0)
    }
    function S() {
        t(!1)
    }
    function N() {
        o.didMove = !1,
        document.addEventListener("pointermove", I),
        document.addEventListener("pointerup", k)
    }
    function _() {
        document.removeEventListener("pointermove", I),
        document.removeEventListener("pointerup", k)
    }
    function I(P) {
        let M = i.current;
        if (o.canDrag && M) {
            o.didMove = !0,
            e && S(),
            n.draggableDirection === "x" ? o.delta = P.clientX - o.start : o.delta = P.clientY - o.start,
            o.start !== P.clientX && (o.canCloseOnClick = !1);
            let R = n.draggableDirection === "x" ? `${o.delta}px, var(--y)` : `0, calc(${o.delta}px + var(--y))`;
            M.style.transform = `translate3d(${R},0)`,
            M.style.opacity = `${1 - Math.abs(o.delta / o.removalDistance)}`
        }
    }
    function k() {
        _();
        let P = i.current;
        if (o.canDrag && o.didMove && P) {
            if (o.canDrag = !1,
            Math.abs(o.delta) > o.removalDistance) {
                s(!0),
                n.closeToast(!0),
                n.collapseAll();
                return
            }
            P.style.transition = "transform 0.2s, opacity 0.2s",
            P.style.removeProperty("transform"),
            P.style.removeProperty("opacity")
        }
    }
    let B = {
        onPointerDown: w,
        onPointerUp: b
    };
    return a && l && (B.onMouseEnter = S,
    n.stacked || (B.onMouseLeave = v)),
    h && (B.onClick = P => {
        d && d(P),
        o.canCloseOnClick && u(!0)
    }
    ),
    {
        playToast: v,
        pauseToast: S,
        isRunning: e,
        preventExitTransition: r,
        toastRef: i,
        eventHandlers: B
    }
}
var p5e = typeof window < "u" ? V.useLayoutEffect : V.useEffect
  , Tx = ({theme: n, type: e, isLoading: t, ...r}) => ye.createElement("svg", {
    viewBox: "0 0 24 24",
    width: "100%",
    height: "100%",
    fill: n === "colored" ? "currentColor" : `var(--toastify-icon-color-${e})`,
    ...r
});
function m5e(n) {
    return ye.createElement(Tx, {
        ...n
    }, ye.createElement("path", {
        d: "M23.32 17.191L15.438 2.184C14.728.833 13.416 0 11.996 0c-1.42 0-2.733.833-3.443 2.184L.533 17.448a4.744 4.744 0 000 4.368C1.243 23.167 2.555 24 3.975 24h16.05C22.22 24 24 22.044 24 19.632c0-.904-.251-1.746-.68-2.44zm-9.622 1.46c0 1.033-.724 1.823-1.698 1.823s-1.698-.79-1.698-1.822v-.043c0-1.028.724-1.822 1.698-1.822s1.698.79 1.698 1.822v.043zm.039-12.285l-.84 8.06c-.057.581-.408.943-.897.943-.49 0-.84-.367-.896-.942l-.84-8.065c-.057-.624.25-1.095.779-1.095h1.91c.528.005.84.476.784 1.1z"
    }))
}
function g5e(n) {
    return ye.createElement(Tx, {
        ...n
    }, ye.createElement("path", {
        d: "M12 0a12 12 0 1012 12A12.013 12.013 0 0012 0zm.25 5a1.5 1.5 0 11-1.5 1.5 1.5 1.5 0 011.5-1.5zm2.25 13.5h-4a1 1 0 010-2h.75a.25.25 0 00.25-.25v-4.5a.25.25 0 00-.25-.25h-.75a1 1 0 010-2h1a2 2 0 012 2v4.75a.25.25 0 00.25.25h.75a1 1 0 110 2z"
    }))
}
function y5e(n) {
    return ye.createElement(Tx, {
        ...n
    }, ye.createElement("path", {
        d: "M12 0a12 12 0 1012 12A12.014 12.014 0 0012 0zm6.927 8.2l-6.845 9.289a1.011 1.011 0 01-1.43.188l-4.888-3.908a1 1 0 111.25-1.562l4.076 3.261 6.227-8.451a1 1 0 111.61 1.183z"
    }))
}
function b5e(n) {
    return ye.createElement(Tx, {
        ...n
    }, ye.createElement("path", {
        d: "M11.983 0a12.206 12.206 0 00-8.51 3.653A11.8 11.8 0 000 12.207 11.779 11.779 0 0011.8 24h.214A12.111 12.111 0 0024 11.791 11.766 11.766 0 0011.983 0zM10.5 16.542a1.476 1.476 0 011.449-1.53h.027a1.527 1.527 0 011.523 1.47 1.475 1.475 0 01-1.449 1.53h-.027a1.529 1.529 0 01-1.523-1.47zM11 12.5v-6a1 1 0 012 0v6a1 1 0 11-2 0z"
    }))
}
function w5e() {
    return ye.createElement("div", {
        className: "Toastify__spinner"
    })
}
var zC = {
    info: g5e,
    warning: m5e,
    success: y5e,
    error: b5e,
    spinner: w5e
}
  , v5e = n => n in zC;
function x5e({theme: n, type: e, isLoading: t, icon: r}) {
    let s = null
      , i = {
        theme: n,
        type: e
    };
    return r === !1 || (Mc(r) ? s = r({
        ...i,
        isLoading: t
    }) : V.isValidElement(r) ? s = V.cloneElement(r, i) : t ? s = zC.spinner() : v5e(e) && (s = zC[e](i))),
    s
}
var E5e = n => {
    let {isRunning: e, preventExitTransition: t, toastRef: r, eventHandlers: s, playToast: i} = h5e(n)
      , {closeButton: o, children: a, autoClose: l, onClick: u, type: d, hideProgressBar: h, closeToast: p, transition: g, position: w, className: b, style: v, progressClassName: S, updateId: N, role: _, progress: I, rtl: k, toastId: B, deleteToast: P, isIn: M, isLoading: R, closeOnClick: L, theme: q, ariaLabel: H} = n
      , j = Jn("Toastify__toast", `Toastify__toast-theme--${q}`, `Toastify__toast--${d}`, {
        "Toastify__toast--rtl": k
    }, {
        "Toastify__toast--close-on-click": L
    })
      , A = Mc(b) ? b({
        rtl: k,
        position: w,
        type: d,
        defaultClassName: j
    }) : Jn(j, b)
      , E = x5e(n)
      , C = !!I || !l
      , O = {
        closeToast: p,
        type: d,
        theme: q
    }
      , z = null;
    return o === !1 || (Mc(o) ? z = o(O) : V.isValidElement(o) ? z = V.cloneElement(o, O) : z = QSe(O)),
    ye.createElement(g, {
        isIn: M,
        done: P,
        position: w,
        preventExitTransition: t,
        nodeRef: r,
        playToast: i
    }, ye.createElement("div", {
        id: B,
        tabIndex: 0,
        onClick: u,
        "data-in": M,
        className: A,
        ...s,
        style: v,
        ref: r,
        ...M && {
            role: _,
            "aria-label": H
        }
    }, E != null && ye.createElement("div", {
        className: Jn("Toastify__toast-icon", {
            "Toastify--animate-icon Toastify__zoom-enter": !R
        })
    }, E), XV(a, n, !e), z, !n.customProgressBar && ye.createElement(ZSe, {
        ...N && !C ? {
            key: `p-${N}`
        } : {},
        rtl: k,
        theme: q,
        delay: l,
        isRunning: e,
        isIn: M,
        closeToast: p,
        hide: h,
        type: d,
        className: S,
        controlledProgress: C,
        progress: I || 0
    })))
}
  , S5e = (n, e=!1) => ({
    enter: `Toastify--animate Toastify__${n}-enter`,
    exit: `Toastify--animate Toastify__${n}-exit`,
    appendPosition: e
})
  , A5e = XSe(S5e("bounce", !0))
  , C5e = {
    position: "top-right",
    transition: A5e,
    autoClose: 5e3,
    closeButton: !0,
    pauseOnHover: !0,
    pauseOnFocusLoss: !0,
    draggable: "touch",
    draggablePercent: 80,
    draggableDirection: "x",
    role: "alert",
    theme: "light",
    "aria-label": "Notifications Alt+T",
    hotKeys: n => n.altKey && n.code === "KeyT"
};
function _5e(n) {
    let e = {
        ...C5e,
        ...n
    }
      , t = n.stacked
      , [r,s] = V.useState(!0)
      , i = V.useRef(null)
      , {getToastToRender: o, isToastActive: a, count: l} = f5e(e)
      , {className: u, style: d, rtl: h, containerId: p, hotKeys: g} = e;
    function w(v) {
        let S = Jn("Toastify__toast-container", `Toastify__toast-container--${v}`, {
            "Toastify__toast-container--rtl": h
        });
        return Mc(u) ? u({
            position: v,
            rtl: h,
            defaultClassName: S
        }) : Jn(S, LC(u))
    }
    function b() {
        t && (s(!0),
        Ze.play())
    }
    return p5e( () => {
        var v;
        if (t) {
            let S = i.current.querySelectorAll('[data-in="true"]')
              , N = 12
              , _ = (v = e.position) == null ? void 0 : v.includes("top")
              , I = 0
              , k = 0;
            Array.from(S).reverse().forEach( (B, P) => {
                let M = B;
                M.classList.add("Toastify__toast--stacked"),
                P > 0 && (M.dataset.collapsed = `${r}`),
                M.dataset.pos || (M.dataset.pos = _ ? "top" : "bot");
                let R = I * (r ? .2 : 1) + (r ? 0 : N * P);
                M.style.setProperty("--y", `${_ ? R : R * -1}px`),
                M.style.setProperty("--g", `${N}`),
                M.style.setProperty("--s", `${1 - (r ? k : 0)}`),
                I += M.offsetHeight,
                k += .025
            }
            )
        }
    }
    , [r, l, t]),
    V.useEffect( () => {
        function v(S) {
            var N;
            let _ = i.current;
            g(S) && ((N = _.querySelector('[tabIndex="0"]')) == null || N.focus(),
            s(!1),
            Ze.pause()),
            S.key === "Escape" && (document.activeElement === _ || _ != null && _.contains(document.activeElement)) && (s(!0),
            Ze.play())
        }
        return document.addEventListener("keydown", v),
        () => {
            document.removeEventListener("keydown", v)
        }
    }
    , [g]),
    ye.createElement("section", {
        ref: i,
        className: "Toastify",
        id: p,
        onMouseEnter: () => {
            t && (s(!1),
            Ze.pause())
        }
        ,
        onMouseLeave: b,
        "aria-live": "polite",
        "aria-atomic": "false",
        "aria-relevant": "additions text",
        "aria-label": e["aria-label"]
    }, o( (v, S) => {
        let N = S.length ? {
            ...d
        } : {
            ...d,
            pointerEvents: "none"
        };
        return ye.createElement("div", {
            tabIndex: -1,
            className: w(v),
            "data-stacked": t,
            style: N,
            key: `c-${v}`
        }, S.map( ({content: _, props: I}) => ye.createElement(E5e, {
            ...I,
            stacked: t,
            collapseAll: b,
            isIn: a(I.toastId, I.containerId),
            key: `t-${I.key}`
        }, _)))
    }
    ))
}
const ud = Pc.BASE_URL.app;
async function k5e(n, e) {
    return await Gr(`${ud}/api/v2/price/l1x_getCoinGeckoComparePrice?source=${n}&target=${e}`)
}
async function N5e(n) {
    return await Wr(`${ud}/api/v1/profile/l1x_registerWithEmail`, n)
}
async function D5e(n) {
    return await Wr(`${ud}/api/v1/profile/l1x_loginWithEmail`, n)
}
async function T5e(n) {
    return await Wr(`${ud}/api/v1/profile/l1x_verifyEmail`, n)
}
async function I5e(n) {
    return await Wr(`${ud}/api/v1/profile/l1x_resendVerificationCode`, n)
}
async function M5e(n) {
    return await Wr(`${ud}/api/v1/profile/l1x_sendForgotPasswordEmail`, n)
}
async function B5e(n) {
    return await Wr(`${ud}/api/v1/profile/l1x_resetPassword`, n)
}
async function R5e(n) {
    return await Gr(`${ud}/api/v1/profile/l1x_isEmailExist?email=${n}`)
}
const nq = V.createContext({
    walletType: null,
    walletAddress: null,
    balance: {
        isLoading: !0,
        l1xgBalance: 0,
        l1xsLocked: 0,
        l1xsBalance: 0
    },
    loading: !1,
    connectWallet: () => {}
    ,
    connectEmail: () => {}
    ,
    disconnectWallet: () => {}
    ,
    refreshBalance: () => {}
    ,
    backendConfig: null,
    emailAddress: null,
    setEmailAddress: () => {}
});
function O5e({children: n}) {
    const [e,t] = V.useState(null)
      , [r,s] = V.useState(null)
      , [i,o] = V.useState(null)
      , [a,l] = V.useState({
        isLoading: !0,
        l1xgBalance: 0,
        l1xsLocked: 0,
        l1xsBalance: 0
    })
      , [u,d] = V.useState(!1)
      , [h,p] = V.useState(null)
      , g = Uo()
      , w = nk()
      , b = kr();
    V.useEffect( () => {
        v();
        const k = S0("userInfo");
        k?.success && _(),
        k?.emailAddress && (s(k?.emailAddress),
        _())
    }
    , []);
    const v = async () => {
        try {
            const k = await qV();
            k?.status === "success" && p(k?.data)
        } catch (k) {
            console.error(" Configuration fetch error:", k)
        }
    }
    ;
    async function S(k) {
        try {
            d(!0);
            const B = await ISe(w && k === jr.Metamask ? "walletconnect" : k)
              , P = await g.executeV3("action");
            await R7({}, P),
            await _()
        } catch (B) {
            console.error(" Wallet connect failed:", B)
        } finally {
            d(!1)
        }
    }
    async function N(k, B) {
        try {
            d(!0);
            const P = await D5e({
                email: k,
                password: B
            });
            if (P.status === "success") {
                Hg("userInfo", {
                    walletType: null,
                    authToken: P.data?.token,
                    referralCode: null,
                    loginType: "email",
                    emailAddress: k
                }),
                localStorage.setItem("authToken", P.data?.token),
                s(k);
                const M = await g.executeV3("action");
                return await R7({}, M),
                await _(),
                b("/"),
                {
                    status: !0,
                    message: "Login successful"
                }
            } else
                return {
                    status: !1,
                    message: P?.message === "Email not verified." ? P?.message : P?.message || "Login failed"
                }
        } catch {
            return {
                status: !1,
                message: "Login failed"
            }
        } finally {
            d(!1)
        }
    }
    const _ = V.useCallback(async () => {
        try {
            l({
                isLoading: !0,
                l1xgBalance: 0,
                l1xsLocked: 0,
                l1xsBalance: 0
            });
            const k = await FSe();
            if (k?.status === "success") {
                const B = {
                    ...k?.data,
                    isLoading: !1
                };
                l(B),
                Hg("userId", k?.data?.userId)
            } else
                l({
                    isLoading: !1,
                    l1xgBalance: 0,
                    l1xsLocked: 0,
                    l1xsBalance: 0
                })
        } catch (k) {
            console.error(" balance fetch error:", k),
            l({
                isLoading: !1,
                l1xgBalance: 0,
                l1xsLocked: 0,
                l1xsBalance: 0
            })
        }
    }
    , []);
    function I() {
        Ji.disconnectWallet(),
        t(null),
        o(null),
        l({
            isLoading: !0,
            l1xgBalance: 0,
            l1xsLocked: 0,
            l1xsBalance: 0
        }),
        T8("userInfo")
    }
    return m.jsx(nq.Provider, {
        value: {
            walletType: e,
            walletAddress: i,
            balance: a,
            loading: u,
            connectWallet: S,
            connectEmail: N,
            disconnectWallet: I,
            refreshBalance: _,
            backendConfig: h,
            emailAddress: r,
            setEmailAddress: s
        },
        children: n
    })
}
function Hs() {
    return V.useContext(nq)
}
const P5e = ({setShowWalletLogin: n}) => {
    const e = nk()
      , {refreshBalance: t, connectWallet: r} = Hs();
    Uo();
    const s = async i => {
        await r(i)
    }
    ;
    return m.jsx(m.Fragment, {
        children: m.jsxs("div", {
            className: "lg:min-w-[400px]  w-full md:px-3 text-center login-with-wallet",
            children: [m.jsx("h2", {
                className: "text-3xl md:text-4xl font-light mb-3 md:mb-5",
                children: "Login with Wallet"
            }), m.jsx("p", {
                className: "text-sm font-light mb-12 md:mb-6",
                children: "Connect your Web3 wallet to enter your account"
            }), m.jsxs("div", {
                onClick: () => s(M7?.Metamask),
                className: "bg-brandDeepDark rounded-2xl border border-[#3F4E63] p-4 shadow-2xl mb-7 flex items-center gap-4 transition-all duration-300 hover:bg-white/10 hover:scale-105 cursor-pointer",
                children: [m.jsx("div", {
                    className: "",
                    children: m.jsx("img", {
                        src: ASe
                    })
                }), m.jsxs("div", {
                    className: "text-left cursor-pointer ",
                    children: [m.jsx("h3", {
                        className: "text-xl font-semibold",
                        children: "MetaMask"
                    }), m.jsx("p", {
                        className: "text-sm text-white/50",
                        children: "Most Popular EVM"
                    })]
                })]
            }), e ? "" : m.jsxs("div", {
                onClick: () => s(M7?.Phantom),
                className: "bg-brandDeepDark rounded-2xl border border-[#3F4E63] p-4 shadow-2xl flex items-center gap-4 transition-all duration-300 hover:bg-white/10 hover:scale-105 cursor-pointer",
                children: [m.jsx("div", {
                    className: "",
                    children: m.jsx("img", {
                        src: CSe
                    })
                }), m.jsxs("div", {
                    className: "text-left cursor-pointer ",
                    children: [m.jsx("h3", {
                        className: "text-xl font-semibold",
                        children: "Phantom"
                    }), m.jsx("p", {
                        className: "text-sm text-white/50",
                        children: "Solana Loves it."
                    })]
                })]
            }), m.jsx("div", {
                className: "mt-6 text-center",
                children: m.jsxs("button", {
                    type: "button",
                    onClick: () => n(!1),
                    className: "text-white group cursor-pointer inline-flex items-center gap-2.5",
                    children: [m.jsx("span", {
                        className: "bg-[#404E61] w-10 h-10 rounded-4xl p-2 flex flex-col justify-center items-center mx-auto transition-all duration-300 group-hover:bg-white",
                        children: m.jsx("svg", {
                            xmlns: "http://www.w3.org/2000/svg",
                            fill: "none",
                            viewBox: "0 0 24 24",
                            strokeWidth: 1.5,
                            stroke: "currentColor",
                            className: "size-4 transition-all duration-300 group-hover:stroke-[#404E61]",
                            children: m.jsx("path", {
                                strokeLinecap: "round",
                                strokeLinejoin: "round",
                                d: "M10.5 19.5 3 12m0 0 7.5-7.5M3 12h18"
                            })
                        })
                    }), m.jsx("span", {
                        className: "transition-all duration-300 group-hover:text-white",
                        children: "Back to email login"
                    })]
                })
            })]
        })
    })
}
  , rq = "/assets/verify-email-img-Bg6es9td.png";
let j5e = {
    data: ""
}
  , L5e = n => {
    if (typeof window == "object") {
        let e = (n ? n.querySelector("#_goober") : window._goober) || Object.assign(document.createElement("style"), {
            innerHTML: " ",
            id: "_goober"
        });
        return e.nonce = window.__nonce__,
        e.parentNode || (n || document.head).appendChild(e),
        e.firstChild
    }
    return n || j5e
}
  , F5e = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g
  , U5e = /\/\*[^]*?\*\/|  +/g
  , j7 = /\n+/g
  , ju = (n, e) => {
    let t = ""
      , r = ""
      , s = "";
    for (let i in n) {
        let o = n[i];
        i[0] == "@" ? i[1] == "i" ? t = i + " " + o + ";" : r += i[1] == "f" ? ju(o, i) : i + "{" + ju(o, i[1] == "k" ? "" : e) + "}" : typeof o == "object" ? r += ju(o, e ? e.replace(/([^,])+/g, a => i.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g, l => /&/.test(l) ? l.replace(/&/g, a) : a ? a + " " + l : l)) : i) : o != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(),
        s += ju.p ? ju.p(i, o) : i + ":" + o + ";")
    }
    return t + (e && s ? e + "{" + s + "}" : s) + r
}
  , Ll = {}
  , sq = n => {
    if (typeof n == "object") {
        let e = "";
        for (let t in n)
            e += t + sq(n[t]);
        return e
    }
    return n
}
  , z5e = (n, e, t, r, s) => {
    let i = sq(n)
      , o = Ll[i] || (Ll[i] = (l => {
        let u = 0
          , d = 11;
        for (; u < l.length; )
            d = 101 * d + l.charCodeAt(u++) >>> 0;
        return "go" + d
    }
    )(i));
    if (!Ll[o]) {
        let l = i !== n ? n : (u => {
            let d, h, p = [{}];
            for (; d = F5e.exec(u.replace(U5e, "")); )
                d[4] ? p.shift() : d[3] ? (h = d[3].replace(j7, " ").trim(),
                p.unshift(p[0][h] = p[0][h] || {})) : p[0][d[1]] = d[2].replace(j7, " ").trim();
            return p[0]
        }
        )(n);
        Ll[o] = ju(s ? {
            ["@keyframes " + o]: l
        } : l, t ? "" : "." + o)
    }
    let a = t && Ll.g ? Ll.g : null;
    return t && (Ll.g = Ll[o]),
    ( (l, u, d, h) => {
        h ? u.data = u.data.replace(h, l) : u.data.indexOf(l) === -1 && (u.data = d ? l + u.data : u.data + l)
    }
    )(Ll[o], e, r, a),
    o
}
  , $5e = (n, e, t) => n.reduce( (r, s, i) => {
    let o = e[i];
    if (o && o.call) {
        let a = o(t)
          , l = a && a.props && a.props.className || /^go/.test(a) && a;
        o = l ? "." + l : a && typeof a == "object" ? a.props ? "" : ju(a, "") : a === !1 ? "" : a
    }
    return r + s + (o ?? "")
}
, "");
function Ix(n) {
    let e = this || {}
      , t = n.call ? n(e.p) : n;
    return z5e(t.unshift ? t.raw ? $5e(t, [].slice.call(arguments, 1), e.p) : t.reduce( (r, s) => Object.assign(r, s && s.call ? s(e.p) : s), {}) : t, L5e(e.target), e.g, e.o, e.k)
}
let iq, $C, HC;
Ix.bind({
    g: 1
});
let Bc = Ix.bind({
    k: 1
});
function H5e(n, e, t, r) {
    ju.p = e,
    iq = n,
    $C = t,
    HC = r
}
function dd(n, e) {
    let t = this || {};
    return function() {
        let r = arguments;
        function s(i, o) {
            let a = Object.assign({}, i)
              , l = a.className || s.className;
            t.p = Object.assign({
                theme: $C && $C()
            }, a),
            t.o = / *go\d+/.test(l),
            a.className = Ix.apply(t, r) + (l ? " " + l : "");
            let u = n;
            return n[0] && (u = a.as || n,
            delete a.as),
            HC && u[0] && HC(a),
            iq(u, a)
        }
        return s
    }
}
var V5e = n => typeof n == "function"
  , VC = (n, e) => V5e(n) ? n(e) : n
  , q5e = ( () => {
    let n = 0;
    return () => (++n).toString()
}
)()
  , G5e = ( () => {
    let n;
    return () => {
        if (n === void 0 && typeof window < "u") {
            let e = matchMedia("(prefers-reduced-motion: reduce)");
            n = !e || e.matches
        }
        return n
    }
}
)()
  , W5e = 20
  , oq = "default"
  , aq = (n, e) => {
    let {toastLimit: t} = n.settings;
    switch (e.type) {
    case 0:
        return {
            ...n,
            toasts: [e.toast, ...n.toasts].slice(0, t)
        };
    case 1:
        return {
            ...n,
            toasts: n.toasts.map(o => o.id === e.toast.id ? {
                ...o,
                ...e.toast
            } : o)
        };
    case 2:
        let {toast: r} = e;
        return aq(n, {
            type: n.toasts.find(o => o.id === r.id) ? 1 : 0,
            toast: r
        });
    case 3:
        let {toastId: s} = e;
        return {
            ...n,
            toasts: n.toasts.map(o => o.id === s || s === void 0 ? {
                ...o,
                dismissed: !0,
                visible: !1
            } : o)
        };
    case 4:
        return e.toastId === void 0 ? {
            ...n,
            toasts: []
        } : {
            ...n,
            toasts: n.toasts.filter(o => o.id !== e.toastId)
        };
    case 5:
        return {
            ...n,
            pausedAt: e.time
        };
    case 6:
        let i = e.time - (n.pausedAt || 0);
        return {
            ...n,
            pausedAt: void 0,
            toasts: n.toasts.map(o => ({
                ...o,
                pauseDuration: o.pauseDuration + i
            }))
        }
    }
}
  , Y5e = []
  , K5e = {
    toasts: [],
    pausedAt: void 0,
    settings: {
        toastLimit: W5e
    }
}
  , jp = {}
  , lq = (n, e=oq) => {
    jp[e] = aq(jp[e] || K5e, n),
    Y5e.forEach( ([t,r]) => {
        t === e && r(jp[e])
    }
    )
}
  , cq = n => Object.keys(jp).forEach(e => lq(n, e))
  , X5e = n => Object.keys(jp).find(e => jp[e].toasts.some(t => t.id === n))
  , rk = (n=oq) => e => {
    lq(e, n)
}
  , Q5e = (n, e="blank", t) => ({
    createdAt: Date.now(),
    visible: !0,
    dismissed: !1,
    type: e,
    ariaProps: {
        role: "status",
        "aria-live": "polite"
    },
    message: n,
    pauseDuration: 0,
    ...t,
    id: t?.id || q5e()
})
  , Zy = n => (e, t) => {
    let r = Q5e(e, n, t);
    return rk(r.toasterId || X5e(r.id))({
        type: 2,
        toast: r
    }),
    r.id
}
  , vs = (n, e) => Zy("blank")(n, e);
vs.error = Zy("error");
vs.success = Zy("success");
vs.loading = Zy("loading");
vs.custom = Zy("custom");
vs.dismiss = (n, e) => {
    let t = {
        type: 3,
        toastId: n
    };
    e ? rk(e)(t) : cq(t)
}
;
vs.dismissAll = n => vs.dismiss(void 0, n);
vs.remove = (n, e) => {
    let t = {
        type: 4,
        toastId: n
    };
    e ? rk(e)(t) : cq(t)
}
;
vs.removeAll = n => vs.remove(void 0, n);
vs.promise = (n, e, t) => {
    let r = vs.loading(e.loading, {
        ...t,
        ...t?.loading
    });
    return typeof n == "function" && (n = n()),
    n.then(s => {
        let i = e.success ? VC(e.success, s) : void 0;
        return i ? vs.success(i, {
            id: r,
            ...t,
            ...t?.success
        }) : vs.dismiss(r),
        s
    }
    ).catch(s => {
        let i = e.error ? VC(e.error, s) : void 0;
        i ? vs.error(i, {
            id: r,
            ...t,
            ...t?.error
        }) : vs.dismiss(r)
    }
    ),
    n
}
;
var Z5e = Bc`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`
  , J5e = Bc`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`
  , eAe = Bc`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`
  , tAe = dd("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${n => n.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${Z5e} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${J5e} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${n => n.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${eAe} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`
  , nAe = Bc`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`
  , rAe = dd("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${n => n.secondary || "#e0e0e0"};
  border-right-color: ${n => n.primary || "#616161"};
  animation: ${nAe} 1s linear infinite;
`
  , sAe = Bc`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`
  , iAe = Bc`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`
  , oAe = dd("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${n => n.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${sAe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${iAe} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${n => n.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`
  , aAe = dd("div")`
  position: absolute;
`
  , lAe = dd("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`
  , cAe = Bc`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`
  , uAe = dd("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${cAe} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`
  , dAe = ({toast: n}) => {
    let {icon: e, type: t, iconTheme: r} = n;
    return e !== void 0 ? typeof e == "string" ? V.createElement(uAe, null, e) : e : t === "blank" ? null : V.createElement(lAe, null, V.createElement(rAe, {
        ...r
    }), t !== "loading" && V.createElement(aAe, null, t === "error" ? V.createElement(tAe, {
        ...r
    }) : V.createElement(oAe, {
        ...r
    })))
}
  , fAe = n => `
0% {transform: translate3d(0,${n * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`
  , hAe = n => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${n * -150}%,-1px) scale(.6); opacity:0;}
`
  , pAe = "0%{opacity:0;} 100%{opacity:1;}"
  , mAe = "0%{opacity:1;} 100%{opacity:0;}"
  , gAe = dd("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`
  , yAe = dd("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`
  , bAe = (n, e) => {
    let t = n.includes("top") ? 1 : -1
      , [r,s] = G5e() ? [pAe, mAe] : [fAe(t), hAe(t)];
    return {
        animation: e ? `${Bc(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${Bc(s)} 0.4s forwards cubic-bezier(.06,.71,.55,1)`
    }
}
;
V.memo( ({toast: n, position: e, style: t, children: r}) => {
    let s = n.height ? bAe(n.position || e || "top-center", n.visible) : {
        opacity: 0
    }
      , i = V.createElement(dAe, {
        toast: n
    })
      , o = V.createElement(yAe, {
        ...n.ariaProps
    }, VC(n.message, n));
    return V.createElement(gAe, {
        className: n.className,
        style: {
            ...s,
            ...t,
            ...n.style
        }
    }, typeof r == "function" ? r({
        icon: i,
        message: o
    }) : V.createElement(V.Fragment, null, i, o))
}
);
H5e(V.createElement);
Ix`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
var L7 = vs;
const sk = ({isOpen: n, onClose: e, emailAddress: t, forgetPassword: r}) => {
    if (!n)
        return null;
    const [s,i] = V.useState(!1)
      , [o,a] = V.useState(!1)
      , [l,u] = V.useState(null);
    V.useEffect( () => {
        if (n) {
            const h = setTimeout( () => a(!0), 6e4);
            u(h)
        }
        return () => clearTimeout(l)
    }
    , [n]);
    const d = async () => {
        i(!0),
        a(!1);
        try {
            const h = await I5e({
                email: t,
                isPlay: !0
            });
            L7.success(h?.message || "Verification link resent!")
        } catch {
            L7.error("Failed to resend verification link.")
        } finally {
            i(!1);
            const h = setTimeout( () => a(!0), 60 * 1e3);
            u(h)
        }
    }
    ;
    return m.jsxs("div", {
        children: [m.jsx("div", {
            className: "bg-[#27364b] max-w-lg w-full rounded-3xl absolute top-12 left-0 right-0 mx-auto z-50 text-white overflow-hidden",
            children: m.jsxs("div", {
                className: "bg-[#2B3A4F] py-18 px-8 relative",
                children: [m.jsx("div", {
                    className: "cursor-pointer w-12 h-12 absolute right-1 top-1 flex items-center justify-center flex-col opacity-55",
                    onClick: e,
                    children: m.jsx("svg", {
                        xmlns: "http://www.w3.org/2000/svg",
                        fill: "none",
                        viewBox: "0 0 24 24",
                        strokeWidth: 1.5,
                        stroke: "currentColor",
                        className: "size-6",
                        children: m.jsx("path", {
                            strokeLinecap: "round",
                            strokeLinejoin: "round",
                            d: "M6 18 18 6M6 6l12 12"
                        })
                    })
                }), m.jsxs("div", {
                    className: "verify-email-address text-center",
                    children: [m.jsx("div", {
                        className: "mb-4",
                        children: m.jsx("img", {
                            src: rq,
                            alt: "verify",
                            className: "mx-auto"
                        })
                    }), r ? m.jsx("h3", {
                        className: "text-3xl font-medium mb-4",
                        children: "Reset Password"
                    }) : m.jsx("h3", {
                        className: "text-3xl font-medium mb-4",
                        children: "Verify your email address"
                    }), r ? m.jsxs("p", {
                        className: "text-sm font-light",
                        children: ["We've sent a password reset link to", " ", m.jsx("span", {
                            className: "inline-block text-[#FF6717]",
                            children: t
                        }), ". Please check your inbox and click on the link to reset your password."]
                    }) : m.jsxs("p", {
                        className: "text-sm font-light",
                        children: ["You've entered", " ", m.jsx("span", {
                            className: "inline-block text-[#FF6717]",
                            children: t
                        }), " as the email address for your account. Please verify this email address by clicking on the link sent in the email."]
                    }), m.jsx("div", {
                        className: "mt-8 text-center",
                        children: o && m.jsx("button", {
                            disabled: s,
                            onClick: d,
                            className: "cursor-pointer inline-flex items-center justify-between gap-3 btn-clr py-4 px-18 rounded-xl text-base font-semibold hover:brightness-90 hover:scale-[1.02] transition-all duration-200 disabled:opacity-60",
                            children: s ? "Sending..." : r ? "Resent Link" : "Resend Verification Link"
                        })
                    })]
                })]
            })
        }), m.jsx("div", {
            className: "fixed bg-black/70 w-full h-full top-0 left-0 z-40 backdrop-blur-lg"
        })]
    })
}
  , wAe = ({isOpen: n, onClose: e, email: t, setShowVerify: r}) => {
    const [s,i] = V.useState(t)
      , [o,a] = V.useState(!1)
      , l = h => {
        i(h.target.value)
    }
    ;
    V.useEffect( () => {
        t && i(t)
    }
    , [t]);
    const u = h => h && h.trim() !== "";
    if (!n)
        return null;
    const d = async () => {
        try {
            a(!0);
            const h = await M5e({
                email: s,
                isPlay: !0
            });
            if (h?.status === "success") {
                r(!0);
                return
            }
            Ze.error(h?.message)
        } catch {
            Ze.error("Failed to forget password.")
        } finally {
            a(!1)
        }
    }
    ;
    return m.jsxs("div", {
        className: "",
        children: [m.jsx("div", {
            className: "bg-[#27364b] max-w-md w-full rounded-3xl absolute top-12 left-0 right-0 mx-auto z-50 text-white overflow-hidden",
            children: m.jsxs("div", {
                className: "bg-brandGray p-8 relative",
                children: [m.jsx("h2", {
                    className: "text-2xl font-light mb-8",
                    children: "Forgot Password"
                }), m.jsx("div", {
                    className: "cursor-pointer w-12 h-12 absolute right-1 top-1 flex items-center justify-center flex-col opacity-55",
                    onClick: e,
                    children: m.jsx("svg", {
                        xmlns: "http://www.w3.org/2000/svg",
                        fill: "none",
                        viewBox: "0 0 24 24",
                        strokeWidth: 1.5,
                        stroke: "currentColor",
                        className: "size-6",
                        children: m.jsx("path", {
                            strokeLinecap: "round",
                            strokeLinejoin: "round",
                            d: "M6 18 18 6M6 6l12 12"
                        })
                    })
                }), m.jsx("div", {
                    className: "rounded-2xl mt-5",
                    children: m.jsxs("div", {
                        className: "relative mb-8",
                        children: [m.jsx("input", {
                            type: "email",
                            id: "EmailAddress",
                            name: "emailaddress",
                            placeholder: " ",
                            value: s,
                            onChange: l,
                            className: `peer w-full px-4 py-3 bg-transparent border-1 ${u(s) ? "border-orange-400" : "border-[#3F4E63]"} rounded-lg text-white text-base focus:outline-none focus:border-orange-400 transition-colors`
                        }), m.jsx("label", {
                            htmlFor: "oldpassword",
                            className: `absolute left-4 -top-3 text-sm bg-brandGray px-2 ${u(s) ? "text-orange-500" : "text-[#8FA1B8]"} peer-focus:text-orange-500 transition-all duration-200 pointer-events-none peer-placeholder-shown:top-3.5 peer-placeholder-shown:text-sm peer-focus:-top-3 peer-focus:text-sm`,
                            children: "Email Address"
                        })]
                    })
                }), m.jsx("div", {
                    className: "mt-8",
                    children: m.jsx("button", {
                        disabled: o,
                        onClick: d,
                        className: "cursor-pointer w-full gap-3 btn-clr py-4 px-5 rounded-xl text-base font-semibold hover:brightness-90 hover:scale-[1.02] transition-all duration-200",
                        children: o ? "Sending..." : "Send Reset Link"
                    })
                })]
            })
        }), m.jsx("div", {
            className: "fixed bg-black/70 w-full h-full top-0 left-0 z-40 backdrop-blur-lg"
        })]
    })
}
  , vAe = ({stage: n, email: e, setEmail: t, password: r, setPassword: s, setShowWalletLogin: i, setStage: o}) => {
    const [a,l] = V.useState("")
      , [u,d] = V.useState(!1)
      , [h,p] = V.useState(!1)
      , [g,w] = V.useState(!1)
      , [b,v] = V.useState(!1)
      , S = kr()
      , {refreshBalance: N, connectEmail: _, setEmailAddress: I} = Hs()
      , [k,B] = V.useState(!1);
    V.useState( () => {
        S0("passwordAlert") && B(!0)
    }
    , []);
    const P = async () => {
        try {
            if (v(!0),
            l(""),
            Hg("passwordAlert", !0),
            !e || !r) {
                l("Please enter email and password");
                return
            }
            const L = await _(e, r);
            L?.status || (L?.message === "Email not verified." ? (w(!1),
            d(!0)) : l("Invalid email or password"))
        } catch {} finally {
            v(!1)
        }
    }
      , M = async () => {
        if (!e)
            return l("Please enter email");
        const L = await R5e(e);
        if (L?.status === "failure") {
            if (L?.message === "Email not register.") {
                B(!0),
                S("/create-account", {
                    state: {
                        email: e
                    }
                });
                return
            }
            L?.message !== "Email exists." && B(!0),
            o("password")
        }
    }
      , R = L => L && L?.trim() !== "";
    return m.jsxs(m.Fragment, {
        children: [m.jsxs("div", {
            className: "lg:min-w-[400px] lg:px-3 text-center w-full",
            children: [m.jsx("h2", {
                className: "text-3xl md:text-4xl font-light mb-3 md:mb-5",
                children: "Login / Sign Up"
            }), m.jsx("p", {
                className: "text-sm font-light mb-12 md:mb-6",
                children: n === "email" ? "Enter email address to continue" : "Enter your password to continue"
            }), n === "email" && m.jsx(m.Fragment, {
                children: m.jsxs("div", {
                    className: "relative mb-4",
                    children: [m.jsx("input", {
                        type: "email",
                        id: "email",
                        value: e,
                        onChange: L => t(L.target.value),
                        placeholder: " ",
                        className: `peer w-full px-4 py-3 bg-[#192433] border-1 ${R(e) ? "border-orange-400" : "border-[#3F4E63]"} rounded-lg text-white text-base focus:outline-none focus:border-orange-400 transition-colors`
                    }), m.jsx("label", {
                        htmlFor: "email",
                        className: `absolute left-4 -top-3 text-sm bg-[#192433] px-2 ${R(e) ? "text-orange-500" : "text-[#8FA1B8]"} peer-focus:text-orange-500 transition-all duration-200 pointer-events-none peer-placeholder-shown:top-3.5 peer-placeholder-shown:text-sm peer-focus:-top-3.5 peer-focus:text-sm`,
                        children: "Email Address"
                    }), a && m.jsx("p", {
                        className: "text-red-400 text-left text-sm mt-2 mb-4",
                        children: a
                    })]
                })
            }), n === "password" && m.jsxs(m.Fragment, {
                children: [k ? "" : m.jsxs("p", {
                    className: "bg-yellow-600/20 text-yellow-500 font-medium py-2 px-2.5 rounded-lg mb-4 leading-normal",
                    children: ["Your email is already linked with your L1XApp account. ", m.jsx("br", {}), " Please enter your password to continue with the same account on L1XPlay."]
                }), m.jsxs("div", {
                    className: "relative mb-8",
                    children: [m.jsx("input", {
                        type: "password",
                        id: "password",
                        value: r,
                        onChange: L => s(L.target.value),
                        placeholder: " ",
                        className: `peer w-full px-4 py-3 bg-[#192433] border-1 ${R(r) ? "border-orange-400" : "border-[#3F4E63]"} rounded-lg text-white text-base focus:outline-none focus:border-orange-400 transition-colors`
                    }), m.jsx("label", {
                        htmlFor: "password",
                        className: `absolute left-4 -top-3 text-sm bg-[#192433] px-2 ${R(r) ? "text-orange-500" : "text-[#8FA1B8]"} peer-focus:text-orange-500 transition-all duration-200 pointer-events-none peer-placeholder-shown:top-3.5 peer-placeholder-shown:text-sm peer-focus:-top-3.5 peer-focus:text-sm`,
                        children: "Password"
                    }), a && m.jsx("p", {
                        className: "text-red-400 text-sm mb-4 text-left",
                        children: a
                    }), m.jsx("div", {
                        className: "flex flex-col items-end mt-3",
                        children: m.jsx("button", {
                            onClick: () => {
                                Hg("passwordAlert", !0),
                                p(!0)
                            }
                            ,
                            className: "underline hover:text-brandOrange",
                            children: "Forgot Password"
                        })
                    })]
                })]
            }), m.jsx("div", {
                className: "relative",
                children: n === "email" ? m.jsx("button", {
                    type: "button",
                    onClick: M,
                    className: "text-white rounded-lg brand-gradient-bg block font-medium py-4 px-3 md:px-10 text-xs md:text-base text-center w-full cursor-pointer",
                    children: "Continue"
                }) : m.jsx("button", {
                    type: "button",
                    disabled: b,
                    onClick: P,
                    className: "text-white rounded-lg brand-gradient-bg block font-medium py-4 px-3 md:px-10 text-xs md:text-base text-center w-full cursor-pointer",
                    children: b ? "Logging in..." : "Login"
                })
            }), m.jsxs("div", {
                className: "flex items-center justify-between my-5.5",
                children: [m.jsx("p", {
                    className: "text-txtGray",
                    children: "Dont have an account?"
                }), m.jsx(Us, {
                    to: "/create-account",
                    className: "underline hover:text-brandOrange",
                    children: "Create Account"
                })]
            }), m.jsxs("div", {
                className: "flex items-center text-txtGray my-11",
                children: [m.jsx("span", {
                    className: "h-[1px] bg-[#697F9B] mr-2 w-full"
                }), m.jsx("p", {
                    className: "whitespace-nowrap text-sm",
                    children: "Or login with Wallet"
                }), m.jsx("span", {
                    className: "h-[1px] bg-[#697F9B] ml-2 w-full"
                })]
            }), m.jsxs("div", {
                onClick: () => i(!0),
                className: "flex cursor-pointer bg-brandDeepDark border border-[#3F4E63] rounded-2xl overflow-hidden shadow-xl",
                children: [m.jsx("div", {
                    className: "bg-[#364559] px-4 text-center py-3",
                    children: m.jsx("img", {
                        src: SSe
                    })
                }), m.jsxs("div", {
                    className: "p-5 text-left",
                    children: [m.jsx("p", {
                        className: "text-[#BBC8D9] mb-1 font-light",
                        children: "Login with"
                    }), m.jsx("h3", {
                        className: "text-2xl font-semibold",
                        children: "Web3 Wallet"
                    })]
                })]
            })]
        }), m.jsx(sk, {
            forgetPassword: g,
            emailAddress: e,
            isOpen: u,
            onClose: () => d(!1)
        }), m.jsx(wAe, {
            email: e,
            isOpen: h,
            onClose: () => p(!1),
            setShowVerify: () => {
                w(!0),
                p(!1),
                d(!0)
            }
        })]
    })
}
;
function xAe() {
    const [n,e] = V.useState(Ji.getActiveAddress());
    return V.useEffect( () => {
        const t = r => {
            e(r.walletAddress)
        }
        ;
        return Ji.subscribe(t),
        () => {
            Ji.unsubscribe(t)
        }
    }
    , []),
    n
}
const EAe = () => {
    const [n,e] = V.useState("")
      , [t,r] = V.useState("")
      , [s,i] = V.useState("email")
      , [o,a] = V.useState(!1)
      , l = kr()
      , u = xAe();
    return V.useEffect( () => {
        u && l("/")
    }
    , [u]),
    m.jsxs("div", {
        className: "grid grid-cols-12 bg-login-img ",
        children: [m.jsx("div", {
            className: "col-span-12 md:col-span-7 xl:col-span-8 md:h-screen justify-center items-center bg-brandGray md:bg-transparent",
            children: m.jsxs("div", {
                className: "p-5",
                children: [m.jsx(Us, {
                    to: "/",
                    className: "mb-4 lg:mb-0 inline-block",
                    children: m.jsx("img", {
                        className: "w-20 md:w-auto",
                        src: _x
                    })
                }), m.jsx("div", {
                    className: "text-center flex-col justify-center items-center md:h-[calc(100vh-100px)]  md:flex",
                    children: m.jsxs("div", {
                        children: [m.jsx("img", {
                            src: $V,
                            className: "mx-auto mb-6 max-w-[100px] md:max-w-full"
                        }), m.jsx("h3", {
                            className: "text-2xl md:text-5xl font-semibold mb-2 md:mb-4",
                            children: "Ready to win?"
                        }), m.jsx("p", {
                            className: "text-sm md:text-lg font-light uppercase",
                            children: "Log in or sign up to get started"
                        })]
                    })
                })]
            })
        }), m.jsxs("div", {
            className: "col-span-12 w-full md:col-span-5 xl:col-span-4 bg-brandGray p-4 flex justify-center items-center md:h-screen mobile-height",
            children: [!o && m.jsx(vAe, {
                stage: s,
                setStage: i,
                email: n,
                setEmail: e,
                password: t,
                setPassword: r,
                setShowWalletLogin: a
            }), o && m.jsx(P5e, {
                setShowWalletLogin: a
            })]
        })]
    })
}
  , ri = "/assets/coin-star-Coqr70A3.svg"
  , SAe = "/assets/cybersecurity-concept-collage-design-BLqYxRUv.svg"
  , za = (n, e="info") => {
    switch (e) {
    case "success":
        Ze.success(n);
        break;
    case "error":
        Ze.error(n);
        break;
    case "warning":
        Ze.warning(n);
        break;
    default:
        Ze.info(n);
        break
    }
}
  , AAe = () => m.jsx(_5e, {
    position: "top-right",
    autoClose: 2500,
    hideProgressBar: !1,
    closeOnClick: !0,
    pauseOnHover: !0,
    draggable: !0,
    theme: "colored"
});
function CAe(n=[], e="", t="") {
    return n.find(r => r[e] === t)
}
async function _Ae(n, e) {
    const t = e === "USDT"
      , r = await k5e(n, e);
    if (r?.status !== "success")
        return {
            status: !1,
            rate: null,
            conversionId: null,
            sourceUsdRate: null
        };
    const s = r?.data
      , i = s?.[0]
      , o = tg(t ? Math.trunc(s?.[1]) : s?.[2])
      , a = tg(t ? s?.[2] : s?.[4])
      , l = tg(Math.trunc(s?.[1]));
    return {
        sourceUsdRate: o,
        conversionId: i,
        destinationUsdRate: a,
        sourceToDestConversion: l
    }
}
function tg(n, e=8) {
    try {
        if (n == null)
            throw new Error("Value is missing");
        const t = n.toString().trim();
        if (!/^\d+$/.test(t))
            throw new Error(`Invalid numeric input: "${t}"`);
        const r = Ov(t, e);
        return parseFloat(r)
    } catch {
        return 0
    }
}
function Q2(n) {
    const e = ["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown", "Backspace", "Tab", "Delete", "."];
    if (n.type === "keydown" && (!e.includes(n.key) && !/^\d$/.test(n.key) && n.preventDefault(),
    n.key === "." && n.target.value.includes(".") && n.preventDefault()),
    n.type === "paste") {
        const r = (n.clipboardData || window.clipboardData).getData("text").trim();
        /^\d*\.?\d*$/.test(r) || n.preventDefault(),
        r.includes(".") && n.target.value.includes(".") && n.preventDefault()
    }
}
function wn(n, e=4) {
    const t = Number(n);
    return !isNaN(t) && parseFloat(t) === t && t % 1 !== 0 ? parseFloat(t)?.toFixed(e) : t
}
function zo(n, e=5) {
    if (n?.length >= 8) {
        const t = n.substring(0, e)
          , r = n.substring(n.length - e);
        return `${t}...${r}`
    } else
        return n
}
function uq(n) {
    const e = new Date(n)
      , t = {
        day: "2-digit",
        month: "short",
        year: "numeric",
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit",
        hour12: !0,
        timeZone: "Asia/Kolkata"
    };
    return e.toLocaleString("en-GB", t).replace(",", " |")
}
const dq = async (n, e="Copied to clipboard!") => {
    try {
        if (!n)
            return za("Nothing to copy", "warning"),
            !1;
        if (navigator.clipboard && window.isSecureContext)
            return await navigator.clipboard.writeText(n),
            za(e, "success"),
            !0;
        const t = document.createElement("textarea");
        t.value = n,
        t.style.position = "fixed",
        t.style.left = "-999999px",
        t.style.top = "-999999px",
        document.body.appendChild(t),
        t.focus(),
        t.select();
        const r = document.execCommand("copy");
        if (t.remove(),
        r)
            return za(e, "success"),
            !0;
        throw new Error("Copy command failed")
    } catch (t) {
        return console.error("Failed to copy:", t),
        za("Failed to copy to clipboard", "error"),
        !1
    }
}
;
typeof window < "u" && (window.copyToClipboard = dq);
const kAe = (n, e=20) => n?.length > e ? n.substring(0, e - 3) + "..." : n
  , Af = (n, e=2) => n == null || isNaN(n) ? (console.error("safeToFixed: Invalid value provided", {
    value: n,
    decimals: e
}),
"0.00") : Number(n).toFixed(e)
  , F7 = async n => {
    try {
        if (typeof window < "u" && window.crypto?.subtle) {
            const e = new TextEncoder().encode(n)
              , t = await window.crypto.subtle.digest("SHA-256", e);
            return Array.from(new Uint8Array(t)).map(r => r.toString(16).padStart(2, "0")).join("")
        } else {
            const {createHash: e} = await g_(async () => {
                const {createHash: t} = await import("./__vite-browser-external-l0sNRNKZ.js");
                return {
                    createHash: t
                }
            }
            , []);
            return e("sha256").update(n).digest("hex")
        }
    } catch (e) {
        return console.error(" Error generating hash:", e),
        `error_${Date.now()}`
    }
}
  , fq = ({networkList: n, isOpen: e, onClose: t, depositData: r, setDepositData: s}) => {
    const {selectedToken: i, selectedNetwork: o} = r;
    if (!e)
        return null;
    const a = u => {
        if (i?.address === _c)
            s(d => ({
                ...d,
                selectedNetwork: u,
                selectedToken: u?.tokens?.[0],
                fromAmount: "",
                fromUsdAmount: "",
                toAmount: "",
                toUsdAmount: ""
            }));
        else {
            const d = CAe(u?.tokens, "tokenSymbol", i?.tokenSymbol);
            s(h => ({
                ...h,
                selectedNetwork: u,
                selectedToken: d,
                fromAmount: "",
                fromUsdAmount: "",
                toAmount: "",
                toUsdAmount: ""
            }))
        }
    }
      , l = u => {
        s(d => ({
            ...d,
            selectedToken: u
        })),
        t()
    }
    ;
    return m.jsxs("div", {
        className: "",
        children: [m.jsx("div", {
            className: "bg-[#27364b] md:max-w-xl md:w-full rounded-3xl absolute top-12 left-0 right-0 md:mx-auto z-[100] text-white overflow-hidden mx-4",
            children: m.jsxs("div", {
                className: "bg-[#27364b] p-5",
                children: [m.jsxs("div", {
                    className: "flex items-center justify-between",
                    children: [m.jsxs("div", {
                        className: "flex items-center gap-2.5",
                        children: [m.jsx("div", {
                            className: "cursor-pointer w-10 h-10 rounded-4xl flex items-center justify-center bg-[#44536b]",
                            children: m.jsx("svg", {
                                xmlns: "http://www.w3.org/2000/svg",
                                fill: "none",
                                viewBox: "0 0 24 24",
                                strokeWidth: 1.5,
                                stroke: "currentColor",
                                className: "size-6",
                                children: m.jsx("path", {
                                    strokeLinecap: "round",
                                    strokeLinejoin: "round",
                                    d: "M10.5 19.5 3 12m0 0 7.5-7.5M3 12h18"
                                })
                            })
                        }), m.jsx("h3", {
                            className: "text-3xl font-semibold",
                            children: "Swap"
                        })]
                    }), m.jsx("div", {
                        onClick: t,
                        className: "cursor-pointer w-12 h-12 flex items-center justify-center",
                        children: m.jsx("svg", {
                            xmlns: "http://www.w3.org/2000/svg",
                            fill: "none",
                            viewBox: "0 0 24 24",
                            strokeWidth: 1.5,
                            stroke: "currentColor",
                            className: "size-6",
                            children: m.jsx("path", {
                                strokeLinecap: "round",
                                strokeLinejoin: "round",
                                d: "M6 18 18 6M6 6l12 12"
                            })
                        })
                    })]
                }), m.jsxs("div", {
                    className: "relative my-6",
                    children: [m.jsx("input", {
                        placeholder: "Search Token",
                        className: "bg-[#121822] h-12 pl-3.5 pr-10 py-1.5 rounded-xl text-white text-sm w-full"
                    }), m.jsx("div", {
                        className: "absolute right-0 top-0 w-12 h-12 flex items-center flex-col justify-center",
                        children: m.jsx("svg", {
                            xmlns: "http://www.w3.org/2000/svg",
                            fill: "none",
                            viewBox: "0 0 24 24",
                            strokeWidth: 1.5,
                            stroke: "currentColor",
                            className: "size-6",
                            children: m.jsx("path", {
                                strokeLinecap: "round",
                                strokeLinejoin: "round",
                                d: "m21 21-5.197-5.197m0 0A7.5 7.5 0 1 0 5.196 5.196a7.5 7.5 0 0 0 10.607 10.607Z"
                            })
                        })
                    })]
                }), m.jsxs("div", {
                    className: "grid grid-cols-1 md:grid-cols-2",
                    children: [m.jsxs("div", {
                        className: " md:p-4 md:border-r md:border-[#3d4c61] mb-6 md:mb-0",
                        children: [m.jsx("h4", {
                            className: "font-semibold text-xl mb-2.5",
                            children: "Networks"
                        }), m.jsx("div", {
                            children: n?.map( (u, d) => {
                                if (u?.symbol !== "L1X")
                                    return m.jsxs("div", {
                                        onClick: () => a(u),
                                        className: `cursor-pointer py-2 px-4 rounded-xl relative flex items-center gap-3 mb-2 transition-colors duration-200 ${o === u?.name ? "bg-[#000000]" : "bg-[#313f53]"}`,
                                        children: [m.jsx("span", {
                                            children: m.jsx("img", {
                                                src: u?.icon,
                                                className: "w-6 h-6",
                                                alt: u?.name
                                            })
                                        }), m.jsx("h5", {
                                            children: u?.name
                                        }), o?.symbol === u?.symbol && m.jsx("span", {
                                            className: "absolute right-2 top-2",
                                            children: m.jsx("svg", {
                                                xmlns: "http://www.w3.org/2000/svg",
                                                fill: "none",
                                                viewBox: "0 0 24 24",
                                                strokeWidth: 1.5,
                                                stroke: "#ffffff",
                                                className: "size-6",
                                                children: m.jsx("path", {
                                                    strokeLinecap: "round",
                                                    strokeLinejoin: "round",
                                                    d: "m4.5 12.75 6 6 9-13.5"
                                                })
                                            })
                                        })]
                                    }, d)
                            }
                            )
                        })]
                    }), m.jsxs("div", {
                        className: "bg-[#27364b] md:p-4",
                        children: [m.jsx("h4", {
                            className: "font-semibold text-xl mb-2.5",
                            children: "Popular tokens"
                        }), m.jsx("div", {
                            children: o?.tokens?.map( (u, d) => m.jsxs("div", {
                                onClick: () => l(u),
                                className: `cursor-pointer py-2 px-4 rounded-xl relative flex items-center gap-3 mb-2 transition-colors duration-200 ${i === u.name ? "bg-[#000000]" : "bg-[#313f53]"}`,
                                children: [m.jsx("span", {
                                    children: m.jsx("img", {
                                        src: u?.icon,
                                        className: "w-6 h-6",
                                        alt: u?.tokenName
                                    })
                                }), m.jsx("h5", {
                                    children: u?.tokenName
                                }), i?.tokenSymbol === u?.tokenSymbol && m.jsx("span", {
                                    className: "absolute right-2 top-2",
                                    children: m.jsx("svg", {
                                        xmlns: "http://www.w3.org/2000/svg",
                                        fill: "none",
                                        viewBox: "0 0 24 24",
                                        strokeWidth: 1.5,
                                        stroke: "#ffffff",
                                        className: "size-6",
                                        children: m.jsx("path", {
                                            strokeLinecap: "round",
                                            strokeLinejoin: "round",
                                            d: "m4.5 12.75 6 6 9-13.5"
                                        })
                                    })
                                })]
                            }, d))
                        })]
                    })]
                })]
            })
        }), m.jsx("div", {
            className: "fixed bg-black/70 w-full h-full top-0 left-0 z-[99] backdrop-blur-md"
        })]
    })
}
  , ik = "/assets/successful-Cs1hN-dS.gif"
  , NAe = ({txHash: n, fromAmount: e, referrenceId: t, onClaimSuccess: r}) => {
    const [s,i] = V.useState(!1)
      , [o,a] = V.useState(!1)
      , l = Uo()
      , {walletAddress: u, balance: d, connectWallet: h, refreshBalance: p} = Hs()
      , g = async () => {
        try {
            i(!0);
            const w = {
                referenceId: t
            }
              , b = await l.executeV3("action");
            (await GV(w, b))?.status === "success" && (a(!0),
            p(),
            r && r())
        } catch {} finally {
            i(!1)
        }
    }
    ;
    return m.jsxs("div", {
        className: "text-center",
        children: [m.jsx("div", {
            children: m.jsx("img", {
                src: ik,
                className: "mx-auto"
            })
        }), m.jsx("h4", {
            className: "text-2xl font-medium mb-3",
            children: "Purchase Successful "
        }), m.jsxs("p", {
            className: "text-sm font-light",
            children: ["Your purchase of ", m.jsxs("span", {
                className: "font-semibold",
                children: [wn(e, 4), " L1XG"]
            }), " has been successfully credited to your account."]
        }), m.jsxs("div", {
            className: "inline-flex gap-3 items-center p-2 rounded-lg bg-[#1D2938] mx-auto mt-3",
            children: ["Transaction ID: ", zo(n), " ", m.jsx("span", {
                className: "cursor-pointer inline-block",
                children: m.jsx("svg", {
                    xmlns: "http://www.w3.org/2000/svg",
                    fill: "none",
                    viewBox: "0 0 24 24",
                    strokeWidth: 1.5,
                    stroke: "#73849B",
                    className: "size-6",
                    children: m.jsx("path", {
                        strokeLinecap: "round",
                        strokeLinejoin: "round",
                        d: "M16.5 8.25V6a2.25 2.25 0 0 0-2.25-2.25H6A2.25 2.25 0 0 0 3.75 6v8.25A2.25 2.25 0 0 0 6 16.5h2.25m8.25-8.25H18a2.25 2.25 0 0 1 2.25 2.25V18A2.25 2.25 0 0 1 18 20.25h-7.5A2.25 2.25 0 0 1 8.25 18v-1.5m8.25-8.25h-6a2.25 2.25 0 0 0-2.25 2.25v6"
                    })
                })
            })]
        }), m.jsx("div", {
            className: "h-[1px] bg-white/20 max-w-sm mx-auto my-8"
        }), o ? "" : m.jsxs("div", {
            children: [m.jsx("h5", {
                className: "text-2xl font-medium mb-3",
                children: "Claim your L1XP and start playing"
            }), m.jsx("div", {
                className: "text-center mb-7",
                children: m.jsx("button", {
                    onClick: g,
                    disabled: s,
                    className: "text-white rounded-4xl bg-gradient-to-r from-[#7900FF] to-[#FF6717] hover:from-[#FF6717] hover:to-[#FF6717] inline-flex gap-1 md:gap-2 items-center text-medium font-medium py-3 px-3 md:px-10 text-xs md:text-base",
                    children: s ? "Claiming..." : "Claim L1XP"
                })
            }), m.jsx("p", {
                className: "font-light text-sm/relaxed",
                children: "Youll instantly receive a portion of your L1XP. The remaining balance will stay locked and will unlock gradually as you complete actions or milestones in the app."
            })]
        })]
    })
}
  , DAe = ({isOpen: n, onClose: e, amount: t}) => n ? m.jsx("div", {
    className: "fixed inset-0 flex items-center justify-center z-50 backdrop-blur-lg bg-black/70",
    onClick: e,
    children: m.jsx("div", {
        className: "bg-[#27364b] max-w-md w-full rounded-3xl relative mx-4 z-50 text-white overflow-hidden",
        onClick: r => r.stopPropagation(),
        children: m.jsxs("div", {
            className: "bg-[#2B3A4F] p-8 relative",
            children: [m.jsx("div", {
                className: "cursor-pointer w-12 h-12 absolute right-1 top-1 flex items-center justify-center flex-col opacity-55",
                onClick: e,
                children: m.jsx("svg", {
                    xmlns: "http://www.w3.org/2000/svg",
                    fill: "none",
                    viewBox: "0 0 24 24",
                    strokeWidth: 1.5,
                    stroke: "currentColor",
                    className: "size-6",
                    children: m.jsx("path", {
                        strokeLinecap: "round",
                        strokeLinejoin: "round",
                        d: "M6 18 18 6M6 6l12 12"
                    })
                })
            }), m.jsxs("div", {
                className: "rounded-2xl mt-5",
                children: [m.jsx("div", {
                    children: m.jsx("img", {
                        src: ik,
                        className: "mx-auto"
                    })
                }), m.jsx("h2", {
                    className: "text-3xl font-medium text-center mb-4",
                    children: "Claim Successful!"
                }), m.jsx("div", {
                    className: "text-center p-4 rounded-2xl mt-5",
                    children: m.jsxs("div", {
                        className: "inline-flex p-4 rounded-2xl bg-[#1e293a] items-center justify-center gap-3",
                        children: [" ", m.jsxs("h3", {
                            className: "flex items-center gap-3 text-4xl font-bold",
                            children: [m.jsx("img", {
                                src: ri
                            }), " ", t]
                        }), " ", m.jsx("h4", {
                            className: "text-4xl font-normal",
                            children: "L1XP"
                        })]
                    })
                })]
            }), m.jsx("div", {
                className: "mt-8",
                children: m.jsx("button", {
                    onClick: e,
                    className: "cursor-pointer w-full gap-3 py-4 px-5 rounded-xl text-base font-semibold hover:brightness-90 hover:scale-[1.02] transition-all duration-200 bg-[#46576f]",
                    children: "Close"
                })
            })]
        })
    })
}) : null
  , Lp = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__
  , td = globalThis
  , Rg = "10.23.0";
function ok() {
    return ak(td),
    td
}
function ak(n) {
    const e = n.__SENTRY__ = n.__SENTRY__ || {};
    return e.version = e.version || Rg,
    e[Rg] = e[Rg] || {}
}
function lk(n, e, t=td) {
    const r = t.__SENTRY__ = t.__SENTRY__ || {}
      , s = r[Rg] = r[Rg] || {};
    return s[n] || (s[n] = e())
}
const TAe = "Sentry Logger "
  , U7 = {};
function IAe(n) {
    if (!("console"in td))
        return n();
    const e = td.console
      , t = {}
      , r = Object.keys(U7);
    r.forEach(s => {
        const i = U7[s];
        t[s] = e[s],
        e[s] = i
    }
    );
    try {
        return n()
    } finally {
        r.forEach(s => {
            e[s] = t[s]
        }
        )
    }
}
function MAe() {
    uk().enabled = !0
}
function BAe() {
    uk().enabled = !1
}
function hq() {
    return uk().enabled
}
function RAe(...n) {
    ck("log", ...n)
}
function OAe(...n) {
    ck("warn", ...n)
}
function PAe(...n) {
    ck("error", ...n)
}
function ck(n, ...e) {
    Lp && hq() && IAe( () => {
        td.console[n](`${TAe}[${n}]:`, ...e)
    }
    )
}
function uk() {
    return Lp ? lk("loggerSettings", () => ({
        enabled: !1
    })) : {
        enabled: !1
    }
}
const Xw = {
    enable: MAe,
    disable: BAe,
    isEnabled: hq,
    log: RAe,
    warn: OAe,
    error: PAe
}
  , jAe = Object.prototype.toString;
function LAe(n, e) {
    return jAe.call(n) === `[object ${e}]`
}
function FAe(n) {
    return LAe(n, "Object")
}
function UAe(n) {
    return !!(n?.then && typeof n.then == "function")
}
function zAe(n, e=0) {
    return typeof n != "string" || e === 0 || n.length <= e ? n : `${n.slice(0, e)}...`
}
function $Ae(n, e, t) {
    try {
        Object.defineProperty(n, e, {
            value: t,
            writable: !0,
            configurable: !0
        })
    } catch {
        Lp && Xw.log(`Failed to add non-enumerable property "${e}" to object`, n)
    }
}
function HAe() {
    const n = td;
    return n.crypto || n.msCrypto
}
let mA;
function VAe() {
    return Math.random() * 16
}
function Og(n=HAe()) {
    try {
        if (n?.randomUUID)
            return n.randomUUID().replace(/-/g, "")
    } catch {}
    return mA || (mA = "10000000100040008000" + 1e11),
    mA.replace(/[018]/g, e => (e ^ (VAe() & 15) >> e / 4).toString(16))
}
const pq = 1e3;
function mq() {
    return Date.now() / pq
}
function qAe() {
    const {performance: n} = td;
    if (!n?.now || !n.timeOrigin)
        return mq;
    const e = n.timeOrigin;
    return () => (e + n.now()) / pq
}
let z7;
function GAe() {
    return (z7 ?? (z7 = qAe()))()
}
function WAe(n, e={}) {
    if (e.user && (!n.ipAddress && e.user.ip_address && (n.ipAddress = e.user.ip_address),
    !n.did && !e.did && (n.did = e.user.id || e.user.email || e.user.username)),
    n.timestamp = e.timestamp || GAe(),
    e.abnormal_mechanism && (n.abnormal_mechanism = e.abnormal_mechanism),
    e.ignoreDuration && (n.ignoreDuration = e.ignoreDuration),
    e.sid && (n.sid = e.sid.length === 32 ? e.sid : Og()),
    e.init !== void 0 && (n.init = e.init),
    !n.did && e.did && (n.did = `${e.did}`),
    typeof e.started == "number" && (n.started = e.started),
    n.ignoreDuration)
        n.duration = void 0;
    else if (typeof e.duration == "number")
        n.duration = e.duration;
    else {
        const t = n.timestamp - n.started;
        n.duration = t >= 0 ? t : 0
    }
    e.release && (n.release = e.release),
    e.environment && (n.environment = e.environment),
    !n.ipAddress && e.ipAddress && (n.ipAddress = e.ipAddress),
    !n.userAgent && e.userAgent && (n.userAgent = e.userAgent),
    typeof e.errors == "number" && (n.errors = e.errors),
    e.status && (n.status = e.status)
}
function gq(n, e, t=2) {
    if (!e || typeof e != "object" || t <= 0)
        return e;
    if (n && Object.keys(e).length === 0)
        return n;
    const r = {
        ...n
    };
    for (const s in e)
        Object.prototype.hasOwnProperty.call(e, s) && (r[s] = gq(r[s], e[s], t - 1));
    return r
}
function $7() {
    return Og()
}
const qC = "_sentrySpan";
function H7(n, e) {
    e ? $Ae(n, qC, e) : delete n[qC]
}
function V7(n) {
    return n[qC]
}
const YAe = 100;
class nd {
    constructor() {
        this._notifyingListeners = !1,
        this._scopeListeners = [],
        this._eventProcessors = [],
        this._breadcrumbs = [],
        this._attachments = [],
        this._user = {},
        this._tags = {},
        this._extra = {},
        this._contexts = {},
        this._sdkProcessingMetadata = {},
        this._propagationContext = {
            traceId: $7(),
            sampleRand: Math.random()
        }
    }
    clone() {
        const e = new nd;
        return e._breadcrumbs = [...this._breadcrumbs],
        e._tags = {
            ...this._tags
        },
        e._extra = {
            ...this._extra
        },
        e._contexts = {
            ...this._contexts
        },
        this._contexts.flags && (e._contexts.flags = {
            values: [...this._contexts.flags.values]
        }),
        e._user = this._user,
        e._level = this._level,
        e._session = this._session,
        e._transactionName = this._transactionName,
        e._fingerprint = this._fingerprint,
        e._eventProcessors = [...this._eventProcessors],
        e._attachments = [...this._attachments],
        e._sdkProcessingMetadata = {
            ...this._sdkProcessingMetadata
        },
        e._propagationContext = {
            ...this._propagationContext
        },
        e._client = this._client,
        e._lastEventId = this._lastEventId,
        H7(e, V7(this)),
        e
    }
    setClient(e) {
        this._client = e
    }
    setLastEventId(e) {
        this._lastEventId = e
    }
    getClient() {
        return this._client
    }
    lastEventId() {
        return this._lastEventId
    }
    addScopeListener(e) {
        this._scopeListeners.push(e)
    }
    addEventProcessor(e) {
        return this._eventProcessors.push(e),
        this
    }
    setUser(e) {
        return this._user = e || {
            email: void 0,
            id: void 0,
            ip_address: void 0,
            username: void 0
        },
        this._session && WAe(this._session, {
            user: e
        }),
        this._notifyScopeListeners(),
        this
    }
    getUser() {
        return this._user
    }
    setTags(e) {
        return this._tags = {
            ...this._tags,
            ...e
        },
        this._notifyScopeListeners(),
        this
    }
    setTag(e, t) {
        return this._tags = {
            ...this._tags,
            [e]: t
        },
        this._notifyScopeListeners(),
        this
    }
    setExtras(e) {
        return this._extra = {
            ...this._extra,
            ...e
        },
        this._notifyScopeListeners(),
        this
    }
    setExtra(e, t) {
        return this._extra = {
            ...this._extra,
            [e]: t
        },
        this._notifyScopeListeners(),
        this
    }
    setFingerprint(e) {
        return this._fingerprint = e,
        this._notifyScopeListeners(),
        this
    }
    setLevel(e) {
        return this._level = e,
        this._notifyScopeListeners(),
        this
    }
    setTransactionName(e) {
        return this._transactionName = e,
        this._notifyScopeListeners(),
        this
    }
    setContext(e, t) {
        return t === null ? delete this._contexts[e] : this._contexts[e] = t,
        this._notifyScopeListeners(),
        this
    }
    setSession(e) {
        return e ? this._session = e : delete this._session,
        this._notifyScopeListeners(),
        this
    }
    getSession() {
        return this._session
    }
    update(e) {
        if (!e)
            return this;
        const t = typeof e == "function" ? e(this) : e
          , r = t instanceof nd ? t.getScopeData() : FAe(t) ? e : void 0
          , {tags: s, extra: i, user: o, contexts: a, level: l, fingerprint: u=[], propagationContext: d} = r || {};
        return this._tags = {
            ...this._tags,
            ...s
        },
        this._extra = {
            ...this._extra,
            ...i
        },
        this._contexts = {
            ...this._contexts,
            ...a
        },
        o && Object.keys(o).length && (this._user = o),
        l && (this._level = l),
        u.length && (this._fingerprint = u),
        d && (this._propagationContext = d),
        this
    }
    clear() {
        return this._breadcrumbs = [],
        this._tags = {},
        this._extra = {},
        this._user = {},
        this._contexts = {},
        this._level = void 0,
        this._transactionName = void 0,
        this._fingerprint = void 0,
        this._session = void 0,
        H7(this, void 0),
        this._attachments = [],
        this.setPropagationContext({
            traceId: $7(),
            sampleRand: Math.random()
        }),
        this._notifyScopeListeners(),
        this
    }
    addBreadcrumb(e, t) {
        const r = typeof t == "number" ? t : YAe;
        if (r <= 0)
            return this;
        const s = {
            timestamp: mq(),
            ...e,
            message: e.message ? zAe(e.message, 2048) : e.message
        };
        return this._breadcrumbs.push(s),
        this._breadcrumbs.length > r && (this._breadcrumbs = this._breadcrumbs.slice(-r),
        this._client?.recordDroppedEvent("buffer_overflow", "log_item")),
        this._notifyScopeListeners(),
        this
    }
    getLastBreadcrumb() {
        return this._breadcrumbs[this._breadcrumbs.length - 1]
    }
    clearBreadcrumbs() {
        return this._breadcrumbs = [],
        this._notifyScopeListeners(),
        this
    }
    addAttachment(e) {
        return this._attachments.push(e),
        this
    }
    clearAttachments() {
        return this._attachments = [],
        this
    }
    getScopeData() {
        return {
            breadcrumbs: this._breadcrumbs,
            attachments: this._attachments,
            contexts: this._contexts,
            tags: this._tags,
            extra: this._extra,
            user: this._user,
            level: this._level,
            fingerprint: this._fingerprint || [],
            eventProcessors: this._eventProcessors,
            propagationContext: this._propagationContext,
            sdkProcessingMetadata: this._sdkProcessingMetadata,
            transactionName: this._transactionName,
            span: V7(this)
        }
    }
    setSDKProcessingMetadata(e) {
        return this._sdkProcessingMetadata = gq(this._sdkProcessingMetadata, e, 2),
        this
    }
    setPropagationContext(e) {
        return this._propagationContext = e,
        this
    }
    getPropagationContext() {
        return this._propagationContext
    }
    captureException(e, t) {
        const r = t?.event_id || Og();
        if (!this._client)
            return Lp && Xw.warn("No client configured on scope - will not capture exception!"),
            r;
        const s = new Error("Sentry syntheticException");
        return this._client.captureException(e, {
            originalException: e,
            syntheticException: s,
            ...t,
            event_id: r
        }, this),
        r
    }
    captureMessage(e, t, r) {
        const s = r?.event_id || Og();
        if (!this._client)
            return Lp && Xw.warn("No client configured on scope - will not capture message!"),
            s;
        const i = new Error(e);
        return this._client.captureMessage(e, t, {
            originalException: e,
            syntheticException: i,
            ...r,
            event_id: s
        }, this),
        s
    }
    captureEvent(e, t) {
        const r = t?.event_id || Og();
        return this._client ? (this._client.captureEvent(e, {
            ...t,
            event_id: r
        }, this),
        r) : (Lp && Xw.warn("No client configured on scope - will not capture event!"),
        r)
    }
    _notifyScopeListeners() {
        this._notifyingListeners || (this._notifyingListeners = !0,
        this._scopeListeners.forEach(e => {
            e(this)
        }
        ),
        this._notifyingListeners = !1)
    }
}
function KAe() {
    return lk("defaultCurrentScope", () => new nd)
}
function XAe() {
    return lk("defaultIsolationScope", () => new nd)
}
class QAe {
    constructor(e, t) {
        let r;
        e ? r = e : r = new nd;
        let s;
        t ? s = t : s = new nd,
        this._stack = [{
            scope: r
        }],
        this._isolationScope = s
    }
    withScope(e) {
        const t = this._pushScope();
        let r;
        try {
            r = e(t)
        } catch (s) {
            throw this._popScope(),
            s
        }
        return UAe(r) ? r.then(s => (this._popScope(),
        s), s => {
            throw this._popScope(),
            s
        }
        ) : (this._popScope(),
        r)
    }
    getClient() {
        return this.getStackTop().client
    }
    getScope() {
        return this.getStackTop().scope
    }
    getIsolationScope() {
        return this._isolationScope
    }
    getStackTop() {
        return this._stack[this._stack.length - 1]
    }
    _pushScope() {
        const e = this.getScope().clone();
        return this._stack.push({
            client: this.getClient(),
            scope: e
        }),
        e
    }
    _popScope() {
        return this._stack.length <= 1 ? !1 : !!this._stack.pop()
    }
}
function a0() {
    const n = ok()
      , e = ak(n);
    return e.stack = e.stack || new QAe(KAe(),XAe())
}
function ZAe(n) {
    return a0().withScope(n)
}
function JAe(n, e) {
    const t = a0();
    return t.withScope( () => (t.getStackTop().scope = n,
    e(n)))
}
function q7(n) {
    return a0().withScope( () => n(a0().getIsolationScope()))
}
function e4e() {
    return {
        withIsolationScope: q7,
        withScope: ZAe,
        withSetScope: JAe,
        withSetIsolationScope: (n, e) => q7(e),
        getCurrentScope: () => a0().getScope(),
        getIsolationScope: () => a0().getIsolationScope()
    }
}
function yq(n) {
    const e = ak(n);
    return e.acs ? e.acs : e4e()
}
function bq() {
    const n = ok();
    return yq(n).getCurrentScope()
}
function dk() {
    const n = ok();
    return yq(n).getIsolationScope()
}
function t4e(n) {
    if (n)
        return n4e(n) ? {
            captureContext: n
        } : s4e(n) ? {
            captureContext: n
        } : n
}
function n4e(n) {
    return n instanceof nd || typeof n == "function"
}
const r4e = ["user", "level", "extra", "contexts", "tags", "fingerprint", "propagationContext"];
function s4e(n) {
    return Object.keys(n).some(e => r4e.includes(e))
}
function i4e(n, e) {
    return bq().captureException(n, t4e(e))
}
function o4e(n, e) {
    const t = typeof e == "string" ? e : void 0
      , r = typeof e != "string" ? {
        captureContext: e
    } : void 0;
    return bq().captureMessage(n, t, r)
}
function a4e(n, e) {
    dk().setContext(n, e)
}
function G7(n, e) {
    dk().setTag(n, e)
}
function W7(n) {
    dk().setUser(n)
}
const eh = new rt("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA")
  , Y7 = new rt("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb")
  , fk = new rt("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");
new rt("So11111111111111111111111111111111111111112");
new rt("9pan9bMn5HatX4EJdBwg9VgCa7Uz5HL8N1m5D3NdXejP");
const hk = n => {
    const e = n.decode.bind(n)
      , t = n.encode.bind(n);
    return {
        decode: e,
        encode: t
    }
}
;
var Pd = {}, K7;
function l4e() {
    if (K7)
        return Pd;
    K7 = 1,
    Object.defineProperty(Pd, "__esModule", {
        value: !0
    });
    function n(s) {
        {
            const i = Buffer.from(s);
            i.reverse();
            const o = i.toString("hex");
            return o.length === 0 ? BigInt(0) : BigInt(`0x${o}`)
        }
    }
    Pd.toBigIntLE = n;
    function e(s) {
        {
            const i = s.toString("hex");
            return i.length === 0 ? BigInt(0) : BigInt(`0x${i}`)
        }
    }
    Pd.toBigIntBE = e;
    function t(s, i) {
        {
            const o = s.toString(16)
              , a = Buffer.from(o.padStart(i * 2, "0").slice(0, i * 2), "hex");
            return a.reverse(),
            a
        }
    }
    Pd.toBufferLE = t;
    function r(s, i) {
        {
            const o = s.toString(16);
            return Buffer.from(o.padStart(i * 2, "0").slice(0, i * 2), "hex")
        }
    }
    return Pd.toBufferBE = r,
    Pd
}
var X7 = l4e();
const c4e = n => e => {
    const t = oe.blob(n, e)
      , {encode: r, decode: s} = hk(t)
      , i = t;
    return i.decode = (o, a) => {
        const l = s(o, a);
        return X7.toBigIntLE(Buffer.from(l))
    }
    ,
    i.encode = (o, a, l) => {
        const u = X7.toBufferLE(o, n);
        return r(u, a, l)
    }
    ,
    i
}
  , Pg = c4e(8)
  , wq = n => {
    const e = oe.u8(n)
      , {encode: t, decode: r} = hk(e)
      , s = e;
    return s.decode = (i, o) => !!r(i, o),
    s.encode = (i, o, a) => {
        const l = Number(i);
        return t(l, o, a)
    }
    ,
    s
}
  , ys = n => {
    const e = oe.blob(32, n)
      , {encode: t, decode: r} = hk(e)
      , s = e;
    return s.decode = (i, o) => {
        const a = r(i, o);
        return new rt(a)
    }
    ,
    s.encode = (i, o, a) => {
        const l = i.toBuffer();
        return t(l, o, a)
    }
    ,
    s
}
;
class Jy extends Error {
    constructor(e) {
        super(e)
    }
}
class u4e extends Jy {
    constructor() {
        super(...arguments),
        this.name = "TokenAccountNotFoundError"
    }
}
class d4e extends Jy {
    constructor() {
        super(...arguments),
        this.name = "TokenInvalidAccountOwnerError"
    }
}
class gA extends Jy {
    constructor() {
        super(...arguments),
        this.name = "TokenInvalidAccountSizeError"
    }
}
class f4e extends Jy {
    constructor() {
        super(...arguments),
        this.name = "TokenInvalidMintError"
    }
}
class h4e extends Jy {
    constructor() {
        super(...arguments),
        this.name = "TokenOwnerOffCurveError"
    }
}
var GC;
(function(n) {
    n[n.InitializeMint = 0] = "InitializeMint",
    n[n.InitializeAccount = 1] = "InitializeAccount",
    n[n.InitializeMultisig = 2] = "InitializeMultisig",
    n[n.Transfer = 3] = "Transfer",
    n[n.Approve = 4] = "Approve",
    n[n.Revoke = 5] = "Revoke",
    n[n.SetAuthority = 6] = "SetAuthority",
    n[n.MintTo = 7] = "MintTo",
    n[n.Burn = 8] = "Burn",
    n[n.CloseAccount = 9] = "CloseAccount",
    n[n.FreezeAccount = 10] = "FreezeAccount",
    n[n.ThawAccount = 11] = "ThawAccount",
    n[n.TransferChecked = 12] = "TransferChecked",
    n[n.ApproveChecked = 13] = "ApproveChecked",
    n[n.MintToChecked = 14] = "MintToChecked",
    n[n.BurnChecked = 15] = "BurnChecked",
    n[n.InitializeAccount2 = 16] = "InitializeAccount2",
    n[n.SyncNative = 17] = "SyncNative",
    n[n.InitializeAccount3 = 18] = "InitializeAccount3",
    n[n.InitializeMultisig2 = 19] = "InitializeMultisig2",
    n[n.InitializeMint2 = 20] = "InitializeMint2",
    n[n.GetAccountDataSize = 21] = "GetAccountDataSize",
    n[n.InitializeImmutableOwner = 22] = "InitializeImmutableOwner",
    n[n.AmountToUiAmount = 23] = "AmountToUiAmount",
    n[n.UiAmountToAmount = 24] = "UiAmountToAmount",
    n[n.InitializeMintCloseAuthority = 25] = "InitializeMintCloseAuthority",
    n[n.TransferFeeExtension = 26] = "TransferFeeExtension",
    n[n.ConfidentialTransferExtension = 27] = "ConfidentialTransferExtension",
    n[n.DefaultAccountStateExtension = 28] = "DefaultAccountStateExtension",
    n[n.Reallocate = 29] = "Reallocate",
    n[n.MemoTransferExtension = 30] = "MemoTransferExtension",
    n[n.CreateNativeMint = 31] = "CreateNativeMint",
    n[n.InitializeNonTransferableMint = 32] = "InitializeNonTransferableMint",
    n[n.InterestBearingMintExtension = 33] = "InterestBearingMintExtension",
    n[n.CpiGuardExtension = 34] = "CpiGuardExtension",
    n[n.InitializePermanentDelegate = 35] = "InitializePermanentDelegate",
    n[n.TransferHookExtension = 36] = "TransferHookExtension",
    n[n.MetadataPointerExtension = 39] = "MetadataPointerExtension",
    n[n.GroupPointerExtension = 40] = "GroupPointerExtension",
    n[n.GroupMemberPointerExtension = 41] = "GroupMemberPointerExtension",
    n[n.ScaledUiAmountExtension = 43] = "ScaledUiAmountExtension",
    n[n.PausableExtension = 44] = "PausableExtension"
}
)(GC || (GC = {}));
var WC;
(function(n) {
    n[n.Uninitialized = 0] = "Uninitialized",
    n[n.Mint = 1] = "Mint",
    n[n.Account = 2] = "Account"
}
)(WC || (WC = {}));
const p4e = 1
  , m4e = oe.struct([oe.u8("m"), oe.u8("n"), wq("isInitialized"), ys("signer1"), ys("signer2"), ys("signer3"), ys("signer4"), ys("signer5"), ys("signer6"), ys("signer7"), ys("signer8"), ys("signer9"), ys("signer10"), ys("signer11")])
  , g4e = m4e.span;
var Q7;
(function(n) {
    n[n.Uninitialized = 0] = "Uninitialized",
    n[n.Initialized = 1] = "Initialized",
    n[n.Frozen = 2] = "Frozen"
}
)(Q7 || (Q7 = {}));
const y4e = oe.struct([ys("mint"), ys("owner"), Pg("amount"), oe.u32("delegateOption"), ys("delegate"), oe.u8("state"), oe.u32("isNativeOption"), Pg("isNative"), Pg("delegatedAmount"), oe.u32("closeAuthorityOption"), ys("closeAuthority")])
  , yA = y4e.span;
function b4e(n, e, t) {
    if (t.length) {
        n.push({
            pubkey: e,
            isSigner: !1,
            isWritable: !1
        });
        for (const r of t)
            n.push({
                pubkey: r instanceof rt ? r : r.publicKey,
                isSigner: !0,
                isWritable: !1
            })
    } else
        n.push({
            pubkey: e,
            isSigner: !0,
            isWritable: !1
        });
    return n
}
const vq = oe.struct([oe.u32("mintAuthorityOption"), ys("mintAuthority"), Pg("supply"), oe.u8("decimals"), wq("isInitialized"), oe.u32("freezeAuthorityOption"), ys("freezeAuthority")])
  , bA = vq.span;
async function w4e(n, e, t, r=eh) {
    const s = await n.getAccountInfo(e, t);
    return v4e(e, s, r)
}
function v4e(n, e, t=eh) {
    if (!e)
        throw new u4e;
    if (!e.owner.equals(t))
        throw new d4e;
    if (e.data.length < bA)
        throw new gA;
    const r = vq.decode(e.data.slice(0, bA));
    let s = Buffer.alloc(0);
    if (e.data.length > bA) {
        if (e.data.length <= yA)
            throw new gA;
        if (e.data.length === g4e)
            throw new gA;
        if (e.data[yA] != WC.Mint)
            throw new f4e;
        s = e.data.slice(yA + p4e)
    }
    return {
        address: n,
        mintAuthority: r.mintAuthorityOption ? r.mintAuthority : null,
        supply: r.supply,
        decimals: r.decimals,
        isInitialized: r.isInitialized,
        freezeAuthority: r.freezeAuthorityOption ? r.freezeAuthority : null,
        tlvData: s
    }
}
async function Z7(n, e, t=!1, r=eh, s=fk) {
    if (!t && !rt.isOnCurve(e.toBuffer()))
        throw new h4e;
    const [i] = await rt.findProgramAddress([e.toBuffer(), r.toBuffer(), n.toBuffer()], s);
    return i
}
function x4e(n, e, t, r, s=eh, i=fk) {
    return E4e(n, e, t, r, Buffer.alloc(0), s, i)
}
function E4e(n, e, t, r, s, i=eh, o=fk) {
    const a = [{
        pubkey: n,
        isSigner: !0,
        isWritable: !0
    }, {
        pubkey: e,
        isSigner: !1,
        isWritable: !0
    }, {
        pubkey: t,
        isSigner: !1,
        isWritable: !1
    }, {
        pubkey: r,
        isSigner: !1,
        isWritable: !1
    }, {
        pubkey: s0.programId,
        isSigner: !1,
        isWritable: !1
    }, {
        pubkey: i,
        isSigner: !1,
        isWritable: !1
    }];
    return new Gi({
        keys: a,
        programId: o,
        data: s
    })
}
const J7 = oe.struct([oe.u8("instruction"), Pg("amount")]);
function S4e(n, e, t, r, s=[], i=eh) {
    const o = b4e([{
        pubkey: n,
        isSigner: !1,
        isWritable: !0
    }, {
        pubkey: e,
        isSigner: !1,
        isWritable: !0
    }], t, s)
      , a = Buffer.alloc(J7.span);
    return J7.encode({
        instruction: GC.Transfer,
        amount: BigInt(r)
    }, a),
    new Gi({
        keys: o,
        programId: i,
        data: a
    })
}
async function A4e(n, e, t) {
    try {
        if (!Df(n))
            return {
                status: !1,
                message: "Invalid recepient address"
            };
        let r;
        if (t === "walletconnect" || t === jr.WalletConnect) {
            const o = Ji.getProvider("walletconnect");
            if (!o)
                throw new Error("WalletConnect provider not initialised");
            r = new Ys(o)
        } else if (t === jr.Metamask || t === jr.TrustWallet) {
            if (!window.ethereum)
                throw new Error("Ethereum provider not found");
            r = new Ys(window.ethereum)
        } else if (t === jr.CtrlWallet) {
            if (!window.ethereum)
                throw new Error("Ethereum provider not found");
            r = new Ys(window.ethereum)
        } else {
            if (!window.ethereum)
                throw new Error(`Unsupported wallet type: ${t}`);
            console.warn(` Using default window.ethereum for walletType: ${t}`),
            r = new Ys(window.ethereum)
        }
        if (!r)
            throw new Error("Provider not initialized");
        const i = await (await r.getSigner()).sendTransaction({
            to: n,
            value: BZ(String(e))
        });
        return await i.wait(),
        {
            status: !0,
            txHash: i.hash,
            message: "Native transfer successful."
        }
    } catch (r) {
        return console.error(" Failed to transfer native EVM:", r),
        {
            status: !1,
            txHash: null,
            message: of(r)?.message || "Native transfer failed."
        }
    }
}
async function C4e(n, e, t, r) {
    try {
        if (!Df(t) || !Df(e))
            throw new Error("Invalid address");
        const s = ["function decimals() view returns (uint8)", "function balanceOf(address) view returns (uint)", "function transfer(address to, uint amount) returns (bool)"]
          , i = new Ro(e,s,n)
          , o = await n.getAddress()
          , a = await i.decimals()
          , l = A0(String(r), a)
          , u = await i.transfer(t, l);
        return await u.wait(),
        {
            status: !0,
            txHash: u?.hash,
            message: "Transfer complete successfully"
        }
    } catch (s) {
        return console.error(" transferERC20Token ~ Error:", s),
        {
            status: !1,
            txHash: null,
            message: of(s?.message)?.message || s?.message || "Transfer failed"
        }
    }
}
async function eP(n) {
    try {
        if (n === "11111111111111111111111111111111" || ["So", "AToken", "Tokenk", "Stake", "Vote", "ComputeBudget", "SysvarRent", "SysvarC1ock", "SysvarRecentB1ockHashes"].some(s => n.startsWith(s)))
            return !1;
        let t = new rt(n);
        return rt.isOnCurve(t.toBytes())
    } catch {
        return !1
    }
}
async function _4e(n, e, t, r, s) {
    try {
        const i = new p_(r,"confirmed")
          , o = new sa().add(s0.transfer({
            fromPubkey: new rt(n),
            toPubkey: new rt(e),
            lamports: Math.floor(Number(t) * 1e9)
        }));
        o.feePayer = new rt(n);
        const {blockhash: a, lastValidBlockHeight: l} = await i.getLatestBlockhash();
        o.recentBlockhash = a;
        const u = await s.signTransaction(o)
          , d = await i.sendRawTransaction(u.serialize(), {
            skipPreflight: !1,
            preflightCommitment: "confirmed"
        });
        let h;
        try {
            h = await i.confirmTransaction({
                signature: d,
                blockhash: a,
                lastValidBlockHeight: l
            }, "confirmed")
        } catch {
            console.warn("Timeout, checking status manually..."),
            h = (await i.getSignatureStatus(d)).value
        }
        return h && h.err == null ? {
            status: !0,
            txHash: d,
            message: " SOL transfer successful."
        } : {
            status: !1,
            txHash: d,
            message: " Transaction may have failed. Please verify manually."
        }
    } catch (i) {
        return console.error("Failed to transfer SOL:", i),
        {
            status: !1,
            txHash: null,
            message: i.message || "SOL transfer failed."
        }
    }
}
async function k4e({rpc: n, mint: e, fromAddress: t, toAddress: r, amount: s, signer: i=window.solana}) {
    const o = new p_(n,"confirmed")
      , a = new rt(t)
      , l = new rt(r)
      , u = new rt(e);
    try {
        const d = await o.getAccountInfo(u);
        if (!d?.owner)
            throw new Error(`Mint not found on RPC  ${e}`);
        const h = d.owner.equals(Y7) ? Y7 : eh;
        let p = null;
        try {
            p = await w4e(o, u, void 0, h)
        } catch {
            throw new Error("Invalid mint account or RPC returned incomplete data")
        }
        const g = await Z7(u, a, !1, h)
          , w = await Z7(u, l, !1, h)
          , b = [];
        await o.getAccountInfo(w) || b.push(x4e(a, w, l, u, h));
        const S = typeof p?.decimals == "number" ? p.decimals : 0
          , N = Number(s);
        if (!Number.isFinite(N))
            throw new Error("Invalid transfer amount specified");
        const _ = BigInt(Math.round(N * 10 ** S));
        b.push(S4e(g, w, a, _, [], h));
        const I = new sa().add(...b);
        I.feePayer = a;
        const {blockhash: k, lastValidBlockHeight: B} = await o.getLatestBlockhash();
        I.recentBlockhash = k;
        const P = await i.signTransaction(I)
          , M = await o.sendRawTransaction(P.serialize(), {
            skipPreflight: !1
        });
        try {
            await o.confirmTransaction({
                signature: M,
                blockhash: k,
                lastValidBlockHeight: B
            }, "confirmed")
        } catch {
            if (!await o.getTransaction(M, {
                commitment: "confirmed"
            }))
                throw new Error("Transaction not confirmed")
        }
        return {
            status: !0,
            txHash: M,
            message: " SPL token transfer successful"
        }
    } catch (d) {
        return {
            status: !1,
            message: d.message
        }
    }
}
function N4e(n) {
    return n ? n.length <= 10 ? n : `${n.slice(0, 6)}...${n.slice(-4)}` : null
}
function mf(n, e={}) {
    try {
        const r = S0("userInfo")?.walletAddress || ""
          , s = e.level || "error"
          , i = e.network || (r ? Df(r) ? "evm" : eP(r) ? "solana" : "unknown" : "none")
          , o = e.mask === !1 ? r : N4e(r);
        W7(o ? {
            id: o,
            ip_address: "{{auto}}"
        } : {
            id: void 0
        }),
        G7("wallet.network", i),
        r && G7("wallet.format", Df(r) ? "evm" : eP(r) ? "solana" : "unknown");
        const a = {
            walletAddress: o,
            providedNetwork: e.network,
            ...e.extra
        };
        a4e("wallet", a);
        const l = {
            level: s,
            fingerprint: e.fingerprint,
            tags: {
                "wallet.network": i
            },
            extra: a
        };
        typeof n == "string" ? o4e(n, s) : i4e(n, l)
    } catch (t) {
        console.error("sentryLog failed:", t)
    }
}
async function D4e(n, e) {
    const t = {
        sourceNetworkChainId: n.selectedNetwork.chainId,
        sourceAssetSymbol: n.selectedToken.tokenSymbol,
        sourceAmount: String(n.toAmount),
        conversionRateId: n.conversionId
    }
      , r = await e.executeV3("action");
    return await MSe(t, r)
}
async function T4e({walletInfo: n, selectedToken: e, toAmount: t, provider: r, config: s, selectedNetwork: i}) {
    const o = s.DEPOSIT_ADDRESS;
    if (n.walletType === "Phantom") {
        const l = "https://solana-mainnet.g.alchemy.com/v2/Z8B-4ev_WBd-c1_xEryENFeYbWn9ZYr9"
          , u = s.SOLANA_DEPOSIT_ADDRESS
          , d = await window.solana.connect()
          , h = window.solana;
        return e.address === Ez ? await _4e(d.publicKey.toString(), u, t, l, h) : await k4e({
            rpc: l,
            mint: e.tokenSymbol === "USDC" ? "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v" : "Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB",
            fromAddress: d.publicKey.toString(),
            toAddress: u,
            amount: t,
            signer: h
        })
    }
    if (e.address === _c)
        return await A4e(o, t, n.walletType);
    const a = await r.getSigner();
    return await C4e(a, e.address, o, t)
}
async function I4e(n, e, t, r) {
    const s = {
        referenceId: n,
        txHash: e,
        chainId: t
    }
      , i = await r.executeV3("action");
    return await BSe(s, i)
}
function M4e(n, e) {
    let t = n?.walletType;
    if (!t)
        try {
            t = JSON.parse(localStorage.getItem("userInfo"))?.walletType
        } catch {}
    return !t && e && (t = "walletconnect"),
    t
}
function B4e(n) {
    if (n === "walletconnect") {
        const e = Ji.getProvider("walletconnect");
        if (!e)
            throw new Error("WalletConnect provider not found");
        return new Ys(e)
    }
    if (!window.ethereum)
        throw new Error("Ethereum provider not found");
    return new Ys(window.ethereum)
}
async function R4e(n, e) {
    const t = {
        chainId: n.chainId,
        chainName: n.name,
        rpcUrls: [n.rpc],
        nativeCurrency: {
            name: n.name,
            symbol: n.symbol,
            decimals: 18
        },
        blockExplorerUrls: [""]
    }
      , r = await Ji.switchOrAddNetwork(t, e);
    if (!r?.success)
        throw new Error(r?.message || "Network switch failed");
    await new Promise(s => setTimeout(s, 1500))
}
async function O4e(n, e) {
    const t = await n.getNetwork();
    if (Number(t.chainId) !== Number(e))
        throw new Error("Network mismatch")
}
async function P4e(n, e, t) {
    try {
        const r = await t.executeV3("action")
          , s = await HSe({
            email: n,
            amount: e
        }, r);
        return s?.status !== "success" ? {
            status: !1,
            message: s?.message || "Failed to initiate Alchemy Pay"
        } : s?.status === "success" && s?.data?.paymentUrl ? {
            status: !0,
            message: "Payment initiated",
            paymentUrl: s?.data?.paymentUrl
        } : {
            status: !1,
            message: "Payment URL not found"
        }
    } catch (r) {
        return console.log(" ~ handlePaymentWithAlchemyPay ~ error:", r),
        {
            status: !1,
            message: "An error occurred during payment initiation"
        }
    }
}
const j4e = ({config: n, getDepositeTx: e, userBalance: t}) => {
    const [r,s] = V.useState(!1)
      , [i,o] = V.useState([])
      , [a,l] = V.useState(!1)
      , [u,d] = V.useState(!1)
      , [h,p] = V.useState(!1)
      , [g,w] = V.useState(null)
      , [b,v] = V.useState(null)
      , [S,N] = V.useState(null)
      , _ = B0()
      , {emailAddress: I, refreshBalance: k} = Hs()
      , B = nk()
      , P = Uo()
      , [M,R] = V.useState({
        selectedNetwork: null,
        selectedToken: null,
        fromAmount: "",
        fromUsdAmount: "",
        toAmount: "",
        toUsdAmount: "",
        conversionId: null
    })
      , [L,q] = V.useState(!1)
      , [H,j] = V.useState("payment")
      , A = 6e4
      , E = 1
      , C = () => {
        q(!1),
        j(null),
        window.location.href = "https://emailintegration.d258kv1z9kdqr5.amplifyapp.com/deposit"
    }
      , O = ce => {
        q(!1),
        j(ce)
    }
      , {merchantOrderId: z} = E0()
      , G = V.useRef(null);
    kr();
    const Y = V.useRef(null)
      , $ = V.useRef(null);
    V.useEffect( () => {
        W()
    }
    , []);
    const D = () => {
        Y.current && (clearInterval(Y.current),
        Y.current = null)
    }
    ;
    V.useEffect( () => {
        if (D(),
        !!z)
            return q(!1),
            U(z),
            Y.current = setInterval( () => {
                U(z)
            }
            , A),
            D
    }
    , [z]);
    const U = async ce => {
        try {
            const me = await WV(ce);
            if (new Promise(Ee => setTimeout(Ee, 2e3)),
            me?.status === "success" && me?.data) {
                const Ee = me?.data?.status;
                Ee === "FINISHED" ? (O("success"),
                D()) : Ee === "PAY_FAIL" ? (O("failed"),
                D()) : O("processing")
            } else
                Ze.error(me?.message || "Failed to fetch payment status")
        } catch {
            Ze.error("An error occurred while fetching payment status")
        }
    }
      , W = async () => {
        try {
            const ce = await LSe();
            if (ce?.status === "success") {
                const me = ce?.data || []
                  , Ee = me?.[1] || {}
                  , Oe = Ee?.tokens?.[0] || {};
                o(me),
                R(mt => ({
                    ...mt,
                    selectedNetwork: Ee,
                    selectedToken: Oe
                }))
            } else
                throw new Error(ce?.message || "Failed to fetch networks")
        } catch (ce) {
            console.error("Network fetch error:", ce)
        }
    }
    ;
    async function Q() {
        try {
            if (l(!0),
            I) {
                const ot = await P4e(I, M.fromUsdAmount, P);
                if (!ot?.status)
                    return za(ot?.message, "error");
                N(ot?.paymentUrl),
                q(!0);
                return
            }
            const ce = M4e(_, B);
            if (!ce)
                return za("Wallet not connected", "error");
            ce === "Metamask" && await R4e(M.selectedNetwork, ce);
            let me = B4e(ce);
            ce === "Metamask" && await O4e(me, M.selectedNetwork.chainId);
            const Ee = await D4e(M, P);
            if (Ee.status !== "success")
                return za(Ee.message, "error");
            const Oe = Ee.data.referenceId
              , mt = await T4e({
                walletInfo: _,
                selectedToken: M.selectedToken,
                toAmount: M.toAmount,
                provider: me,
                config: n,
                selectedNetwork: M.selectedNetwork
            });
            if (!mt?.status)
                return za(mt.message, "error");
            const st = await I4e(Oe, mt.txHash, M.selectedNetwork.chainId, P);
            if (st.status !== "success")
                return za(st.message, "error");
            k(),
            e("deposit"),
            p(!0)
        } catch (ce) {
            mf(ce),
            console.error("Purchase failed:", ce),
            za(of(ce)?.message, "error")
        } finally {
            l(!1)
        }
    }
    const J = (ce, me="from") => {
        G.current && clearTimeout(G.current),
        G.current = setTimeout(async () => {
            if (!(!M?.selectedToken?.tokenSymbol || !ce)) {
                l(!0);
                try {
                    const Ee = await _Ae(M.selectedToken.tokenSymbol, "USDT")
                      , Oe = wn(me === "from" ? ce : Ee?.sourceUsdRate?.toFixed(4) * ce)
                      , mt = wn(me === "from" ? (Number(ce) + E) / Ee?.sourceUsdRate : Number(ce) / Ee?.sourceUsdRate)
                      , st = Number(Oe) > E ? wn(Number(Oe) - E, 4) : 0
                      , ot = wn(Number(Oe) + E, 4);
                    R(Ct => ({
                        ...Ct,
                        fromAmount: me === "from" ? ce : st,
                        toAmount: me === "from" ? mt : Ct.toAmount,
                        fromUsdAmount: me === "from" ? ce : st,
                        toUsdAmount: me === "from" ? ot : Oe,
                        conversionId: Ee?.conversionId
                    }))
                } catch (Ee) {
                    console.error("Conversion fetch failed:", Ee)
                } finally {
                    l(!1)
                }
            }
        }
        , 1e3)
    }
      , ne = ce => {
        const me = ce.target.value;
        if (me === "" || parseFloat(me) <= 0)
            return R(Ee => ({
                ...Ee,
                fromAmount: me,
                toAmount: parseFloat(me) <= 0 ? "" : me,
                toUsdAmount: me,
                fromUsdAmount: me
            }));
        if (I) {
            R(Ee => ({
                ...Ee,
                fromAmount: me,
                fromUsdAmount: me
            }));
            return
        }
        R(Ee => ({
            ...Ee,
            fromAmount: me
        })),
        M?.selectedToken?.address === _c || M?.selectedToken?.address === Ez ? J(me, "from") : R(Ee => ({
            ...Ee,
            fromUsdAmount: me,
            toAmount: Number(me) + E,
            toUsdAmount: Number(me) + E,
            conversionId: B7
        }))
    }
      , ie = ce => {
        const me = ce.target.value;
        if (R(Ee => ({
            ...Ee,
            toAmount: me
        })),
        M?.selectedToken?.address === _c)
            J(me, "to");
        else {
            const Ee = Number(me) <= E ? 0 : Number(me) - E;
            R(Oe => ({
                ...Oe,
                fromUsdAmount: Ee,
                fromAmount: Ee,
                toUsdAmount: me,
                conversionId: B7
            }))
        }
    }
      , ae = !M.fromAmount || Number(M.fromAmount) <= 0
      , xe = !M.selectedToken || !M.selectedNetwork
      , ue = a || ae || (I ? Number(M.fromAmount) < 15 : xe);
    return m.jsxs(m.Fragment, {
        children: [h ? m.jsx(NAe, {
            txHash: g,
            fromAmount: M?.fromAmount,
            referrenceId: b,
            onClaimSuccess: () => {
                d(!0),
                e("deposit"),
                p(!1),
                R(ce => ({
                    ...ce,
                    fromAmount: "",
                    fromUsdAmount: "",
                    toAmount: "",
                    toUsdAmount: ""
                }))
            }
        }) : m.jsxs("div", {
            children: [m.jsxs("div", {
                className: "mb-5",
                children: [m.jsx("label", {
                    className: "text-sm font-light mb-1 block",
                    children: "Balance"
                }), m.jsxs("div", {
                    className: "bg-[#212D3D] p-4 rounded-xl flex items-center gap-3 text-base",
                    children: [m.jsx("img", {
                        src: ri,
                        alt: "coin"
                    }), t?.isLoading ? m.jsxs("span", {
                        className: "flex items-center gap-1",
                        children: [m.jsx("div", {
                            className: "h-4 w-24 bg-gray-700 rounded animate-pulse"
                        }), m.jsx("span", {
                            className: "inline-block",
                            children: "L1XG"
                        })]
                    }) : m.jsxs("span", {
                        children: [wn(t?.l1xgBalance, 4), " L1XG"]
                    })]
                })]
            }), m.jsxs("div", {
                children: [m.jsx("label", {
                    className: "text-sm font-light mb-1 block",
                    children: "Deposit More"
                }), m.jsx("div", {
                    className: "bg-[#212D3D] p-4 rounded-xl",
                    children: m.jsxs("div", {
                        className: "grid grid-cols-1",
                        children: [m.jsxs("div", {
                            className: "border-b pb-3.5 mb-3.5 border-[#465568] xl:pr-5",
                            children: [m.jsx("label", {
                                className: "text-sm font-light mb-1 block text-[#8FA1B8]",
                                children: "Enter deposit amount"
                            }), m.jsxs("div", {
                                className: "flex items-center justify-between gap-2",
                                children: [m.jsx("input", {
                                    value: M.fromAmount,
                                    onChange: ne,
                                    className: "bg-transparent border-none text-3xl font-semibold w-full text-white outline-none focus:outline-none focus:ring-0",
                                    placeholder: "0.00",
                                    onKeyDown: Q2
                                }), m.jsxs("div", {
                                    className: "flex items-center gap-3 text-2xl font-semibold text-right justify-end",
                                    children: [m.jsx("img", {
                                        src: ri,
                                        alt: "coin"
                                    }), m.jsx("span", {
                                        className: "whitespace-nowrap",
                                        children: "L1XG"
                                    })]
                                })]
                            }), a ? m.jsx("span", {
                                className: "inline-block h-6 w-20 bg-gray-700 rounded-4xl animate-pulse mt-1"
                            }) : m.jsxs("span", {
                                className: "inline-block bg-[#3D4C61] py-0.5 px-2 rounded-4xl text-sm text-[#8FA1B8] mt-1",
                                children: ["$", M.fromUsdAmount || "0.00"]
                            })]
                        }), I ? "" : m.jsxs("div", {
                            className: "",
                            children: [m.jsx("label", {
                                className: "text-sm font-light mb-1 block text-[#8FA1B8]",
                                children: "Pay with"
                            }), m.jsxs("div", {
                                className: "flex items-center justify-between gap-2",
                                children: [m.jsx("input", {
                                    value: M.toAmount,
                                    onChange: ie,
                                    className: "bg-transparent border-none text-3xl font-semibold w-full text-white outline-none focus:outline-none focus:ring-0",
                                    placeholder: "0.00",
                                    onKeyDown: Q2
                                }), m.jsxs("div", {
                                    onClick: () => s(!0),
                                    className: "cursor-pointer bg-[#F0B90B] rounded-4xl flex items-center pl-1.5 relative",
                                    style: {
                                        background: HV[M?.selectedNetwork?.name] || "#ffffff"
                                    },
                                    children: [m.jsx("div", {
                                        className: "w-7 h-7 mr-3.5 rounded-4xl flex items-center justify-center",
                                        children: m.jsx("img", {
                                            src: M?.selectedNetwork?.icon,
                                            alt: "network"
                                        })
                                    }), m.jsx("div", {
                                        className: "img-bg-drp"
                                    }), m.jsxs("div", {
                                        className: "flex items-center gap-3.5 bg-[#2775CA] rounded-4xl p-1 relative z-10",
                                        style: {
                                            background: VV[M?.selectedToken?.tokenSymbol] || "#ffffff"
                                        },
                                        children: [m.jsxs("div", {
                                            className: "flex items-center gap-1.5",
                                            children: [m.jsx("div", {
                                                className: "w-7 h-7 rounded-4xl flex items-center justify-center",
                                                children: m.jsx("img", {
                                                    src: M?.selectedToken?.icon,
                                                    alt: "token"
                                                })
                                            }), M?.selectedToken?.tokenSymbol]
                                        }), m.jsx("svg", {
                                            xmlns: "http://www.w3.org/2000/svg",
                                            fill: "none",
                                            viewBox: "0 0 24 24",
                                            strokeWidth: 1.5,
                                            stroke: "currentColor",
                                            className: "size-6",
                                            children: m.jsx("path", {
                                                strokeLinecap: "round",
                                                strokeLinejoin: "round",
                                                d: "m19.5 8.25-7.5 7.5-7.5-7.5"
                                            })
                                        })]
                                    })]
                                })]
                            }), a ? m.jsx("span", {
                                className: "inline-block h-6 w-20 bg-gray-700 rounded-4xl animate-pulse mt-1"
                            }) : m.jsxs("span", {
                                className: "inline-block bg-[#3D4C61] py-0.5 px-2 rounded-4xl text-sm text-[#8FA1B8] mt-1",
                                children: ["$", M.toUsdAmount || "0.00"]
                            })]
                        })]
                    })
                })]
            }), m.jsx("div", {
                className: "text-center mt-5",
                children: m.jsx("button", {
                    onClick: Q,
                    disabled: ue,
                    className: `text-white cursor-pointer rounded-4xl brand-gradient-bg inline-flex gap-2 items-center 
                            text-medium font-medium py-3 px-10 text-base transition-all 
                            ${ue ? "opacity-50 cursor-not-allowed!" : ""}`,
                    children: a ? "Processing..." : "Purchase L1XG"
                })
            }), I ? m.jsx("div", {
                className: "mt-6",
                children: m.jsxs("div", {
                    className: "bg-[#1F2A3A] border border-[#2F3C4E] rounded-2xl px-4 py-3 flex items-center gap-3 text-sm text-[#A8B8CC]",
                    children: [m.jsx("div", {
                        className: "w-9 h-9 rounded-xl bg-[#2B3A4F] flex items-center justify-center text-[#FFC12C]",
                        children: m.jsx("svg", {
                            xmlns: "http://www.w3.org/2000/svg",
                            fill: "none",
                            viewBox: "0 0 24 24",
                            strokeWidth: 1.5,
                            stroke: "currentColor",
                            className: "size-5",
                            children: m.jsx("path", {
                                strokeLinecap: "round",
                                strokeLinejoin: "round",
                                d: "M11.25 11.25l.041-.02a.75.75 0 0 1 1.063.852l-.708 2.836a.75.75 0 0 0 1.063.853l.041-.021M12 9h.008v.008H12V9Zm9 3a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"
                            })
                        })
                    }), m.jsx("p", {
                        className: "leading-relaxed",
                        children: "A minimum of 15 L1XG is required."
                    })]
                })
            }) : "", m.jsxs("div", {
                className: "bg-[#394A60] rounded-2xl p-4 xl:flex items-center gap-6 mt-6 text-center xl:text-left",
                children: [m.jsx("img", {
                    src: SAe,
                    alt: "security",
                    className: "mx-auto xl:mx-0"
                }), m.jsx("div", {
                    children: m.jsx("h4", {
                        className: "text-base font-semibold mb-2 mt-2 xl:mt-0",
                        children: "When you buy L1XG, youll instantly get most of your L1XP for gameplay and rewards, while the rest unlocks as you log in."
                    })
                })]
            })]
        }), m.jsx(fq, {
            networkList: i,
            isOpen: r,
            onClose: () => s(!1),
            setDepositData: R,
            depositData: M
        }), m.jsx(DAe, {
            isOpen: u,
            onClose: () => d(!1),
            amount: M?.fromAmount
        }), L && m.jsx("div", {
            className: "modalForPay fixed inset-0 z-50 flex items-center justify-center bg-black/70 backdrop-blur-sm px-4",
            children: m.jsxs("div", {
                className: "payment-modal-container bg-[#1A2332] border border-[#394A60] rounded-2xl shadow-2xl w-full max-w-lg relative overflow-hidden",
                children: [m.jsxs("header", {
                    className: "px-6 py-4 border-b border-white/10 flex items-center justify-between text-white",
                    children: [m.jsx("h2", {
                        className: "text-lg font-semibold",
                        children: "Payment Flow"
                    }), m.jsx("button", {
                        type: "button",
                        onClick: C,
                        className: "text-sm text-white/60 hover:text-white transition",
                        children: "Close"
                    })]
                }), m.jsx("div", {
                    className: "payment-modal-stage min-h-[55vh] flex flex-col gap-6 ",
                    children: m.jsxs("div", {
                        "data-stage": "payment",
                        className: "flex-1 flex flex-col p-4",
                        children: [m.jsx("div", {
                            children: m.jsx("p", {
                                className: "text-sm text-[#99B0CF] mb-4",
                                children: "Complete your purchase securely through the embedded gateway."
                            })
                        }), m.jsx("div", {
                            className: "bg-[#0F1825] rounded-xl overflow-hidden flex-1",
                            children: m.jsx("iframe", {
                                ref: $,
                                title: "Alchemy Pay Ramp",
                                src: S,
                                className: "w-full h-full border-0 min-h-[600px]",
                                allow: "payment *; accelerometer; autoplay; camera; gyroscope; encrypted-media;",
                                sandbox: "allow-scripts allow-same-origin allow-forms allow-popups allow-top-navigation allow-top-navigation-by-user-activation allow-popups-to-escape-sandbox"
                            })
                        })]
                    })
                })]
            })
        }), H === "processing" && m.jsx("div", {
            className: "modalForPay fixed inset-0 z-50 flex items-center justify-center bg-black/70 backdrop-blur-sm ",
            children: m.jsx("div", {
                className: "payment-modal-container bg-[#1A2332]  w-full max-w-full relative overflow-hidden",
                children: m.jsx("div", {
                    className: "payment-modal-stage min-h-[100vh] flex flex-col gap-6 ",
                    children: m.jsxs("div", {
                        "data-stage": "processing",
                        className: "flex-1 flex flex-col justify-center items-center text-white text-center gap-4",
                        children: [m.jsx("div", {
                            className: "w-16 h-16 border-4 border-[#FFC12C] border-t-transparent rounded-full animate-spin"
                        }), m.jsxs("div", {
                            children: [m.jsx("h3", {
                                className: "text-xl font-semibold",
                                children: "Processing"
                            }), m.jsx("p", {
                                className: "text-sm text-[#99B0CF] mt-2 max-w-md",
                                children: "We're verifying your payment and confirming the on-chain transaction."
                            })]
                        })]
                    })
                })
            })
        }), H === "success" && m.jsx("div", {
            className: "modalForPay fixed inset-0 z-50 flex items-center justify-center bg-black/70 backdrop-blur-sm",
            children: m.jsx("div", {
                className: "payment-modal-container bg-[#1A2332] border border-[#394A60]  w-full max-w-full relative overflow-hidden",
                children: m.jsx("div", {
                    className: "payment-modal-stage min-h-[100vh] flex flex-col gap-6 ",
                    children: m.jsxs("div", {
                        "data-stage": "success",
                        className: "flex-1 flex flex-col justify-center items-center text-white text-center gap-4",
                        children: [m.jsxs("div", {
                            className: "relative w-16 h-16",
                            children: [m.jsx("div", {
                                className: "absolute inset-0 rounded-full bg-emerald-400/20 animate-ping"
                            }), m.jsx("div", {
                                className: "relative w-full h-full rounded-full bg-emerald-500/20 border border-emerald-300 flex items-center justify-center",
                                children: m.jsx("span", {
                                    className: "text-2xl text-emerald-300",
                                    children: ""
                                })
                            })]
                        }), m.jsxs("div", {
                            children: [m.jsx("h3", {
                                className: "text-2xl font-semibold",
                                children: "Payment Successful"
                            }), m.jsx("p", {
                                className: "text-sm text-white/70 mt-2 max-w-xs mx-auto",
                                children: "We've confirmed your payment. You can continue once you're ready."
                            })]
                        }), m.jsx("button", {
                            type: "button",
                            onClick: C,
                            className: "px-5 py-2 rounded-full bg-emerald-400 text-[#081120] font-semibold hover:bg-emerald-300 transition",
                            children: "Continue"
                        })]
                    })
                })
            })
        }), H === "failed" && m.jsx("div", {
            className: "modalForPay fixed inset-0 z-50 flex items-center justify-center bg-black/70 backdrop-blur-sm",
            children: m.jsx("div", {
                className: "payment-modal-container bg-[#1A2332] w-full max-w-full relative overflow-hidden",
                children: m.jsx("div", {
                    className: "payment-modal-stage min-h-[100vh] flex flex-col gap-6 ",
                    children: m.jsxs("div", {
                        "data-stage": "failed",
                        className: "flex-1 flex flex-col justify-center items-center text-white text-center gap-4",
                        children: [m.jsxs("div", {
                            className: "relative w-16 h-16",
                            children: [m.jsx("div", {
                                className: "absolute inset-0 rounded-full bg-red-400/20 animate-ping"
                            }), m.jsx("div", {
                                className: "relative w-full h-full rounded-full bg-red-500/20 border border-red-300 flex items-center justify-center",
                                children: m.jsx("span", {
                                    className: "text-2xl text-red-300",
                                    children: ""
                                })
                            })]
                        }), m.jsxs("div", {
                            children: [m.jsx("h3", {
                                className: "text-2xl font-semibold",
                                children: "Payment Failed"
                            }), m.jsx("p", {
                                className: "text-sm text-white/70 mt-2 max-w-xs mx-auto",
                                children: "Something went wrong. Try again or close the modal."
                            })]
                        }), m.jsxs("div", {
                            className: "flex items-center gap-3",
                            children: [m.jsx("button", {
                                type: "button",
                                onClick: C,
                                className: "px-5 py-2 rounded-full bg-[#FFC12C] text-[#081120] font-semibold hover:bg-[#ffcf58] transition",
                                children: "Retry"
                            }), m.jsx("button", {
                                type: "button",
                                onClick: C,
                                className: "px-5 py-2 rounded-full bg-white/10 text-white font-semibold hover:bg-white/20 transition",
                                children: "Close"
                            })]
                        })]
                    })
                })
            })
        })]
    })
}
  , YC = {
    tokenName: "USDT",
    tokenSymbol: "USDT",
    tokenDecimal: 18,
    address: "0x55d398326f99059ff775485246999027b3197955",
    icon: "https://l1x-app.s3.ap-southeast-2.amazonaws.com/l1x-app/token/usdt.svg",
    networkId: 4
}
  , tP = {
    id: 4,
    name: "Binance",
    symbol: "BSC",
    displaySymbol: "BSC",
    chainId: "56",
    rpc: "https://still-aged-sailboat.bsc.quiknode.pro/86cf1fbd52f32b6a4a4896ca87a228c8e32273f0/",
    icon: "https://l1x-app.s3.ap-southeast-2.amazonaws.com/l1x-app/token/binance.svg",
    tokenList: [YC]
}
  , L4e = ({getDepositeTx: n, userBalance: e}) => {
    const [t,r] = V.useState(!1)
      , [s,i] = V.useState([])
      , [o,a] = V.useState(!1)
      , [l,u] = V.useState(!1)
      , [d,h] = V.useState(null)
      , [p,g] = V.useState(null)
      , {walletAddress: w, balance: b, backendConfig: v, connectWallet: S, emailAddress: N, refreshBalance: _} = Hs()
      , I = Uo()
      , [k,B] = V.useState("")
      , [P,M] = V.useState({
        selectedNetwork: tP,
        selectedToken: YC,
        fromAmount: "",
        fromUsdAmount: "",
        toAmount: "",
        toUsdAmount: "",
        conversionId: null
    })
      , R = 1
      , L = V.useRef(null)
      , q = async () => {
        try {
            const {fromAmount: z, toAmount: G} = P;
            if (b?.l1xsBalance < z) {
                Ze.error("Insufficient Balance");
                return
            }
            u(!0);
            let Y = {
                inputAmount: z,
                outputAmount: G
            };
            N && (Y.receiverAddress = k);
            const $ = await I.executeV3("action")
              , D = await OSe(Y, $);
            D?.status === "success" ? (n("withdraw"),
            _(),
            M({
                selectedNetwork: tP,
                selectedToken: YC,
                fromAmount: "",
                fromUsdAmount: "",
                toAmount: "",
                toUsdAmount: "",
                conversionId: null
            })) : (mf(D?.message),
            Ze.error(D?.message || "Failed to withdraw."))
        } catch (z) {
            mf(z),
            console.error("Purchase failed:", z),
            h("Failed to withdraw L1XP. Please try again."),
            Ze.error("Failed to withdraw L1XP. Please try again.")
        } finally {
            u(!1)
        }
    }
      , H = (z, G="from") => {
        L.current && clearTimeout(L.current),
        L.current = setTimeout(async () => {
            if (!(!P?.selectedToken?.tokenSymbol || !z)) {
                a(!0);
                try {
                    const Y = z
                      , $ = z < R ? 0 : z - R;
                    M(D => ({
                        ...D,
                        fromAmount: G === "from" ? z : Y,
                        toAmount: G === "from" ? $ : D.toAmount,
                        fromUsdAmount: Y,
                        toUsdAmount: $
                    }))
                } catch (Y) {
                    console.error("Conversion fetch failed:", Y),
                    h("Unable to fetch conversion rate.")
                } finally {
                    a(!1)
                }
            }
        }
        , 1e3)
    }
      , j = z => {
        const G = z.target.value;
        if (G === "")
            return M(Y => ({
                ...Y,
                fromAmount: G,
                toAmount: G,
                toUsdAmount: G,
                fromUsdAmount: G
            }));
        M(Y => ({
            ...Y,
            fromAmount: G
        })),
        h(null),
        H(G, "from")
    }
      , A = z => {
        const G = z.target.value;
        M(Y => ({
            ...Y,
            toAmount: G
        })),
        h(null),
        H(G, "to")
    }
      , E = z => {
        const G = z.target.value;
        B(G),
        h(null)
    }
      , C = Df(k)
      , O = o || !P.fromAmount || Number(P.fromAmount) <= 0 || Number(P.fromAmount) < Number(v?.MIN_WITHDRAW_AMOUNT) || !P.selectedToken || !P.selectedNetwork || N ? !C : !1;
    return m.jsxs(m.Fragment, {
        children: [m.jsxs("div", {
            children: [m.jsxs("div", {
                className: "mb-5",
                children: [m.jsx("label", {
                    className: "text-sm font-light mb-1 block",
                    children: "Withdrawable Balance"
                }), m.jsxs("div", {
                    className: "bg-[#212D3D] p-4 rounded-xl flex items-center gap-3 text-base",
                    children: [m.jsx("img", {
                        src: ri
                    }), e?.isLoading ? m.jsxs("span", {
                        className: "flex items-center gap-1",
                        children: [m.jsx("div", {
                            className: "h-4 w-24 bg-gray-700 rounded animate-pulse"
                        }), m.jsx("span", {
                            className: "inline-block",
                            children: "L1XP"
                        })]
                    }) : m.jsxs("span", {
                        children: [wn(e?.l1xsBalance, 4), " L1XP"]
                    })]
                })]
            }), m.jsxs("div", {
                children: [m.jsx("label", {
                    className: "text-sm font-light mb-1 block",
                    children: "Enter Withdrawal Amount "
                }), m.jsx("div", {
                    className: "bg-[#212D3D] p-4 rounded-xl",
                    children: m.jsxs("div", {
                        className: "grid grid-cols-1",
                        children: [m.jsxs("div", {
                            className: "border-b  pb-3.5  mb-3.5  border-[#465568] xl:pr-5",
                            children: [m.jsx("label", {
                                className: "text-sm font-light mb-1 block text-[#8FA1B8]",
                                children: "Enter amount"
                            }), m.jsxs("div", {
                                className: "flex items-center justify-between gap-2",
                                children: [m.jsx("input", {
                                    value: P.fromAmount,
                                    onChange: j,
                                    className: "bg-transparent border-none text-3xl font-semibold w-full text-white outline-none focus:outline-none focus:ring-0",
                                    placeholder: "0.00",
                                    onKeyDown: Q2
                                }), m.jsxs("div", {
                                    className: "flex items-center gap-3 text-2xl font-semibold  text-right  justify-end",
                                    children: [m.jsx("img", {
                                        src: ri
                                    }), " ", m.jsx("span", {
                                        className: "whitespace-nowrap",
                                        children: "L1XP"
                                    })]
                                })]
                            }), o ? m.jsx("span", {
                                className: "inline-block h-6 w-20 bg-gray-700 rounded-4xl animate-pulse mt-1"
                            }) : m.jsxs("span", {
                                className: "inline-block bg-[#3D4C61] py-0.5 px-2 rounded-4xl text-sm text-[#8FA1B8] mt-1",
                                children: ["$", P.fromUsdAmount || "0.00"]
                            })]
                        }), m.jsxs("div", {
                            className: "",
                            children: [m.jsx("label", {
                                className: "text-sm font-light mb-1 block text-[#8FA1B8]",
                                children: "You will receive"
                            }), m.jsxs("div", {
                                className: "flex items-center justify-between gap-2",
                                children: [m.jsx("input", {
                                    value: P.toAmount,
                                    onChange: A,
                                    className: "bg-transparent border-none text-3xl font-semibold w-full text-white outline-none focus:outline-none focus:ring-0",
                                    placeholder: "0.00",
                                    onKeyDown: Q2
                                }), m.jsxs("div", {
                                    className: " bg-[#F0B90B] rounded-4xl flex items-center pl-1.5 relative",
                                    style: {
                                        background: HV[P?.selectedNetwork?.name] || "#ffffff"
                                    },
                                    children: [m.jsx("div", {
                                        className: "w-7 h-7 mr-3.5 rounded-4xl flex items-center justify-center",
                                        children: m.jsx("img", {
                                            src: P?.selectedNetwork?.icon,
                                            alt: "network"
                                        })
                                    }), m.jsx("div", {
                                        className: "flex items-center gap-3.5 bg-[#2775CA] rounded-4xl p-1 relative z-10",
                                        style: {
                                            background: VV[P?.selectedToken?.tokenSymbol] || "#ffffff"
                                        },
                                        children: m.jsxs("div", {
                                            className: "flex items-center gap-1.5",
                                            children: [m.jsx("div", {
                                                className: "w-7 h-7 rounded-4xl flex items-center justify-center",
                                                children: m.jsx("img", {
                                                    src: P?.selectedToken?.icon,
                                                    alt: "token"
                                                })
                                            }), P?.selectedToken?.tokenSymbol]
                                        })
                                    })]
                                })]
                            }), o ? m.jsx("span", {
                                className: "inline-block h-6 w-20 bg-gray-700 rounded-4xl animate-pulse mt-1"
                            }) : m.jsxs("span", {
                                className: "inline-block bg-[#3D4C61] py-0.5 px-2 rounded-4xl text-sm text-[#8FA1B8] mt-1",
                                children: ["$", P.toUsdAmount || "0.00"]
                            })]
                        }), N ? m.jsxs("div", {
                            className: "mt-5 border-t  pb-3.5  mb-3.5  border-[#465568] xl:pr-5",
                            children: [m.jsx("label", {
                                className: "text-sm font-light mb-1 mt-5 block text-[#8FA1B8]",
                                children: "Receiver address"
                            }), m.jsx("div", {
                                className: "flex items-center justify-between gap-2",
                                children: m.jsx("input", {
                                    value: k,
                                    onChange: E,
                                    className: "bg-transparent border-none text-12  w-full text-white outline-none focus:outline-none focus:ring-0",
                                    placeholder: "Enter wallet address"
                                })
                            }), !C && k && m.jsx("span", {
                                className: "inline-block bg-[#3D4C61] py-0.5 px-2 rounded-4xl text-sm text-[#ed682f] mt-1",
                                children: "Invalid wallet address"
                            })]
                        }) : ""]
                    })
                })]
            }), m.jsx("div", {
                className: "text-center mt-5",
                children: m.jsx("button", {
                    onClick: q,
                    disabled: O,
                    className: `text-white rounded-4xl brand-gradient-bg inline-flex gap-2 items-center 
                            text-medium font-medium py-3 px-10 text-base transition-all cursor-pointer
                            ${O ? "opacity-50 cursor-not-allowed!" : ""}`,
                    children: l ? "Processing..." : "Withdraw"
                })
            }), m.jsx("div", {
                className: "mt-6",
                children: m.jsxs("div", {
                    className: "bg-[#1F2A3A] border border-[#2F3C4E] rounded-2xl px-4 py-3 flex items-center gap-3 text-sm text-[#A8B8CC]",
                    children: [m.jsx("div", {
                        className: "w-9 h-9 rounded-xl bg-[#2B3A4F] flex items-center justify-center text-[#FFC12C]",
                        children: m.jsx("svg", {
                            xmlns: "http://www.w3.org/2000/svg",
                            fill: "none",
                            viewBox: "0 0 24 24",
                            strokeWidth: 1.5,
                            stroke: "currentColor",
                            className: "size-5",
                            children: m.jsx("path", {
                                strokeLinecap: "round",
                                strokeLinejoin: "round",
                                d: "M11.25 11.25l.041-.02a.75.75 0 0 1 1.063.852l-.708 2.836a.75.75 0 0 0 1.063.853l.041-.021M12 9h.008v.008H12V9Zm9 3a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"
                            })
                        })
                    }), m.jsx("p", {
                        className: "leading-relaxed",
                        children: "A minimum of 50 L1XP is required to initiate a withdrawal."
                    })]
                })
            })]
        }), m.jsx(fq, {
            networkList: s,
            isOpen: t,
            onClose: () => r(!1),
            setDepositData: M,
            depositData: P
        })]
    })
}
  , F4e = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAdFSURBVHgBnVdrcFPHFf7u3ivZsi1LtmQkYzvQAIYGE7cxpSlNoBgTwx+TPoaQaZN20qbONNDmj5zgDM0M0zGMyzSd0rR5TGgbCEmZlvGUtJQhtXFCQocCKeBSbOwCqYUtybIkWy9L9+7tuZKshy3sNGe0s7u6u/ud/fbsOWeB+UXQytGjR5devXr1jYmJiRFZlmOqqnIqKrXjPp/POTg4eKS9vf1zNJal5sy76JyA165d66itrW3T2twzgtCJYwh/eBYxzwQUroNQZkPR/V9GaXMjChdVcs5VNhmc7DSbzbtoDsf/CSyeO3duw+qGhpMCY8Lknu8J0bM9gKkyAZYoih4y1VzRUU1tpRDh2yEY130Jn33ph+Cywnvff6+lsbHxRD4F8gEzj8dzqNxs3h4/vJdF//RbqEVlBCaBU8kGnm7LShJYlgsQpzriVVD1xGYs3tHEXR7376qqqp6kdZW5gEWXy/WB1Wr5QmTbXUw1WkhzBq5KOcAcBYiO+qEvMCNqMBEggcsErCSB46SArJICHhWb/r2bj3nHzttstrXZ4Cwb1Ol0vlZRYV091WJigtFIBOU/orjbjbvf+zt6djkgTQaRl0aaqjMZ0GX/CbNarKvHxsbeyMabbgjd3d2bbQsqvh3bvlAUFlSm/lbpp85eWEhO04XD1GFZaLOluMaMriW/ZGaTefvFixcbp0emgdc9+MBx/KGDodSYmSXHUPTsr8Fdw5hXUvqJ/gjGv38fkZphS2824ErHP1h9ff3JbGDB7/fvEyWdoHT9IkMv7dTQ9jqklV9E+anRTwQuBsK4deBr4CY9gj+oSytDRoKBg31gJP39/R1I8UTHaXQo+x4FSkozqwgCQs8+TKqJiW7F34YJ3HnHneoCQVx/8TFItGPFUojSfR/l0K8v0qPn8W4sW7qsLbFjh8NxLxNIp/N/zVotOYPZKuF/aEH6X1vPDSgEzsjwfC+/hLt7eqEU6Ag0hH/tb4XOH4JCtC586gR4WcEsHT9+Z1hbWvOCS1hra2sbRgYZykuRT5htIcaa7Ol+Ve8AlHEPJk+egHVwiAwsikt7f0SgQcjmIiza+ccE+ExGNDFYCxFyRlBXV/djZrFY1vMzR2ZYr5qzc8leDXdjdfrrojN9UPw+FIQjOL/HQTueJNBiLHvmUAI8R7LoptND/29uoLq6epOgOXnh+fUS935MfIsESY5izAOVjj/pNHTJWjJCJkrtp2+kFzp67BgMOh3ipmKsdLyKSFE5+CRDTHMmVGKyAXLcgFhJCdXUJ+eit1nQcnpDTBJFUVJ8o2nluM8DQ5cfMyV6/DAm33wZzqZVqHr3SvIY6AaojGHVC7/ClIm8WJUVrm+tzdokMWcSwL5ByqaICI5ENevWs8RXQZ0/kClJbycwaRaVAldzT0nNbuQuzFJdSVEUWTDbdar3v8lh5RWIPGyitkg0i8kIpJVCMxTfBBb2ZKjmdGgCOYrLe57GyrbXYIh5UPPcOzlUx4nquKmE/GxyjsFeSOtRBAiHw158flNGJaJPKLcBZXSNKNYyqhkpowa8sGeB/mfd/Vj7yuuIk6fTTWjX6UmwIN3hkgKoJXpwox4w6ohqKceyazZVIhAIuNnw8PAptvGJOalWyGtpDmRabj1QB8liRdxQgIbdnbQjY+IOD774ODmQ8B3X0ax66SPVGB8f72V9fX17VEsN4B/PNYppAtxOWE6NpvvO9bVg5nIYm7dgbNlSxIuLUL/r5wk6JQK/eeDr5K+jeYFD3ghKl5SoBw8e7GTbtm0b0i6xsLoFM+MQd43AfNKT7o9uWAzRVgU1FEbZU09j6CvrIE1NJUDvoesUp7usuczbr2yB6JsNfldTTWLjHR0dlxLR6fr1wU6x7YiKSCQzihxK8f7jhJ60ZvfGKgKtxp1EcyC1zxym2gCJduZ/viHne9Q3hca3GkH52E+1fuI6LV++vF2lLE1sbqV/puOrgMje70C+/CG8ZBCirQZziooE6OIdx8D8Uyg9cCXzjda6Z2c9FMrDKAl8Ths9HY/V8xcuNAvf3M1B7i8tkh7h/TsS9H5SkcsMKHv1I6hiJrmJEf0rHffx072ntyJlQGngNWvWdPv8gbd1bzs5d93O0Xb27pIxO24oIt/DMZeEhv346o2dipb0NTU1/WUaeOaqjJK9sxVWa0PkkRqRl+RP9hToMeUKQK83I0LJnjIj2dOyTYWSvaCbo7n/BcXtcV+w2+13TPY04Vo2eHtk5FDBWze5fuOj5PR9mG3uFErKrYgVGXLdZUrkYBS2lgY8RBmmd9z7+5mg+YA1UShsfff9Mx9sFbc7uLnrFqTae6F6R/PTniUxbwAlqz6DB//5M3WJYwu/dOVyc0VFxWMzQTWZLzQwLR8zGosdTBC57LzJwu/+GeGz2U8YOz1h1sK8dTN0FPJI1IGBgc4VK1a0IytkfBrRlGPag2xoaOhN7YGmxXA1KVx7wGkPOe1Bpz3sUuPnfbT9D0oZaNqh9+B2AAAAAElFTkSuQmCC"
  , Fp = ({type: n}) => {
    switch (n) {
    case "profile":
        return m.jsxs("div", {
            className: "animate-pulse flex items-center gap-3",
            children: [m.jsx("div", {
                className: "h-8 w-8 bg-gray-700 rounded-full"
            }), m.jsx("div", {
                className: "h-4 w-24 bg-gray-700 rounded"
            })]
        });
    case "balanceamount":
        return m.jsx("div", {
            className: "h-4 w-full bg-gray-700 rounded animate-pulse"
        });
    case "historytable":
        return m.jsxs("div", {
            className: "bg-[#263446] p-4 rounded-lg flex justify-between gap-1 xl:gap-2 items-center",
            children: [m.jsxs("div", {
                className: "flex items-center gap-2.5",
                children: [m.jsx("div", {
                    className: "animate-pulse h-6 w-6 bg-gray-700 rounded"
                }), m.jsx("div", {
                    className: "animate-pulse h-4 w-32 bg-gray-700 rounded"
                })]
            }), m.jsxs("div", {
                className: "flex items-center gap-2.5",
                children: [m.jsx("div", {
                    className: "animate-pulse h-4 w-12 bg-gray-700 rounded"
                }), m.jsx("div", {
                    className: "animate-pulse h-4 w-24 bg-gray-700 rounded"
                })]
            }), m.jsx("div", {
                className: "animate-pulse h-4 w-32 bg-gray-700 rounded"
            })]
        });
    default:
        return null
    }
}
;
function KC({rows: n=5, cols: e=4}) {
    return m.jsx(ye.Fragment, {
        children: [...Array(n)].map( (t, r) => m.jsx("tr", {
            className: "bg-[#263446] rounded-xl",
            children: [...Array(e)].map( (s, i) => m.jsx("td", {
                className: "py-3 px-4",
                children: m.jsx("div", {
                    className: "animate-pulse bg-gray-700 rounded h-4 w-24"
                })
            }, i))
        }, r))
    })
}
const U4e = ({title: n, data: e=[], activeTab: t, handleClaim: r, handleWithdraw: s, fetchMore: i, getDepositeTx: o, metadata: a, isProcessing: l}) => {
    const [u,d] = V.useState(e)
      , [h,p] = V.useState(!1)
      , [g,w] = V.useState(1)
      , b = V.useRef(null);
    V.useEffect( () => {
        d(e)
    }
    , [e]);
    const v = N => {
        switch (N) {
        case "VERIFIED":
        case "PENDING":
            return {
                label: "Pending",
                bgColor: "bg-gradient-to-r from-[#f59e0b]/20 to-[#f59e0b]/10",
                borderColor: "border-[#f59e0b]/30",
                textColor: "text-[#fbbf24]",
                dotColor: "bg-[#fbbf24]"
            };
        case "COMPLETED":
            return {
                label: "Completed",
                bgColor: "bg-gradient-to-r from-[#37A505]/20 to-[#37A505]/10",
                borderColor: "border-[#37A505]/30",
                textColor: "text-[#4ade80]",
                dotColor: "bg-[#4ade80]"
            };
        case "failed":
            return {
                label: "Failed",
                bgColor: "bg-gradient-to-r from-[#ef4444]/20 to-[#ef4444]/10",
                borderColor: "border-[#ef4444]/30",
                textColor: "text-[#ef4444]",
                dotColor: "bg-[#ef4444]"
            };
        default:
            return {
                label: N,
                bgColor: "bg-gradient-to-r from-[#64748b]/20 to-[#64748b]/10",
                borderColor: "border-[#64748b]/30",
                textColor: "text-[#94a3b8]",
                dotColor: "bg-[#94a3b8]"
            }
        }
    }
      , S = V.useCallback(N => {
        N[0].isIntersecting && !h && (p(!0),
        a?.currentPage < a?.lastPage ? o(a?.currentPage + 1).finally( () => p(!1)) : p(!1))
    }
    , [h, a, o]);
    return V.useEffect( () => {
        const N = {
            root: null,
            rootMargin: "100px",
            threshold: 1
        }
          , _ = new IntersectionObserver(S,N);
        return b.current && _.observe(b.current),
        () => _.disconnect()
    }
    , [S]),
    m.jsxs("div", {
        className: `p-4 overflow-y-auto max-h-[80vh] [&::-webkit-scrollbar]:w-2
  [&::-webkit-scrollbar-track]:rounded-full
  [&::-webkit-scrollbar-track]:bg-[#3d4b6f]
  [&::-webkit-scrollbar-thumb]:rounded-full
  [&::-webkit-scrollbar-thumb]:bg-[#8a95b1]
  dark:[&::-webkit-scrollbar-track]:bg-neutral-700
  dark:[&::-webkit-scrollbar-thumb]:bg-neutral-500`,
        children: [m.jsx("h4", {
            className: "text-xl font-light mb-3",
            children: n
        }), u.length === 0 ? m.jsxs("div", {
            className: "flex flex-col items-center justify-center py-12 px-4",
            children: [m.jsx("div", {
                className: "w-20 h-20 rounded-full bg-gradient-to-br from-[#253245] to-[#1e2938] border border-[#2f4159]/50 flex items-center justify-center mb-4",
                children: m.jsx("svg", {
                    xmlns: "http://www.w3.org/2000/svg",
                    fill: "none",
                    viewBox: "0 0 24 24",
                    strokeWidth: 1.5,
                    stroke: "currentColor",
                    className: "w-10 h-10 text-[#64748b]",
                    children: m.jsx("path", {
                        strokeLinecap: "round",
                        strokeLinejoin: "round",
                        d: "M12 6v6h4.5m4.5 0a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"
                    })
                })
            }), m.jsx("h3", {
                className: "text-xl font-semibold text-white mb-2",
                children: "No Transaction History Found"
            }), m.jsxs("p", {
                className: "text-sm text-[#94a3b8] text-center max-w-md",
                children: ["You haven't made any ", t === "deposit" ? "deposits" : "withdrawals", " yet. Your transaction history will appear here once you start making transactions."]
            })]
        }) : u.map( (N, _) => {
            const I = t === "withdraw" ? v(N?.requestStatus) : null
              , k = t === "withdraw" && N?.requestStatus === "COMPLETED" && N?.txHash
              , P = k ? `https://bscscan.com/tx/${N?.txHash}` : N?.uuid
              , M = zo(k ? N?.txHash : N?.uuid)
              , R = "UUID copied!";
            return m.jsxs("div", {
                className: "bg-gradient-to-br from-[#253245] to-[#1e2938] p-2 rounded-xl border border-[#2f4159]/50 hover:border-[#FF6717]/40 transition-all duration-300 mb-3 shadow-lg hover:shadow-xl group",
                children: [m.jsxs("div", {
                    className: "flex items-center justify-between mb-3",
                    children: [m.jsxs("div", {
                        className: "flex items-center gap-3",
                        children: [m.jsx("div", {
                            className: "w-7 h-7 rounded-full bg-gradient-to-br from-[#FF6717] to-[#7900FF] p-[2px] group-hover:scale-110 transition-transform duration-300",
                            children: m.jsx("div", {
                                className: "w-full h-full rounded-full bg-[#1e2938] flex items-center justify-center",
                                children: m.jsx("img", {
                                    src: F4e,
                                    className: "w-5 h-5"
                                })
                            })
                        }), m.jsx("div", {
                            children: m.jsxs("div", {
                                className: "text-xl font-bold text-white font-jura",
                                children: [wn(N?.destAmountInUsd || N?.destinationAmount), "  ", N?.destAssetSymbol || N?.sourceToken]
                            })
                        })]
                    }), m.jsxs("div", {
                        className: "flex items-center gap-2",
                        children: [t === "withdraw" && I.label === "Pending" ? m.jsxs(m.Fragment, {
                            children: [m.jsx("div", {
                                className: "w-7 h-7 flex items-center justify-center rounded-full bg-black cursor-pointer hover:scale-105 transition-transform duration-200",
                                onClick: () => o(1),
                                children: m.jsx("svg", {
                                    xmlns: "http://www.w3.org/2000/svg",
                                    fill: "none",
                                    viewBox: "0 0 24 24",
                                    strokeWidth: 1.5,
                                    stroke: "currentColor",
                                    className: "size-4",
                                    children: m.jsx("path", {
                                        strokeLinecap: "round",
                                        strokeLinejoin: "round",
                                        d: "M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0 3.181 3.183a8.25 8.25 0 0 0 13.803-3.7M4.031 9.865a8.25 8.25 0 0 1 13.803-3.7l3.181 3.182m0-4.991v4.99"
                                    })
                                })
                            }), m.jsxs("span", {
                                className: `px-4 py-1.5 ${I.bgColor} border ${I.borderColor} rounded-full ${I.textColor} text-xs font-semibold uppercase tracking-wide flex items-center gap-1.5 shadow-sm`,
                                children: [m.jsx("span", {
                                    className: `w-1.5 h-1.5 ${I.dotColor} rounded-full ${I.label === "Pending" ? "animate-pulse" : ""}`
                                }), I.label]
                            })]
                        }) : t === "withdraw" ? m.jsxs("span", {
                            className: `px-4 py-1.5 ${I.bgColor} border ${I.borderColor} rounded-full ${I.textColor} text-xs font-semibold uppercase tracking-wide flex items-center gap-1.5 shadow-sm`,
                            children: [m.jsx("span", {
                                className: `w-1.5 h-1.5 ${I.dotColor} rounded-full ${I.label === "Pending" ? "animate-pulse" : ""}`
                            }), I.label]
                        }) : null, t === "deposit" && (N?.status === 1 ? m.jsx("button", {
                            disabled: l,
                            onClick: () => r(N?.uuid),
                            className: "btn-clr text-white px-5 py-2 rounded-lg font-semibold text-sm hover:scale-105 transition-transform duration-200 disabled:opacity-50 disabled:cursor-not-allowed shadow-lg cursor-pointer",
                            children: l ? "Claiming..." : "Claim L1XP"
                        }) : m.jsxs("span", {
                            className: "px-4 py-1.5 bg-gradient-to-r from-[#37A505]/20 to-[#37A505]/10 border border-[#37A505]/30 rounded-full text-[#4ade80] text-xs font-semibold uppercase tracking-wide flex items-center gap-1.5 shadow-sm",
                            children: [m.jsx("svg", {
                                xmlns: "http://www.w3.org/2000/svg",
                                fill: "none",
                                viewBox: "0 0 24 24",
                                strokeWidth: 2,
                                stroke: "currentColor",
                                className: "w-4 h-4",
                                children: m.jsx("path", {
                                    strokeLinecap: "round",
                                    strokeLinejoin: "round",
                                    d: "m4.5 12.75 6 6 9-13.5"
                                })
                            }), "Claimed"]
                        }))]
                    })]
                }), m.jsxs("div", {
                    className: "flex items-center justify-between pt-3 border-t border-[#2f4159]/50",
                    children: [k ? m.jsxs("a", {
                        href: P,
                        target: "_blank",
                        rel: "noopener noreferrer",
                        className: "inline-flex items-center gap-1 text-sm text-[#FF6717] font-mono tracking-wide hover:underline decoration-dashed decoration-[#7bd7ff]/70 transition-colors duration-200",
                        children: [M, m.jsx("svg", {
                            xmlns: "http://www.w3.org/2000/svg",
                            fill: "none",
                            viewBox: "0 0 24 24",
                            strokeWidth: 1.5,
                            stroke: "currentColor",
                            className: "ms-1 size-4 opacity-80 group-hover:opacity-100 transition-opacity duration-200",
                            children: m.jsx("path", {
                                strokeLinecap: "round",
                                strokeLinejoin: "round",
                                d: "m4.5 19.5 15-15m0 0H8.25m11.25 0v11.25"
                            })
                        })]
                    }) : m.jsxs("div", {
                        className: "flex items-center gap-2",
                        children: [m.jsx("span", {
                            className: "text-sm text-[#73849B] font-mono tracking-wide",
                            children: M
                        }), m.jsx("button", {
                            onClick: () => window.copyToClipboard(P, R),
                            className: "hover:scale-110 transition-transform duration-200 cursor-pointer",
                            title: "Copy UUID",
                            children: m.jsx("svg", {
                                xmlns: "http://www.w3.org/2000/svg",
                                fill: "none",
                                viewBox: "0 0 24 24",
                                strokeWidth: 1.5,
                                stroke: "#73849B",
                                className: "w-4 h-4 hover:stroke-brandOrange",
                                children: m.jsx("path", {
                                    strokeLinecap: "round",
                                    strokeLinejoin: "round",
                                    d: "M16.5 8.25V6a2.25 2.25 0 0 0-2.25-2.25H6A2.25 2.25 0 0 0 3.75 6v8.25A2.25 2.25 0 0 0 6 16.5h2.25m8.25-8.25H18a2.25 2.25 0 0 1 2.25 2.25V18A2.25 2.25 0 0 1 18 20.25h-7.5A2.25 2.25 0 0 1 8.25 18v-1.5m8.25-8.25h-6a2.25 2.25 0 0 0-2.25 2.25v6"
                                })
                            })
                        })]
                    }), m.jsxs("div", {
                        className: "flex items-center gap-2 text-[#94a3b8] text-sm",
                        children: [m.jsx("svg", {
                            xmlns: "http://www.w3.org/2000/svg",
                            fill: "none",
                            viewBox: "0 0 24 24",
                            strokeWidth: 1.5,
                            stroke: "currentColor",
                            className: "w-4 h-4",
                            children: m.jsx("path", {
                                strokeLinecap: "round",
                                strokeLinejoin: "round",
                                d: "M12 6v6h4.5m4.5 0a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"
                            })
                        }), m.jsx("span", {
                            className: "font-medium",
                            children: uq(N?.createdAt)
                        })]
                    })]
                })]
            }, _)
        }
        ), m.jsx("div", {
            ref: b,
            children: h && m.jsx("div", {
                className: "space-y-2.5",
                children: Array.from({
                    length: 3
                }).map( (N, _) => m.jsx(Fp, {
                    type: "historytable"
                }, _))
            })
        })]
    })
}
  , z4e = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGUAAABkCAYAAACfIP5qAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAA06SURBVHgB7V0LcFTVGf7uuY+9u5sXISRBHooQkUQsKCA4jNqZqjAjVceiRaRMpVYdHawdX/gYmREfnb4Un4N28EXVMoDF6rTUguCIpVYiQiCEhxQChA1JyIM89j5O/3PvboQkhCxkbxb2fsMlZO/usvf/zv/9//n/c/YCPuQOvyvw0WdgsQPrFgYebNkY2PLpC9pPY+dk+PAUEmJGX/akOpH/T6+3N+vc+FfA4pEg/89rgWmx5/jwCI40PTwd2Y2l2nq+K8iN1QGTrw3YdHBzdcDgh/To9OkOaX0mY+kyIljsp12xXFtQdAV7zNoKLnPOjznnPiEg4UCdtWTIVOO22DkbHoPh7IYYdGLE20vnK1eQFzQNP5cI2cwtIkSc63z9LdwaPEGZ+epdGIQ+wtnsKYIM85G7s/s9fkfr6nB/aYy5i5uK7EhTt9dtWLD5MOwNDGsbBjf+WPAQZ6OniGsSRjcrVqovPPtkW23wqHQx38NtIkRBDwaiKkPSWqTzvnpL+wl8+TotxLMqe+XT8hReozePKJTn2uXcZDZnUiLXqkuSHeHmuHxz6dSp0OBx0D8bSInHDf7ArIz+zZsC26bNVD8xN3FVauEgNnpuUFkShAAVBtgXbQoqbPv1q7Gczpjw0FZnekxxPEOkUAc/DSwaWCL9wqyArUA8koARJTJDiH4eINtvE+GDXq85b2yzoWDPL0Xx/R9gOzySsjOVFCl22J+/pN04eSZ73yqHxtq4KUkJSo3wjGay9RYipJF+Bo8/TUHfwhDUarcgH7HkAUnGmSZf7VK18KHgOa3l+q7J17DlZilncpQjIUKUmFSVG8AXUSDamRABVQFTmjBg/QO4Fx4QInAmeYojVVddBXnpfO3tvCJ5hrXTtmNFqsSlqpLsu910LaB2/xLLhikXQfnhHxD87DOHmKSScyaQ0i5VX72uzRh3M3vbKoNMUmVLLMHCYZC4a6KYsZm84yjv0jNOBJvBPixjVcG9mIokz/RTWb7aperVX+lDjV36vksnsz9bpRyywaWECFHprTQ6ykim1tNhJUaI82GIy/z+mPLSDJQgyUhVT3ECKs0RAm8+pL2XP1K+0dhm26obMRKTKmF8IVXlpvuupzHjMG2isxD12kz0RxKDfqp5SrzHYW56W53zyVt6c16A3cC325YIuEjk8wqpEsH7izZKc8l2Ok57CqgwMLUNuckO+qlCSnvh8JX7AkVWpR4ZPVZ+w97KbZaoVGkxqdpMZGwgqeKJS1V3n9OsgznpSrw47VInXUjKTD8V5MuRgfsnITjv6cDyASVsirGZpMrNiBLPqvbQAN5x+lLVHSwGXqvgn/n34FokIej3ZdszXji0Sher981+Qvs82CgNRxW3ZeXkldzjEBJZFdnlv+QZEduVqiRqgGSDhwtApTUs+7gM1YBbQui194f3iPcxrEUPqmNun6usZrW8n11DPQ45wUEiZEqM0a0xMkLwDDR3sZCHemW2E/R7tbzvdUyJFQ6hH14TWHPH/UopdthZ0hHOEyJE1HyFd+wjmVrbCtR7S4gwP2uhudJgJXf189qt6GX58spT2tuxO1Zo80Zczp6xKsCppM6lRAdGmJ5eQ1bZQhNAKq04UuUljtKRR5+hRIUlS6Y8CrjzR62hRV87EtYrGVmySWmXqpUL1InT7mL/sPdIWbzhFKVKTPrKiIxqGphheAtK5pxJaDFlIHmyW8SE09PnNW32X/KvjIrlSb0S9JMZ6J0U97np/bJWvIM1oyex+cY2KIoFibEEvEP0OIJ0fEeDsNRwiQnAO4hIQQqJ4XQ5YzRXOqPHxHUTdrhIHj1AMt/85Es0oBeCfjI8pV2qdi/Tnho2mT1ubqceB0+wxyEQltwALrzDdnscnkJIVb6QKs395NGu7U3jxDYLpUr9wtZz0QtBX+ri99Nh2nn9R3/EVdfNVv/G9yHMGyitT0iquCtVwgBb6NpqubdBXFwBJXNO5Xg0eUcusXHUxknGL0eBJG1ca8269HbrXfT8f+InOhGH+BjGtYOzcscia4IEexC41OPAZXHO8kLa7jufaXkuM0+aGN3DTVk+hemboK+OPutuwy2VMPTyLOAkEPbvR2Y5XxXLjWJ9zZPDsmAGijje/XXmlZF6M4d6Cp1YZDaTTcYjS2pbNn976JDwQ8fmHZ8Xf6FzcsMPRq8YF868oc6Ikh0SU7YoVesGnhNEU6UkhEqsVDi1dFvYQFApgqqXZMThrIOhw+AJi7tJXcrsod2rgig8QFOx83Ddb4rWlT6CLoiJ9yr41rFjVmUz+eoaw7AlUW1KEAaNqBEDdCcO+uge5IxmOBhQKhqbnh21tvTRjucdcbhtwIARFwSDp0yIj8RABlaaWtqsC3Nz580qKAh3cR4YqKrjjxgmfEK8gyz+mAYGZWvFHc85JBSHQgMbTE9XZvog2GTzi0KhTom+Q0oL54YfC/oAFPUN2+rkDb5cpSB8UlIQPikpCJ+UFIRPSgrCJyUF4ZOSgvBJSUH4pKQgfFJSED4pKQiflBSET0oKwiclBeGTkoLwvwWuA7gp9kM2OctTYCd527yuQa6uqo/9Fu9ocZ8UxsDbWoAD+4HCQZAvGgt5ZAmQkQFJD5GJkkeMWNlyiRx44kOmlS39aMWLS5YsEcuOrPQlhSzChSfs3A55yvXQXnwLcjGRISsxL+HJ9xTALOF8Bh24/pabnqqurs5ctWpVc3qSIpF31NcAgRBCf98AVlQE1DcCdQ2xhVme4Xv7q4p0162zbiZSFqdfoBeERKrASi5BxrpvwAoKgepaGrOm14QcD8uErutOvz69PEVIFnkIu2QCQovfByKHKabISI0VhDRYrFNZBX+mw6aBqAWJkA++JyQFkT6eQrJlf7cT4VUbKH4c7ZoQMVBFoA9oboLaRumxSJE9lrW0IUWkvfKUH4MNH+HGkOMMHVtJPiAX9o6dsMq+dTReLhoFdvFooLZBrJyDV7sR04eUg5XQX3mPMqzGziNfITNoGppvvg7W119CCokNMRR/mo8SiSMRfOdDsHAm0NoCL4hJD1KIBKlwCNiokTTqjxxPipiPEAlN48iDsrLAzi9yZcx5GT3PiKJp/AXI3LgbzlJrnvz9GekR6NtaIY8ZR/GCdfaS3By0zn/E2TMiBUPHG92JMTLk84ah5Z7ZQP8ceIG0IIVHo5AHDXG+hqgTmpthfrwMUm7eib0goMPc+G/Y+yqdskyykR6eQhKE3PzOZRMysF1XR0XIaPclFap/SaoCvn+/G3+SjPQgRRb73rsI8GIHXSDg1rpOlvaK/Tu63uM9kKeDNCFFJY+odffkHwvhAYX5YCOKu/cU8igpux/YhcXuvCXJSAtSpGAQdtk3XceDxmbojz4Dq7zM9aiOEBK3qwLa3HnwamdsengKGdba+i14XX3n/kgLTSonXgZ9wfOwtmwCb21tP8UNA/a2zVBv+yW0n/0caGiAF0ib2pekqjBWLnPmIsdBeE+khow+BxlrvqHUeTwVBi2HEFlMHJethj7/WaCq2rNaWdrM6KX8QkRf/i20mbPdwuSxBlZkZ1LJ8gsQXPiG603iEHWwRmoNV9d4knXFkT5VYjEHMVrR+nsa9Xn9O2dRIvsSm3Fr66gUQzJ3hLK1Gvp31PBkbnIs0qp0L+UPhPHa72gi+DXJWIYn6e2pIL36KRQr2AUlVHi8BtHdu4CcLFfKUgzp1w6mkrxSNBJNUy9Hw4d/BfLz3PjC+9ZrOA2OzHDQ+SaztFyMxy0boeJRaH34bhy44XqYdYedXgrCodhcxcumFrUIiBEpFERlTaRMPJK2S4wsw0LWyOE4cnAvKi8fB/2ySci46RYExk+AXFhIjUpBTnK9hxoKpiGBXFeT9pWVLbx1zpwv6WGW1ovxLKoaZ2drMIcXwY5U4chTT8AWk0dNc7OxJCtaXkBV/lR7aNzcyNFNsYecr5lK+xWSIpTkkGrVNspQaJ7ipZ4zIl8F64fIzvhDTmEt7Rd4O30scorMkOTBgsiewV91D3e6ElSdWz2lxNTFJyUGSsiQTd6SGsvyfLRDyFdOWHII6kv4pBwD55bb5CoZwb6NLz4pHZAK8cUnpQs48SXcd9HFJ+UEEHXKfn0UX3xSToB4fMkMek+MT0o3EDFFp/iieRxffFJOgvj8xUv4pPQAIj124otH/TCflB6gPb6EvIkvPik9hJfxxSclAcTnL8mOMKz9Lx89gpi/5CQ5vjh8hBgzrNRcbZNy6M34YlMzR++iI++Qsr6xsbwgoMJHz9Bb8SUU0LCu+UgEHVZqOPfvfa2q6jOdyW0G50m7nffZhtOtj5EymSbH4cV7q7Z2POfcNpYO9vLevaPnDhtWsaOxkbdxLrEE9447N4sXtzdlfXQvrb4AEZOXIeFwExf3qu/pS6gvL/FzcsLKY+VbLkIXtyCMW965DdTkodk5C7IGv5EjyxPaEvQa0+LS4Fy1icmMpw0pAuJGrSZnLVGExbeMnOzpQVmW6wxj7Sv7I3cuOnAgvu/C7ubt/UTMQ8Rv/d4J/we9YLeRNM3ttwAAAABJRU5ErkJggg=="
  , $4e = n => ["Completed", "Added"].includes(n) ? {
    status: "Completed",
    color: "text-[#4ade80]",
    bgColor: "bg-gradient-to-br from-[#4ade80]/20 to-[#22c55e]/10",
    borderColor: "border-[#4ade80]/30",
    prefix: "+"
} : {
    status: "Debited",
    color: "text-[#ef4444]",
    bgColor: "bg-gradient-to-br from-[#ef4444]/20 to-[#dc2626]/10",
    borderColor: "border-[#ef4444]/30",
    prefix: "-"
};
function H4e() {
    const [n,e] = V.useState([])
      , [t,r] = V.useState({
        page: 1,
        totalPages: 1
    })
      , [s,i] = V.useState(!0)
      , [o,a] = V.useState(!1)
      , l = V.useRef(null)
      , u = V.useRef(null)
      , d = V.useCallback(async p => {
        try {
            p === 1 ? i(!0) : a(!0);
            const g = await jSe(p);
            if (g?.status === "success") {
                const w = g?.data?.transactionHistory?.data || []
                  , b = g?.data?.transactionHistory?.meta || {};
                e(S => {
                    if (p === 1)
                        return w;
                    {
                        const N = new Set(S.map(I => I?.transaction_id || I?.id))
                          , _ = w.filter(I => !N.has(I?.transaction_id || I?.id));
                        return [...S, ..._]
                    }
                }
                );
                const v = {
                    ...b,
                    page: b.page || p,
                    totalPages: b.totalPages || b.lastPage || 1
                };
                r(S => ({
                    ...S,
                    ...v
                }))
            }
        } catch (g) {
            console.error("[BalanceHistory] Error loading transaction history:", g)
        } finally {
            i(!1),
            a(!1)
        }
    }
    , []);
    V.useEffect( () => {
        d(1)
    }
    , [d]);
    const h = V.useCallback( () => {
        if (s || o)
            return;
        const p = t.page || 1
          , g = t.totalPages || t.lastPage || 1;
        p < g && d(p + 1)
    }
    , [t, s, o, d]);
    return V.useEffect( () => {
        const p = u.current
          , g = l.current;
        if (!p || !g)
            return;
        const w = t.page || 1
          , b = t.totalPages || t.lastPage || 1;
        if (!(w < b))
            return;
        const S = new IntersectionObserver(N => {
            if (N[0].isIntersecting && !s && !o) {
                const I = t.page || 1
                  , k = t.totalPages || t.lastPage || 1;
                I < k && h()
            }
        }
        ,{
            root: g,
            rootMargin: "50px",
            threshold: .1
        });
        return S.observe(p),
        () => {
            S.disconnect()
        }
    }
    , [h, s, o, t]),
    m.jsxs(m.Fragment, {
        children: [m.jsx("div", {
            className: "flex items-center justify-between my-4",
            children: m.jsx("h6", {
                className: "text-base",
                children: "History"
            })
        }), m.jsxs("div", {
            ref: l,
            className: `max-h-[380px] overflow-y-auto pr-1 [&::-webkit-scrollbar]:w-2
  [&::-webkit-scrollbar-track]:rounded-full
  [&::-webkit-scrollbar-track]:bg-[#3d4b6f]
  [&::-webkit-scrollbar-thumb]:rounded-full
  [&::-webkit-scrollbar-thumb]:bg-[#8a95b1]
  dark:[&::-webkit-scrollbar-track]:bg-neutral-700
  dark:[&::-webkit-scrollbar-thumb]:bg-neutral-500`,
            children: [s ? m.jsx(KC, {
                rows: 10,
                cols: 4
            }) : n.map( (p, g) => {
                const w = $4e(p?.status);
                return m.jsxs("div", {
                    className: "bg-gradient-to-br from-[#253245] to-[#1e2938] p-3 rounded-xl border border-[#2f4159]/50 hover:border-[#FF6717]/40 transition-all duration-300 mb-3 shadow-lg hover:shadow-xl group",
                    children: [m.jsxs("div", {
                        className: "flex items-center justify-between mb-2",
                        children: [m.jsx("div", {
                            className: "flex items-center gap-2",
                            children: m.jsx("span", {
                                className: "text-lg text-white font-medium capitalize",
                                children: p?.type?.replace(/_/g, " ")
                            })
                        }), m.jsxs("div", {
                            className: "flex items-center gap-3",
                            children: [m.jsx("div", {
                                className: `w-7 h-7 rounded-full ${w.bgColor} border ${w.borderColor} p-[2px] group-hover:scale-110 transition-transform duration-300`,
                                children: m.jsx("div", {
                                    className: "w-full h-full rounded-full bg-[#1e2938] flex items-center justify-center",
                                    children: m.jsx("img", {
                                        src: ri,
                                        className: "w-4 h-4"
                                    })
                                })
                            }), m.jsx("div", {
                                children: m.jsx("div", {
                                    className: `text-xl font-bold font-jura ${w.color} flex items-center gap-1`,
                                    children: m.jsxs("span", {
                                        children: [wn(p?.amount || 0, 4), " L1XP"]
                                    })
                                })
                            })]
                        })]
                    }), m.jsxs("div", {
                        className: "flex items-center justify-between pt-2 border-t border-[#2f4159]/50",
                        children: [m.jsxs("div", {
                            className: "flex items-center gap-2",
                            children: [m.jsx("span", {
                                className: "text-sm text-[#73849B] font-mono tracking-wide",
                                children: zo(p?.transaction_id)
                            }), m.jsx("button", {
                                onClick: () => window.copyToClipboard(p?.transaction_id, "Transaction ID copied!"),
                                className: "hover:scale-110 transition-transform duration-200 cursor-pointer",
                                title: "Copy Transaction ID",
                                children: m.jsx("svg", {
                                    xmlns: "http://www.w3.org/2000/svg",
                                    fill: "none",
                                    viewBox: "0 0 24 24",
                                    strokeWidth: 1.5,
                                    stroke: "#73849B",
                                    className: "w-4 h-4 hover:stroke-[#FF6717]",
                                    children: m.jsx("path", {
                                        strokeLinecap: "round",
                                        strokeLinejoin: "round",
                                        d: "M16.5 8.25V6a2.25 2.25 0 0 0-2.25-2.25H6A2.25 2.25 0 0 0 3.75 6v8.25A2.25 2.25 0 0 0 6 16.5h2.25m8.25-8.25H18a2.25 2.25 0 0 1 2.25 2.25V18A2.25 2.25 0 0 1 18 20.25h-7.5A2.25 2.25 0 0 1 8.25 18v-1.5m8.25-8.25h-6a2.25 2.25 0 0 0-2.25 2.25v6"
                                    })
                                })
                            })]
                        }), m.jsx("div", {
                            className: "text-right",
                            children: m.jsxs("div", {
                                className: "flex items-center gap-2 text-[#94a3b8] text-sm mb-1",
                                children: [m.jsx("svg", {
                                    xmlns: "http://www.w3.org/2000/svg",
                                    fill: "none",
                                    viewBox: "0 0 24 24",
                                    strokeWidth: 1.5,
                                    stroke: "currentColor",
                                    className: "w-4 h-4",
                                    children: m.jsx("path", {
                                        strokeLinecap: "round",
                                        strokeLinejoin: "round",
                                        d: "M12 6v6h4.5m4.5 0a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"
                                    })
                                }), m.jsx("span", {
                                    className: "font-medium",
                                    children: uq(p?.created_at)
                                })]
                            })
                        })]
                    })]
                }, g)
            }
            ), o && m.jsx("div", {
                className: "my-4",
                children: m.jsx(KC, {
                    rows: 3,
                    cols: 3
                })
            }), !s && n.length > 0 && ( () => {
                const p = t.page || 1
                  , g = t.totalPages || t.lastPage || 1;
                return p < g ? m.jsx("div", {
                    ref: u,
                    className: "h-4 w-full flex items-center justify-center py-2",
                    children: o && m.jsx("div", {
                        className: "text-sm text-[#73849B]",
                        children: "Loading more..."
                    })
                }) : null
            }
            )()]
        })]
    })
}
const V4e = ({setIsOpen: n, userBalance: e}) => {
    const [t,r] = V.useState([])
      , [s,i] = V.useState({})
      , o = kr()
      , {refreshBalance: a} = Hs()
      , l = u => {
        n(!1),
        o("/deposit", {
            state: {
                activeTab: u
            }
        })
    }
    ;
    return V.useEffect( () => {
        a()
    }
    , []),
    m.jsx("div", {
        className: "fixed inset-0 flex items-start justify-center bg-black/50 z-[99] px-4 backdrop-blur-md",
        children: m.jsx("div", {
            className: "balance-bg-popup p-5 text-white rounded-2xl max-w-2xl w-full text-left absolute top-20 shadow-lg",
            children: m.jsxs("div", {
                className: "relative z-10",
                children: [m.jsxs("div", {
                    className: "flex items-center justify-between",
                    children: [m.jsx("h3", {
                        className: "text-2xl font-medium text-white",
                        children: "My Wallet"
                    }), m.jsx("button", {
                        onClick: () => n(!1),
                        className: " text-[#A8B8CC] hover:text-white cursor-pointer",
                        children: m.jsx("svg", {
                            xmlns: "http://www.w3.org/2000/svg",
                            fill: "none",
                            viewBox: "0 0 24 24",
                            strokeWidth: 1.5,
                            stroke: "currentColor",
                            className: "size-6",
                            children: m.jsx("path", {
                                strokeLinecap: "round",
                                strokeLinejoin: "round",
                                d: "M6 18 18 6M6 6l12 12"
                            })
                        })
                    })]
                }), m.jsxs("div", {
                    className: "bg-[#172333] p-4 rounded-xl mt-6",
                    children: [m.jsx("label", {
                        className: "text-[#70829A] text-sm block mb-2.5",
                        children: "Total Balance"
                    }), m.jsxs("div", {
                        className: "md:flex items-center gap-4 justify-between border-b border-[#283E5C] pb-4 mb-4",
                        children: [m.jsxs("div", {
                            className: "flex items-center gap-2.5 mb-2 md:mb-0",
                            children: [m.jsx("img", {
                                src: ri,
                                className: "w-9"
                            }), e?.isLoading ? m.jsxs("div", {
                                className: "flex items-center gap-2",
                                children: [m.jsx("div", {
                                    className: "h-6 w-32 bg-gray-700 rounded animate-pulse"
                                }), m.jsx("span", {
                                    className: "text-2xl font-semibold",
                                    children: "L1XP"
                                })]
                            }) : m.jsxs("h3", {
                                className: "text-2xl font-semibold",
                                children: [wn(Number(e?.l1xsBalance) + Number(e?.l1xsLocked) || 0), " L1XP"]
                            })]
                        }), m.jsxs("div", {
                            className: "flex items-center gap-4 ",
                            children: [m.jsxs("button", {
                                onClick: () => l("deposit"),
                                className: "bg-[#37A505] py-2 px-3 md:px-7 rounded-4xl flex items-center gap-2.5 text-white cursor-pointer",
                                children: [m.jsx("svg", {
                                    xmlns: "http://www.w3.org/2000/svg",
                                    fill: "none",
                                    viewBox: "0 0 24 24",
                                    strokeWidth: 1.5,
                                    stroke: "currentColor",
                                    className: "size-4 md:size-6",
                                    children: m.jsx("path", {
                                        strokeLinecap: "round",
                                        strokeLinejoin: "round",
                                        d: "M12 4.5v15m7.5-7.5h-15"
                                    })
                                }), "Add Balance"]
                            }), m.jsxs("button", {
                                onClick: () => l("withdraw"),
                                className: "bg-[#314258] py-2 px-3 md:px-7 rounded-4xl flex items-center gap-2.5 text-white cursor-pointer",
                                children: [m.jsx("svg", {
                                    xmlns: "http://www.w3.org/2000/svg",
                                    fill: "none",
                                    viewBox: "0 0 24 24",
                                    strokeWidth: 1.5,
                                    stroke: "currentColor",
                                    className: "size-4 md:size-6",
                                    children: m.jsx("path", {
                                        strokeLinecap: "round",
                                        strokeLinejoin: "round",
                                        d: "M5 12h14"
                                    })
                                }), " Withdraw"]
                            })]
                        })]
                    }), m.jsxs("div", {
                        className: "grid grid-cols-2",
                        children: [m.jsxs("div", {
                            className: " border-r border-[#283E5C] pr-5",
                            children: [m.jsx("label", {
                                className: "text-[#70829A] text-sm block mb-1.5",
                                children: "Playable Balance"
                            }), m.jsxs("div", {
                                className: "flex items-center gap-2.5",
                                children: [m.jsx("img", {
                                    src: ri,
                                    className: "w-5"
                                }), e?.isLoading ? m.jsxs("div", {
                                    className: "flex items-center gap-2",
                                    children: [m.jsx("div", {
                                        className: "h-5 w-24 bg-gray-700 rounded animate-pulse"
                                    }), m.jsx("span", {
                                        className: "text-lg font-semibold",
                                        children: "L1XP"
                                    })]
                                }) : m.jsxs("h3", {
                                    className: "text-lg font-semibold",
                                    children: [wn(e?.l1xsBalance || 0, 4), " L1XP"]
                                })]
                            })]
                        }), m.jsxs("div", {
                            className: "pl-5",
                            children: [m.jsx("label", {
                                className: "text-[#70829A] text-sm block mb-1.5",
                                children: "Locked Balance"
                            }), m.jsxs("div", {
                                className: "flex items-center gap-2.5",
                                children: [m.jsx("img", {
                                    src: ri,
                                    className: "w-5"
                                }), e?.isLoading ? m.jsxs("div", {
                                    className: "flex items-center gap-2",
                                    children: [m.jsx("div", {
                                        className: "h-5 w-24 bg-gray-700 rounded animate-pulse"
                                    }), m.jsx("span", {
                                        className: "text-lg font-semibold",
                                        children: "L1XP"
                                    })]
                                }) : m.jsxs("h3", {
                                    className: "text-lg font-semibold",
                                    children: [wn(e?.l1xsLocked || 0, 4), " L1XP"]
                                }), m.jsxs("span", {
                                    className: "text-[#70829A] relative group cursor-pointer",
                                    children: [m.jsx("svg", {
                                        xmlns: "http://www.w3.org/2000/svg",
                                        fill: "none",
                                        viewBox: "0 0 24 24",
                                        strokeWidth: 1.5,
                                        stroke: "currentColor",
                                        className: "size-6",
                                        children: m.jsx("path", {
                                            strokeLinecap: "round",
                                            strokeLinejoin: "round",
                                            d: "m11.25 11.25.041-.02a.75.75 0 0 1 1.063.852l-.708 2.836a.75.75 0 0 0 1.063.853l.041-.021M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Zm-9-3.75h.008v.008H12V8.25Z"
                                        })
                                    }), m.jsxs("div", {
                                        className: "absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 w-64 p-3 bg-black text-white text-xs rounded-lg shadow-lg opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all duration-200 pointer-events-none z-50 border border-[#283E5C]",
                                        children: [m.jsx("p", {
                                            className: "text-center",
                                            children: "To unlock your balance, please log out and log back in."
                                        }), m.jsx("div", {
                                            className: "absolute top-full left-1/2 transform -translate-x-1/2 -mt-1",
                                            children: m.jsx("div", {
                                                className: "w-2 h-2 bg-black border-r border-b border-black transform rotate-45"
                                            })
                                        })]
                                    })]
                                })]
                            })]
                        })]
                    })]
                }), m.jsx(H4e, {
                    txHistory: t
                })]
            })
        })
    })
}
  , q4e = "data:image/svg+xml,%3csvg%20width='20'%20height='20'%20viewBox='0%200%2020%2020'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20clip-path='url(%23clip0_371_2449)'%3e%3cpath%20d='M0.833008%203.33398V8.33398H5.83301'%20stroke='white'%20stroke-width='2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M2.92467%2012.5C3.465%2014.0337%204.48912%2015.3502%205.84272%2016.2512C7.19632%2017.1522%208.80608%2017.5889%2010.4294%2017.4954C12.0528%2017.402%2013.6018%2016.7835%2014.8431%2015.7332C16.0844%2014.6828%2016.9507%2013.2575%2017.3115%2011.672C17.6723%2010.0865%2017.5081%208.42667%2016.8435%206.94262C16.179%205.45857%2015.0501%204.2307%2013.627%203.44401C12.204%202.65732%2010.5638%202.35442%208.95357%202.58097C7.34338%202.80751%205.85043%203.55122%204.69967%204.70004L0.833008%208.33337'%20stroke='white'%20stroke-width='2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M10%208V11L12%2012'%20stroke='white'%20stroke-width='2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/g%3e%3cdefs%3e%3cclipPath%20id='clip0_371_2449'%3e%3crect%20width='20'%20height='20'%20fill='white'/%3e%3c/clipPath%3e%3c/defs%3e%3c/svg%3e"
  , G4e = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M9%2021H5C4.46957%2021%203.96086%2020.7893%203.58579%2020.4142C3.21071%2020.0391%203%2019.5304%203%2019V5C3%204.46957%203.21071%203.96086%203.58579%203.58579C3.96086%203.21071%204.46957%203%205%203H9'%20stroke='white'%20stroke-width='2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M16%2017L21%2012L16%207'%20stroke='white'%20stroke-width='2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M21%2012H9'%20stroke='white'%20stroke-width='2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e";
var ng = {}, js = {}, wA, nP;
function W4e() {
    if (nP)
        return wA;
    nP = 1;
    var n = function(e) {
        e == null && (e = new Date().getTime()),
        this.N = 624,
        this.M = 397,
        this.MATRIX_A = 2567483615,
        this.UPPER_MASK = 2147483648,
        this.LOWER_MASK = 2147483647,
        this.mt = new Array(this.N),
        this.mti = this.N + 1,
        e.constructor == Array ? this.init_by_array(e, e.length) : this.init_seed(e)
    };
    return n.prototype.init_seed = function(e) {
        for (this.mt[0] = e >>> 0,
        this.mti = 1; this.mti < this.N; this.mti++) {
            var e = this.mt[this.mti - 1] ^ this.mt[this.mti - 1] >>> 30;
            this.mt[this.mti] = (((e & 4294901760) >>> 16) * 1812433253 << 16) + (e & 65535) * 1812433253 + this.mti,
            this.mt[this.mti] >>>= 0
        }
    }
    ,
    n.prototype.init_by_array = function(e, t) {
        var r, s, i;
        for (this.init_seed(19650218),
        r = 1,
        s = 0,
        i = this.N > t ? this.N : t; i; i--) {
            var o = this.mt[r - 1] ^ this.mt[r - 1] >>> 30;
            this.mt[r] = (this.mt[r] ^ (((o & 4294901760) >>> 16) * 1664525 << 16) + (o & 65535) * 1664525) + e[s] + s,
            this.mt[r] >>>= 0,
            r++,
            s++,
            r >= this.N && (this.mt[0] = this.mt[this.N - 1],
            r = 1),
            s >= t && (s = 0)
        }
        for (i = this.N - 1; i; i--) {
            var o = this.mt[r - 1] ^ this.mt[r - 1] >>> 30;
            this.mt[r] = (this.mt[r] ^ (((o & 4294901760) >>> 16) * 1566083941 << 16) + (o & 65535) * 1566083941) - r,
            this.mt[r] >>>= 0,
            r++,
            r >= this.N && (this.mt[0] = this.mt[this.N - 1],
            r = 1)
        }
        this.mt[0] = 2147483648
    }
    ,
    n.prototype.random_int = function() {
        var e, t = new Array(0,this.MATRIX_A);
        if (this.mti >= this.N) {
            var r;
            for (this.mti == this.N + 1 && this.init_seed(5489),
            r = 0; r < this.N - this.M; r++)
                e = this.mt[r] & this.UPPER_MASK | this.mt[r + 1] & this.LOWER_MASK,
                this.mt[r] = this.mt[r + this.M] ^ e >>> 1 ^ t[e & 1];
            for (; r < this.N - 1; r++)
                e = this.mt[r] & this.UPPER_MASK | this.mt[r + 1] & this.LOWER_MASK,
                this.mt[r] = this.mt[r + (this.M - this.N)] ^ e >>> 1 ^ t[e & 1];
            e = this.mt[this.N - 1] & this.UPPER_MASK | this.mt[0] & this.LOWER_MASK,
            this.mt[this.N - 1] = this.mt[this.M - 1] ^ e >>> 1 ^ t[e & 1],
            this.mti = 0
        }
        return e = this.mt[this.mti++],
        e ^= e >>> 11,
        e ^= e << 7 & 2636928640,
        e ^= e << 15 & 4022730752,
        e ^= e >>> 18,
        e >>> 0
    }
    ,
    n.prototype.random_int31 = function() {
        return this.random_int() >>> 1
    }
    ,
    n.prototype.random_incl = function() {
        return this.random_int() * (1 / 4294967295)
    }
    ,
    n.prototype.random = function() {
        return this.random_int() * (1 / 4294967296)
    }
    ,
    n.prototype.random_excl = function() {
        return (this.random_int() + .5) * (1 / 4294967296)
    }
    ,
    n.prototype.random_long = function() {
        var e = this.random_int() >>> 5
          , t = this.random_int() >>> 6;
        return (e * 67108864 + t) * (1 / 9007199254740992)
    }
    ,
    wA = n,
    wA
}
var vA = {}, rP;
function Y4e() {
    return rP || (rP = 1,
    (function(n) {
        Object.defineProperty(n, "__esModule", {
            value: !0
        }),
        n.HSLToHex = n.hexToHSL = n.colorRotate = void 0;
        var e = function(s, i) {
            var o = (0,
            n.hexToHSL)(s)
              , a = o.h;
            return a = (a + i) % 360,
            a = a < 0 ? 360 + a : a,
            o.h = a,
            (0,
            n.HSLToHex)(o)
        };
        n.colorRotate = e;
        var t = function(s) {
            var i = "0x" + s[1] + s[2]
              , o = "0x" + s[3] + s[4]
              , a = "0x" + s[5] + s[6]
              , l = parseInt(i) / 255
              , u = parseInt(o) / 255
              , d = parseInt(a) / 255
              , h = Math.min(l, u, d)
              , p = Math.max(l, u, d)
              , g = p - h
              , w = 0
              , b = 0
              , v = 0;
            return g == 0 ? w = 0 : p == l ? w = (u - d) / g % 6 : p == u ? w = (d - l) / g + 2 : w = (l - u) / g + 4,
            w = Math.round(w * 60),
            w < 0 && (w += 360),
            v = (p + h) / 2,
            b = g == 0 ? 0 : g / (1 - Math.abs(2 * v - 1)),
            b = +(b * 100).toFixed(1),
            v = +(v * 100).toFixed(1),
            {
                h: w,
                s: b,
                l: v
            }
        };
        n.hexToHSL = t;
        var r = function(s) {
            var i = s.h
              , o = s.s
              , a = s.l;
            o /= 100,
            a /= 100;
            var l = (1 - Math.abs(2 * a - 1)) * o
              , u = l * (1 - Math.abs(i / 60 % 2 - 1))
              , d = a - l / 2
              , h = 0
              , p = 0
              , g = 0;
            0 <= i && i < 60 ? (h = l,
            p = u,
            g = 0) : 60 <= i && i < 120 ? (h = u,
            p = l,
            g = 0) : 120 <= i && i < 180 ? (h = 0,
            p = l,
            g = u) : 180 <= i && i < 240 ? (h = 0,
            p = u,
            g = l) : 240 <= i && i < 300 ? (h = u,
            p = 0,
            g = l) : 300 <= i && i < 360 && (h = l,
            p = 0,
            g = u);
            var w = Math.round((h + d) * 255).toString(16)
              , b = Math.round((p + d) * 255).toString(16)
              , v = Math.round((g + d) * 255).toString(16);
            return w.length == 1 && (w = "0" + w),
            b.length == 1 && (b = "0" + b),
            v.length == 1 && (v = "0" + v),
            "#" + w + b + v
        };
        n.HSLToHex = r
    }
    )(vA)),
    vA
}
var iw = {}, sP;
function K4e() {
    return sP || (sP = 1,
    Object.defineProperty(iw, "__esModule", {
        value: !0
    }),
    iw.default = Object.freeze(["#01888c", "#fc7500", "#034f5d", "#f73f01", "#fc1960", "#c7144c", "#f3c100", "#1598f2", "#2465e1", "#f19e02"])),
    iw
}
var np = {}, iP;
function X4e() {
    if (iP)
        return np;
    iP = 1;
    var n = np && np.__assign || function() {
        return n = Object.assign || function(s) {
            for (var i, o = 1, a = arguments.length; o < a; o++) {
                i = arguments[o];
                for (var l in i)
                    Object.prototype.hasOwnProperty.call(i, l) && (s[l] = i[l])
            }
            return s
        }
        ,
        n.apply(this, arguments)
    }
    ;
    Object.defineProperty(np, "__esModule", {
        value: !0
    });
    var e = A8()
      , t = {
        borderRadius: "50px",
        display: "inline-block",
        margin: 0,
        overflow: "hidden",
        padding: 0
    }
      , r = function(s) {
        var i = s.children
          , o = s.color
          , a = s.diameter
          , l = s.style;
        return (0,
        e.jsx)("div", n({
            className: "paper",
            style: n(n(n({}, t), {
                backgroundColor: o,
                height: a,
                width: a
            }), l)
        }, {
            children: i
        }), void 0)
    };
    return np.default = r,
    np
}
var oP;
function Q4e() {
    if (oP)
        return js;
    oP = 1;
    var n = js && js.__extends || (function() {
        var S = function(N, _) {
            return S = Object.setPrototypeOf || {
                __proto__: []
            }instanceof Array && function(I, k) {
                I.__proto__ = k
            }
            || function(I, k) {
                for (var B in k)
                    Object.prototype.hasOwnProperty.call(k, B) && (I[B] = k[B])
            }
            ,
            S(N, _)
        };
        return function(N, _) {
            if (typeof _ != "function" && _ !== null)
                throw new TypeError("Class extends value " + String(_) + " is not a constructor or null");
            S(N, _);
            function I() {
                this.constructor = N
            }
            N.prototype = _ === null ? Object.create(_) : (I.prototype = _.prototype,
            new I)
        }
    }
    )()
      , e = js && js.__assign || function() {
        return e = Object.assign || function(S) {
            for (var N, _ = 1, I = arguments.length; _ < I; _++) {
                N = arguments[_];
                for (var k in N)
                    Object.prototype.hasOwnProperty.call(N, k) && (S[k] = N[k])
            }
            return S
        }
        ,
        e.apply(this, arguments)
    }
      , t = js && js.__createBinding || (Object.create ? (function(S, N, _, I) {
        I === void 0 && (I = _),
        Object.defineProperty(S, I, {
            enumerable: !0,
            get: function() {
                return N[_]
            }
        })
    }
    ) : (function(S, N, _, I) {
        I === void 0 && (I = _),
        S[I] = N[_]
    }
    ))
      , r = js && js.__setModuleDefault || (Object.create ? (function(S, N) {
        Object.defineProperty(S, "default", {
            enumerable: !0,
            value: N
        })
    }
    ) : function(S, N) {
        S.default = N
    }
    )
      , s = js && js.__importStar || function(S) {
        if (S && S.__esModule)
            return S;
        var N = {};
        if (S != null)
            for (var _ in S)
                _ !== "default" && Object.prototype.hasOwnProperty.call(S, _) && t(N, S, _);
        return r(N, S),
        N
    }
      , i = js && js.__importDefault || function(S) {
        return S && S.__esModule ? S : {
            default: S
        }
    }
    ;
    Object.defineProperty(js, "__esModule", {
        value: !0
    });
    var o = A8()
      , a = s(by())
      , l = i(W4e())
      , u = Y4e()
      , d = i(K4e())
      , h = i(X4e())
      , p = 4
      , g = "http://www.w3.org/2000/svg"
      , w = 30
      , b = 24
      , v = (function(S) {
        n(N, S);
        function N() {
            var _ = S !== null && S.apply(this, arguments) || this;
            return _.genColor = function(I) {
                _.generator.random();
                var k = Math.floor(I.length * _.generator.random())
                  , B = I.splice(k, 1)[0];
                return B
            }
            ,
            _.hueShift = function(I, k) {
                var B = k.random() * 30 - w / 2
                  , P = function(M) {
                    return (0,
                    u.colorRotate)(M, B)
                };
                return I.map(P)
            }
            ,
            _.genShape = function(I, k, B, P) {
                var M = k / 2
                  , R = _.generator.random()
                  , L = Math.PI * 2 * R
                  , q = k / P * _.generator.random() + B * k / P
                  , H = Math.cos(L) * q
                  , j = Math.sin(L) * q
                  , A = "translate(" + H + " " + j + ")"
                  , E = _.generator.random()
                  , C = R * 360 + E * 180
                  , O = "rotate(" + C.toFixed(1) + " " + M + " " + M + ")"
                  , z = A + " " + O
                  , G = _.genColor(I);
                return (0,
                o.jsx)("rect", {
                    x: "0",
                    y: "0",
                    rx: "0",
                    ry: "0",
                    height: k,
                    width: k,
                    transform: z,
                    fill: G
                }, B)
            }
            ,
            _
        }
        return N.prototype.render = function() {
            var _ = this
              , I = this.props
              , k = I.diameter
              , B = k === void 0 ? b : k
              , P = I.paperStyles
              , M = P === void 0 ? {} : P
              , R = I.seed
              , L = I.svgStyles
              , q = L === void 0 ? {} : L;
            this.generator = new l.default(R);
            var H = this.hueShift(d.default.slice(), this.generator)
              , j = Array(p).fill(void 0);
            return (0,
            o.jsx)(h.default, e({
                color: this.genColor(H),
                diameter: B,
                style: M
            }, {
                children: (0,
                o.jsx)("svg", e({
                    xmlns: g,
                    x: "0",
                    y: "0",
                    height: B,
                    width: B,
                    style: q
                }, {
                    children: j.map(function(A, E) {
                        return _.genShape(H, B, E, p - 1)
                    })
                }), void 0)
            }), void 0)
        }
        ,
        N
    }
    )(a.PureComponent);
    return js.default = v,
    js
}
var ow = {}, aP;
function Z4e() {
    if (aP)
        return ow;
    aP = 1,
    Object.defineProperty(ow, "__esModule", {
        value: !0
    });
    function n(e) {
        var t = e.slice(2, 10)
          , r = parseInt(t, 16);
        return r
    }
    return ow.default = n,
    ow
}
var lP;
function J4e() {
    return lP || (lP = 1,
    (function(n) {
        var e = ng && ng.__importDefault || function(s) {
            return s && s.__esModule ? s : {
                default: s
            }
        }
        ;
        Object.defineProperty(n, "__esModule", {
            value: !0
        }),
        n.jsNumberForAddress = n.default = void 0;
        var t = Q4e();
        Object.defineProperty(n, "default", {
            enumerable: !0,
            get: function() {
                return e(t).default
            }
        });
        var r = Z4e();
        Object.defineProperty(n, "jsNumberForAddress", {
            enumerable: !0,
            get: function() {
                return e(r).default
            }
        })
    }
    )(ng)),
    ng
}
var ay = J4e();
const Z2 = Fo(ay)
  , eCe = ({isOpen: n, onClose: e, walletAddress: t, disconnectWallet: r, emailAddress: s, setEmailAddress: i}) => {
    if (!n)
        return null;
    const [o,a] = V.useState(null)
      , l = kr()
      , u = () => {
        s ? (T8("userInfo"),
        i(null)) : r(),
        e()
    }
    ;
    return m.jsxs("div", {
        className: "",
        children: [m.jsx("div", {
            className: "bg-[#27364b] md:max-w-sm md:w-full rounded-3xl absolute top-12 left-0 right-0 mx-4 md:mx-auto z-[100] text-white overflow-hidden",
            children: m.jsxs("div", {
                className: "bg-[#2B3A4F] p-8 relative ",
                children: [m.jsx("div", {
                    className: "cursor-pointer w-12 h-12 absolute right-1 top-1 flex items-center justify-center flex-col opacity-55",
                    onClick: e,
                    children: m.jsx("svg", {
                        xmlns: "http://www.w3.org/2000/svg",
                        fill: "none",
                        viewBox: "0 0 24 24",
                        strokeWidth: 1.5,
                        stroke: "currentColor",
                        className: "size-6",
                        children: m.jsx("path", {
                            strokeLinecap: "round",
                            strokeLinejoin: "round",
                            d: "M6 18 18 6M6 6l12 12"
                        })
                    })
                }), m.jsx("div", {
                    className: "w-24 h-24 mx-auto rounded-full overflow-hidden bg-white p-1 flex items-center justify-center",
                    children: m.jsx(Z2, {
                        diameter: 90,
                        seed: ay.jsNumberForAddress(t)
                    })
                }), m.jsxs("p", {
                    className: "flex items-center gap-3 text-lg justify-center mt-3",
                    children: [zo(t, 8), m.jsx("span", {
                        className: "inline-block cursor-pointer hover:opacity-80 transition-opacity",
                        onClick: () => dq(t, "Wallet address copied!"),
                        title: "Copy wallet address",
                        children: m.jsx("svg", {
                            xmlns: "http://www.w3.org/2000/svg",
                            fill: "none",
                            viewBox: "0 0 24 24",
                            strokeWidth: 1.5,
                            stroke: "#97A7BD",
                            className: "size-5",
                            children: m.jsx("path", {
                                strokeLinecap: "round",
                                strokeLinejoin: "round",
                                d: "M16.5 8.25V6a2.25 2.25 0 0 0-2.25-2.25H6A2.25 2.25 0 0 0 3.75 6v8.25A2.25 2.25 0 0 0 6 16.5h2.25m8.25-8.25H18a2.25 2.25 0 0 1 2.25 2.25V18A2.25 2.25 0 0 1 18 20.25h-7.5A2.25 2.25 0 0 1 8.25 18v-1.5m8.25-8.25h-6a2.25 2.25 0 0 0-2.25 2.25v6"
                            })
                        })
                    })]
                }), m.jsxs("div", {
                    className: "bg-[#253245] rounded-2xl mt-5",
                    children: [m.jsxs("button", {
                        onClick: () => {
                            e(),
                            l("/my-profile", {
                                state: {
                                    tab: "profile",
                                    emailAddress: s
                                }
                            })
                        }
                        ,
                        className: "cursor-pointer flex gap-3 items-center justify-between py-4 px-3 w-full text-base border-b border-[#32425A] hover:bg-[#32425A]/20 transition-colors duration-200",
                        children: [m.jsxs("div", {
                            className: "flex items-center gap-3",
                            children: [m.jsx("svg", {
                                xmlns: "http://www.w3.org/2000/svg",
                                fill: "none",
                                viewBox: "0 0 24 24",
                                strokeWidth: 1.5,
                                stroke: "currentColor",
                                className: "size-6",
                                children: m.jsx("path", {
                                    strokeLinecap: "round",
                                    strokeLinejoin: "round",
                                    d: "M17.982 18.725A7.488 7.488 0 0 0 12 15.75a7.488 7.488 0 0 0-5.982 2.975m11.963 0a9 9 0 1 0-11.963 0m11.963 0A8.966 8.966 0 0 1 12 21a8.966 8.966 0 0 1-5.982-2.275M15 9.75a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z"
                                })
                            }), "My Profile"]
                        }), m.jsx("svg", {
                            xmlns: "http://www.w3.org/2000/svg",
                            fill: "none",
                            viewBox: "0 0 24 24",
                            strokeWidth: 1.5,
                            stroke: "#515B6A",
                            className: "size-6",
                            children: m.jsx("path", {
                                strokeLinecap: "round",
                                strokeLinejoin: "round",
                                d: "m8.25 4.5 7.5 7.5-7.5 7.5"
                            })
                        })]
                    }), m.jsxs("button", {
                        onClick: () => {
                            e(),
                            l("/my-profile", {
                                state: {
                                    tab: "history",
                                    emailAddress: s
                                }
                            })
                        }
                        ,
                        className: "cursor-pointer flex gap-3 items-center justify-between py-4 px-3 w-full text-base hover:bg-[#32425A]/20 transition-colors duration-200",
                        children: [m.jsxs("div", {
                            className: "flex items-center gap-3",
                            children: [m.jsx("img", {
                                src: q4e
                            }), "Game History"]
                        }), m.jsx("svg", {
                            xmlns: "http://www.w3.org/2000/svg",
                            fill: "none",
                            viewBox: "0 0 24 24",
                            strokeWidth: 1.5,
                            stroke: "#515B6A",
                            className: "size-6",
                            children: m.jsx("path", {
                                strokeLinecap: "round",
                                strokeLinejoin: "round",
                                d: "m8.25 4.5 7.5 7.5-7.5 7.5"
                            })
                        })]
                    })]
                }), m.jsx("div", {
                    className: "mt-8",
                    children: m.jsxs("button", {
                        onClick: u,
                        className: "cursor-pointer flex items-center justify-between w-full gap-3 btn-clr py-4 px-5 rounded-xl text-base font-semibold hover:brightness-90 hover:scale-[1.02] transition-all duration-200",
                        children: ["Logout ", m.jsx("img", {
                            src: G4e
                        })]
                    })
                })]
            })
        }), m.jsx("div", {
            className: "fixed bg-black/70 w-full h-full top-0 left-0 z-[99] backdrop-blur-lg"
        })]
    })
}
;
var xA = {
    exports: {}
}, EA, cP;
function tCe() {
    if (cP)
        return EA;
    cP = 1;
    var n = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    return EA = n,
    EA
}
var SA, uP;
function nCe() {
    if (uP)
        return SA;
    uP = 1;
    var n = tCe();
    function e() {}
    function t() {}
    return t.resetWarningCache = e,
    SA = function() {
        function r(o, a, l, u, d, h) {
            if (h !== n) {
                var p = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
                throw p.name = "Invariant Violation",
                p
            }
        }
        r.isRequired = r;
        function s() {
            return r
        }
        var i = {
            array: r,
            bigint: r,
            bool: r,
            func: r,
            number: r,
            object: r,
            string: r,
            symbol: r,
            any: r,
            arrayOf: s,
            element: r,
            elementType: r,
            instanceOf: s,
            node: r,
            objectOf: s,
            oneOf: s,
            oneOfType: s,
            shape: s,
            exact: s,
            checkPropTypes: t,
            resetWarningCache: e
        };
        return i.PropTypes = i,
        i
    }
    ,
    SA
}
var dP;
function rCe() {
    return dP || (dP = 1,
    xA.exports = nCe()()),
    xA.exports
}
var sCe = rCe();
const rp = Fo(sCe);
rp.number,
rp.number,
rp.string,
rp.string,
rp.string,
rp.string;
const pk = () => {
    const [n,e] = V.useState(!1)
      , [t,r] = V.useState(!1)
      , s = B0()
      , [i,o] = V.useState(!1)
      , a = kr()
      , l = Ti()
      , {balance: u, disconnectWallet: d, emailAddress: h, setEmailAddress: p} = Hs()
      , g = () => {
        const b = document.getElementById("howItWorks");
        b && b.scrollIntoView({
            behavior: "smooth",
            block: "start"
        })
    }
      , w = b => {
        b.preventDefault(),
        e(!1),
        l.pathname === "/landing" ? g() : a("/landing#howItWorks")
    }
    ;
    return m.jsxs(m.Fragment, {
        children: [m.jsxs("div", {
            className: "py-5 px-2 md:px-7 flex items-center justify-between relative z-90",
            children: [m.jsx(Us, {
                to: "/",
                children: m.jsx("img", {
                    className: "w-20 md:w-auto",
                    src: _x
                })
            }), m.jsxs("div", {
                className: "lg:flex lg:w-full lg:justify-end",
                children: [m.jsx("div", {
                    className: "block lg:hidden cursor-pointer relative z-50",
                    onClick: () => e(!n),
                    children: n ? m.jsx("svg", {
                        xmlns: "http://www.w3.org/2000/svg",
                        fill: "none",
                        viewBox: "0 0 24 24",
                        strokeWidth: 1.5,
                        stroke: "#ffffff",
                        className: "w-7 h-7",
                        children: m.jsx("path", {
                            strokeLinecap: "round",
                            strokeLinejoin: "round",
                            d: "M6 18L18 6M6 6l12 12"
                        })
                    }) : m.jsx("svg", {
                        xmlns: "http://www.w3.org/2000/svg",
                        fill: "none",
                        viewBox: "0 0 24 24",
                        strokeWidth: 1.5,
                        stroke: "#ffffff",
                        className: "w-7 h-7",
                        children: m.jsx("path", {
                            strokeLinecap: "round",
                            strokeLinejoin: "round",
                            d: "M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5"
                        })
                    })
                }), n && m.jsx("div", {
                    className: "fixed inset-0 bg-black/60 backdrop-blur-sm lg:hidden z-40",
                    onClick: () => e(!1)
                }), m.jsxs("ul", {
                    className: `flex flex-col lg:flex-row items-start lg:items-center gap-4 lg:gap-3 
        fixed lg:static top-0 left-0 w-xs lg:w-auto h-screen lg:h-auto bg-[#2d3948] lg:bg-transparent p-5 lg:p-0
        transition-all duration-300 ease-in-out z-40 
        ${n ? "top-[0px] left-0 opacity-100 visible" : "left-[-100px] opacity-0 invisible lg:visible lg:opacity-100"}`,
                    children: [m.jsx("li", {
                        children: m.jsx("a", {
                            href: "/",
                            className: "text-white text-base font-medium py-2 md:py-3 px-2 md:px-6 inline-block cursor-pointer",
                            children: "About"
                        })
                    }), m.jsx("li", {
                        children: m.jsx("a", {
                            href: "#howItWorks",
                            onClick: w,
                            className: "text-white text-base font-medium py-2 md:py-3 px-2 md:px-6 inline-block cursor-pointer",
                            children: "How L1X Play Works"
                        })
                    }), m.jsx("li", {
                        children: m.jsx(Us, {
                            to: "/leaderboard",
                            onClick: () => e(!1),
                            className: "text-white text-base font-medium py-2 md:py-3 px-2 md:px-6 inline-block",
                            children: "Leaderboard"
                        })
                    }), (s?.walletAddress || h) && m.jsx("li", {
                        children: u?.isLoading === !0 ? m.jsx("div", {
                            className: "text-white text-base font-medium py-2 md:py-3 px-2 md:px-6 inline-block",
                            children: "Loading balance..."
                        }) : u && u.isLoading === !1 ? Number(u?.l1xsBalance || 0) > 0 ? m.jsx("div", {
                            className: "text-black  lg:w-auto w-full rounded-4xl bg-white flex gap-1 md:gap-2 items-center text-medium font-medium py-2 px-1 text-base pe-3 ps-2",
                            children: m.jsxs("div", {
                                onClick: () => {
                                    e(!1),
                                    r(!0)
                                }
                                ,
                                className: "flex items-center gap-2 cursor-pointer",
                                children: [m.jsx("img", {
                                    src: z4e,
                                    className: "w-6"
                                }), " ", wn(Number(u?.l1xsBalance) + Number(u?.l1xsLocked)), " L1XP ", m.jsx("svg", {
                                    xmlns: "http://www.w3.org/2000/svg",
                                    fill: "none",
                                    viewBox: "0 0 24 24",
                                    strokeWidth: 2,
                                    stroke: "currentColor",
                                    className: "size-4",
                                    children: m.jsx("path", {
                                        strokeLinecap: "round",
                                        strokeLinejoin: "round",
                                        d: "m19.5 8.25-7.5 7.5-7.5-7.5"
                                    })
                                })]
                            })
                        }) : m.jsxs(Us, {
                            to: "/deposit",
                            onClick: () => e(!1),
                            className: "text-white bg-[#37A505] rounded-4xl text-xs md:text-base font-medium py-2 md:py-2 px-2 md:px-3 gap-2 inline-flex items-center",
                            children: [m.jsx("span", {
                                className: "w-5 h-5 rounded-4xl bg-white flex items-center justify-center text-black",
                                children: m.jsx("svg", {
                                    xmlns: "http://www.w3.org/2000/svg",
                                    fill: "none",
                                    viewBox: "0 0 24 24",
                                    strokeWidth: 1.5,
                                    stroke: "currentColor",
                                    className: "size-6",
                                    children: m.jsx("path", {
                                        strokeLinecap: "round",
                                        strokeLinejoin: "round",
                                        d: "M12 4.5v15m7.5-7.5h-15"
                                    })
                                })
                            }), "Add Balance"]
                        }) : m.jsx("div", {
                            className: "text-white text-xs md:text-base font-medium py-2 md:py-3 px-2 md:px-6 inline-block",
                            children: "Loading balance..."
                        })
                    }), m.jsx("li", {
                        children: m.jsxs("button", {
                            onClick: () => {
                                e(!1),
                                s?.walletAddress || h ? o(!0) : a("/login")
                            }
                            ,
                            className: "text-white rounded-4xl brand-gradient-bg flex gap-1 md:gap-2 items-center text-medium font-medium py-2 px-3 md:px-5 text-base cursor-pointer",
                            children: [m.jsx("svg", {
                                xmlns: "http://www.w3.org/2000/svg",
                                fill: "none",
                                viewBox: "0 0 24 24",
                                strokeWidth: 1.5,
                                stroke: "currentColor",
                                className: "size-6",
                                children: m.jsx("path", {
                                    strokeLinecap: "round",
                                    strokeLinejoin: "round",
                                    d: "M15.75 6a3.75 3.75 0 1 1-7.5 0 3.75 3.75 0 0 1 7.5 0ZM4.501 20.118a7.5 7.5 0 0 1 14.998 0A17.933 17.933 0 0 1 12 21.75c-2.676 0-5.216-.584-7.499-1.632Z"
                                })
                            }), s?.walletAddress ? zo(s?.walletAddress) : h ? kAe(h, 12) : "Connect"]
                        })
                    })]
                })]
            })]
        }), t && m.jsx(V4e, {
            setIsOpen: r,
            userBalance: u
        }), m.jsx(eCe, {
            setEmailAddress: p,
            emailAddress: h,
            disconnectWallet: d,
            isOpen: i,
            onClose: () => o(!1),
            walletAddress: s?.walletAddress || ""
        })]
    })
}
  , xq = () => m.jsxs(m.Fragment, {
    children: [m.jsx("h3", {
        className: "text-2xl mb-8",
        children: "L1X-Play PLATFORM DISCLAIMER "
    }), m.jsxs("div", {
        className: `height-screens [&::-webkit-scrollbar]:w-2
  [&::-webkit-scrollbar-track]:rounded-full
  [&::-webkit-scrollbar-track]:bg-gray-100
  [&::-webkit-scrollbar-thumb]:rounded-full
  [&::-webkit-scrollbar-thumb]:bg-gray-300
  dark:[&::-webkit-scrollbar-track]:bg-[#1D2938]
  dark:[&::-webkit-scrollbar-thumb]:bg-[#354458]`,
        children: [m.jsx("h4", {
            className: "text-base font-medium",
            children: "1. General Information"
        }), m.jsxs("ol", {
            className: "pl-6 mt-2 mb-8",
            children: [m.jsx("li", {
                className: "mb-4 text-[#99B0CF] leading-5 font-light",
                children: '1.1. The platform (the "Platform") provides digital access to gaming, sweepstakes, prize draws, or contests (collectively, "Gaming") that may utilize digital tokens or blockchain-based representations for entry management, prize distribution, or participant verification ("Tokenized Entries").'
            }), m.jsx("li", {
                className: "mb-4 text-[#99B0CF] leading-5 font-light",
                children: '1.2. Participation in any Gaming is entirely voluntary and subject to the official rules, terms, and conditions specific to each promotion ("Gaming Rules").'
            }), m.jsx("li", {
                className: "mb-4 text-[#99B0CF] leading-5 font-light",
                children: "1.3. The Platform is operated for entertainment and promotional purposes only. It does not constitute an offer, solicitation, or recommendation to acquire, trade, or invest in any digital asset, token, or cryptocurrency."
            })]
        }), m.jsx("h4", {
            className: "text-base font-medium",
            children: "2. No Financial Product or Investment"
        }), m.jsxs("ol", {
            className: "pl-6 mt-2 mb-8",
            children: [m.jsx("li", {
                className: "mb-4 text-[#99B0CF] leading-5 font-light",
                children: "2.1. Tokens used within the Platform are not, and are not intended to be, financial products, securities, managed investment schemes, derivatives, or collective investment vehicles under any applicable law."
            }), m.jsx("li", {
                className: "mb-4 text-[#99B0CF] leading-5 font-light",
                children: "2.2. The Tokens confer no ownership interest, profit participation, dividend, or voting rights in the Platform or any associated entity."
            }), m.jsx("li", {
                className: "mb-4 text-[#99B0CF] leading-5 font-light",
                children: "2.3. The Tokens are issued solely for use within the Platform for Gaming participation, prize eligibility, and related engagement functions. They have no intrinsic or redeemable monetary value outside the Platform unless expressly stated."
            })]
        }), m.jsx("h4", {
            className: "text-base font-medium",
            children: "3. Jurisdictional Restrictions "
        }), m.jsxs("ol", {
            className: "pl-6 mt-2 mb-8",
            children: [m.jsx("li", {
                className: "mb-4 text-[#99B0CF] leading-5 font-light",
                children: "3.1. Gaming may not be available in all jurisdictions. Participation is void where prohibited by law."
            }), m.jsx("li", {
                className: "mb-4 text-[#99B0CF] leading-5 font-light",
                children: "3.2. It is the participant's responsibility to ensure that entry into any Gaming complies with local, state, federal, or international laws applicable to them."
            }), m.jsx("li", {
                className: "mb-4 text-[#99B0CF] leading-5 font-light",
                children: "3.3. The Platform operator disclaims any responsibility for participation by persons located in jurisdictions where Gaming or tokenized participation may be unlawful."
            })]
        }), m.jsx("h4", {
            className: "text-base font-medium",
            children: "4. No Guarantee or Warranties  "
        }), m.jsxs("ol", {
            className: "pl-6 mt-2 mb-8",
            children: [m.jsx("li", {
                className: "mb-4 text-[#99B0CF] leading-5 font-light",
                children: '4.1. The Platform and its associated services are provided on an "as-is" and "as-available" basis.'
            }), m.jsxs("li", {
                className: "mb-4 text-[#99B0CF] leading-5 font-light",
                children: [m.jsx("p", {
                    className: "mb-4",
                    children: "4.2. The operator makes no representations or warranties, express or implied, regarding: "
                }), m.jsxs("ul", {
                    className: "ml-12",
                    children: [m.jsx("li", {
                        className: "mb-4",
                        children: "(a) the continuity, reliability, or security of the Platform;"
                    }), m.jsx("li", {
                        className: "mb-4",
                        children: "(b) the accuracy or completeness of token balances, blockchain records, or prize distributions; or"
                    }), m.jsx("li", {
                        className: "mb-4",
                        children: "(c) the non-infringement, merchantability, or fitness for purpose of the Platform or any digital component thereof."
                    })]
                })]
            }), m.jsx("li", {
                className: "mb-4 text-[#99B0CF] leading-5 font-light",
                children: "4.3. The Company shall not be responsible for any data loss, gameplay disruption, transaction failure, or refund delay arising from or related to technical errors, network instability, blockchain congestion, server downtime, browser malfunctions, device incompatibility, or any third-party system failure. If a session or transaction ends prematurely and no valid completion or confirmation data is received by the Companys systems, such entry shall be deemed incomplete and invalid, and no refund of entry fees or tokens shall be provided."
            })]
        }), m.jsx("h4", {
            className: "text-base font-medium",
            children: "5. Limitation of Liability  "
        }), m.jsxs("ol", {
            className: "pl-6 mt-2 mb-8",
            children: [m.jsxs("li", {
                className: "mb-4 text-[#99B0CF] leading-5 font-light",
                children: [m.jsx("p", {
                    className: "mb-4",
                    children: "5.1. To the maximum extent permitted by law, the Platform operator and its affiliates shall not be liable for any loss, damage, claim, or expense arising from or related to:  "
                }), m.jsxs("ul", {
                    className: "ml-12",
                    children: [m.jsx("li", {
                        className: "mb-4",
                        children: "(a) participation in or inability to participate in any Gaming; "
                    }), m.jsx("li", {
                        className: "mb-4",
                        children: "(b) failure or malfunction of blockchain networks, smart contracts, or third-party services; "
                    }), m.jsx("li", {
                        className: "mb-4",
                        children: "(c) unauthorized access to participant data or wallets; or "
                    }), m.jsx("li", {
                        className: "mb-4",
                        children: "(d) reliance on any information contained on the Platform. "
                    })]
                })]
            }), m.jsx("li", {
                className: "mb-4 text-[#99B0CF] leading-5 font-light",
                children: "5.2. In no event shall the operator's total aggregate liability exceed the value of the entry fee or token associated with the relevant Gaming function."
            })]
        }), m.jsx("h4", {
            className: "text-base font-medium",
            children: "6. Token Handling and Risk Notice "
        }), m.jsxs("ol", {
            className: "pl-6 mt-2 mb-8",
            children: [m.jsx("li", {
                className: "mb-4 text-[#99B0CF] leading-5 font-light",
                children: "6.1. Tokenized Entries may involve blockchain transactions that are irreversible and dependent on participant accuracy."
            }), m.jsx("li", {
                className: "mb-4 text-[#99B0CF] leading-5 font-light",
                children: "6.2. Participants acknowledge that blockchain technologies are subject to risks including, but not limited to, price volatility, regulatory uncertainty, hacking, and smart contract errors."
            }), m.jsx("li", {
                className: "mb-4 text-[#99B0CF] leading-5 font-light",
                children: "6.3. The Platform operator accepts no responsibility for lost private keys, wallet access failures, or third-party exchange losses."
            })]
        }), m.jsx("h4", {
            className: "text-base font-medium",
            children: "7. Regulatory Compliance and Changes  "
        }), m.jsxs("ol", {
            className: "pl-6 mt-2 mb-8",
            children: [m.jsx("li", {
                className: "mb-4 text-[#99B0CF] leading-5 font-light",
                children: "7.1. The Platform reserves the right to modify, suspend, or terminate any Gaming or token function to ensure compliance with applicable law or regulatory guidance."
            }), m.jsx("li", {
                className: "mb-4 text-[#99B0CF] leading-5 font-light",
                children: "7.2. Participants acknowledge that digital asset and promotional regulations may evolve, and continued participation constitutes acceptance of any amended terms."
            })]
        }), m.jsx("h4", {
            className: "text-base font-medium",
            children: "8. No Legal or Financial Advice "
        }), m.jsxs("ol", {
            className: "pl-6 mt-2 mb-8",
            children: [m.jsx("li", {
                className: "mb-4 text-[#99B0CF] leading-5 font-light",
                children: "8.1. Nothing on the Platform or in related communications constitutes legal, tax, or financial advice."
            }), m.jsx("li", {
                className: "mb-4 text-[#99B0CF] leading-5 font-light",
                children: "8.2. Participants should seek independent professional advice before engaging with digital assets, tokens, or Gaming offered through the Platform."
            })]
        })]
    })]
})
  , iCe = () => {
    const n = kr()
      , e = () => {
        window.history.length > 1 ? n(-1) : n("/")
    }
    ;
    return m.jsxs("div", {
        className: "banner-bg relative min-h-screen",
        children: [m.jsx(pk, {}), m.jsx("div", {
            className: "container mx-auto px-4 py-12",
            children: m.jsx("div", {
                className: "max-w-4xl w-full mx-auto rounded-3xl text-white overflow-hidden",
                children: m.jsxs("div", {
                    className: "bg-[#1D2938] p-8 relative",
                    children: [m.jsx("button", {
                        className: "cursor-pointer w-12 h-12 absolute right-4 top-4 flex items-center justify-center flex-col bg-[#27364B]/80 hover:bg-[#354458] rounded-full",
                        onClick: e,
                        children: m.jsx("svg", {
                            xmlns: "http://www.w3.org/2000/svg",
                            fill: "none",
                            viewBox: "0 0 24 24",
                            strokeWidth: 1.5,
                            stroke: "currentColor",
                            className: "size-6",
                            children: m.jsx("path", {
                                strokeLinecap: "round",
                                strokeLinejoin: "round",
                                d: "M6 18 18 6M6 6l12 12"
                            })
                        })
                    }), m.jsx(xq, {}), m.jsx("div", {
                        className: "text-center flex items-center justify-center gap-4 mt-8",
                        children: m.jsx("button", {
                            onClick: e,
                            className: "brand-gradient-bg py-3.5 px-9 rounded-4xl text-base cursor-pointer max-w-48 w-full block",
                            children: "Go Back"
                        })
                    })]
                })
            })
        })]
    })
}
  , oCe = ({isOpen: n, onAccept: e}) => n ? m.jsxs("div", {
    className: "fixed inset-0 z-50 flex items-center justify-center px-4 py-6 md:py-12 backdrop-blur-sm",
    children: [m.jsx("div", {
        className: "absolute inset-0 bg-[#0B111C]/30"
    }), m.jsx("div", {
        className: "relative max-w-4xl w-full bg-[#1D2938] rounded-3xl text-white shadow-2xl border border-[#27364B]/50 overflow-hidden z-10",
        children: m.jsxs("div", {
            className: "px-6 md:px-10 pt-12 pb-6 md:pb-10",
            children: [m.jsxs("div", {
                className: "mb-6 text-center",
                children: [m.jsx("h2", {
                    className: "text-3xl md:text-4xl font-semibold",
                    children: "Terms & Conditions"
                }), m.jsx("p", {
                    className: "text-sm md:text-base text-[#A8B8CC] mt-2",
                    children: "Please review and accept the terms to continue using L1X-Play."
                })]
            }), m.jsx("div", {
                className: "h-[320px] md:h-[calc(100vh-300px)] overflow-y-auto pr-2 custom-scrollbar",
                children: m.jsx(xq, {})
            }), m.jsxs("div", {
                className: "flex flex-col md:flex-row items-center justify-between gap-4 mt-8",
                children: [m.jsx(Us, {
                    to: "/terms-and-conditions",
                    target: "_blank",
                    rel: "noopener noreferrer",
                    className: "text-sm text-[#FFC12C] underline underline-offset-4 hover:text-[#FFE066] transition-colors",
                    children: "Open full Terms & Conditions page"
                }), m.jsx("button", {
                    type: "button",
                    onClick: e,
                    className: "w-full md:w-auto brand-gradient-bg px-6 py-3 rounded-4xl text-sm font-semibold cursor-pointer",
                    children: "I Agree & Continue"
                })]
            })]
        })
    })]
}) : null
  , aCe = ({activeTab: n, setActiveTab: e}) => m.jsxs("ul", {
    className: "bg-[#182637] rounded-4xl p-1.5 inline-flex items-center mb-5",
    children: [m.jsxs("li", {
        onClick: () => e("deposit"),
        className: `py-2.5 px-8 rounded-4xl flex items-center gap-2 cursor-pointer transition-colors ${n === "deposit" ? "bg-brandGreen" : "hover:bg-gray-600"}`,
        children: [m.jsx("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            fill: "none",
            viewBox: "0 0 24 24",
            strokeWidth: 1.5,
            stroke: "currentColor",
            className: "size-5",
            children: m.jsx("path", {
                strokeLinecap: "round",
                strokeLinejoin: "round",
                d: "M12 4.5v15m7.5-7.5h-15"
            })
        }), "Deposit"]
    }), m.jsxs("li", {
        onClick: () => e("withdraw"),
        className: `py-2.5 px-8 rounded-4xl flex items-center gap-2 cursor-pointer transition-colors ${n === "withdraw" ? "bg-brandGreen" : "hover:bg-gray-600"}`,
        children: [m.jsx("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            fill: "none",
            viewBox: "0 0 24 24",
            strokeWidth: 1.5,
            stroke: "currentColor",
            className: "size-5",
            children: m.jsx("path", {
                strokeLinecap: "round",
                strokeLinejoin: "round",
                d: "M5 12h14"
            })
        }), "Withdraw"]
    })]
})
  , fP = () => {
    const [n,e] = V.useState(!1)
      , r = Ti().state?.activeTab
      , [s,i] = V.useState(r || "deposit")
      , [o,a] = V.useState([])
      , [l,u] = V.useState(null)
      , [d,h] = V.useState(!1)
      , [p,g] = V.useState(!1)
      , {walletAddress: w, balance: b, connectWallet: v, refreshBalance: S} = Hs()
      , N = Uo()
      , [_,I] = V.useState({})
      , [k,B] = V.useState(!1);
    V.useEffect( () => {
        M()
    }
    , []),
    V.useEffect( () => {
        localStorage.getItem("termsAccepted") || B(!0)
    }
    , []),
    V.useEffect( () => {
        P(s, 1)
    }
    , [s]);
    const P = async (q, H=1) => {
        try {
            let j;
            if (q === "deposit" ? j = await RSe(H) : q === "withdraw" && (j = await PSe(H)),
            j?.status === "success") {
                const A = j?.data?.data || []
                  , E = j?.data?.meta || {};
                a(C => H === 1 ? A : [...C, ...A]),
                I(E)
            }
        } catch (j) {
            console.error("Error fetching transactions:", j)
        }
    }
      , M = async () => {
        try {
            const q = await qV();
            q?.status === "success" && u(q?.data)
        } catch {}
    }
      , R = async q => {
        try {
            g(!0);
            const H = {
                referenceId: q
            }
              , j = await N.executeV3("action");
            (await GV(H, j))?.status === "success" && (await P("deposit", 1),
            S())
        } catch (H) {
            console.log(" ~ handleClaim ~ error:", H)
        } finally {
            g(!1)
        }
    }
      , L = () => {
        localStorage.setItem("termsAccepted", "true"),
        B(!1)
    }
    ;
    return m.jsxs("div", {
        className: "",
        children: [m.jsx("div", {
            className: "container mx-auto",
            children: m.jsxs("div", {
                className: "mt-18 mb-5 bg-brandMDark rounded-3xl grid gap-2.5 md:gap-0 grid-cols-1 md:grid-cols-2 overflow-hidden mx-4",
                children: [m.jsxs("div", {
                    className: "bg-brandGray p-4",
                    children: [m.jsx(aCe, {
                        activeTab: s,
                        setActiveTab: i
                    }), s === "deposit" && m.jsx(j4e, {
                        config: l,
                        getDepositeTx: P,
                        userBalance: b
                    }), s === "withdraw" && m.jsx(L4e, {
                        getDepositeTx: P,
                        userBalance: b
                    })]
                }), m.jsx("div", {
                    children: m.jsx(U4e, {
                        activeTab: s,
                        handleClaim: q => R(q),
                        isProcessing: p,
                        data: o,
                        title: s === "deposit" ? "Deposit History" : "Withdraw History",
                        getDepositeTx: q => P(s, q),
                        metadata: _
                    })
                })]
            })
        }), m.jsx(oCe, {
            isOpen: k,
            onAccept: L
        })]
    })
}
  , lCe = "/assets/leaderboard-line-BW8fvVjQ.svg"
  , Eq = "/assets/1st-price-PSRFWqka.svg"
  , Sq = "/assets/2nd-price-DnIOGiN7.svg"
  , Aq = "/assets/3rd-price-BvggE0e4.svg"
  , cCe = "/assets/crown-iRGJssYz.svg"
  , hP = "/assets/star-point-_q2GCC6y.svg"
  , Cq = "/assets/coin-DqC4ZsJE.svg";
function Vd(n, {currency: e="$", decimals: t=4, fallback: r="-", abbreviate: s=!0, truncate: i=!0, isNegligible: o=!0}={}) {
    if (n == null || isNaN(n))
        return r;
    const a = Math.abs(Number(n));
    if (a === 0)
        return m.jsxs("span", {
            children: [e, "0"]
        });
    const l = a.toFixed(12).split(".")[1]
      , u = /[1-9]/.test(l);
    if (a < 1e-4 && !u)
        return m.jsx("span", {
            style: {
                color: "#fff",
                opacity: .6
            },
            children: "0.0000"
        });
    if (a >= 1e3) {
        const {shortValue: g, suffix: w} = uCe(a, t, i);
        return m.jsxs("span", {
            style: {
                color: "#fff"
            },
            children: [e, g, w]
        })
    }
    if (a >= .001) {
        const [g,w=""] = a.toString().split(".")
          , b = w.search(/[1-9]/)
          , v = w.slice(0, b + t).padEnd(b + t, "0");
        return m.jsxs("span", {
            style: {
                color: "#fff"
            },
            children: [e, fCe(g), ".", v]
        })
    }
    let d = 0;
    for (; d < l.length && l[d] === "0"; )
        d++;
    const h = Math.max(0, d - 1)
      , p = l.slice(d, d + t);
    return m.jsxs("span", {
        style: {
            color: "#fff"
        },
        children: [e, "0.0", h > 0 ? m.jsx("span", {
            style: {
                fontSize: "1.4em",
                fontWeight: 400,
                position: "relative",
                top: "-0.1em"
            },
            children: hCe(h)
        }) : "0", p]
    })
}
function uCe(n, e=2, t=!0) {
    const r = [{
        value: 1e33,
        symbol: "Dc"
    }, {
        value: 1e30,
        symbol: "No"
    }, {
        value: 1e27,
        symbol: "Oc"
    }, {
        value: 1e24,
        symbol: "Sp"
    }, {
        value: 1e21,
        symbol: "Sx"
    }, {
        value: 1e18,
        symbol: "Qi"
    }, {
        value: 1e15,
        symbol: "Q"
    }, {
        value: 1e12,
        symbol: "T"
    }, {
        value: 1e9,
        symbol: "B"
    }, {
        value: 1e6,
        symbol: "M"
    }, {
        value: 1e3,
        symbol: "K"
    }];
    for (let s = 0; s < r.length; s++)
        if (n >= r[s].value) {
            const i = n / r[s].value
              , o = t ? dCe(i, e) : i.toFixed(e);
            return {
                shortValue: Number(o).toString(),
                suffix: r[s].symbol
            }
        }
    return {
        shortValue: n.toFixed(e),
        suffix: ""
    }
}
function dCe(n, e) {
    const t = Math.pow(10, e);
    return (Math.floor(n * t) / t).toFixed(e)
}
function fCe(n) {
    return n.replace(/\B(?=(\d{3})+(?!\d))/g, ",")
}
function hCe(n) {
    const e = {
        0: "",
        1: "",
        2: "",
        3: "",
        4: "",
        5: "",
        6: "",
        7: "",
        8: "",
        9: ""
    };
    return String(n).split("").map(t => e[t] || "").join("")
}
const _q = 6048e5
  , pCe = 864e5
  , Mx = 6e4
  , Bx = 36e5
  , mCe = 1e3
  , pP = Symbol.for("constructDateFrom");
function kn(n, e) {
    return typeof n == "function" ? n(e) : n && typeof n == "object" && pP in n ? n[pP](e) : n instanceof Date ? new n.constructor(e) : new Date(e)
}
function ht(n, e) {
    return kn(e || n, n)
}
function ca(n, e, t) {
    const r = ht(n, t?.in);
    return isNaN(e) ? kn(t?.in || n, NaN) : (e && r.setDate(r.getDate() + e),
    r)
}
function ha(n, e, t) {
    const r = ht(n, t?.in);
    if (isNaN(e))
        return kn(n, NaN);
    if (!e)
        return r;
    const s = r.getDate()
      , i = kn(n, r.getTime());
    i.setMonth(r.getMonth() + e + 1, 0);
    const o = i.getDate();
    return s >= o ? i : (r.setFullYear(i.getFullYear(), i.getMonth(), s),
    r)
}
function kq(n, e, t) {
    return kn(n, +ht(n) + e)
}
function gCe(n, e, t) {
    return kq(n, e * Bx)
}
let yCe = {};
function th() {
    return yCe
}
function Rc(n, e) {
    const t = th()
      , r = e?.weekStartsOn ?? e?.locale?.options?.weekStartsOn ?? t.weekStartsOn ?? t.locale?.options?.weekStartsOn ?? 0
      , s = ht(n, e?.in)
      , i = s.getDay()
      , o = (i < r ? 7 : 0) + i - r;
    return s.setDate(s.getDate() - o),
    s.setHours(0, 0, 0, 0),
    s
}
function l0(n, e) {
    return Rc(n, {
        ...e,
        weekStartsOn: 1
    })
}
function Nq(n, e) {
    const t = ht(n, e?.in)
      , r = t.getFullYear()
      , s = kn(t, 0);
    s.setFullYear(r + 1, 0, 4),
    s.setHours(0, 0, 0, 0);
    const i = l0(s)
      , o = kn(t, 0);
    o.setFullYear(r, 0, 4),
    o.setHours(0, 0, 0, 0);
    const a = l0(o);
    return t.getTime() >= i.getTime() ? r + 1 : t.getTime() >= a.getTime() ? r : r - 1
}
function J2(n) {
    const e = ht(n)
      , t = new Date(Date.UTC(e.getFullYear(), e.getMonth(), e.getDate(), e.getHours(), e.getMinutes(), e.getSeconds(), e.getMilliseconds()));
    return t.setUTCFullYear(e.getFullYear()),
    +n - +t
}
function Lc(n, ...e) {
    const t = kn.bind(null, e.find(r => typeof r == "object"));
    return e.map(t)
}
function Ff(n, e) {
    const t = ht(n, e?.in);
    return t.setHours(0, 0, 0, 0),
    t
}
function c0(n, e, t) {
    const [r,s] = Lc(t?.in, n, e)
      , i = Ff(r)
      , o = Ff(s)
      , a = +i - J2(i)
      , l = +o - J2(o);
    return Math.round((a - l) / pCe)
}
function bCe(n, e) {
    const t = Nq(n, e)
      , r = kn(n, 0);
    return r.setFullYear(t, 0, 4),
    r.setHours(0, 0, 0, 0),
    l0(r)
}
function XC(n, e, t) {
    const r = ht(n, t?.in);
    return r.setTime(r.getTime() + e * Mx),
    r
}
function mk(n, e, t) {
    return ha(n, e * 3, t)
}
function wCe(n, e, t) {
    return kq(n, e * 1e3)
}
function ev(n, e, t) {
    return ca(n, e * 7, t)
}
function bc(n, e, t) {
    return ha(n, e * 12, t)
}
function mP(n, e) {
    let t, r = e?.in;
    return n.forEach(s => {
        !r && typeof s == "object" && (r = kn.bind(null, s));
        const i = ht(s, r);
        (!t || t < i || isNaN(+i)) && (t = i)
    }
    ),
    kn(r, t || NaN)
}
function gP(n, e) {
    let t, r = e?.in;
    return n.forEach(s => {
        !r && typeof s == "object" && (r = kn.bind(null, s));
        const i = ht(s, r);
        (!t || t > i || isNaN(+i)) && (t = i)
    }
    ),
    kn(r, t || NaN)
}
function vCe(n, e, t) {
    const [r,s] = Lc(t?.in, n, e);
    return +Ff(r) == +Ff(s)
}
function wc(n) {
    return n instanceof Date || typeof n == "object" && Object.prototype.toString.call(n) === "[object Date]"
}
function tv(n) {
    return !(!wc(n) && typeof n != "number" || isNaN(+ht(n)))
}
function nv(n, e, t) {
    const [r,s] = Lc(t?.in, n, e)
      , i = r.getFullYear() - s.getFullYear()
      , o = r.getMonth() - s.getMonth();
    return i * 12 + o
}
function Cf(n, e) {
    const t = ht(n, e?.in);
    return Math.trunc(t.getMonth() / 3) + 1
}
function rv(n, e, t) {
    const [r,s] = Lc(t?.in, n, e)
      , i = r.getFullYear() - s.getFullYear()
      , o = Cf(r) - Cf(s);
    return i * 4 + o
}
function sv(n, e, t) {
    const [r,s] = Lc(t?.in, n, e);
    return r.getFullYear() - s.getFullYear()
}
function xCe(n, e, t) {
    const [r,s] = Lc(t?.in, n, e)
      , i = yP(r, s)
      , o = Math.abs(c0(r, s));
    r.setDate(r.getDate() - i * o);
    const a = +(yP(r, s) === -i)
      , l = i * (o - a);
    return l === 0 ? 0 : l
}
function yP(n, e) {
    const t = n.getFullYear() - e.getFullYear() || n.getMonth() - e.getMonth() || n.getDate() - e.getDate() || n.getHours() - e.getHours() || n.getMinutes() - e.getMinutes() || n.getSeconds() - e.getSeconds() || n.getMilliseconds() - e.getMilliseconds();
    return t < 0 ? -1 : t > 0 ? 1 : t
}
function Dq(n, e) {
    const t = ht(n, e?.in);
    return t.setHours(23, 59, 59, 999),
    t
}
function Tq(n, e) {
    const t = ht(n, e?.in)
      , r = t.getMonth();
    return t.setFullYear(t.getFullYear(), r + 1, 0),
    t.setHours(23, 59, 59, 999),
    t
}
function QC(n, e) {
    const t = ht(n, e?.in)
      , r = t.getMonth()
      , s = r - r % 3;
    return t.setMonth(s, 1),
    t.setHours(0, 0, 0, 0),
    t
}
function Iq(n, e) {
    const t = ht(n, e?.in);
    return t.setDate(1),
    t.setHours(0, 0, 0, 0),
    t
}
function Mq(n, e) {
    const t = ht(n, e?.in)
      , r = t.getFullYear();
    return t.setFullYear(r + 1, 0, 0),
    t.setHours(23, 59, 59, 999),
    t
}
function Rx(n, e) {
    const t = ht(n, e?.in);
    return t.setFullYear(t.getFullYear(), 0, 1),
    t.setHours(0, 0, 0, 0),
    t
}
function ECe(n, e) {
    const t = th()
      , r = t.weekStartsOn ?? t.locale?.options?.weekStartsOn ?? 0
      , s = ht(n, e?.in)
      , i = s.getDay()
      , o = (i < r ? -7 : 0) + 6 - (i - r);
    return s.setDate(s.getDate() + o),
    s.setHours(23, 59, 59, 999),
    s
}
const SCe = {
    lessThanXSeconds: {
        one: "less than a second",
        other: "less than {{count}} seconds"
    },
    xSeconds: {
        one: "1 second",
        other: "{{count}} seconds"
    },
    halfAMinute: "half a minute",
    lessThanXMinutes: {
        one: "less than a minute",
        other: "less than {{count}} minutes"
    },
    xMinutes: {
        one: "1 minute",
        other: "{{count}} minutes"
    },
    aboutXHours: {
        one: "about 1 hour",
        other: "about {{count}} hours"
    },
    xHours: {
        one: "1 hour",
        other: "{{count}} hours"
    },
    xDays: {
        one: "1 day",
        other: "{{count}} days"
    },
    aboutXWeeks: {
        one: "about 1 week",
        other: "about {{count}} weeks"
    },
    xWeeks: {
        one: "1 week",
        other: "{{count}} weeks"
    },
    aboutXMonths: {
        one: "about 1 month",
        other: "about {{count}} months"
    },
    xMonths: {
        one: "1 month",
        other: "{{count}} months"
    },
    aboutXYears: {
        one: "about 1 year",
        other: "about {{count}} years"
    },
    xYears: {
        one: "1 year",
        other: "{{count}} years"
    },
    overXYears: {
        one: "over 1 year",
        other: "over {{count}} years"
    },
    almostXYears: {
        one: "almost 1 year",
        other: "almost {{count}} years"
    }
}
  , ACe = (n, e, t) => {
    let r;
    const s = SCe[n];
    return typeof s == "string" ? r = s : e === 1 ? r = s.one : r = s.other.replace("{{count}}", e.toString()),
    t?.addSuffix ? t.comparison && t.comparison > 0 ? "in " + r : r + " ago" : r
}
;
function AA(n) {
    return (e={}) => {
        const t = e.width ? String(e.width) : n.defaultWidth;
        return n.formats[t] || n.formats[n.defaultWidth]
    }
}
const CCe = {
    full: "EEEE, MMMM do, y",
    long: "MMMM do, y",
    medium: "MMM d, y",
    short: "MM/dd/yyyy"
}
  , _Ce = {
    full: "h:mm:ss a zzzz",
    long: "h:mm:ss a z",
    medium: "h:mm:ss a",
    short: "h:mm a"
}
  , kCe = {
    full: "{{date}} 'at' {{time}}",
    long: "{{date}} 'at' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
}
  , NCe = {
    date: AA({
        formats: CCe,
        defaultWidth: "full"
    }),
    time: AA({
        formats: _Ce,
        defaultWidth: "full"
    }),
    dateTime: AA({
        formats: kCe,
        defaultWidth: "full"
    })
}
  , DCe = {
    lastWeek: "'last' eeee 'at' p",
    yesterday: "'yesterday at' p",
    today: "'today at' p",
    tomorrow: "'tomorrow at' p",
    nextWeek: "eeee 'at' p",
    other: "P"
}
  , TCe = (n, e, t, r) => DCe[n];
function rg(n) {
    return (e, t) => {
        const r = t?.context ? String(t.context) : "standalone";
        let s;
        if (r === "formatting" && n.formattingValues) {
            const o = n.defaultFormattingWidth || n.defaultWidth
              , a = t?.width ? String(t.width) : o;
            s = n.formattingValues[a] || n.formattingValues[o]
        } else {
            const o = n.defaultWidth
              , a = t?.width ? String(t.width) : n.defaultWidth;
            s = n.values[a] || n.values[o]
        }
        const i = n.argumentCallback ? n.argumentCallback(e) : e;
        return s[i]
    }
}
const ICe = {
    narrow: ["B", "A"],
    abbreviated: ["BC", "AD"],
    wide: ["Before Christ", "Anno Domini"]
}
  , MCe = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["Q1", "Q2", "Q3", "Q4"],
    wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
}
  , BCe = {
    narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
    abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
}
  , RCe = {
    narrow: ["S", "M", "T", "W", "T", "F", "S"],
    short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
    abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
}
  , OCe = {
    narrow: {
        am: "a",
        pm: "p",
        midnight: "mi",
        noon: "n",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "midnight",
        noon: "noon",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
    },
    wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "midnight",
        noon: "noon",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
    }
}
  , PCe = {
    narrow: {
        am: "a",
        pm: "p",
        midnight: "mi",
        noon: "n",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "midnight",
        noon: "noon",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
    },
    wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "midnight",
        noon: "noon",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
    }
}
  , jCe = (n, e) => {
    const t = Number(n)
      , r = t % 100;
    if (r > 20 || r < 10)
        switch (r % 10) {
        case 1:
            return t + "st";
        case 2:
            return t + "nd";
        case 3:
            return t + "rd"
        }
    return t + "th"
}
  , LCe = {
    ordinalNumber: jCe,
    era: rg({
        values: ICe,
        defaultWidth: "wide"
    }),
    quarter: rg({
        values: MCe,
        defaultWidth: "wide",
        argumentCallback: n => n - 1
    }),
    month: rg({
        values: BCe,
        defaultWidth: "wide"
    }),
    day: rg({
        values: RCe,
        defaultWidth: "wide"
    }),
    dayPeriod: rg({
        values: OCe,
        defaultWidth: "wide",
        formattingValues: PCe,
        defaultFormattingWidth: "wide"
    })
};
function sg(n) {
    return (e, t={}) => {
        const r = t.width
          , s = r && n.matchPatterns[r] || n.matchPatterns[n.defaultMatchWidth]
          , i = e.match(s);
        if (!i)
            return null;
        const o = i[0]
          , a = r && n.parsePatterns[r] || n.parsePatterns[n.defaultParseWidth]
          , l = Array.isArray(a) ? UCe(a, h => h.test(o)) : FCe(a, h => h.test(o));
        let u;
        u = n.valueCallback ? n.valueCallback(l) : l,
        u = t.valueCallback ? t.valueCallback(u) : u;
        const d = e.slice(o.length);
        return {
            value: u,
            rest: d
        }
    }
}
function FCe(n, e) {
    for (const t in n)
        if (Object.prototype.hasOwnProperty.call(n, t) && e(n[t]))
            return t
}
function UCe(n, e) {
    for (let t = 0; t < n.length; t++)
        if (e(n[t]))
            return t
}
function zCe(n) {
    return (e, t={}) => {
        const r = e.match(n.matchPattern);
        if (!r)
            return null;
        const s = r[0]
          , i = e.match(n.parsePattern);
        if (!i)
            return null;
        let o = n.valueCallback ? n.valueCallback(i[0]) : i[0];
        o = t.valueCallback ? t.valueCallback(o) : o;
        const a = e.slice(s.length);
        return {
            value: o,
            rest: a
        }
    }
}
const $Ce = /^(\d+)(th|st|nd|rd)?/i
  , HCe = /\d+/i
  , VCe = {
    narrow: /^(b|a)/i,
    abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
    wide: /^(before christ|before common era|anno domini|common era)/i
}
  , qCe = {
    any: [/^b/i, /^(a|c)/i]
}
  , GCe = {
    narrow: /^[1234]/i,
    abbreviated: /^q[1234]/i,
    wide: /^[1234](th|st|nd|rd)? quarter/i
}
  , WCe = {
    any: [/1/i, /2/i, /3/i, /4/i]
}
  , YCe = {
    narrow: /^[jfmasond]/i,
    abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
    wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
}
  , KCe = {
    narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
    any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
}
  , XCe = {
    narrow: /^[smtwf]/i,
    short: /^(su|mo|tu|we|th|fr|sa)/i,
    abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
    wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
}
  , QCe = {
    narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
    any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
}
  , ZCe = {
    narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
    any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
}
  , JCe = {
    any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^mi/i,
        noon: /^no/i,
        morning: /morning/i,
        afternoon: /afternoon/i,
        evening: /evening/i,
        night: /night/i
    }
}
  , e8e = {
    ordinalNumber: zCe({
        matchPattern: $Ce,
        parsePattern: HCe,
        valueCallback: n => parseInt(n, 10)
    }),
    era: sg({
        matchPatterns: VCe,
        defaultMatchWidth: "wide",
        parsePatterns: qCe,
        defaultParseWidth: "any"
    }),
    quarter: sg({
        matchPatterns: GCe,
        defaultMatchWidth: "wide",
        parsePatterns: WCe,
        defaultParseWidth: "any",
        valueCallback: n => n + 1
    }),
    month: sg({
        matchPatterns: YCe,
        defaultMatchWidth: "wide",
        parsePatterns: KCe,
        defaultParseWidth: "any"
    }),
    day: sg({
        matchPatterns: XCe,
        defaultMatchWidth: "wide",
        parsePatterns: QCe,
        defaultParseWidth: "any"
    }),
    dayPeriod: sg({
        matchPatterns: ZCe,
        defaultMatchWidth: "any",
        parsePatterns: JCe,
        defaultParseWidth: "any"
    })
}
  , Bq = {
    code: "en-US",
    formatDistance: ACe,
    formatLong: NCe,
    formatRelative: TCe,
    localize: LCe,
    match: e8e,
    options: {
        weekStartsOn: 0,
        firstWeekContainsDate: 1
    }
};
function t8e(n, e) {
    const t = ht(n, e?.in);
    return c0(t, Rx(t)) + 1
}
function gk(n, e) {
    const t = ht(n, e?.in)
      , r = +l0(t) - +bCe(t);
    return Math.round(r / _q) + 1
}
function yk(n, e) {
    const t = ht(n, e?.in)
      , r = t.getFullYear()
      , s = th()
      , i = e?.firstWeekContainsDate ?? e?.locale?.options?.firstWeekContainsDate ?? s.firstWeekContainsDate ?? s.locale?.options?.firstWeekContainsDate ?? 1
      , o = kn(e?.in || n, 0);
    o.setFullYear(r + 1, 0, i),
    o.setHours(0, 0, 0, 0);
    const a = Rc(o, e)
      , l = kn(e?.in || n, 0);
    l.setFullYear(r, 0, i),
    l.setHours(0, 0, 0, 0);
    const u = Rc(l, e);
    return +t >= +a ? r + 1 : +t >= +u ? r : r - 1
}
function n8e(n, e) {
    const t = th()
      , r = e?.firstWeekContainsDate ?? e?.locale?.options?.firstWeekContainsDate ?? t.firstWeekContainsDate ?? t.locale?.options?.firstWeekContainsDate ?? 1
      , s = yk(n, e)
      , i = kn(e?.in || n, 0);
    return i.setFullYear(s, 0, r),
    i.setHours(0, 0, 0, 0),
    Rc(i, e)
}
function Rq(n, e) {
    const t = ht(n, e?.in)
      , r = +Rc(t, e) - +n8e(t, e);
    return Math.round(r / _q) + 1
}
function Cn(n, e) {
    const t = n < 0 ? "-" : ""
      , r = Math.abs(n).toString().padStart(e, "0");
    return t + r
}
const Nu = {
    y(n, e) {
        const t = n.getFullYear()
          , r = t > 0 ? t : 1 - t;
        return Cn(e === "yy" ? r % 100 : r, e.length)
    },
    M(n, e) {
        const t = n.getMonth();
        return e === "M" ? String(t + 1) : Cn(t + 1, 2)
    },
    d(n, e) {
        return Cn(n.getDate(), e.length)
    },
    a(n, e) {
        const t = n.getHours() / 12 >= 1 ? "pm" : "am";
        switch (e) {
        case "a":
        case "aa":
            return t.toUpperCase();
        case "aaa":
            return t;
        case "aaaaa":
            return t[0];
        case "aaaa":
        default:
            return t === "am" ? "a.m." : "p.m."
        }
    },
    h(n, e) {
        return Cn(n.getHours() % 12 || 12, e.length)
    },
    H(n, e) {
        return Cn(n.getHours(), e.length)
    },
    m(n, e) {
        return Cn(n.getMinutes(), e.length)
    },
    s(n, e) {
        return Cn(n.getSeconds(), e.length)
    },
    S(n, e) {
        const t = e.length
          , r = n.getMilliseconds()
          , s = Math.trunc(r * Math.pow(10, t - 3));
        return Cn(s, e.length)
    }
}
  , sp = {
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
}
  , bP = {
    G: function(n, e, t) {
        const r = n.getFullYear() > 0 ? 1 : 0;
        switch (e) {
        case "G":
        case "GG":
        case "GGG":
            return t.era(r, {
                width: "abbreviated"
            });
        case "GGGGG":
            return t.era(r, {
                width: "narrow"
            });
        case "GGGG":
        default:
            return t.era(r, {
                width: "wide"
            })
        }
    },
    y: function(n, e, t) {
        if (e === "yo") {
            const r = n.getFullYear()
              , s = r > 0 ? r : 1 - r;
            return t.ordinalNumber(s, {
                unit: "year"
            })
        }
        return Nu.y(n, e)
    },
    Y: function(n, e, t, r) {
        const s = yk(n, r)
          , i = s > 0 ? s : 1 - s;
        if (e === "YY") {
            const o = i % 100;
            return Cn(o, 2)
        }
        return e === "Yo" ? t.ordinalNumber(i, {
            unit: "year"
        }) : Cn(i, e.length)
    },
    R: function(n, e) {
        const t = Nq(n);
        return Cn(t, e.length)
    },
    u: function(n, e) {
        const t = n.getFullYear();
        return Cn(t, e.length)
    },
    Q: function(n, e, t) {
        const r = Math.ceil((n.getMonth() + 1) / 3);
        switch (e) {
        case "Q":
            return String(r);
        case "QQ":
            return Cn(r, 2);
        case "Qo":
            return t.ordinalNumber(r, {
                unit: "quarter"
            });
        case "QQQ":
            return t.quarter(r, {
                width: "abbreviated",
                context: "formatting"
            });
        case "QQQQQ":
            return t.quarter(r, {
                width: "narrow",
                context: "formatting"
            });
        case "QQQQ":
        default:
            return t.quarter(r, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    q: function(n, e, t) {
        const r = Math.ceil((n.getMonth() + 1) / 3);
        switch (e) {
        case "q":
            return String(r);
        case "qq":
            return Cn(r, 2);
        case "qo":
            return t.ordinalNumber(r, {
                unit: "quarter"
            });
        case "qqq":
            return t.quarter(r, {
                width: "abbreviated",
                context: "standalone"
            });
        case "qqqqq":
            return t.quarter(r, {
                width: "narrow",
                context: "standalone"
            });
        case "qqqq":
        default:
            return t.quarter(r, {
                width: "wide",
                context: "standalone"
            })
        }
    },
    M: function(n, e, t) {
        const r = n.getMonth();
        switch (e) {
        case "M":
        case "MM":
            return Nu.M(n, e);
        case "Mo":
            return t.ordinalNumber(r + 1, {
                unit: "month"
            });
        case "MMM":
            return t.month(r, {
                width: "abbreviated",
                context: "formatting"
            });
        case "MMMMM":
            return t.month(r, {
                width: "narrow",
                context: "formatting"
            });
        case "MMMM":
        default:
            return t.month(r, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    L: function(n, e, t) {
        const r = n.getMonth();
        switch (e) {
        case "L":
            return String(r + 1);
        case "LL":
            return Cn(r + 1, 2);
        case "Lo":
            return t.ordinalNumber(r + 1, {
                unit: "month"
            });
        case "LLL":
            return t.month(r, {
                width: "abbreviated",
                context: "standalone"
            });
        case "LLLLL":
            return t.month(r, {
                width: "narrow",
                context: "standalone"
            });
        case "LLLL":
        default:
            return t.month(r, {
                width: "wide",
                context: "standalone"
            })
        }
    },
    w: function(n, e, t, r) {
        const s = Rq(n, r);
        return e === "wo" ? t.ordinalNumber(s, {
            unit: "week"
        }) : Cn(s, e.length)
    },
    I: function(n, e, t) {
        const r = gk(n);
        return e === "Io" ? t.ordinalNumber(r, {
            unit: "week"
        }) : Cn(r, e.length)
    },
    d: function(n, e, t) {
        return e === "do" ? t.ordinalNumber(n.getDate(), {
            unit: "date"
        }) : Nu.d(n, e)
    },
    D: function(n, e, t) {
        const r = t8e(n);
        return e === "Do" ? t.ordinalNumber(r, {
            unit: "dayOfYear"
        }) : Cn(r, e.length)
    },
    E: function(n, e, t) {
        const r = n.getDay();
        switch (e) {
        case "E":
        case "EE":
        case "EEE":
            return t.day(r, {
                width: "abbreviated",
                context: "formatting"
            });
        case "EEEEE":
            return t.day(r, {
                width: "narrow",
                context: "formatting"
            });
        case "EEEEEE":
            return t.day(r, {
                width: "short",
                context: "formatting"
            });
        case "EEEE":
        default:
            return t.day(r, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    e: function(n, e, t, r) {
        const s = n.getDay()
          , i = (s - r.weekStartsOn + 8) % 7 || 7;
        switch (e) {
        case "e":
            return String(i);
        case "ee":
            return Cn(i, 2);
        case "eo":
            return t.ordinalNumber(i, {
                unit: "day"
            });
        case "eee":
            return t.day(s, {
                width: "abbreviated",
                context: "formatting"
            });
        case "eeeee":
            return t.day(s, {
                width: "narrow",
                context: "formatting"
            });
        case "eeeeee":
            return t.day(s, {
                width: "short",
                context: "formatting"
            });
        case "eeee":
        default:
            return t.day(s, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    c: function(n, e, t, r) {
        const s = n.getDay()
          , i = (s - r.weekStartsOn + 8) % 7 || 7;
        switch (e) {
        case "c":
            return String(i);
        case "cc":
            return Cn(i, e.length);
        case "co":
            return t.ordinalNumber(i, {
                unit: "day"
            });
        case "ccc":
            return t.day(s, {
                width: "abbreviated",
                context: "standalone"
            });
        case "ccccc":
            return t.day(s, {
                width: "narrow",
                context: "standalone"
            });
        case "cccccc":
            return t.day(s, {
                width: "short",
                context: "standalone"
            });
        case "cccc":
        default:
            return t.day(s, {
                width: "wide",
                context: "standalone"
            })
        }
    },
    i: function(n, e, t) {
        const r = n.getDay()
          , s = r === 0 ? 7 : r;
        switch (e) {
        case "i":
            return String(s);
        case "ii":
            return Cn(s, e.length);
        case "io":
            return t.ordinalNumber(s, {
                unit: "day"
            });
        case "iii":
            return t.day(r, {
                width: "abbreviated",
                context: "formatting"
            });
        case "iiiii":
            return t.day(r, {
                width: "narrow",
                context: "formatting"
            });
        case "iiiiii":
            return t.day(r, {
                width: "short",
                context: "formatting"
            });
        case "iiii":
        default:
            return t.day(r, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    a: function(n, e, t) {
        const s = n.getHours() / 12 >= 1 ? "pm" : "am";
        switch (e) {
        case "a":
        case "aa":
            return t.dayPeriod(s, {
                width: "abbreviated",
                context: "formatting"
            });
        case "aaa":
            return t.dayPeriod(s, {
                width: "abbreviated",
                context: "formatting"
            }).toLowerCase();
        case "aaaaa":
            return t.dayPeriod(s, {
                width: "narrow",
                context: "formatting"
            });
        case "aaaa":
        default:
            return t.dayPeriod(s, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    b: function(n, e, t) {
        const r = n.getHours();
        let s;
        switch (r === 12 ? s = sp.noon : r === 0 ? s = sp.midnight : s = r / 12 >= 1 ? "pm" : "am",
        e) {
        case "b":
        case "bb":
            return t.dayPeriod(s, {
                width: "abbreviated",
                context: "formatting"
            });
        case "bbb":
            return t.dayPeriod(s, {
                width: "abbreviated",
                context: "formatting"
            }).toLowerCase();
        case "bbbbb":
            return t.dayPeriod(s, {
                width: "narrow",
                context: "formatting"
            });
        case "bbbb":
        default:
            return t.dayPeriod(s, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    B: function(n, e, t) {
        const r = n.getHours();
        let s;
        switch (r >= 17 ? s = sp.evening : r >= 12 ? s = sp.afternoon : r >= 4 ? s = sp.morning : s = sp.night,
        e) {
        case "B":
        case "BB":
        case "BBB":
            return t.dayPeriod(s, {
                width: "abbreviated",
                context: "formatting"
            });
        case "BBBBB":
            return t.dayPeriod(s, {
                width: "narrow",
                context: "formatting"
            });
        case "BBBB":
        default:
            return t.dayPeriod(s, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    h: function(n, e, t) {
        if (e === "ho") {
            let r = n.getHours() % 12;
            return r === 0 && (r = 12),
            t.ordinalNumber(r, {
                unit: "hour"
            })
        }
        return Nu.h(n, e)
    },
    H: function(n, e, t) {
        return e === "Ho" ? t.ordinalNumber(n.getHours(), {
            unit: "hour"
        }) : Nu.H(n, e)
    },
    K: function(n, e, t) {
        const r = n.getHours() % 12;
        return e === "Ko" ? t.ordinalNumber(r, {
            unit: "hour"
        }) : Cn(r, e.length)
    },
    k: function(n, e, t) {
        let r = n.getHours();
        return r === 0 && (r = 24),
        e === "ko" ? t.ordinalNumber(r, {
            unit: "hour"
        }) : Cn(r, e.length)
    },
    m: function(n, e, t) {
        return e === "mo" ? t.ordinalNumber(n.getMinutes(), {
            unit: "minute"
        }) : Nu.m(n, e)
    },
    s: function(n, e, t) {
        return e === "so" ? t.ordinalNumber(n.getSeconds(), {
            unit: "second"
        }) : Nu.s(n, e)
    },
    S: function(n, e) {
        return Nu.S(n, e)
    },
    X: function(n, e, t) {
        const r = n.getTimezoneOffset();
        if (r === 0)
            return "Z";
        switch (e) {
        case "X":
            return vP(r);
        case "XXXX":
        case "XX":
            return qd(r);
        case "XXXXX":
        case "XXX":
        default:
            return qd(r, ":")
        }
    },
    x: function(n, e, t) {
        const r = n.getTimezoneOffset();
        switch (e) {
        case "x":
            return vP(r);
        case "xxxx":
        case "xx":
            return qd(r);
        case "xxxxx":
        case "xxx":
        default:
            return qd(r, ":")
        }
    },
    O: function(n, e, t) {
        const r = n.getTimezoneOffset();
        switch (e) {
        case "O":
        case "OO":
        case "OOO":
            return "GMT" + wP(r, ":");
        case "OOOO":
        default:
            return "GMT" + qd(r, ":")
        }
    },
    z: function(n, e, t) {
        const r = n.getTimezoneOffset();
        switch (e) {
        case "z":
        case "zz":
        case "zzz":
            return "GMT" + wP(r, ":");
        case "zzzz":
        default:
            return "GMT" + qd(r, ":")
        }
    },
    t: function(n, e, t) {
        const r = Math.trunc(+n / 1e3);
        return Cn(r, e.length)
    },
    T: function(n, e, t) {
        return Cn(+n, e.length)
    }
};
function wP(n, e="") {
    const t = n > 0 ? "-" : "+"
      , r = Math.abs(n)
      , s = Math.trunc(r / 60)
      , i = r % 60;
    return i === 0 ? t + String(s) : t + String(s) + e + Cn(i, 2)
}
function vP(n, e) {
    return n % 60 === 0 ? (n > 0 ? "-" : "+") + Cn(Math.abs(n) / 60, 2) : qd(n, e)
}
function qd(n, e="") {
    const t = n > 0 ? "-" : "+"
      , r = Math.abs(n)
      , s = Cn(Math.trunc(r / 60), 2)
      , i = Cn(r % 60, 2);
    return t + s + e + i
}
const xP = (n, e) => {
    switch (n) {
    case "P":
        return e.date({
            width: "short"
        });
    case "PP":
        return e.date({
            width: "medium"
        });
    case "PPP":
        return e.date({
            width: "long"
        });
    case "PPPP":
    default:
        return e.date({
            width: "full"
        })
    }
}
  , Oq = (n, e) => {
    switch (n) {
    case "p":
        return e.time({
            width: "short"
        });
    case "pp":
        return e.time({
            width: "medium"
        });
    case "ppp":
        return e.time({
            width: "long"
        });
    case "pppp":
    default:
        return e.time({
            width: "full"
        })
    }
}
  , r8e = (n, e) => {
    const t = n.match(/(P+)(p+)?/) || []
      , r = t[1]
      , s = t[2];
    if (!s)
        return xP(n, e);
    let i;
    switch (r) {
    case "P":
        i = e.dateTime({
            width: "short"
        });
        break;
    case "PP":
        i = e.dateTime({
            width: "medium"
        });
        break;
    case "PPP":
        i = e.dateTime({
            width: "long"
        });
        break;
    case "PPPP":
    default:
        i = e.dateTime({
            width: "full"
        });
        break
    }
    return i.replace("{{date}}", xP(r, e)).replace("{{time}}", Oq(s, e))
}
  , ZC = {
    p: Oq,
    P: r8e
}
  , s8e = /^D+$/
  , i8e = /^Y+$/
  , o8e = ["D", "DD", "YY", "YYYY"];
function a8e(n) {
    return s8e.test(n)
}
function l8e(n) {
    return i8e.test(n)
}
function c8e(n, e, t) {
    const r = u8e(n, e, t);
    if (console.warn(r),
    o8e.includes(n))
        throw new RangeError(r)
}
function u8e(n, e, t) {
    const r = n[0] === "Y" ? "years" : "days of the month";
    return `Use \`${n.toLowerCase()}\` instead of \`${n}\` (in \`${e}\`) for formatting ${r} to the input \`${t}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`
}
const d8e = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g
  , f8e = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g
  , h8e = /^'([^]*?)'?$/
  , p8e = /''/g
  , m8e = /[a-zA-Z]/;
function EP(n, e, t) {
    const r = th()
      , s = t?.locale ?? r.locale ?? Bq
      , i = t?.firstWeekContainsDate ?? t?.locale?.options?.firstWeekContainsDate ?? r.firstWeekContainsDate ?? r.locale?.options?.firstWeekContainsDate ?? 1
      , o = t?.weekStartsOn ?? t?.locale?.options?.weekStartsOn ?? r.weekStartsOn ?? r.locale?.options?.weekStartsOn ?? 0
      , a = ht(n, t?.in);
    if (!tv(a))
        throw new RangeError("Invalid time value");
    let l = e.match(f8e).map(d => {
        const h = d[0];
        if (h === "p" || h === "P") {
            const p = ZC[h];
            return p(d, s.formatLong)
        }
        return d
    }
    ).join("").match(d8e).map(d => {
        if (d === "''")
            return {
                isToken: !1,
                value: "'"
            };
        const h = d[0];
        if (h === "'")
            return {
                isToken: !1,
                value: g8e(d)
            };
        if (bP[h])
            return {
                isToken: !0,
                value: d
            };
        if (h.match(m8e))
            throw new RangeError("Format string contains an unescaped latin alphabet character `" + h + "`");
        return {
            isToken: !1,
            value: d
        }
    }
    );
    s.localize.preprocessor && (l = s.localize.preprocessor(a, l));
    const u = {
        firstWeekContainsDate: i,
        weekStartsOn: o,
        locale: s
    };
    return l.map(d => {
        if (!d.isToken)
            return d.value;
        const h = d.value;
        (!t?.useAdditionalWeekYearTokens && l8e(h) || !t?.useAdditionalDayOfYearTokens && a8e(h)) && c8e(h, e, String(n));
        const p = bP[h[0]];
        return p(a, h, s.localize, u)
    }
    ).join("")
}
function g8e(n) {
    const e = n.match(h8e);
    return e ? e[1].replace(p8e, "'") : n
}
function SP(n, e) {
    return ht(n, e?.in).getDate()
}
function y8e(n, e) {
    return ht(n, e?.in).getDay()
}
function b8e(n, e) {
    const t = ht(n, e?.in)
      , r = t.getFullYear()
      , s = t.getMonth()
      , i = kn(t, 0);
    return i.setFullYear(r, s + 1, 0),
    i.setHours(0, 0, 0, 0),
    i.getDate()
}
function w8e() {
    return Object.assign({}, th())
}
function vc(n, e) {
    return ht(n, e?.in).getHours()
}
function v8e(n, e) {
    const t = ht(n, e?.in).getDay();
    return t === 0 ? 7 : t
}
function xc(n, e) {
    return ht(n, e?.in).getMinutes()
}
function Fs(n, e) {
    return ht(n, e?.in).getMonth()
}
function Gu(n) {
    return ht(n).getSeconds()
}
function JC(n) {
    return +ht(n)
}
function Ut(n, e) {
    return ht(n, e?.in).getFullYear()
}
function rd(n, e) {
    return +ht(n) > +ht(e)
}
function Ya(n, e) {
    return +ht(n) < +ht(e)
}
function x8e(n, e) {
    return +ht(n) == +ht(e)
}
function E8e(n, e) {
    const t = S8e(e) ? new e(0) : kn(e, 0);
    return t.setFullYear(n.getFullYear(), n.getMonth(), n.getDate()),
    t.setHours(n.getHours(), n.getMinutes(), n.getSeconds(), n.getMilliseconds()),
    t
}
function S8e(n) {
    return typeof n == "function" && n.prototype?.constructor === n
}
const A8e = 10;
class Pq {
    subPriority = 0;
    validate(e, t) {
        return !0
    }
}
class C8e extends Pq {
    constructor(e, t, r, s, i) {
        super(),
        this.value = e,
        this.validateValue = t,
        this.setValue = r,
        this.priority = s,
        i && (this.subPriority = i)
    }
    validate(e, t) {
        return this.validateValue(e, this.value, t)
    }
    set(e, t, r) {
        return this.setValue(e, t, this.value, r)
    }
}
class _8e extends Pq {
    priority = A8e;
    subPriority = -1;
    constructor(e, t) {
        super(),
        this.context = e || (r => kn(t, r))
    }
    set(e, t) {
        return t.timestampIsSet ? e : kn(e, E8e(e, this.context))
    }
}
class bn {
    run(e, t, r, s) {
        const i = this.parse(e, t, r, s);
        return i ? {
            setter: new C8e(i.value,this.validate,this.set,this.priority,this.subPriority),
            rest: i.rest
        } : null
    }
    validate(e, t, r) {
        return !0
    }
}
class k8e extends bn {
    priority = 140;
    parse(e, t, r) {
        switch (t) {
        case "G":
        case "GG":
        case "GGG":
            return r.era(e, {
                width: "abbreviated"
            }) || r.era(e, {
                width: "narrow"
            });
        case "GGGGG":
            return r.era(e, {
                width: "narrow"
            });
        case "GGGG":
        default:
            return r.era(e, {
                width: "wide"
            }) || r.era(e, {
                width: "abbreviated"
            }) || r.era(e, {
                width: "narrow"
            })
        }
    }
    set(e, t, r) {
        return t.era = r,
        e.setFullYear(r, 0, 1),
        e.setHours(0, 0, 0, 0),
        e
    }
    incompatibleTokens = ["R", "u", "t", "T"]
}
const Ar = {
    month: /^(1[0-2]|0?\d)/,
    date: /^(3[0-1]|[0-2]?\d)/,
    dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
    week: /^(5[0-3]|[0-4]?\d)/,
    hour23h: /^(2[0-3]|[0-1]?\d)/,
    hour24h: /^(2[0-4]|[0-1]?\d)/,
    hour11h: /^(1[0-1]|0?\d)/,
    hour12h: /^(1[0-2]|0?\d)/,
    minute: /^[0-5]?\d/,
    second: /^[0-5]?\d/,
    singleDigit: /^\d/,
    twoDigits: /^\d{1,2}/,
    threeDigits: /^\d{1,3}/,
    fourDigits: /^\d{1,4}/,
    anyDigitsSigned: /^-?\d+/,
    singleDigitSigned: /^-?\d/,
    twoDigitsSigned: /^-?\d{1,2}/,
    threeDigitsSigned: /^-?\d{1,3}/,
    fourDigitsSigned: /^-?\d{1,4}/
}
  , qa = {
    basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
    basic: /^([+-])(\d{2})(\d{2})|Z/,
    basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
    extended: /^([+-])(\d{2}):(\d{2})|Z/,
    extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
};
function Cr(n, e) {
    return n && {
        value: e(n.value),
        rest: n.rest
    }
}
function rr(n, e) {
    const t = e.match(n);
    return t ? {
        value: parseInt(t[0], 10),
        rest: e.slice(t[0].length)
    } : null
}
function Ga(n, e) {
    const t = e.match(n);
    if (!t)
        return null;
    if (t[0] === "Z")
        return {
            value: 0,
            rest: e.slice(1)
        };
    const r = t[1] === "+" ? 1 : -1
      , s = t[2] ? parseInt(t[2], 10) : 0
      , i = t[3] ? parseInt(t[3], 10) : 0
      , o = t[5] ? parseInt(t[5], 10) : 0;
    return {
        value: r * (s * Bx + i * Mx + o * mCe),
        rest: e.slice(t[0].length)
    }
}
function jq(n) {
    return rr(Ar.anyDigitsSigned, n)
}
function yr(n, e) {
    switch (n) {
    case 1:
        return rr(Ar.singleDigit, e);
    case 2:
        return rr(Ar.twoDigits, e);
    case 3:
        return rr(Ar.threeDigits, e);
    case 4:
        return rr(Ar.fourDigits, e);
    default:
        return rr(new RegExp("^\\d{1," + n + "}"), e)
    }
}
function iv(n, e) {
    switch (n) {
    case 1:
        return rr(Ar.singleDigitSigned, e);
    case 2:
        return rr(Ar.twoDigitsSigned, e);
    case 3:
        return rr(Ar.threeDigitsSigned, e);
    case 4:
        return rr(Ar.fourDigitsSigned, e);
    default:
        return rr(new RegExp("^-?\\d{1," + n + "}"), e)
    }
}
function bk(n) {
    switch (n) {
    case "morning":
        return 4;
    case "evening":
        return 17;
    case "pm":
    case "noon":
    case "afternoon":
        return 12;
    case "am":
    case "midnight":
    case "night":
    default:
        return 0
    }
}
function Lq(n, e) {
    const t = e > 0
      , r = t ? e : 1 - e;
    let s;
    if (r <= 50)
        s = n || 100;
    else {
        const i = r + 50
          , o = Math.trunc(i / 100) * 100
          , a = n >= i % 100;
        s = n + o - (a ? 100 : 0)
    }
    return t ? s : 1 - s
}
function Fq(n) {
    return n % 400 === 0 || n % 4 === 0 && n % 100 !== 0
}
class N8e extends bn {
    priority = 130;
    incompatibleTokens = ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"];
    parse(e, t, r) {
        const s = i => ({
            year: i,
            isTwoDigitYear: t === "yy"
        });
        switch (t) {
        case "y":
            return Cr(yr(4, e), s);
        case "yo":
            return Cr(r.ordinalNumber(e, {
                unit: "year"
            }), s);
        default:
            return Cr(yr(t.length, e), s)
        }
    }
    validate(e, t) {
        return t.isTwoDigitYear || t.year > 0
    }
    set(e, t, r) {
        const s = e.getFullYear();
        if (r.isTwoDigitYear) {
            const o = Lq(r.year, s);
            return e.setFullYear(o, 0, 1),
            e.setHours(0, 0, 0, 0),
            e
        }
        const i = !("era"in t) || t.era === 1 ? r.year : 1 - r.year;
        return e.setFullYear(i, 0, 1),
        e.setHours(0, 0, 0, 0),
        e
    }
}
class D8e extends bn {
    priority = 130;
    parse(e, t, r) {
        const s = i => ({
            year: i,
            isTwoDigitYear: t === "YY"
        });
        switch (t) {
        case "Y":
            return Cr(yr(4, e), s);
        case "Yo":
            return Cr(r.ordinalNumber(e, {
                unit: "year"
            }), s);
        default:
            return Cr(yr(t.length, e), s)
        }
    }
    validate(e, t) {
        return t.isTwoDigitYear || t.year > 0
    }
    set(e, t, r, s) {
        const i = yk(e, s);
        if (r.isTwoDigitYear) {
            const a = Lq(r.year, i);
            return e.setFullYear(a, 0, s.firstWeekContainsDate),
            e.setHours(0, 0, 0, 0),
            Rc(e, s)
        }
        const o = !("era"in t) || t.era === 1 ? r.year : 1 - r.year;
        return e.setFullYear(o, 0, s.firstWeekContainsDate),
        e.setHours(0, 0, 0, 0),
        Rc(e, s)
    }
    incompatibleTokens = ["y", "R", "u", "Q", "q", "M", "L", "I", "d", "D", "i", "t", "T"]
}
class T8e extends bn {
    priority = 130;
    parse(e, t) {
        return iv(t === "R" ? 4 : t.length, e)
    }
    set(e, t, r) {
        const s = kn(e, 0);
        return s.setFullYear(r, 0, 4),
        s.setHours(0, 0, 0, 0),
        l0(s)
    }
    incompatibleTokens = ["G", "y", "Y", "u", "Q", "q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]
}
class I8e extends bn {
    priority = 130;
    parse(e, t) {
        return iv(t === "u" ? 4 : t.length, e)
    }
    set(e, t, r) {
        return e.setFullYear(r, 0, 1),
        e.setHours(0, 0, 0, 0),
        e
    }
    incompatibleTokens = ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"]
}
class M8e extends bn {
    priority = 120;
    parse(e, t, r) {
        switch (t) {
        case "Q":
        case "QQ":
            return yr(t.length, e);
        case "Qo":
            return r.ordinalNumber(e, {
                unit: "quarter"
            });
        case "QQQ":
            return r.quarter(e, {
                width: "abbreviated",
                context: "formatting"
            }) || r.quarter(e, {
                width: "narrow",
                context: "formatting"
            });
        case "QQQQQ":
            return r.quarter(e, {
                width: "narrow",
                context: "formatting"
            });
        case "QQQQ":
        default:
            return r.quarter(e, {
                width: "wide",
                context: "formatting"
            }) || r.quarter(e, {
                width: "abbreviated",
                context: "formatting"
            }) || r.quarter(e, {
                width: "narrow",
                context: "formatting"
            })
        }
    }
    validate(e, t) {
        return t >= 1 && t <= 4
    }
    set(e, t, r) {
        return e.setMonth((r - 1) * 3, 1),
        e.setHours(0, 0, 0, 0),
        e
    }
    incompatibleTokens = ["Y", "R", "q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]
}
class B8e extends bn {
    priority = 120;
    parse(e, t, r) {
        switch (t) {
        case "q":
        case "qq":
            return yr(t.length, e);
        case "qo":
            return r.ordinalNumber(e, {
                unit: "quarter"
            });
        case "qqq":
            return r.quarter(e, {
                width: "abbreviated",
                context: "standalone"
            }) || r.quarter(e, {
                width: "narrow",
                context: "standalone"
            });
        case "qqqqq":
            return r.quarter(e, {
                width: "narrow",
                context: "standalone"
            });
        case "qqqq":
        default:
            return r.quarter(e, {
                width: "wide",
                context: "standalone"
            }) || r.quarter(e, {
                width: "abbreviated",
                context: "standalone"
            }) || r.quarter(e, {
                width: "narrow",
                context: "standalone"
            })
        }
    }
    validate(e, t) {
        return t >= 1 && t <= 4
    }
    set(e, t, r) {
        return e.setMonth((r - 1) * 3, 1),
        e.setHours(0, 0, 0, 0),
        e
    }
    incompatibleTokens = ["Y", "R", "Q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]
}
class R8e extends bn {
    incompatibleTokens = ["Y", "R", "q", "Q", "L", "w", "I", "D", "i", "e", "c", "t", "T"];
    priority = 110;
    parse(e, t, r) {
        const s = i => i - 1;
        switch (t) {
        case "M":
            return Cr(rr(Ar.month, e), s);
        case "MM":
            return Cr(yr(2, e), s);
        case "Mo":
            return Cr(r.ordinalNumber(e, {
                unit: "month"
            }), s);
        case "MMM":
            return r.month(e, {
                width: "abbreviated",
                context: "formatting"
            }) || r.month(e, {
                width: "narrow",
                context: "formatting"
            });
        case "MMMMM":
            return r.month(e, {
                width: "narrow",
                context: "formatting"
            });
        case "MMMM":
        default:
            return r.month(e, {
                width: "wide",
                context: "formatting"
            }) || r.month(e, {
                width: "abbreviated",
                context: "formatting"
            }) || r.month(e, {
                width: "narrow",
                context: "formatting"
            })
        }
    }
    validate(e, t) {
        return t >= 0 && t <= 11
    }
    set(e, t, r) {
        return e.setMonth(r, 1),
        e.setHours(0, 0, 0, 0),
        e
    }
}
class O8e extends bn {
    priority = 110;
    parse(e, t, r) {
        const s = i => i - 1;
        switch (t) {
        case "L":
            return Cr(rr(Ar.month, e), s);
        case "LL":
            return Cr(yr(2, e), s);
        case "Lo":
            return Cr(r.ordinalNumber(e, {
                unit: "month"
            }), s);
        case "LLL":
            return r.month(e, {
                width: "abbreviated",
                context: "standalone"
            }) || r.month(e, {
                width: "narrow",
                context: "standalone"
            });
        case "LLLLL":
            return r.month(e, {
                width: "narrow",
                context: "standalone"
            });
        case "LLLL":
        default:
            return r.month(e, {
                width: "wide",
                context: "standalone"
            }) || r.month(e, {
                width: "abbreviated",
                context: "standalone"
            }) || r.month(e, {
                width: "narrow",
                context: "standalone"
            })
        }
    }
    validate(e, t) {
        return t >= 0 && t <= 11
    }
    set(e, t, r) {
        return e.setMonth(r, 1),
        e.setHours(0, 0, 0, 0),
        e
    }
    incompatibleTokens = ["Y", "R", "q", "Q", "M", "w", "I", "D", "i", "e", "c", "t", "T"]
}
function P8e(n, e, t) {
    const r = ht(n, t?.in)
      , s = Rq(r, t) - e;
    return r.setDate(r.getDate() - s * 7),
    ht(r, t?.in)
}
class j8e extends bn {
    priority = 100;
    parse(e, t, r) {
        switch (t) {
        case "w":
            return rr(Ar.week, e);
        case "wo":
            return r.ordinalNumber(e, {
                unit: "week"
            });
        default:
            return yr(t.length, e)
        }
    }
    validate(e, t) {
        return t >= 1 && t <= 53
    }
    set(e, t, r, s) {
        return Rc(P8e(e, r, s), s)
    }
    incompatibleTokens = ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "i", "t", "T"]
}
function L8e(n, e, t) {
    const r = ht(n, t?.in)
      , s = gk(r, t) - e;
    return r.setDate(r.getDate() - s * 7),
    r
}
class F8e extends bn {
    priority = 100;
    parse(e, t, r) {
        switch (t) {
        case "I":
            return rr(Ar.week, e);
        case "Io":
            return r.ordinalNumber(e, {
                unit: "week"
            });
        default:
            return yr(t.length, e)
        }
    }
    validate(e, t) {
        return t >= 1 && t <= 53
    }
    set(e, t, r) {
        return l0(L8e(e, r))
    }
    incompatibleTokens = ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]
}
const U8e = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
  , z8e = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
class $8e extends bn {
    priority = 90;
    subPriority = 1;
    parse(e, t, r) {
        switch (t) {
        case "d":
            return rr(Ar.date, e);
        case "do":
            return r.ordinalNumber(e, {
                unit: "date"
            });
        default:
            return yr(t.length, e)
        }
    }
    validate(e, t) {
        const r = e.getFullYear()
          , s = Fq(r)
          , i = e.getMonth();
        return s ? t >= 1 && t <= z8e[i] : t >= 1 && t <= U8e[i]
    }
    set(e, t, r) {
        return e.setDate(r),
        e.setHours(0, 0, 0, 0),
        e
    }
    incompatibleTokens = ["Y", "R", "q", "Q", "w", "I", "D", "i", "e", "c", "t", "T"]
}
class H8e extends bn {
    priority = 90;
    subpriority = 1;
    parse(e, t, r) {
        switch (t) {
        case "D":
        case "DD":
            return rr(Ar.dayOfYear, e);
        case "Do":
            return r.ordinalNumber(e, {
                unit: "date"
            });
        default:
            return yr(t.length, e)
        }
    }
    validate(e, t) {
        const r = e.getFullYear();
        return Fq(r) ? t >= 1 && t <= 366 : t >= 1 && t <= 365
    }
    set(e, t, r) {
        return e.setMonth(0, r),
        e.setHours(0, 0, 0, 0),
        e
    }
    incompatibleTokens = ["Y", "R", "q", "Q", "M", "L", "w", "I", "d", "E", "i", "e", "c", "t", "T"]
}
function wk(n, e, t) {
    const r = th()
      , s = t?.weekStartsOn ?? t?.locale?.options?.weekStartsOn ?? r.weekStartsOn ?? r.locale?.options?.weekStartsOn ?? 0
      , i = ht(n, t?.in)
      , o = i.getDay()
      , l = (e % 7 + 7) % 7
      , u = 7 - s
      , d = e < 0 || e > 6 ? e - (o + u) % 7 : (l + u) % 7 - (o + u) % 7;
    return ca(i, d, t)
}
class V8e extends bn {
    priority = 90;
    parse(e, t, r) {
        switch (t) {
        case "E":
        case "EE":
        case "EEE":
            return r.day(e, {
                width: "abbreviated",
                context: "formatting"
            }) || r.day(e, {
                width: "short",
                context: "formatting"
            }) || r.day(e, {
                width: "narrow",
                context: "formatting"
            });
        case "EEEEE":
            return r.day(e, {
                width: "narrow",
                context: "formatting"
            });
        case "EEEEEE":
            return r.day(e, {
                width: "short",
                context: "formatting"
            }) || r.day(e, {
                width: "narrow",
                context: "formatting"
            });
        case "EEEE":
        default:
            return r.day(e, {
                width: "wide",
                context: "formatting"
            }) || r.day(e, {
                width: "abbreviated",
                context: "formatting"
            }) || r.day(e, {
                width: "short",
                context: "formatting"
            }) || r.day(e, {
                width: "narrow",
                context: "formatting"
            })
        }
    }
    validate(e, t) {
        return t >= 0 && t <= 6
    }
    set(e, t, r, s) {
        return e = wk(e, r, s),
        e.setHours(0, 0, 0, 0),
        e
    }
    incompatibleTokens = ["D", "i", "e", "c", "t", "T"]
}
class q8e extends bn {
    priority = 90;
    parse(e, t, r, s) {
        const i = o => {
            const a = Math.floor((o - 1) / 7) * 7;
            return (o + s.weekStartsOn + 6) % 7 + a
        }
        ;
        switch (t) {
        case "e":
        case "ee":
            return Cr(yr(t.length, e), i);
        case "eo":
            return Cr(r.ordinalNumber(e, {
                unit: "day"
            }), i);
        case "eee":
            return r.day(e, {
                width: "abbreviated",
                context: "formatting"
            }) || r.day(e, {
                width: "short",
                context: "formatting"
            }) || r.day(e, {
                width: "narrow",
                context: "formatting"
            });
        case "eeeee":
            return r.day(e, {
                width: "narrow",
                context: "formatting"
            });
        case "eeeeee":
            return r.day(e, {
                width: "short",
                context: "formatting"
            }) || r.day(e, {
                width: "narrow",
                context: "formatting"
            });
        case "eeee":
        default:
            return r.day(e, {
                width: "wide",
                context: "formatting"
            }) || r.day(e, {
                width: "abbreviated",
                context: "formatting"
            }) || r.day(e, {
                width: "short",
                context: "formatting"
            }) || r.day(e, {
                width: "narrow",
                context: "formatting"
            })
        }
    }
    validate(e, t) {
        return t >= 0 && t <= 6
    }
    set(e, t, r, s) {
        return e = wk(e, r, s),
        e.setHours(0, 0, 0, 0),
        e
    }
    incompatibleTokens = ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "c", "t", "T"]
}
class G8e extends bn {
    priority = 90;
    parse(e, t, r, s) {
        const i = o => {
            const a = Math.floor((o - 1) / 7) * 7;
            return (o + s.weekStartsOn + 6) % 7 + a
        }
        ;
        switch (t) {
        case "c":
        case "cc":
            return Cr(yr(t.length, e), i);
        case "co":
            return Cr(r.ordinalNumber(e, {
                unit: "day"
            }), i);
        case "ccc":
            return r.day(e, {
                width: "abbreviated",
                context: "standalone"
            }) || r.day(e, {
                width: "short",
                context: "standalone"
            }) || r.day(e, {
                width: "narrow",
                context: "standalone"
            });
        case "ccccc":
            return r.day(e, {
                width: "narrow",
                context: "standalone"
            });
        case "cccccc":
            return r.day(e, {
                width: "short",
                context: "standalone"
            }) || r.day(e, {
                width: "narrow",
                context: "standalone"
            });
        case "cccc":
        default:
            return r.day(e, {
                width: "wide",
                context: "standalone"
            }) || r.day(e, {
                width: "abbreviated",
                context: "standalone"
            }) || r.day(e, {
                width: "short",
                context: "standalone"
            }) || r.day(e, {
                width: "narrow",
                context: "standalone"
            })
        }
    }
    validate(e, t) {
        return t >= 0 && t <= 6
    }
    set(e, t, r, s) {
        return e = wk(e, r, s),
        e.setHours(0, 0, 0, 0),
        e
    }
    incompatibleTokens = ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "e", "t", "T"]
}
function W8e(n, e, t) {
    const r = ht(n, t?.in)
      , s = v8e(r, t)
      , i = e - s;
    return ca(r, i, t)
}
class Y8e extends bn {
    priority = 90;
    parse(e, t, r) {
        const s = i => i === 0 ? 7 : i;
        switch (t) {
        case "i":
        case "ii":
            return yr(t.length, e);
        case "io":
            return r.ordinalNumber(e, {
                unit: "day"
            });
        case "iii":
            return Cr(r.day(e, {
                width: "abbreviated",
                context: "formatting"
            }) || r.day(e, {
                width: "short",
                context: "formatting"
            }) || r.day(e, {
                width: "narrow",
                context: "formatting"
            }), s);
        case "iiiii":
            return Cr(r.day(e, {
                width: "narrow",
                context: "formatting"
            }), s);
        case "iiiiii":
            return Cr(r.day(e, {
                width: "short",
                context: "formatting"
            }) || r.day(e, {
                width: "narrow",
                context: "formatting"
            }), s);
        case "iiii":
        default:
            return Cr(r.day(e, {
                width: "wide",
                context: "formatting"
            }) || r.day(e, {
                width: "abbreviated",
                context: "formatting"
            }) || r.day(e, {
                width: "short",
                context: "formatting"
            }) || r.day(e, {
                width: "narrow",
                context: "formatting"
            }), s)
        }
    }
    validate(e, t) {
        return t >= 1 && t <= 7
    }
    set(e, t, r) {
        return e = W8e(e, r),
        e.setHours(0, 0, 0, 0),
        e
    }
    incompatibleTokens = ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "E", "e", "c", "t", "T"]
}
class K8e extends bn {
    priority = 80;
    parse(e, t, r) {
        switch (t) {
        case "a":
        case "aa":
        case "aaa":
            return r.dayPeriod(e, {
                width: "abbreviated",
                context: "formatting"
            }) || r.dayPeriod(e, {
                width: "narrow",
                context: "formatting"
            });
        case "aaaaa":
            return r.dayPeriod(e, {
                width: "narrow",
                context: "formatting"
            });
        case "aaaa":
        default:
            return r.dayPeriod(e, {
                width: "wide",
                context: "formatting"
            }) || r.dayPeriod(e, {
                width: "abbreviated",
                context: "formatting"
            }) || r.dayPeriod(e, {
                width: "narrow",
                context: "formatting"
            })
        }
    }
    set(e, t, r) {
        return e.setHours(bk(r), 0, 0, 0),
        e
    }
    incompatibleTokens = ["b", "B", "H", "k", "t", "T"]
}
class X8e extends bn {
    priority = 80;
    parse(e, t, r) {
        switch (t) {
        case "b":
        case "bb":
        case "bbb":
            return r.dayPeriod(e, {
                width: "abbreviated",
                context: "formatting"
            }) || r.dayPeriod(e, {
                width: "narrow",
                context: "formatting"
            });
        case "bbbbb":
            return r.dayPeriod(e, {
                width: "narrow",
                context: "formatting"
            });
        case "bbbb":
        default:
            return r.dayPeriod(e, {
                width: "wide",
                context: "formatting"
            }) || r.dayPeriod(e, {
                width: "abbreviated",
                context: "formatting"
            }) || r.dayPeriod(e, {
                width: "narrow",
                context: "formatting"
            })
        }
    }
    set(e, t, r) {
        return e.setHours(bk(r), 0, 0, 0),
        e
    }
    incompatibleTokens = ["a", "B", "H", "k", "t", "T"]
}
class Q8e extends bn {
    priority = 80;
    parse(e, t, r) {
        switch (t) {
        case "B":
        case "BB":
        case "BBB":
            return r.dayPeriod(e, {
                width: "abbreviated",
                context: "formatting"
            }) || r.dayPeriod(e, {
                width: "narrow",
                context: "formatting"
            });
        case "BBBBB":
            return r.dayPeriod(e, {
                width: "narrow",
                context: "formatting"
            });
        case "BBBB":
        default:
            return r.dayPeriod(e, {
                width: "wide",
                context: "formatting"
            }) || r.dayPeriod(e, {
                width: "abbreviated",
                context: "formatting"
            }) || r.dayPeriod(e, {
                width: "narrow",
                context: "formatting"
            })
        }
    }
    set(e, t, r) {
        return e.setHours(bk(r), 0, 0, 0),
        e
    }
    incompatibleTokens = ["a", "b", "t", "T"]
}
class Z8e extends bn {
    priority = 70;
    parse(e, t, r) {
        switch (t) {
        case "h":
            return rr(Ar.hour12h, e);
        case "ho":
            return r.ordinalNumber(e, {
                unit: "hour"
            });
        default:
            return yr(t.length, e)
        }
    }
    validate(e, t) {
        return t >= 1 && t <= 12
    }
    set(e, t, r) {
        const s = e.getHours() >= 12;
        return s && r < 12 ? e.setHours(r + 12, 0, 0, 0) : !s && r === 12 ? e.setHours(0, 0, 0, 0) : e.setHours(r, 0, 0, 0),
        e
    }
    incompatibleTokens = ["H", "K", "k", "t", "T"]
}
class J8e extends bn {
    priority = 70;
    parse(e, t, r) {
        switch (t) {
        case "H":
            return rr(Ar.hour23h, e);
        case "Ho":
            return r.ordinalNumber(e, {
                unit: "hour"
            });
        default:
            return yr(t.length, e)
        }
    }
    validate(e, t) {
        return t >= 0 && t <= 23
    }
    set(e, t, r) {
        return e.setHours(r, 0, 0, 0),
        e
    }
    incompatibleTokens = ["a", "b", "h", "K", "k", "t", "T"]
}
class e_e extends bn {
    priority = 70;
    parse(e, t, r) {
        switch (t) {
        case "K":
            return rr(Ar.hour11h, e);
        case "Ko":
            return r.ordinalNumber(e, {
                unit: "hour"
            });
        default:
            return yr(t.length, e)
        }
    }
    validate(e, t) {
        return t >= 0 && t <= 11
    }
    set(e, t, r) {
        return e.getHours() >= 12 && r < 12 ? e.setHours(r + 12, 0, 0, 0) : e.setHours(r, 0, 0, 0),
        e
    }
    incompatibleTokens = ["h", "H", "k", "t", "T"]
}
class t_e extends bn {
    priority = 70;
    parse(e, t, r) {
        switch (t) {
        case "k":
            return rr(Ar.hour24h, e);
        case "ko":
            return r.ordinalNumber(e, {
                unit: "hour"
            });
        default:
            return yr(t.length, e)
        }
    }
    validate(e, t) {
        return t >= 1 && t <= 24
    }
    set(e, t, r) {
        const s = r <= 24 ? r % 24 : r;
        return e.setHours(s, 0, 0, 0),
        e
    }
    incompatibleTokens = ["a", "b", "h", "H", "K", "t", "T"]
}
class n_e extends bn {
    priority = 60;
    parse(e, t, r) {
        switch (t) {
        case "m":
            return rr(Ar.minute, e);
        case "mo":
            return r.ordinalNumber(e, {
                unit: "minute"
            });
        default:
            return yr(t.length, e)
        }
    }
    validate(e, t) {
        return t >= 0 && t <= 59
    }
    set(e, t, r) {
        return e.setMinutes(r, 0, 0),
        e
    }
    incompatibleTokens = ["t", "T"]
}
class r_e extends bn {
    priority = 50;
    parse(e, t, r) {
        switch (t) {
        case "s":
            return rr(Ar.second, e);
        case "so":
            return r.ordinalNumber(e, {
                unit: "second"
            });
        default:
            return yr(t.length, e)
        }
    }
    validate(e, t) {
        return t >= 0 && t <= 59
    }
    set(e, t, r) {
        return e.setSeconds(r, 0),
        e
    }
    incompatibleTokens = ["t", "T"]
}
class s_e extends bn {
    priority = 30;
    parse(e, t) {
        const r = s => Math.trunc(s * Math.pow(10, -t.length + 3));
        return Cr(yr(t.length, e), r)
    }
    set(e, t, r) {
        return e.setMilliseconds(r),
        e
    }
    incompatibleTokens = ["t", "T"]
}
class i_e extends bn {
    priority = 10;
    parse(e, t) {
        switch (t) {
        case "X":
            return Ga(qa.basicOptionalMinutes, e);
        case "XX":
            return Ga(qa.basic, e);
        case "XXXX":
            return Ga(qa.basicOptionalSeconds, e);
        case "XXXXX":
            return Ga(qa.extendedOptionalSeconds, e);
        case "XXX":
        default:
            return Ga(qa.extended, e)
        }
    }
    set(e, t, r) {
        return t.timestampIsSet ? e : kn(e, e.getTime() - J2(e) - r)
    }
    incompatibleTokens = ["t", "T", "x"]
}
class o_e extends bn {
    priority = 10;
    parse(e, t) {
        switch (t) {
        case "x":
            return Ga(qa.basicOptionalMinutes, e);
        case "xx":
            return Ga(qa.basic, e);
        case "xxxx":
            return Ga(qa.basicOptionalSeconds, e);
        case "xxxxx":
            return Ga(qa.extendedOptionalSeconds, e);
        case "xxx":
        default:
            return Ga(qa.extended, e)
        }
    }
    set(e, t, r) {
        return t.timestampIsSet ? e : kn(e, e.getTime() - J2(e) - r)
    }
    incompatibleTokens = ["t", "T", "X"]
}
class a_e extends bn {
    priority = 40;
    parse(e) {
        return jq(e)
    }
    set(e, t, r) {
        return [kn(e, r * 1e3), {
            timestampIsSet: !0
        }]
    }
    incompatibleTokens = "*"
}
class l_e extends bn {
    priority = 20;
    parse(e) {
        return jq(e)
    }
    set(e, t, r) {
        return [kn(e, r), {
            timestampIsSet: !0
        }]
    }
    incompatibleTokens = "*"
}
const c_e = {
    G: new k8e,
    y: new N8e,
    Y: new D8e,
    R: new T8e,
    u: new I8e,
    Q: new M8e,
    q: new B8e,
    M: new R8e,
    L: new O8e,
    w: new j8e,
    I: new F8e,
    d: new $8e,
    D: new H8e,
    E: new V8e,
    e: new q8e,
    c: new G8e,
    i: new Y8e,
    a: new K8e,
    b: new X8e,
    B: new Q8e,
    h: new Z8e,
    H: new J8e,
    K: new e_e,
    k: new t_e,
    m: new n_e,
    s: new r_e,
    S: new s_e,
    X: new i_e,
    x: new o_e,
    t: new a_e,
    T: new l_e
}
  , u_e = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g
  , d_e = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g
  , f_e = /^'([^]*?)'?$/
  , h_e = /''/g
  , p_e = /\S/
  , m_e = /[a-zA-Z]/;
function g_e(n, e, t, r) {
    const s = () => kn(r?.in || t, NaN)
      , i = w8e()
      , o = r?.locale ?? i.locale ?? Bq
      , a = r?.firstWeekContainsDate ?? r?.locale?.options?.firstWeekContainsDate ?? i.firstWeekContainsDate ?? i.locale?.options?.firstWeekContainsDate ?? 1
      , l = r?.weekStartsOn ?? r?.locale?.options?.weekStartsOn ?? i.weekStartsOn ?? i.locale?.options?.weekStartsOn ?? 0;
    if (!e)
        return n ? s() : ht(t, r?.in);
    const u = {
        firstWeekContainsDate: a,
        weekStartsOn: l,
        locale: o
    }
      , d = [new _8e(r?.in,t)]
      , h = e.match(d_e).map(v => {
        const S = v[0];
        if (S in ZC) {
            const N = ZC[S];
            return N(v, o.formatLong)
        }
        return v
    }
    ).join("").match(u_e)
      , p = [];
    for (let v of h) {
        const S = v[0]
          , N = c_e[S];
        if (N) {
            const {incompatibleTokens: _} = N;
            if (Array.isArray(_)) {
                const k = p.find(B => _.includes(B.token) || B.token === S);
                if (k)
                    throw new RangeError(`The format string mustn't contain \`${k.fullToken}\` and \`${v}\` at the same time`)
            } else if (N.incompatibleTokens === "*" && p.length > 0)
                throw new RangeError(`The format string mustn't contain \`${v}\` and any other token at the same time`);
            p.push({
                token: S,
                fullToken: v
            });
            const I = N.run(n, v, o.match, u);
            if (!I)
                return s();
            d.push(I.setter),
            n = I.rest
        } else {
            if (S.match(m_e))
                throw new RangeError("Format string contains an unescaped latin alphabet character `" + S + "`");
            if (v === "''" ? v = "'" : S === "'" && (v = y_e(v)),
            n.indexOf(v) === 0)
                n = n.slice(v.length);
            else
                return s()
        }
    }
    if (n.length > 0 && p_e.test(n))
        return s();
    const g = d.map(v => v.priority).sort( (v, S) => S - v).filter( (v, S, N) => N.indexOf(v) === S).map(v => d.filter(S => S.priority === v).sort( (S, N) => N.subPriority - S.subPriority)).map(v => v[0]);
    let w = ht(t, r?.in);
    if (isNaN(+w))
        return s();
    const b = {};
    for (const v of g) {
        if (!v.validate(w, u))
            return s();
        const S = v.set(w, b, u);
        Array.isArray(S) ? (w = S[0],
        Object.assign(b, S[1])) : w = S
    }
    return w
}
function y_e(n) {
    return n.match(f_e)[1].replace(h_e, "'")
}
function b_e(n, e, t) {
    const [r,s] = Lc(t?.in, n, e);
    return r.getFullYear() === s.getFullYear() && r.getMonth() === s.getMonth()
}
function w_e(n, e, t) {
    const [r,s] = Lc(t?.in, n, e);
    return +QC(r) == +QC(s)
}
function v_e(n, e, t) {
    const [r,s] = Lc(t?.in, n, e);
    return r.getFullYear() === s.getFullYear()
}
function ly(n, e, t) {
    const r = +ht(n, t?.in)
      , [s,i] = [+ht(e.start, t?.in), +ht(e.end, t?.in)].sort( (o, a) => o - a);
    return r >= s && r <= i
}
function x_e(n, e, t) {
    return ca(n, -1, t)
}
function E_e(n, e) {
    const t = () => kn(e?.in, NaN)
      , s = __e(n);
    let i;
    if (s.date) {
        const u = k_e(s.date, 2);
        i = N_e(u.restDateString, u.year)
    }
    if (!i || isNaN(+i))
        return t();
    const o = +i;
    let a = 0, l;
    if (s.time && (a = D_e(s.time),
    isNaN(a)))
        return t();
    if (s.timezone) {
        if (l = T_e(s.timezone),
        isNaN(l))
            return t()
    } else {
        const u = new Date(o + a)
          , d = ht(0, e?.in);
        return d.setFullYear(u.getUTCFullYear(), u.getUTCMonth(), u.getUTCDate()),
        d.setHours(u.getUTCHours(), u.getUTCMinutes(), u.getUTCSeconds(), u.getUTCMilliseconds()),
        d
    }
    return ht(o + a + l, e?.in)
}
const aw = {
    dateTimeDelimiter: /[T ]/,
    timeZoneDelimiter: /[Z ]/i,
    timezone: /([Z+-].*)$/
}
  , S_e = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/
  , A_e = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/
  , C_e = /^([+-])(\d{2})(?::?(\d{2}))?$/;
function __e(n) {
    const e = {}
      , t = n.split(aw.dateTimeDelimiter);
    let r;
    if (t.length > 2)
        return e;
    if (/:/.test(t[0]) ? r = t[0] : (e.date = t[0],
    r = t[1],
    aw.timeZoneDelimiter.test(e.date) && (e.date = n.split(aw.timeZoneDelimiter)[0],
    r = n.substr(e.date.length, n.length))),
    r) {
        const s = aw.timezone.exec(r);
        s ? (e.time = r.replace(s[1], ""),
        e.timezone = s[1]) : e.time = r
    }
    return e
}
function k_e(n, e) {
    const t = new RegExp("^(?:(\\d{4}|[+-]\\d{" + (4 + e) + "})|(\\d{2}|[+-]\\d{" + (2 + e) + "})$)")
      , r = n.match(t);
    if (!r)
        return {
            year: NaN,
            restDateString: ""
        };
    const s = r[1] ? parseInt(r[1]) : null
      , i = r[2] ? parseInt(r[2]) : null;
    return {
        year: i === null ? s : i * 100,
        restDateString: n.slice((r[1] || r[2]).length)
    }
}
function N_e(n, e) {
    if (e === null)
        return new Date(NaN);
    const t = n.match(S_e);
    if (!t)
        return new Date(NaN);
    const r = !!t[4]
      , s = ig(t[1])
      , i = ig(t[2]) - 1
      , o = ig(t[3])
      , a = ig(t[4])
      , l = ig(t[5]) - 1;
    if (r)
        return O_e(e, a, l) ? I_e(e, a, l) : new Date(NaN);
    {
        const u = new Date(0);
        return !B_e(e, i, o) || !R_e(e, s) ? new Date(NaN) : (u.setUTCFullYear(e, i, Math.max(s, o)),
        u)
    }
}
function ig(n) {
    return n ? parseInt(n) : 1
}
function D_e(n) {
    const e = n.match(A_e);
    if (!e)
        return NaN;
    const t = CA(e[1])
      , r = CA(e[2])
      , s = CA(e[3]);
    return P_e(t, r, s) ? t * Bx + r * Mx + s * 1e3 : NaN
}
function CA(n) {
    return n && parseFloat(n.replace(",", ".")) || 0
}
function T_e(n) {
    if (n === "Z")
        return 0;
    const e = n.match(C_e);
    if (!e)
        return 0;
    const t = e[1] === "+" ? -1 : 1
      , r = parseInt(e[2])
      , s = e[3] && parseInt(e[3]) || 0;
    return j_e(r, s) ? t * (r * Bx + s * Mx) : NaN
}
function I_e(n, e, t) {
    const r = new Date(0);
    r.setUTCFullYear(n, 0, 4);
    const s = r.getUTCDay() || 7
      , i = (e - 1) * 7 + t + 1 - s;
    return r.setUTCDate(r.getUTCDate() + i),
    r
}
const M_e = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function Uq(n) {
    return n % 400 === 0 || n % 4 === 0 && n % 100 !== 0
}
function B_e(n, e, t) {
    return e >= 0 && e <= 11 && t >= 1 && t <= (M_e[e] || (Uq(n) ? 29 : 28))
}
function R_e(n, e) {
    return e >= 1 && e <= (Uq(n) ? 366 : 365)
}
function O_e(n, e, t) {
    return e >= 1 && e <= 53 && t >= 0 && t <= 6
}
function P_e(n, e, t) {
    return n === 24 ? e === 0 && t === 0 : t >= 0 && t < 60 && e >= 0 && e < 60 && n >= 0 && n < 25
}
function j_e(n, e) {
    return e >= 0 && e <= 59
}
function Xi(n, e, t) {
    const r = ht(n, t?.in)
      , s = r.getFullYear()
      , i = r.getDate()
      , o = kn(n, 0);
    o.setFullYear(s, e, 15),
    o.setHours(0, 0, 0, 0);
    const a = b8e(o);
    return r.setMonth(e, Math.min(i, a)),
    r
}
function Qw(n, e, t) {
    const r = ht(n, t?.in);
    return r.setHours(e),
    r
}
function Zw(n, e, t) {
    const r = ht(n, t?.in);
    return r.setMinutes(e),
    r
}
function up(n, e, t) {
    const r = ht(n, t?.in)
      , s = Math.trunc(r.getMonth() / 3) + 1
      , i = e - s;
    return Xi(r, r.getMonth() + i * 3)
}
function Jw(n, e, t) {
    const r = ht(n, t?.in);
    return r.setSeconds(e),
    r
}
function La(n, e, t) {
    const r = ht(n, t?.in);
    return isNaN(+r) ? kn(n, NaN) : (r.setFullYear(e),
    r)
}
function _f(n, e, t) {
    return ha(n, -e, t)
}
function zq(n, e, t) {
    return mk(n, -1, t)
}
function AP(n, e, t) {
    return ev(n, -1, t)
}
function u0(n, e, t) {
    return bc(n, -e, t)
}
function Ox() {
    return typeof window < "u"
}
function R0(n) {
    return $q(n) ? (n.nodeName || "").toLowerCase() : "#document"
}
function to(n) {
    var e;
    return (n == null || (e = n.ownerDocument) == null ? void 0 : e.defaultView) || window
}
function al(n) {
    var e;
    return (e = ($q(n) ? n.ownerDocument : n.document) || window.document) == null ? void 0 : e.documentElement
}
function $q(n) {
    return Ox() ? n instanceof Node || n instanceof to(n).Node : !1
}
function Js(n) {
    return Ox() ? n instanceof Element || n instanceof to(n).Element : !1
}
function sl(n) {
    return Ox() ? n instanceof HTMLElement || n instanceof to(n).HTMLElement : !1
}
function CP(n) {
    return !Ox() || typeof ShadowRoot > "u" ? !1 : n instanceof ShadowRoot || n instanceof to(n).ShadowRoot
}
const L_e = new Set(["inline", "contents"]);
function eb(n) {
    const {overflow: e, overflowX: t, overflowY: r, display: s} = Lo(n);
    return /auto|scroll|overlay|hidden|clip/.test(e + r + t) && !L_e.has(s)
}
const F_e = new Set(["table", "td", "th"]);
function U_e(n) {
    return F_e.has(R0(n))
}
const z_e = [":popover-open", ":modal"];
function Px(n) {
    return z_e.some(e => {
        try {
            return n.matches(e)
        } catch {
            return !1
        }
    }
    )
}
const $_e = ["transform", "translate", "scale", "rotate", "perspective"]
  , H_e = ["transform", "translate", "scale", "rotate", "perspective", "filter"]
  , V_e = ["paint", "layout", "strict", "content"];
function vk(n) {
    const e = xk()
      , t = Js(n) ? Lo(n) : n;
    return $_e.some(r => t[r] ? t[r] !== "none" : !1) || (t.containerType ? t.containerType !== "normal" : !1) || !e && (t.backdropFilter ? t.backdropFilter !== "none" : !1) || !e && (t.filter ? t.filter !== "none" : !1) || H_e.some(r => (t.willChange || "").includes(r)) || V_e.some(r => (t.contain || "").includes(r))
}
function q_e(n) {
    let e = sd(n);
    for (; sl(e) && !d0(e); ) {
        if (vk(e))
            return e;
        if (Px(e))
            return null;
        e = sd(e)
    }
    return null
}
function xk() {
    return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none")
}
const G_e = new Set(["html", "body", "#document"]);
function d0(n) {
    return G_e.has(R0(n))
}
function Lo(n) {
    return to(n).getComputedStyle(n)
}
function jx(n) {
    return Js(n) ? {
        scrollLeft: n.scrollLeft,
        scrollTop: n.scrollTop
    } : {
        scrollLeft: n.scrollX,
        scrollTop: n.scrollY
    }
}
function sd(n) {
    if (R0(n) === "html")
        return n;
    const e = n.assignedSlot || n.parentNode || CP(n) && n.host || al(n);
    return CP(e) ? e.host : e
}
function Hq(n) {
    const e = sd(n);
    return d0(e) ? n.ownerDocument ? n.ownerDocument.body : n.body : sl(e) && eb(e) ? e : Hq(e)
}
function cy(n, e, t) {
    var r;
    e === void 0 && (e = []),
    t === void 0 && (t = !0);
    const s = Hq(n)
      , i = s === ((r = n.ownerDocument) == null ? void 0 : r.body)
      , o = to(s);
    if (i) {
        const a = e8(o);
        return e.concat(o, o.visualViewport || [], eb(s) ? s : [], a && t ? cy(a) : [])
    }
    return e.concat(s, cy(s, [], t))
}
function e8(n) {
    return n.parent && Object.getPrototypeOf(n.parent) ? n.frameElement : null
}
const f0 = Math.min
  , kf = Math.max
  , ov = Math.round
  , lw = Math.floor
  , Ja = n => ({
    x: n,
    y: n
})
  , W_e = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
}
  , Y_e = {
    start: "end",
    end: "start"
};
function K_e(n, e, t) {
    return kf(n, f0(e, t))
}
function Lx(n, e) {
    return typeof n == "function" ? n(e) : n
}
function h0(n) {
    return n.split("-")[0]
}
function tb(n) {
    return n.split("-")[1]
}
function X_e(n) {
    return n === "x" ? "y" : "x"
}
function Ek(n) {
    return n === "y" ? "height" : "width"
}
const Q_e = new Set(["top", "bottom"]);
function gf(n) {
    return Q_e.has(h0(n)) ? "y" : "x"
}
function Sk(n) {
    return X_e(gf(n))
}
function Z_e(n, e, t) {
    t === void 0 && (t = !1);
    const r = tb(n)
      , s = Sk(n)
      , i = Ek(s);
    let o = s === "x" ? r === (t ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
    return e.reference[i] > e.floating[i] && (o = av(o)),
    [o, av(o)]
}
function J_e(n) {
    const e = av(n);
    return [t8(n), e, t8(e)]
}
function t8(n) {
    return n.replace(/start|end/g, e => Y_e[e])
}
const _P = ["left", "right"]
  , kP = ["right", "left"]
  , eke = ["top", "bottom"]
  , tke = ["bottom", "top"];
function nke(n, e, t) {
    switch (n) {
    case "top":
    case "bottom":
        return t ? e ? kP : _P : e ? _P : kP;
    case "left":
    case "right":
        return e ? eke : tke;
    default:
        return []
    }
}
function rke(n, e, t, r) {
    const s = tb(n);
    let i = nke(h0(n), t === "start", r);
    return s && (i = i.map(o => o + "-" + s),
    e && (i = i.concat(i.map(t8)))),
    i
}
function av(n) {
    return n.replace(/left|right|bottom|top/g, e => W_e[e])
}
function ske(n) {
    return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        ...n
    }
}
function Vq(n) {
    return typeof n != "number" ? ske(n) : {
        top: n,
        right: n,
        bottom: n,
        left: n
    }
}
function lv(n) {
    const {x: e, y: t, width: r, height: s} = n;
    return {
        width: r,
        height: s,
        top: t,
        left: e,
        right: e + r,
        bottom: t + s,
        x: e,
        y: t
    }
}
var ike = typeof document < "u"
  , oke = function() {}
  , cv = ike ? V.useLayoutEffect : oke;
const ake = {
    ...X9
}
  , lke = ake.useInsertionEffect
  , cke = lke || (n => n());
function uke(n) {
    const e = V.useRef( () => {}
    );
    return cke( () => {
        e.current = n
    }
    ),
    V.useCallback(function() {
        for (var t = arguments.length, r = new Array(t), s = 0; s < t; s++)
            r[s] = arguments[s];
        return e.current == null ? void 0 : e.current(...r)
    }, [])
}
function NP(n, e, t) {
    let {reference: r, floating: s} = n;
    const i = gf(e)
      , o = Sk(e)
      , a = Ek(o)
      , l = h0(e)
      , u = i === "y"
      , d = r.x + r.width / 2 - s.width / 2
      , h = r.y + r.height / 2 - s.height / 2
      , p = r[a] / 2 - s[a] / 2;
    let g;
    switch (l) {
    case "top":
        g = {
            x: d,
            y: r.y - s.height
        };
        break;
    case "bottom":
        g = {
            x: d,
            y: r.y + r.height
        };
        break;
    case "right":
        g = {
            x: r.x + r.width,
            y: h
        };
        break;
    case "left":
        g = {
            x: r.x - s.width,
            y: h
        };
        break;
    default:
        g = {
            x: r.x,
            y: r.y
        }
    }
    switch (tb(e)) {
    case "start":
        g[o] -= p * (t && u ? -1 : 1);
        break;
    case "end":
        g[o] += p * (t && u ? -1 : 1);
        break
    }
    return g
}
const dke = async (n, e, t) => {
    const {placement: r="bottom", strategy: s="absolute", middleware: i=[], platform: o} = t
      , a = i.filter(Boolean)
      , l = await (o.isRTL == null ? void 0 : o.isRTL(e));
    let u = await o.getElementRects({
        reference: n,
        floating: e,
        strategy: s
    })
      , {x: d, y: h} = NP(u, r, l)
      , p = r
      , g = {}
      , w = 0;
    for (let b = 0; b < a.length; b++) {
        const {name: v, fn: S} = a[b]
          , {x: N, y: _, data: I, reset: k} = await S({
            x: d,
            y: h,
            initialPlacement: r,
            placement: p,
            strategy: s,
            middlewareData: g,
            rects: u,
            platform: o,
            elements: {
                reference: n,
                floating: e
            }
        });
        d = N ?? d,
        h = _ ?? h,
        g = {
            ...g,
            [v]: {
                ...g[v],
                ...I
            }
        },
        k && w <= 50 && (w++,
        typeof k == "object" && (k.placement && (p = k.placement),
        k.rects && (u = k.rects === !0 ? await o.getElementRects({
            reference: n,
            floating: e,
            strategy: s
        }) : k.rects),
        {x: d, y: h} = NP(u, p, l)),
        b = -1)
    }
    return {
        x: d,
        y: h,
        placement: p,
        strategy: s,
        middlewareData: g
    }
}
;
async function fke(n, e) {
    var t;
    e === void 0 && (e = {});
    const {x: r, y: s, platform: i, rects: o, elements: a, strategy: l} = n
      , {boundary: u="clippingAncestors", rootBoundary: d="viewport", elementContext: h="floating", altBoundary: p=!1, padding: g=0} = Lx(e, n)
      , w = Vq(g)
      , v = a[p ? h === "floating" ? "reference" : "floating" : h]
      , S = lv(await i.getClippingRect({
        element: (t = await (i.isElement == null ? void 0 : i.isElement(v))) == null || t ? v : v.contextElement || await (i.getDocumentElement == null ? void 0 : i.getDocumentElement(a.floating)),
        boundary: u,
        rootBoundary: d,
        strategy: l
    }))
      , N = h === "floating" ? {
        x: r,
        y: s,
        width: o.floating.width,
        height: o.floating.height
    } : o.reference
      , _ = await (i.getOffsetParent == null ? void 0 : i.getOffsetParent(a.floating))
      , I = await (i.isElement == null ? void 0 : i.isElement(_)) ? await (i.getScale == null ? void 0 : i.getScale(_)) || {
        x: 1,
        y: 1
    } : {
        x: 1,
        y: 1
    }
      , k = lv(i.convertOffsetParentRelativeRectToViewportRelativeRect ? await i.convertOffsetParentRelativeRectToViewportRelativeRect({
        elements: a,
        rect: N,
        offsetParent: _,
        strategy: l
    }) : N);
    return {
        top: (S.top - k.top + w.top) / I.y,
        bottom: (k.bottom - S.bottom + w.bottom) / I.y,
        left: (S.left - k.left + w.left) / I.x,
        right: (k.right - S.right + w.right) / I.x
    }
}
const hke = n => ({
    name: "arrow",
    options: n,
    async fn(e) {
        const {x: t, y: r, placement: s, rects: i, platform: o, elements: a, middlewareData: l} = e
          , {element: u, padding: d=0} = Lx(n, e) || {};
        if (u == null)
            return {};
        const h = Vq(d)
          , p = {
            x: t,
            y: r
        }
          , g = Sk(s)
          , w = Ek(g)
          , b = await o.getDimensions(u)
          , v = g === "y"
          , S = v ? "top" : "left"
          , N = v ? "bottom" : "right"
          , _ = v ? "clientHeight" : "clientWidth"
          , I = i.reference[w] + i.reference[g] - p[g] - i.floating[w]
          , k = p[g] - i.reference[g]
          , B = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(u));
        let P = B ? B[_] : 0;
        (!P || !await (o.isElement == null ? void 0 : o.isElement(B))) && (P = a.floating[_] || i.floating[w]);
        const M = I / 2 - k / 2
          , R = P / 2 - b[w] / 2 - 1
          , L = f0(h[S], R)
          , q = f0(h[N], R)
          , H = L
          , j = P - b[w] - q
          , A = P / 2 - b[w] / 2 + M
          , E = K_e(H, A, j)
          , C = !l.arrow && tb(s) != null && A !== E && i.reference[w] / 2 - (A < H ? L : q) - b[w] / 2 < 0
          , O = C ? A < H ? A - H : A - j : 0;
        return {
            [g]: p[g] + O,
            data: {
                [g]: E,
                centerOffset: A - E - O,
                ...C && {
                    alignmentOffset: O
                }
            },
            reset: C
        }
    }
})
  , pke = function(n) {
    return n === void 0 && (n = {}),
    {
        name: "flip",
        options: n,
        async fn(e) {
            var t, r;
            const {placement: s, middlewareData: i, rects: o, initialPlacement: a, platform: l, elements: u} = e
              , {mainAxis: d=!0, crossAxis: h=!0, fallbackPlacements: p, fallbackStrategy: g="bestFit", fallbackAxisSideDirection: w="none", flipAlignment: b=!0, ...v} = Lx(n, e);
            if ((t = i.arrow) != null && t.alignmentOffset)
                return {};
            const S = h0(s)
              , N = gf(a)
              , _ = h0(a) === a
              , I = await (l.isRTL == null ? void 0 : l.isRTL(u.floating))
              , k = p || (_ || !b ? [av(a)] : J_e(a))
              , B = w !== "none";
            !p && B && k.push(...rke(a, b, w, I));
            const P = [a, ...k]
              , M = await fke(e, v)
              , R = [];
            let L = ((r = i.flip) == null ? void 0 : r.overflows) || [];
            if (d && R.push(M[S]),
            h) {
                const A = Z_e(s, o, I);
                R.push(M[A[0]], M[A[1]])
            }
            if (L = [...L, {
                placement: s,
                overflows: R
            }],
            !R.every(A => A <= 0)) {
                var q, H;
                const A = (((q = i.flip) == null ? void 0 : q.index) || 0) + 1
                  , E = P[A];
                if (E && (!(h === "alignment" ? N !== gf(E) : !1) || L.every(z => gf(z.placement) === N ? z.overflows[0] > 0 : !0)))
                    return {
                        data: {
                            index: A,
                            overflows: L
                        },
                        reset: {
                            placement: E
                        }
                    };
                let C = (H = L.filter(O => O.overflows[0] <= 0).sort( (O, z) => O.overflows[1] - z.overflows[1])[0]) == null ? void 0 : H.placement;
                if (!C)
                    switch (g) {
                    case "bestFit":
                        {
                            var j;
                            const O = (j = L.filter(z => {
                                if (B) {
                                    const G = gf(z.placement);
                                    return G === N || G === "y"
                                }
                                return !0
                            }
                            ).map(z => [z.placement, z.overflows.filter(G => G > 0).reduce( (G, Y) => G + Y, 0)]).sort( (z, G) => z[1] - G[1])[0]) == null ? void 0 : j[0];
                            O && (C = O);
                            break
                        }
                    case "initialPlacement":
                        C = a;
                        break
                    }
                if (s !== C)
                    return {
                        reset: {
                            placement: C
                        }
                    }
            }
            return {}
        }
    }
}
  , mke = new Set(["left", "top"]);
async function gke(n, e) {
    const {placement: t, platform: r, elements: s} = n
      , i = await (r.isRTL == null ? void 0 : r.isRTL(s.floating))
      , o = h0(t)
      , a = tb(t)
      , l = gf(t) === "y"
      , u = mke.has(o) ? -1 : 1
      , d = i && l ? -1 : 1
      , h = Lx(e, n);
    let {mainAxis: p, crossAxis: g, alignmentAxis: w} = typeof h == "number" ? {
        mainAxis: h,
        crossAxis: 0,
        alignmentAxis: null
    } : {
        mainAxis: h.mainAxis || 0,
        crossAxis: h.crossAxis || 0,
        alignmentAxis: h.alignmentAxis
    };
    return a && typeof w == "number" && (g = a === "end" ? w * -1 : w),
    l ? {
        x: g * d,
        y: p * u
    } : {
        x: p * u,
        y: g * d
    }
}
const yke = function(n) {
    return n === void 0 && (n = 0),
    {
        name: "offset",
        options: n,
        async fn(e) {
            var t, r;
            const {x: s, y: i, placement: o, middlewareData: a} = e
              , l = await gke(e, n);
            return o === ((t = a.offset) == null ? void 0 : t.placement) && (r = a.arrow) != null && r.alignmentOffset ? {} : {
                x: s + l.x,
                y: i + l.y,
                data: {
                    ...l,
                    placement: o
                }
            }
        }
    }
};
function qq(n) {
    const e = Lo(n);
    let t = parseFloat(e.width) || 0
      , r = parseFloat(e.height) || 0;
    const s = sl(n)
      , i = s ? n.offsetWidth : t
      , o = s ? n.offsetHeight : r
      , a = ov(t) !== i || ov(r) !== o;
    return a && (t = i,
    r = o),
    {
        width: t,
        height: r,
        $: a
    }
}
function Ak(n) {
    return Js(n) ? n : n.contextElement
}
function Up(n) {
    const e = Ak(n);
    if (!sl(e))
        return Ja(1);
    const t = e.getBoundingClientRect()
      , {width: r, height: s, $: i} = qq(e);
    let o = (i ? ov(t.width) : t.width) / r
      , a = (i ? ov(t.height) : t.height) / s;
    return (!o || !Number.isFinite(o)) && (o = 1),
    (!a || !Number.isFinite(a)) && (a = 1),
    {
        x: o,
        y: a
    }
}
const bke = Ja(0);
function Gq(n) {
    const e = to(n);
    return !xk() || !e.visualViewport ? bke : {
        x: e.visualViewport.offsetLeft,
        y: e.visualViewport.offsetTop
    }
}
function wke(n, e, t) {
    return e === void 0 && (e = !1),
    !t || e && t !== to(n) ? !1 : e
}
function Uf(n, e, t, r) {
    e === void 0 && (e = !1),
    t === void 0 && (t = !1);
    const s = n.getBoundingClientRect()
      , i = Ak(n);
    let o = Ja(1);
    e && (r ? Js(r) && (o = Up(r)) : o = Up(n));
    const a = wke(i, t, r) ? Gq(i) : Ja(0);
    let l = (s.left + a.x) / o.x
      , u = (s.top + a.y) / o.y
      , d = s.width / o.x
      , h = s.height / o.y;
    if (i) {
        const p = to(i)
          , g = r && Js(r) ? to(r) : r;
        let w = p
          , b = e8(w);
        for (; b && r && g !== w; ) {
            const v = Up(b)
              , S = b.getBoundingClientRect()
              , N = Lo(b)
              , _ = S.left + (b.clientLeft + parseFloat(N.paddingLeft)) * v.x
              , I = S.top + (b.clientTop + parseFloat(N.paddingTop)) * v.y;
            l *= v.x,
            u *= v.y,
            d *= v.x,
            h *= v.y,
            l += _,
            u += I,
            w = to(b),
            b = e8(w)
        }
    }
    return lv({
        width: d,
        height: h,
        x: l,
        y: u
    })
}
function Fx(n, e) {
    const t = jx(n).scrollLeft;
    return e ? e.left + t : Uf(al(n)).left + t
}
function Wq(n, e) {
    const t = n.getBoundingClientRect()
      , r = t.left + e.scrollLeft - Fx(n, t)
      , s = t.top + e.scrollTop;
    return {
        x: r,
        y: s
    }
}
function vke(n) {
    let {elements: e, rect: t, offsetParent: r, strategy: s} = n;
    const i = s === "fixed"
      , o = al(r)
      , a = e ? Px(e.floating) : !1;
    if (r === o || a && i)
        return t;
    let l = {
        scrollLeft: 0,
        scrollTop: 0
    }
      , u = Ja(1);
    const d = Ja(0)
      , h = sl(r);
    if ((h || !h && !i) && ((R0(r) !== "body" || eb(o)) && (l = jx(r)),
    sl(r))) {
        const g = Uf(r);
        u = Up(r),
        d.x = g.x + r.clientLeft,
        d.y = g.y + r.clientTop
    }
    const p = o && !h && !i ? Wq(o, l) : Ja(0);
    return {
        width: t.width * u.x,
        height: t.height * u.y,
        x: t.x * u.x - l.scrollLeft * u.x + d.x + p.x,
        y: t.y * u.y - l.scrollTop * u.y + d.y + p.y
    }
}
function xke(n) {
    return Array.from(n.getClientRects())
}
function Eke(n) {
    const e = al(n)
      , t = jx(n)
      , r = n.ownerDocument.body
      , s = kf(e.scrollWidth, e.clientWidth, r.scrollWidth, r.clientWidth)
      , i = kf(e.scrollHeight, e.clientHeight, r.scrollHeight, r.clientHeight);
    let o = -t.scrollLeft + Fx(n);
    const a = -t.scrollTop;
    return Lo(r).direction === "rtl" && (o += kf(e.clientWidth, r.clientWidth) - s),
    {
        width: s,
        height: i,
        x: o,
        y: a
    }
}
const DP = 25;
function Ske(n, e) {
    const t = to(n)
      , r = al(n)
      , s = t.visualViewport;
    let i = r.clientWidth
      , o = r.clientHeight
      , a = 0
      , l = 0;
    if (s) {
        i = s.width,
        o = s.height;
        const d = xk();
        (!d || d && e === "fixed") && (a = s.offsetLeft,
        l = s.offsetTop)
    }
    const u = Fx(r);
    if (u <= 0) {
        const d = r.ownerDocument
          , h = d.body
          , p = getComputedStyle(h)
          , g = d.compatMode === "CSS1Compat" && parseFloat(p.marginLeft) + parseFloat(p.marginRight) || 0
          , w = Math.abs(r.clientWidth - h.clientWidth - g);
        w <= DP && (i -= w)
    } else
        u <= DP && (i += u);
    return {
        width: i,
        height: o,
        x: a,
        y: l
    }
}
const Ake = new Set(["absolute", "fixed"]);
function Cke(n, e) {
    const t = Uf(n, !0, e === "fixed")
      , r = t.top + n.clientTop
      , s = t.left + n.clientLeft
      , i = sl(n) ? Up(n) : Ja(1)
      , o = n.clientWidth * i.x
      , a = n.clientHeight * i.y
      , l = s * i.x
      , u = r * i.y;
    return {
        width: o,
        height: a,
        x: l,
        y: u
    }
}
function TP(n, e, t) {
    let r;
    if (e === "viewport")
        r = Ske(n, t);
    else if (e === "document")
        r = Eke(al(n));
    else if (Js(e))
        r = Cke(e, t);
    else {
        const s = Gq(n);
        r = {
            x: e.x - s.x,
            y: e.y - s.y,
            width: e.width,
            height: e.height
        }
    }
    return lv(r)
}
function Yq(n, e) {
    const t = sd(n);
    return t === e || !Js(t) || d0(t) ? !1 : Lo(t).position === "fixed" || Yq(t, e)
}
function _ke(n, e) {
    const t = e.get(n);
    if (t)
        return t;
    let r = cy(n, [], !1).filter(a => Js(a) && R0(a) !== "body")
      , s = null;
    const i = Lo(n).position === "fixed";
    let o = i ? sd(n) : n;
    for (; Js(o) && !d0(o); ) {
        const a = Lo(o)
          , l = vk(o);
        !l && a.position === "fixed" && (s = null),
        (i ? !l && !s : !l && a.position === "static" && !!s && Ake.has(s.position) || eb(o) && !l && Yq(n, o)) ? r = r.filter(d => d !== o) : s = a,
        o = sd(o)
    }
    return e.set(n, r),
    r
}
function kke(n) {
    let {element: e, boundary: t, rootBoundary: r, strategy: s} = n;
    const o = [...t === "clippingAncestors" ? Px(e) ? [] : _ke(e, this._c) : [].concat(t), r]
      , a = o[0]
      , l = o.reduce( (u, d) => {
        const h = TP(e, d, s);
        return u.top = kf(h.top, u.top),
        u.right = f0(h.right, u.right),
        u.bottom = f0(h.bottom, u.bottom),
        u.left = kf(h.left, u.left),
        u
    }
    , TP(e, a, s));
    return {
        width: l.right - l.left,
        height: l.bottom - l.top,
        x: l.left,
        y: l.top
    }
}
function Nke(n) {
    const {width: e, height: t} = qq(n);
    return {
        width: e,
        height: t
    }
}
function Dke(n, e, t) {
    const r = sl(e)
      , s = al(e)
      , i = t === "fixed"
      , o = Uf(n, !0, i, e);
    let a = {
        scrollLeft: 0,
        scrollTop: 0
    };
    const l = Ja(0);
    function u() {
        l.x = Fx(s)
    }
    if (r || !r && !i)
        if ((R0(e) !== "body" || eb(s)) && (a = jx(e)),
        r) {
            const g = Uf(e, !0, i, e);
            l.x = g.x + e.clientLeft,
            l.y = g.y + e.clientTop
        } else
            s && u();
    i && !r && s && u();
    const d = s && !r && !i ? Wq(s, a) : Ja(0)
      , h = o.left + a.scrollLeft - l.x - d.x
      , p = o.top + a.scrollTop - l.y - d.y;
    return {
        x: h,
        y: p,
        width: o.width,
        height: o.height
    }
}
function _A(n) {
    return Lo(n).position === "static"
}
function IP(n, e) {
    if (!sl(n) || Lo(n).position === "fixed")
        return null;
    if (e)
        return e(n);
    let t = n.offsetParent;
    return al(n) === t && (t = t.ownerDocument.body),
    t
}
function Kq(n, e) {
    const t = to(n);
    if (Px(n))
        return t;
    if (!sl(n)) {
        let s = sd(n);
        for (; s && !d0(s); ) {
            if (Js(s) && !_A(s))
                return s;
            s = sd(s)
        }
        return t
    }
    let r = IP(n, e);
    for (; r && U_e(r) && _A(r); )
        r = IP(r, e);
    return r && d0(r) && _A(r) && !vk(r) ? t : r || q_e(n) || t
}
const Tke = async function(n) {
    const e = this.getOffsetParent || Kq
      , t = this.getDimensions
      , r = await t(n.floating);
    return {
        reference: Dke(n.reference, await e(n.floating), n.strategy),
        floating: {
            x: 0,
            y: 0,
            width: r.width,
            height: r.height
        }
    }
};
function Ike(n) {
    return Lo(n).direction === "rtl"
}
const Mke = {
    convertOffsetParentRelativeRectToViewportRelativeRect: vke,
    getDocumentElement: al,
    getClippingRect: kke,
    getOffsetParent: Kq,
    getElementRects: Tke,
    getClientRects: xke,
    getDimensions: Nke,
    getScale: Up,
    isElement: Js,
    isRTL: Ike
};
function Xq(n, e) {
    return n.x === e.x && n.y === e.y && n.width === e.width && n.height === e.height
}
function Bke(n, e) {
    let t = null, r;
    const s = al(n);
    function i() {
        var a;
        clearTimeout(r),
        (a = t) == null || a.disconnect(),
        t = null
    }
    function o(a, l) {
        a === void 0 && (a = !1),
        l === void 0 && (l = 1),
        i();
        const u = n.getBoundingClientRect()
          , {left: d, top: h, width: p, height: g} = u;
        if (a || e(),
        !p || !g)
            return;
        const w = lw(h)
          , b = lw(s.clientWidth - (d + p))
          , v = lw(s.clientHeight - (h + g))
          , S = lw(d)
          , _ = {
            rootMargin: -w + "px " + -b + "px " + -v + "px " + -S + "px",
            threshold: kf(0, f0(1, l)) || 1
        };
        let I = !0;
        function k(B) {
            const P = B[0].intersectionRatio;
            if (P !== l) {
                if (!I)
                    return o();
                P ? o(!1, P) : r = setTimeout( () => {
                    o(!1, 1e-7)
                }
                , 1e3)
            }
            P === 1 && !Xq(u, n.getBoundingClientRect()) && o(),
            I = !1
        }
        try {
            t = new IntersectionObserver(k,{
                ..._,
                root: s.ownerDocument
            })
        } catch {
            t = new IntersectionObserver(k,_)
        }
        t.observe(n)
    }
    return o(!0),
    i
}
function Rke(n, e, t, r) {
    r === void 0 && (r = {});
    const {ancestorScroll: s=!0, ancestorResize: i=!0, elementResize: o=typeof ResizeObserver == "function", layoutShift: a=typeof IntersectionObserver == "function", animationFrame: l=!1} = r
      , u = Ak(n)
      , d = s || i ? [...u ? cy(u) : [], ...cy(e)] : [];
    d.forEach(S => {
        s && S.addEventListener("scroll", t, {
            passive: !0
        }),
        i && S.addEventListener("resize", t)
    }
    );
    const h = u && a ? Bke(u, t) : null;
    let p = -1
      , g = null;
    o && (g = new ResizeObserver(S => {
        let[N] = S;
        N && N.target === u && g && (g.unobserve(e),
        cancelAnimationFrame(p),
        p = requestAnimationFrame( () => {
            var _;
            (_ = g) == null || _.observe(e)
        }
        )),
        t()
    }
    ),
    u && !l && g.observe(u),
    g.observe(e));
    let w, b = l ? Uf(n) : null;
    l && v();
    function v() {
        const S = Uf(n);
        b && !Xq(b, S) && t(),
        b = S,
        w = requestAnimationFrame(v)
    }
    return t(),
    () => {
        var S;
        d.forEach(N => {
            s && N.removeEventListener("scroll", t),
            i && N.removeEventListener("resize", t)
        }
        ),
        h?.(),
        (S = g) == null || S.disconnect(),
        g = null,
        l && cancelAnimationFrame(w)
    }
}
const Oke = yke
  , Pke = pke
  , MP = hke
  , jke = (n, e, t) => {
    const r = new Map
      , s = {
        platform: Mke,
        ...t
    }
      , i = {
        ...s.platform,
        _c: r
    };
    return dke(n, e, {
        ...s,
        platform: i
    })
}
;
var Lke = typeof document < "u"
  , Fke = function() {}
  , e2 = Lke ? V.useLayoutEffect : Fke;
function uv(n, e) {
    if (n === e)
        return !0;
    if (typeof n != typeof e)
        return !1;
    if (typeof n == "function" && n.toString() === e.toString())
        return !0;
    let t, r, s;
    if (n && e && typeof n == "object") {
        if (Array.isArray(n)) {
            if (t = n.length,
            t !== e.length)
                return !1;
            for (r = t; r-- !== 0; )
                if (!uv(n[r], e[r]))
                    return !1;
            return !0
        }
        if (s = Object.keys(n),
        t = s.length,
        t !== Object.keys(e).length)
            return !1;
        for (r = t; r-- !== 0; )
            if (!{}.hasOwnProperty.call(e, s[r]))
                return !1;
        for (r = t; r-- !== 0; ) {
            const i = s[r];
            if (!(i === "_owner" && n.$$typeof) && !uv(n[i], e[i]))
                return !1
        }
        return !0
    }
    return n !== n && e !== e
}
function Qq(n) {
    return typeof window > "u" ? 1 : (n.ownerDocument.defaultView || window).devicePixelRatio || 1
}
function BP(n, e) {
    const t = Qq(n);
    return Math.round(e * t) / t
}
function kA(n) {
    const e = V.useRef(n);
    return e2( () => {
        e.current = n
    }
    ),
    e
}
function Uke(n) {
    n === void 0 && (n = {});
    const {placement: e="bottom", strategy: t="absolute", middleware: r=[], platform: s, elements: {reference: i, floating: o}={}, transform: a=!0, whileElementsMounted: l, open: u} = n
      , [d,h] = V.useState({
        x: 0,
        y: 0,
        strategy: t,
        placement: e,
        middlewareData: {},
        isPositioned: !1
    })
      , [p,g] = V.useState(r);
    uv(p, r) || g(r);
    const [w,b] = V.useState(null)
      , [v,S] = V.useState(null)
      , N = V.useCallback(z => {
        z !== B.current && (B.current = z,
        b(z))
    }
    , [])
      , _ = V.useCallback(z => {
        z !== P.current && (P.current = z,
        S(z))
    }
    , [])
      , I = i || w
      , k = o || v
      , B = V.useRef(null)
      , P = V.useRef(null)
      , M = V.useRef(d)
      , R = l != null
      , L = kA(l)
      , q = kA(s)
      , H = kA(u)
      , j = V.useCallback( () => {
        if (!B.current || !P.current)
            return;
        const z = {
            placement: e,
            strategy: t,
            middleware: p
        };
        q.current && (z.platform = q.current),
        jke(B.current, P.current, z).then(G => {
            const Y = {
                ...G,
                isPositioned: H.current !== !1
            };
            A.current && !uv(M.current, Y) && (M.current = Y,
            mL.flushSync( () => {
                h(Y)
            }
            ))
        }
        )
    }
    , [p, e, t, q, H]);
    e2( () => {
        u === !1 && M.current.isPositioned && (M.current.isPositioned = !1,
        h(z => ({
            ...z,
            isPositioned: !1
        })))
    }
    , [u]);
    const A = V.useRef(!1);
    e2( () => (A.current = !0,
    () => {
        A.current = !1
    }
    ), []),
    e2( () => {
        if (I && (B.current = I),
        k && (P.current = k),
        I && k) {
            if (L.current)
                return L.current(I, k, j);
            j()
        }
    }
    , [I, k, j, L, R]);
    const E = V.useMemo( () => ({
        reference: B,
        floating: P,
        setReference: N,
        setFloating: _
    }), [N, _])
      , C = V.useMemo( () => ({
        reference: I,
        floating: k
    }), [I, k])
      , O = V.useMemo( () => {
        const z = {
            position: t,
            left: 0,
            top: 0
        };
        if (!C.floating)
            return z;
        const G = BP(C.floating, d.x)
          , Y = BP(C.floating, d.y);
        return a ? {
            ...z,
            transform: "translate(" + G + "px, " + Y + "px)",
            ...Qq(C.floating) >= 1.5 && {
                willChange: "transform"
            }
        } : {
            position: t,
            left: G,
            top: Y
        }
    }
    , [t, a, C.floating, d.x, d.y]);
    return V.useMemo( () => ({
        ...d,
        update: j,
        refs: E,
        elements: C,
        floatingStyles: O
    }), [d, j, E, C, O])
}
const zke = n => {
    function e(t) {
        return {}.hasOwnProperty.call(t, "current")
    }
    return {
        name: "arrow",
        options: n,
        fn(t) {
            const {element: r, padding: s} = typeof n == "function" ? n(t) : n;
            return r && e(r) ? r.current != null ? MP({
                element: r.current,
                padding: s
            }).fn(t) : {} : r ? MP({
                element: r,
                padding: s
            }).fn(t) : {}
        }
    }
}
  , $ke = (n, e) => ({
    ...Oke(n),
    options: [n, e]
})
  , Hke = (n, e) => ({
    ...Pke(n),
    options: [n, e]
})
  , Vke = (n, e) => ({
    ...zke(n),
    options: [n, e]
})
  , qke = {
    ...X9
};
let RP = !1
  , Gke = 0;
const OP = () => "floating-ui-" + Math.random().toString(36).slice(2, 6) + Gke++;
function Wke() {
    const [n,e] = V.useState( () => RP ? OP() : void 0);
    return cv( () => {
        n == null && e(OP())
    }
    , []),
    V.useEffect( () => {
        RP = !0
    }
    , []),
    n
}
const Yke = qke.useId
  , Zq = Yke || Wke
  , Kke = V.forwardRef(function(e, t) {
    const {context: {placement: r, elements: {floating: s}, middlewareData: {arrow: i, shift: o}}, width: a=14, height: l=7, tipRadius: u=0, strokeWidth: d=0, staticOffset: h, stroke: p, d: g, style: {transform: w, ...b}={}, ...v} = e
      , S = Zq()
      , [N,_] = V.useState(!1);
    if (cv( () => {
        if (!s)
            return;
        Lo(s).direction === "rtl" && _(!0)
    }
    , [s]),
    !s)
        return null;
    const [I,k] = r.split("-")
      , B = I === "top" || I === "bottom";
    let P = h;
    (B && o != null && o.x || !B && o != null && o.y) && (P = null);
    const M = d * 2
      , R = M / 2
      , L = a / 2 * (u / -8 + 1)
      , q = l / 2 * u / 4
      , H = !!g
      , j = P && k === "end" ? "bottom" : "top";
    let A = P && k === "end" ? "right" : "left";
    P && N && (A = k === "end" ? "left" : "right");
    const E = i?.x != null ? P || i.x : ""
      , C = i?.y != null ? P || i.y : ""
      , O = g || "M0,0" + (" H" + a) + (" L" + (a - L) + "," + (l - q)) + (" Q" + a / 2 + "," + l + " " + L + "," + (l - q)) + " Z"
      , z = {
        top: H ? "rotate(180deg)" : "",
        left: H ? "rotate(90deg)" : "rotate(-90deg)",
        bottom: H ? "" : "rotate(180deg)",
        right: H ? "rotate(-90deg)" : "rotate(90deg)"
    }[I];
    return m.jsxs("svg", {
        ...v,
        "aria-hidden": !0,
        ref: t,
        width: H ? a : a + M,
        height: a,
        viewBox: "0 0 " + a + " " + (l > a ? l : a),
        style: {
            position: "absolute",
            pointerEvents: "none",
            [A]: E,
            [j]: C,
            [I]: B || H ? "100%" : "calc(100% - " + M / 2 + "px)",
            transform: [z, w].filter(G => !!G).join(" "),
            ...b
        },
        children: [M > 0 && m.jsx("path", {
            clipPath: "url(#" + S + ")",
            fill: "none",
            stroke: p,
            strokeWidth: M + (g ? 0 : 1),
            d: O
        }), m.jsx("path", {
            stroke: M && !g ? v.fill : "none",
            d: O
        }), m.jsx("clipPath", {
            id: S,
            children: m.jsx("rect", {
                x: -R,
                y: R * (H ? -1 : 1),
                width: a + M,
                height: a
            })
        })]
    })
});
function Xke() {
    const n = new Map;
    return {
        emit(e, t) {
            var r;
            (r = n.get(e)) == null || r.forEach(s => s(t))
        },
        on(e, t) {
            n.has(e) || n.set(e, new Set),
            n.get(e).add(t)
        },
        off(e, t) {
            var r;
            (r = n.get(e)) == null || r.delete(t)
        }
    }
}
const Qke = V.createContext(null)
  , Zke = V.createContext(null)
  , Jke = () => {
    var n;
    return ((n = V.useContext(Qke)) == null ? void 0 : n.id) || null
}
  , e6e = () => V.useContext(Zke);
function t6e(n) {
    const {open: e=!1, onOpenChange: t, elements: r} = n
      , s = Zq()
      , i = V.useRef({})
      , [o] = V.useState( () => Xke())
      , a = Jke() != null
      , [l,u] = V.useState(r.reference)
      , d = uke( (g, w, b) => {
        i.current.openEvent = g ? w : void 0,
        o.emit("openchange", {
            open: g,
            event: w,
            reason: b,
            nested: a
        }),
        t?.(g, w, b)
    }
    )
      , h = V.useMemo( () => ({
        setPositionReference: u
    }), [])
      , p = V.useMemo( () => ({
        reference: l || r.reference || null,
        floating: r.floating || null,
        domReference: r.reference
    }), [l, r.reference, r.floating]);
    return V.useMemo( () => ({
        dataRef: i,
        open: e,
        onOpenChange: d,
        elements: p,
        events: o,
        floatingId: s,
        refs: h
    }), [e, d, p, o, s, h])
}
function n6e(n) {
    n === void 0 && (n = {});
    const {nodeId: e} = n
      , t = t6e({
        ...n,
        elements: {
            reference: null,
            floating: null,
            ...n.elements
        }
    })
      , r = n.rootContext || t
      , s = r.elements
      , [i,o] = V.useState(null)
      , [a,l] = V.useState(null)
      , d = s?.domReference || i
      , h = V.useRef(null)
      , p = e6e();
    cv( () => {
        d && (h.current = d)
    }
    , [d]);
    const g = Uke({
        ...n,
        elements: {
            ...s,
            ...a && {
                reference: a
            }
        }
    })
      , w = V.useCallback(_ => {
        const I = Js(_) ? {
            getBoundingClientRect: () => _.getBoundingClientRect(),
            getClientRects: () => _.getClientRects(),
            contextElement: _
        } : _;
        l(I),
        g.refs.setReference(I)
    }
    , [g.refs])
      , b = V.useCallback(_ => {
        (Js(_) || _ === null) && (h.current = _,
        o(_)),
        (Js(g.refs.reference.current) || g.refs.reference.current === null || _ !== null && !Js(_)) && g.refs.setReference(_)
    }
    , [g.refs])
      , v = V.useMemo( () => ({
        ...g.refs,
        setReference: b,
        setPositionReference: w,
        domReference: h
    }), [g.refs, b, w])
      , S = V.useMemo( () => ({
        ...g.elements,
        domReference: d
    }), [g.elements, d])
      , N = V.useMemo( () => ({
        ...g,
        ...r,
        refs: v,
        elements: S,
        nodeId: e
    }), [g, v, S, e, r]);
    return cv( () => {
        r.dataRef.current.floatingContext = N;
        const _ = p?.nodesRef.current.find(I => I.id === e);
        _ && (_.context = N)
    }
    ),
    V.useMemo( () => ({
        ...g,
        context: N,
        refs: v,
        elements: S
    }), [g, v, S, N])
}
var n8 = function(e, t) {
    return n8 = Object.setPrototypeOf || {
        __proto__: []
    }instanceof Array && function(r, s) {
        r.__proto__ = s
    }
    || function(r, s) {
        for (var i in s)
            Object.prototype.hasOwnProperty.call(s, i) && (r[i] = s[i])
    }
    ,
    n8(e, t)
};
function _s(n, e) {
    if (typeof e != "function" && e !== null)
        throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
    n8(n, e);
    function t() {
        this.constructor = n
    }
    n.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype,
    new t)
}
var Xt = function() {
    return Xt = Object.assign || function(t) {
        for (var r, s = 1, i = arguments.length; s < i; s++) {
            r = arguments[s];
            for (var o in r)
                Object.prototype.hasOwnProperty.call(r, o) && (t[o] = r[o])
        }
        return t
    }
    ,
    Xt.apply(this, arguments)
};
function Ka(n, e, t) {
    if (t || arguments.length === 2)
        for (var r = 0, s = e.length, i; r < s; r++)
            (i || !(r in e)) && (i || (i = Array.prototype.slice.call(e, 0, r)),
            i[r] = e[r]);
    return n.concat(i || Array.prototype.slice.call(e))
}
var r6e = function(n) {
    var e = n.showTimeSelectOnly
      , t = e === void 0 ? !1 : e
      , r = n.showTime
      , s = r === void 0 ? !1 : r
      , i = n.className
      , o = n.children
      , a = t ? "Choose Time" : "Choose Date".concat(s ? " and Time" : "");
    return ye.createElement("div", {
        className: i,
        role: "dialog",
        "aria-label": a,
        "aria-modal": "true"
    }, o)
}, s6e = function(n, e) {
    var t = V.useRef(null)
      , r = V.useRef(n);
    r.current = n;
    var s = V.useCallback(function(i) {
        var o, a = i.composed && i.composedPath && i.composedPath().find(function(l) {
            return l instanceof Node
        }) || i.target;
        t.current && !t.current.contains(a) && (e && a instanceof HTMLElement && a.classList.contains(e) || (o = r.current) === null || o === void 0 || o.call(r, i))
    }, [e]);
    return V.useEffect(function() {
        return document.addEventListener("mousedown", s),
        function() {
            document.removeEventListener("mousedown", s)
        }
    }, [s]),
    t
}, Ux = function(n) {
    var e = n.children
      , t = n.onClickOutside
      , r = n.className
      , s = n.containerRef
      , i = n.style
      , o = n.ignoreClass
      , a = s6e(t, o);
    return ye.createElement("div", {
        className: r,
        style: i,
        ref: function(l) {
            a.current = l,
            s && (s.current = l)
        }
    }, e)
}, Ye;
(function(n) {
    n.ArrowUp = "ArrowUp",
    n.ArrowDown = "ArrowDown",
    n.ArrowLeft = "ArrowLeft",
    n.ArrowRight = "ArrowRight",
    n.PageUp = "PageUp",
    n.PageDown = "PageDown",
    n.Home = "Home",
    n.End = "End",
    n.Enter = "Enter",
    n.Space = " ",
    n.Tab = "Tab",
    n.Escape = "Escape",
    n.Backspace = "Backspace",
    n.X = "x"
}
)(Ye || (Ye = {}));
function Jq() {
    var n = typeof window < "u" ? window : globalThis;
    return n
}
var nb = 12;
function vn(n) {
    if (n == null)
        return new Date;
    var e = typeof n == "string" ? E_e(n) : ht(n);
    return zx(e) ? e : new Date
}
function NA(n, e, t, r, s) {
    s === void 0 && (s = vn());
    for (var i = p0(t) || p0(Ck()), o = Array.isArray(e) ? e : [e], a = 0, l = o; a < l.length; a++) {
        var u = l[a]
          , d = g_e(n, u, s, {
            locale: i
        });
        if (zx(d) && (!r || n === Kn(d, u, t)))
            return d
    }
    return null
}
function zx(n, e) {
    return tv(n) && !Ya(n, new Date("1/1/1800"))
}
function Kn(n, e, t) {
    if (t === "en")
        return EP(n, e, {
            useAdditionalWeekYearTokens: !0,
            useAdditionalDayOfYearTokens: !0
        });
    var r = t ? p0(t) : void 0;
    return t && !r && console.warn('A locale object was not found for the provided string ["'.concat(t, '"].')),
    r = r || p0(Ck()),
    EP(n, e, {
        locale: r,
        useAdditionalWeekYearTokens: !0,
        useAdditionalDayOfYearTokens: !0
    })
}
function Wi(n, e) {
    var t = e.dateFormat
      , r = e.locale
      , s = Array.isArray(t) && t.length > 0 ? t[0] : t;
    return n && Kn(n, s, r) || ""
}
var eG = " - ";
function i6e(n, e, t) {
    if (!n && !e)
        return "";
    var r = n ? Wi(n, t) : ""
      , s = e ? Wi(e, t) : ""
      , i = t.rangeSeparator || eG;
    return "".concat(r).concat(i).concat(s)
}
function o6e(n, e) {
    if (!n?.length)
        return "";
    var t = n[0] ? Wi(n[0], e) : "";
    if (n.length === 1)
        return t;
    if (n.length === 2 && n[1]) {
        var r = Wi(n[1], e);
        return "".concat(t, ", ").concat(r)
    }
    var s = n.length - 1;
    return "".concat(t, " (+").concat(s, ")")
}
function DA(n, e) {
    var t = e.hour
      , r = t === void 0 ? 0 : t
      , s = e.minute
      , i = s === void 0 ? 0 : s
      , o = e.second
      , a = o === void 0 ? 0 : o;
    return Qw(Zw(Jw(n, a), i), r)
}
function a6e(n) {
    return gk(n)
}
function l6e(n, e) {
    return Kn(n, "ddd", e)
}
function t2(n) {
    return Ff(n)
}
function Wu(n, e, t) {
    var r = p0(e || Ck());
    return Rc(n, {
        locale: r,
        weekStartsOn: t
    })
}
function Ec(n) {
    return Iq(n)
}
function xg(n) {
    return Rx(n)
}
function PP(n) {
    return QC(n)
}
function jP() {
    return Ff(vn())
}
function LP(n) {
    return Dq(n)
}
function c6e(n) {
    return ECe(n)
}
function u6e(n) {
    return Tq(n)
}
function $a(n, e) {
    return n && e ? v_e(n, e) : !n && !e
}
function Gs(n, e) {
    return n && e ? b_e(n, e) : !n && !e
}
function dv(n, e) {
    return n && e ? w_e(n, e) : !n && !e
}
function Kt(n, e) {
    return n && e ? vCe(n, e) : !n && !e
}
function yf(n, e) {
    return n && e ? x8e(n, e) : !n && !e
}
function Gd(n, e, t) {
    var r, s = Ff(e), i = Dq(t);
    try {
        r = ly(n, {
            start: s,
            end: i
        })
    } catch {
        r = !1
    }
    return r
}
function Ck() {
    var n = Jq();
    return n.__localeId__
}
function p0(n) {
    if (typeof n == "string") {
        var e = Jq();
        return e.__localeData__ ? e.__localeData__[n] : void 0
    } else
        return n
}
function d6e(n, e, t) {
    return e(Kn(n, "EEEE", t))
}
function f6e(n, e) {
    return Kn(n, "EEEEEE", e)
}
function h6e(n, e) {
    return Kn(n, "EEE", e)
}
function _k(n, e) {
    return Kn(Xi(vn(), n), "LLLL", e)
}
function tG(n, e) {
    return Kn(Xi(vn(), n), "LLL", e)
}
function p6e(n, e) {
    return Kn(up(vn(), n), "QQQ", e)
}
function Mo(n, e) {
    var t = e === void 0 ? {} : e
      , r = t.minDate
      , s = t.maxDate
      , i = t.excludeDates
      , o = t.excludeDateIntervals
      , a = t.includeDates
      , l = t.includeDateIntervals
      , u = t.filterDate
      , d = t.disabled;
    return d ? !0 : rb(n, {
        minDate: r,
        maxDate: s
    }) || i && i.some(function(h) {
        return h instanceof Date ? Kt(n, h) : Kt(n, h.date)
    }) || o && o.some(function(h) {
        var p = h.start
          , g = h.end;
        return ly(n, {
            start: p,
            end: g
        })
    }) || a && !a.some(function(h) {
        return Kt(n, h)
    }) || l && !l.some(function(h) {
        var p = h.start
          , g = h.end;
        return ly(n, {
            start: p,
            end: g
        })
    }) || u && !u(vn(n)) || !1
}
function kk(n, e) {
    var t = e === void 0 ? {} : e
      , r = t.excludeDates
      , s = t.excludeDateIntervals;
    return s && s.length > 0 ? s.some(function(i) {
        var o = i.start
          , a = i.end;
        return ly(n, {
            start: o,
            end: a
        })
    }) : r && r.some(function(i) {
        var o;
        return i instanceof Date ? Kt(n, i) : Kt(n, (o = i.date) !== null && o !== void 0 ? o : new Date)
    }) || !1
}
function nG(n, e) {
    var t = e === void 0 ? {} : e
      , r = t.minDate
      , s = t.maxDate
      , i = t.excludeDates
      , o = t.includeDates
      , a = t.filterDate;
    return rb(n, {
        minDate: r ? Iq(r) : void 0,
        maxDate: s ? Tq(s) : void 0
    }) || i?.some(function(l) {
        return Gs(n, l instanceof Date ? l : l.date)
    }) || o && !o.some(function(l) {
        return Gs(n, l)
    }) || a && !a(vn(n)) || !1
}
function cw(n, e, t, r) {
    var s = Ut(n)
      , i = Fs(n)
      , o = Ut(e)
      , a = Fs(e)
      , l = Ut(r);
    return s === o && s === l ? i <= t && t <= a : s < o ? l === s && i <= t || l === o && a >= t || l < o && l > s : !1
}
function m6e(n, e) {
    var t = e === void 0 ? {} : e
      , r = t.minDate
      , s = t.maxDate
      , i = t.excludeDates
      , o = t.includeDates;
    return rb(n, {
        minDate: r,
        maxDate: s
    }) || i && i.some(function(a) {
        return Gs(a instanceof Date ? a : a.date, n)
    }) || o && !o.some(function(a) {
        return Gs(a, n)
    }) || !1
}
function uw(n, e) {
    var t = e === void 0 ? {} : e
      , r = t.minDate
      , s = t.maxDate
      , i = t.excludeDates
      , o = t.includeDates
      , a = t.filterDate
      , l = t.disabled;
    return l ? !0 : rb(n, {
        minDate: r,
        maxDate: s
    }) || i?.some(function(u) {
        return dv(n, u instanceof Date ? u : u.date)
    }) || o && !o.some(function(u) {
        return dv(n, u)
    }) || a && !a(vn(n)) || !1
}
function dw(n, e, t) {
    if (!e || !t || !tv(e) || !tv(t))
        return !1;
    var r = Ut(e)
      , s = Ut(t);
    return r <= n && s >= n
}
function n2(n, e) {
    var t = e === void 0 ? {} : e
      , r = t.minDate
      , s = t.maxDate
      , i = t.excludeDates
      , o = t.includeDates
      , a = t.filterDate
      , l = t.disabled;
    if (l)
        return !0;
    var u = new Date(n,0,1);
    return rb(u, {
        minDate: r ? Rx(r) : void 0,
        maxDate: s ? Mq(s) : void 0
    }) || i?.some(function(d) {
        return $a(u, d instanceof Date ? d : d.date)
    }) || o && !o.some(function(d) {
        return $a(u, d)
    }) || a && !a(vn(u)) || !1
}
function fw(n, e, t, r) {
    var s = Ut(n)
      , i = Cf(n)
      , o = Ut(e)
      , a = Cf(e)
      , l = Ut(r);
    return s === o && s === l ? i <= t && t <= a : s < o ? l === s && i <= t || l === o && a >= t || l < o && l > s : !1
}
function rb(n, e) {
    var t, r = e === void 0 ? {} : e, s = r.minDate, i = r.maxDate;
    return (t = s && c0(n, s) < 0 || i && c0(n, i) > 0) !== null && t !== void 0 ? t : !1
}
function FP(n, e) {
    return e.some(function(t) {
        return vc(t) === vc(n) && xc(t) === xc(n) && Gu(t) === Gu(n)
    })
}
function UP(n, e) {
    var t = e === void 0 ? {} : e
      , r = t.excludeTimes
      , s = t.includeTimes
      , i = t.filterTime;
    return r && FP(n, r) || s && !FP(n, s) || i && !i(n) || !1
}
function zP(n, e) {
    var t = e.minTime
      , r = e.maxTime;
    if (!t || !r)
        throw new Error("Both minTime and maxTime props required");
    var s = vn();
    s = Qw(s, vc(n)),
    s = Zw(s, xc(n)),
    s = Jw(s, Gu(n));
    var i = vn();
    i = Qw(i, vc(t)),
    i = Zw(i, xc(t)),
    i = Jw(i, Gu(t));
    var o = vn();
    o = Qw(o, vc(r)),
    o = Zw(o, xc(r)),
    o = Jw(o, Gu(r));
    var a;
    try {
        a = !ly(s, {
            start: i,
            end: o
        })
    } catch {
        a = !1
    }
    return a
}
function $P(n, e) {
    var t = e === void 0 ? {} : e
      , r = t.minDate
      , s = t.includeDates
      , i = _f(n, 1);
    return r && nv(r, i) > 0 || s && s.every(function(o) {
        return nv(o, i) > 0
    }) || !1
}
function HP(n, e) {
    var t = e === void 0 ? {} : e
      , r = t.maxDate
      , s = t.includeDates
      , i = ha(n, 1);
    return r && nv(i, r) > 0 || s && s.every(function(o) {
        return nv(i, o) > 0
    }) || !1
}
function g6e(n, e) {
    var t = e === void 0 ? {} : e
      , r = t.minDate
      , s = t.includeDates
      , i = Rx(n)
      , o = zq(i);
    return r && rv(r, o) > 0 || s && s.every(function(a) {
        return rv(a, o) > 0
    }) || !1
}
function y6e(n, e) {
    var t = e === void 0 ? {} : e
      , r = t.maxDate
      , s = t.includeDates
      , i = Mq(n)
      , o = mk(i, 1);
    return r && rv(o, r) > 0 || s && s.every(function(a) {
        return rv(o, a) > 0
    }) || !1
}
function VP(n, e) {
    var t = e === void 0 ? {} : e
      , r = t.minDate
      , s = t.includeDates
      , i = u0(n, 1);
    return r && sv(r, i) > 0 || s && s.every(function(o) {
        return sv(o, i) > 0
    }) || !1
}
function b6e(n, e) {
    var t = e === void 0 ? {} : e
      , r = t.minDate
      , s = t.yearItemNumber
      , i = s === void 0 ? nb : s
      , o = xg(u0(n, i))
      , a = fc(o, i).endPeriod
      , l = r && Ut(r);
    return l && l > a || !1
}
function qP(n, e) {
    var t = e === void 0 ? {} : e
      , r = t.maxDate
      , s = t.includeDates
      , i = bc(n, 1);
    return r && sv(i, r) > 0 || s && s.every(function(o) {
        return sv(i, o) > 0
    }) || !1
}
function w6e(n, e) {
    var t = e === void 0 ? {} : e
      , r = t.maxDate
      , s = t.yearItemNumber
      , i = s === void 0 ? nb : s
      , o = bc(n, i)
      , a = fc(o, i).startPeriod
      , l = r && Ut(r);
    return l && l < a || !1
}
function rG(n) {
    var e = n.minDate
      , t = n.includeDates;
    if (t && e) {
        var r = t.filter(function(s) {
            return c0(s, e) >= 0
        });
        return gP(r)
    } else
        return t ? gP(t) : e
}
function sG(n) {
    var e = n.maxDate
      , t = n.includeDates;
    if (t && e) {
        var r = t.filter(function(s) {
            return c0(s, e) <= 0
        });
        return mP(r)
    } else
        return t ? mP(t) : e
}
function GP(n, e) {
    var t;
    n === void 0 && (n = []),
    e === void 0 && (e = "react-datepicker__day--highlighted");
    for (var r = new Map, s = 0, i = n.length; s < i; s++) {
        var o = n[s];
        if (wc(o)) {
            var a = Kn(o, "MM.dd.yyyy")
              , l = r.get(a) || [];
            l.includes(e) || (l.push(e),
            r.set(a, l))
        } else if (typeof o == "object") {
            var u = Object.keys(o)
              , d = (t = u[0]) !== null && t !== void 0 ? t : ""
              , h = o[d];
            if (typeof d == "string" && Array.isArray(h))
                for (var p = 0, g = h.length; p < g; p++) {
                    var w = h[p];
                    if (w) {
                        var a = Kn(w, "MM.dd.yyyy")
                          , l = r.get(a) || [];
                        l.includes(d) || (l.push(d),
                        r.set(a, l))
                    }
                }
        }
    }
    return r
}
function v6e(n, e) {
    return n.length !== e.length ? !1 : n.every(function(t, r) {
        return t === e[r]
    })
}
function x6e(n, e) {
    n === void 0 && (n = []),
    e === void 0 && (e = "react-datepicker__day--holidays");
    var t = new Map;
    return n.forEach(function(r) {
        var s = r.date
          , i = r.holidayName;
        if (wc(s)) {
            var o = Kn(s, "MM.dd.yyyy")
              , a = t.get(o) || {
                className: "",
                holidayNames: []
            };
            if (!("className"in a && a.className === e && v6e(a.holidayNames, [i]))) {
                a.className = e;
                var l = a.holidayNames;
                a.holidayNames = l ? Ka(Ka([], l, !0), [i], !1) : [i],
                t.set(o, a)
            }
        }
    }),
    t
}
function E6e(n, e, t, r, s) {
    for (var i = s.length, o = [], a = 0; a < i; a++) {
        var l = n
          , u = s[a];
        u && (l = gCe(l, vc(u)),
        l = XC(l, xc(u)),
        l = wCe(l, Gu(u)));
        var d = XC(n, (t + 1) * r);
        rd(l, e) && Ya(l, d) && u != null && o.push(u)
    }
    return o
}
function WP(n) {
    return n < 10 ? "0".concat(n) : "".concat(n)
}
function fc(n, e) {
    e === void 0 && (e = nb);
    var t = Math.ceil(Ut(n) / e) * e
      , r = t - (e - 1);
    return {
        startPeriod: r,
        endPeriod: t
    }
}
function S6e(n) {
    var e = new Date(n.getFullYear(),n.getMonth(),n.getDate())
      , t = new Date(n.getFullYear(),n.getMonth(),n.getDate(),24);
    return Math.round((+t - +e) / 36e5)
}
function YP(n) {
    var e = n.getSeconds()
      , t = n.getMilliseconds();
    return ht(n.getTime() - e * 1e3 - t)
}
function A6e(n, e) {
    return YP(n).getTime() === YP(e).getTime()
}
function KP(n) {
    if (!wc(n))
        throw new Error("Invalid date");
    var e = new Date(n);
    return e.setHours(0, 0, 0, 0),
    e
}
function TA(n, e) {
    if (!wc(n) || !wc(e))
        throw new Error("Invalid date received");
    var t = KP(n)
      , r = KP(e);
    return Ya(t, r)
}
function iG(n) {
    return n.key === Ye.Space
}
var C6e = (function(n) {
    _s(e, n);
    function e(t) {
        var r = n.call(this, t) || this;
        return r.inputRef = ye.createRef(),
        r.onTimeChange = function(s) {
            var i, o;
            r.setState({
                time: s
            });
            var a = r.props.date
              , l = a instanceof Date && !isNaN(+a)
              , u = l ? a : new Date;
            if (s?.includes(":")) {
                var d = s.split(":")
                  , h = d[0]
                  , p = d[1];
                u.setHours(Number(h)),
                u.setMinutes(Number(p))
            }
            (o = (i = r.props).onChange) === null || o === void 0 || o.call(i, u)
        }
        ,
        r.renderTimeInput = function() {
            var s = r.state.time
              , i = r.props
              , o = i.date
              , a = i.timeString
              , l = i.customTimeInput;
            return l ? V.cloneElement(l, {
                date: o,
                value: s,
                onChange: r.onTimeChange
            }) : ye.createElement("input", {
                type: "time",
                className: "react-datepicker-time__input",
                placeholder: "Time",
                name: "time-input",
                ref: r.inputRef,
                onClick: function() {
                    var u;
                    (u = r.inputRef.current) === null || u === void 0 || u.focus()
                },
                required: !0,
                value: s,
                onChange: function(u) {
                    r.onTimeChange(u.target.value || a)
                }
            })
        }
        ,
        r.state = {
            time: r.props.timeString
        },
        r
    }
    return e.getDerivedStateFromProps = function(t, r) {
        return t.timeString !== r.time ? {
            time: t.timeString
        } : null
    }
    ,
    e.prototype.render = function() {
        return ye.createElement("div", {
            className: "react-datepicker__input-time-container"
        }, ye.createElement("div", {
            className: "react-datepicker-time__caption"
        }, this.props.timeInputLabel), ye.createElement("div", {
            className: "react-datepicker-time__input-container"
        }, ye.createElement("div", {
            className: "react-datepicker-time__input"
        }, this.renderTimeInput())))
    }
    ,
    e
}
)(V.Component), _6e = (function(n) {
    _s(e, n);
    function e() {
        var t = n !== null && n.apply(this, arguments) || this;
        return t.dayEl = V.createRef(),
        t.handleClick = function(r) {
            !t.isDisabled() && t.props.onClick && t.props.onClick(r)
        }
        ,
        t.handleMouseEnter = function(r) {
            !t.isDisabled() && t.props.onMouseEnter && t.props.onMouseEnter(r)
        }
        ,
        t.handleOnKeyDown = function(r) {
            var s, i, o = r.key;
            o === Ye.Space && (r.preventDefault(),
            r.key = Ye.Enter),
            (i = (s = t.props).handleOnKeyDown) === null || i === void 0 || i.call(s, r)
        }
        ,
        t.isSameDay = function(r) {
            return Kt(t.props.day, r)
        }
        ,
        t.isKeyboardSelected = function() {
            var r;
            if (t.props.disabledKeyboardNavigation)
                return !1;
            var s = t.props.selectsMultiple ? (r = t.props.selectedDates) === null || r === void 0 ? void 0 : r.some(function(o) {
                return t.isSameDayOrWeek(o)
            }) : t.isSameDayOrWeek(t.props.selected)
              , i = t.props.preSelection && t.isDisabled(t.props.preSelection);
            return !s && t.isSameDayOrWeek(t.props.preSelection) && !i
        }
        ,
        t.isDisabled = function(r) {
            return r === void 0 && (r = t.props.day),
            Mo(r, {
                minDate: t.props.minDate,
                maxDate: t.props.maxDate,
                excludeDates: t.props.excludeDates,
                excludeDateIntervals: t.props.excludeDateIntervals,
                includeDateIntervals: t.props.includeDateIntervals,
                includeDates: t.props.includeDates,
                filterDate: t.props.filterDate,
                disabled: t.props.disabled
            })
        }
        ,
        t.isExcluded = function() {
            return kk(t.props.day, {
                excludeDates: t.props.excludeDates,
                excludeDateIntervals: t.props.excludeDateIntervals
            })
        }
        ,
        t.isStartOfWeek = function() {
            return Kt(t.props.day, Wu(t.props.day, t.props.locale, t.props.calendarStartDay))
        }
        ,
        t.isSameWeek = function(r) {
            return t.props.showWeekPicker && Kt(r, Wu(t.props.day, t.props.locale, t.props.calendarStartDay))
        }
        ,
        t.isSameDayOrWeek = function(r) {
            return t.isSameDay(r) || t.isSameWeek(r)
        }
        ,
        t.getHighLightedClass = function() {
            var r = t.props
              , s = r.day
              , i = r.highlightDates;
            if (!i)
                return !1;
            var o = Kn(s, "MM.dd.yyyy");
            return i.get(o)
        }
        ,
        t.getHolidaysClass = function() {
            var r, s = t.props, i = s.day, o = s.holidays;
            if (!o)
                return [void 0];
            var a = Kn(i, "MM.dd.yyyy");
            return o.has(a) ? [(r = o.get(a)) === null || r === void 0 ? void 0 : r.className] : [void 0]
        }
        ,
        t.isInRange = function() {
            var r = t.props
              , s = r.day
              , i = r.startDate
              , o = r.endDate;
            return !i || !o ? !1 : Gd(s, i, o)
        }
        ,
        t.isInSelectingRange = function() {
            var r, s = t.props, i = s.day, o = s.selectsStart, a = s.selectsEnd, l = s.selectsRange, u = s.selectsDisabledDaysInRange, d = s.startDate, h = s.swapRange, p = s.endDate, g = (r = t.props.selectingDate) !== null && r !== void 0 ? r : t.props.preSelection;
            if (!(o || a || l) || !g || !u && t.isDisabled())
                return !1;
            if (o && p && (Ya(g, p) || yf(g, p)))
                return Gd(i, g, p);
            if (a && d && (rd(g, d) || yf(g, d)))
                return Gd(i, d, g);
            if (l && d && !p) {
                if (yf(g, d) || rd(g, d))
                    return Gd(i, d, g);
                if (h && Ya(g, d))
                    return Gd(i, g, d)
            }
            return !1
        }
        ,
        t.isSelectingRangeStart = function() {
            var r;
            if (!t.isInSelectingRange())
                return !1;
            var s = t.props
              , i = s.day
              , o = s.startDate
              , a = s.selectsStart
              , l = s.swapRange
              , u = s.selectsRange
              , d = (r = t.props.selectingDate) !== null && r !== void 0 ? r : t.props.preSelection;
            return a ? Kt(i, d) : u && l && o && d ? Kt(i, Ya(d, o) ? d : o) : Kt(i, o)
        }
        ,
        t.isSelectingRangeEnd = function() {
            var r;
            if (!t.isInSelectingRange())
                return !1;
            var s = t.props
              , i = s.day
              , o = s.endDate
              , a = s.selectsEnd
              , l = s.selectsRange
              , u = s.swapRange
              , d = s.startDate
              , h = (r = t.props.selectingDate) !== null && r !== void 0 ? r : t.props.preSelection;
            return a ? Kt(i, h) : l && u && d && h ? Kt(i, Ya(h, d) ? d : h) : l ? Kt(i, h) : Kt(i, o)
        }
        ,
        t.isRangeStart = function() {
            var r = t.props
              , s = r.day
              , i = r.startDate
              , o = r.endDate;
            return !i || !o ? !1 : Kt(i, s)
        }
        ,
        t.isRangeEnd = function() {
            var r = t.props
              , s = r.day
              , i = r.startDate
              , o = r.endDate;
            return !i || !o ? !1 : Kt(o, s)
        }
        ,
        t.isWeekend = function() {
            var r = y8e(t.props.day);
            return r === 0 || r === 6
        }
        ,
        t.isAfterMonth = function() {
            return t.props.month !== void 0 && (t.props.month + 1) % 12 === Fs(t.props.day)
        }
        ,
        t.isBeforeMonth = function() {
            return t.props.month !== void 0 && (Fs(t.props.day) + 1) % 12 === t.props.month
        }
        ,
        t.isCurrentDay = function() {
            return t.isSameDay(vn())
        }
        ,
        t.isSelected = function() {
            var r;
            return t.props.selectsMultiple ? (r = t.props.selectedDates) === null || r === void 0 ? void 0 : r.some(function(s) {
                return t.isSameDayOrWeek(s)
            }) : t.isSameDayOrWeek(t.props.selected)
        }
        ,
        t.getClassNames = function(r) {
            var s = t.props.dayClassName ? t.props.dayClassName(r) : void 0;
            return Jn("react-datepicker__day", s, "react-datepicker__day--" + l6e(t.props.day), {
                "react-datepicker__day--disabled": t.isDisabled(),
                "react-datepicker__day--excluded": t.isExcluded(),
                "react-datepicker__day--selected": t.isSelected(),
                "react-datepicker__day--keyboard-selected": t.isKeyboardSelected(),
                "react-datepicker__day--range-start": t.isRangeStart(),
                "react-datepicker__day--range-end": t.isRangeEnd(),
                "react-datepicker__day--in-range": t.isInRange(),
                "react-datepicker__day--in-selecting-range": t.isInSelectingRange(),
                "react-datepicker__day--selecting-range-start": t.isSelectingRangeStart(),
                "react-datepicker__day--selecting-range-end": t.isSelectingRangeEnd(),
                "react-datepicker__day--today": t.isCurrentDay(),
                "react-datepicker__day--weekend": t.isWeekend(),
                "react-datepicker__day--outside-month": t.isAfterMonth() || t.isBeforeMonth()
            }, t.getHighLightedClass(), t.getHolidaysClass())
        }
        ,
        t.getAriaLabel = function() {
            var r = t.props
              , s = r.day
              , i = r.ariaLabelPrefixWhenEnabled
              , o = i === void 0 ? "Choose" : i
              , a = r.ariaLabelPrefixWhenDisabled
              , l = a === void 0 ? "Not available" : a
              , u = t.isDisabled() || t.isExcluded() ? l : o;
            return "".concat(u, " ").concat(Kn(s, "PPPP", t.props.locale))
        }
        ,
        t.getTitle = function() {
            var r = t.props
              , s = r.day
              , i = r.holidays
              , o = i === void 0 ? new Map : i
              , a = r.excludeDates
              , l = Kn(s, "MM.dd.yyyy")
              , u = [];
            return o.has(l) && u.push.apply(u, o.get(l).holidayNames),
            t.isExcluded() && u.push(a?.filter(function(d) {
                return d instanceof Date ? Kt(d, s) : Kt(d?.date, s)
            }).map(function(d) {
                if (!(d instanceof Date))
                    return d?.message
            })),
            u.join(", ")
        }
        ,
        t.getTabIndex = function() {
            var r = t.props.selected
              , s = t.props.preSelection
              , i = !(t.props.showWeekPicker && (t.props.showWeekNumber || !t.isStartOfWeek())) && (t.isKeyboardSelected() || t.isSameDay(r) && Kt(s, r)) ? 0 : -1;
            return i
        }
        ,
        t.handleFocusDay = function() {
            var r;
            t.shouldFocusDay() && ((r = t.dayEl.current) === null || r === void 0 || r.focus({
                preventScroll: !0
            }))
        }
        ,
        t.renderDayContents = function() {
            return t.props.monthShowsDuplicateDaysEnd && t.isAfterMonth() || t.props.monthShowsDuplicateDaysStart && t.isBeforeMonth() ? null : t.props.renderDayContents ? t.props.renderDayContents(SP(t.props.day), t.props.day) : SP(t.props.day)
        }
        ,
        t.render = function() {
            return ye.createElement("div", {
                ref: t.dayEl,
                className: t.getClassNames(t.props.day),
                onKeyDown: t.handleOnKeyDown,
                onClick: t.handleClick,
                onMouseEnter: t.props.usePointerEvent ? void 0 : t.handleMouseEnter,
                onPointerEnter: t.props.usePointerEvent ? t.handleMouseEnter : void 0,
                tabIndex: t.getTabIndex(),
                "aria-label": t.getAriaLabel(),
                role: "gridcell",
                title: t.getTitle(),
                "aria-disabled": t.isDisabled(),
                "aria-current": t.isCurrentDay() ? "date" : void 0,
                "aria-selected": t.isSelected() || t.isInRange()
            }, t.renderDayContents(), t.getTitle() !== "" && ye.createElement("span", {
                className: "overlay"
            }, t.getTitle()))
        }
        ,
        t
    }
    return e.prototype.componentDidMount = function() {
        this.handleFocusDay()
    }
    ,
    e.prototype.componentDidUpdate = function() {
        this.handleFocusDay()
    }
    ,
    e.prototype.shouldFocusDay = function() {
        var t = !1;
        return this.getTabIndex() === 0 && this.isSameDay(this.props.preSelection) && ((!document.activeElement || document.activeElement === document.body) && (t = !0),
        this.props.inline && !this.props.shouldFocusDayInline && (t = !1),
        this.isDayActiveElement() && (t = !0),
        this.isDuplicateDay() && (t = !1)),
        t
    }
    ,
    e.prototype.isDayActiveElement = function() {
        var t, r, s;
        return ((r = (t = this.props.containerRef) === null || t === void 0 ? void 0 : t.current) === null || r === void 0 ? void 0 : r.contains(document.activeElement)) && ((s = document.activeElement) === null || s === void 0 ? void 0 : s.classList.contains("react-datepicker__day"))
    }
    ,
    e.prototype.isDuplicateDay = function() {
        return this.props.monthShowsDuplicateDaysEnd && this.isAfterMonth() || this.props.monthShowsDuplicateDaysStart && this.isBeforeMonth()
    }
    ,
    e
}
)(V.Component), k6e = (function(n) {
    _s(e, n);
    function e() {
        var t = n !== null && n.apply(this, arguments) || this;
        return t.weekNumberEl = V.createRef(),
        t.handleClick = function(r) {
            t.props.onClick && t.props.onClick(r)
        }
        ,
        t.handleOnKeyDown = function(r) {
            var s, i, o = r.key;
            o === Ye.Space && (r.preventDefault(),
            r.key = Ye.Enter),
            (i = (s = t.props).handleOnKeyDown) === null || i === void 0 || i.call(s, r)
        }
        ,
        t.isKeyboardSelected = function() {
            return !t.props.disabledKeyboardNavigation && !Kt(t.props.date, t.props.selected) && Kt(t.props.date, t.props.preSelection)
        }
        ,
        t.getTabIndex = function() {
            return t.props.showWeekPicker && t.props.showWeekNumber && (t.isKeyboardSelected() || Kt(t.props.date, t.props.selected) && Kt(t.props.preSelection, t.props.selected)) ? 0 : -1
        }
        ,
        t.handleFocusWeekNumber = function(r) {
            var s = !1;
            t.getTabIndex() === 0 && !r?.isInputFocused && Kt(t.props.date, t.props.preSelection) && ((!document.activeElement || document.activeElement === document.body) && (s = !0),
            t.props.inline && !t.props.shouldFocusDayInline && (s = !1),
            t.props.containerRef && t.props.containerRef.current && t.props.containerRef.current.contains(document.activeElement) && document.activeElement && document.activeElement.classList.contains("react-datepicker__week-number") && (s = !0)),
            s && t.weekNumberEl.current && t.weekNumberEl.current.focus({
                preventScroll: !0
            })
        }
        ,
        t
    }
    return Object.defineProperty(e, "defaultProps", {
        get: function() {
            return {
                ariaLabelPrefix: "week "
            }
        },
        enumerable: !1,
        configurable: !0
    }),
    e.prototype.componentDidMount = function() {
        this.handleFocusWeekNumber()
    }
    ,
    e.prototype.componentDidUpdate = function(t) {
        this.handleFocusWeekNumber(t)
    }
    ,
    e.prototype.render = function() {
        var t = this.props
          , r = t.weekNumber
          , s = t.isWeekDisabled
          , i = t.ariaLabelPrefix
          , o = i === void 0 ? e.defaultProps.ariaLabelPrefix : i
          , a = t.onClick
          , l = {
            "react-datepicker__week-number": !0,
            "react-datepicker__week-number--clickable": !!a && !s,
            "react-datepicker__week-number--selected": !!a && Kt(this.props.date, this.props.selected)
        };
        return ye.createElement("div", {
            ref: this.weekNumberEl,
            className: Jn(l),
            "aria-label": "".concat(o, " ").concat(this.props.weekNumber),
            onClick: this.handleClick,
            onKeyDown: this.handleOnKeyDown,
            tabIndex: this.getTabIndex(),
            role: "gridcell"
        }, r)
    }
    ,
    e
}
)(V.Component), N6e = (function(n) {
    _s(e, n);
    function e() {
        var t = n !== null && n.apply(this, arguments) || this;
        return t.isDisabled = function(r) {
            return Mo(r, {
                minDate: t.props.minDate,
                maxDate: t.props.maxDate,
                excludeDates: t.props.excludeDates,
                excludeDateIntervals: t.props.excludeDateIntervals,
                includeDateIntervals: t.props.includeDateIntervals,
                includeDates: t.props.includeDates,
                filterDate: t.props.filterDate
            })
        }
        ,
        t.handleDayClick = function(r, s) {
            t.props.onDayClick && t.props.onDayClick(r, s)
        }
        ,
        t.handleDayMouseEnter = function(r) {
            t.props.onDayMouseEnter && t.props.onDayMouseEnter(r)
        }
        ,
        t.handleWeekClick = function(r, s, i) {
            for (var o, a, l, u = new Date(r), d = 0; d < 7; d++) {
                var h = new Date(r);
                h.setDate(h.getDate() + d);
                var p = !t.isDisabled(h);
                if (p) {
                    u = h;
                    break
                }
            }
            typeof t.props.onWeekSelect == "function" && t.props.onWeekSelect(u, s, i),
            t.props.showWeekPicker && t.handleDayClick(u, i),
            ((o = t.props.shouldCloseOnSelect) !== null && o !== void 0 ? o : e.defaultProps.shouldCloseOnSelect) && ((l = (a = t.props).setOpen) === null || l === void 0 || l.call(a, !1))
        }
        ,
        t.formatWeekNumber = function(r) {
            return t.props.formatWeekNumber ? t.props.formatWeekNumber(r) : a6e(r)
        }
        ,
        t.isWeekDisabled = function() {
            for (var r = t.startOfWeek(), s = ca(r, 6), i = new Date(r); i <= s; ) {
                if (!t.isDisabled(i))
                    return !1;
                i = ca(i, 1)
            }
            return !0
        }
        ,
        t.renderDays = function() {
            var r = t.startOfWeek()
              , s = []
              , i = t.formatWeekNumber(r);
            if (t.props.showWeekNumber) {
                var o = t.props.onWeekSelect || t.props.showWeekPicker ? t.handleWeekClick.bind(t, r, i) : void 0;
                s.push(ye.createElement(k6e, Xt({
                    key: "W"
                }, e.defaultProps, t.props, {
                    weekNumber: i,
                    isWeekDisabled: t.isWeekDisabled(),
                    date: r,
                    onClick: o
                })))
            }
            return s.concat([0, 1, 2, 3, 4, 5, 6].map(function(a) {
                var l = ca(r, a);
                return ye.createElement(_6e, Xt({}, e.defaultProps, t.props, {
                    ariaLabelPrefixWhenEnabled: t.props.chooseDayAriaLabelPrefix,
                    ariaLabelPrefixWhenDisabled: t.props.disabledDayAriaLabelPrefix,
                    key: l.valueOf(),
                    day: l,
                    onClick: t.handleDayClick.bind(t, l),
                    onMouseEnter: t.handleDayMouseEnter.bind(t, l)
                }))
            }))
        }
        ,
        t.startOfWeek = function() {
            return Wu(t.props.day, t.props.locale, t.props.calendarStartDay)
        }
        ,
        t.isKeyboardSelected = function() {
            return !t.props.disabledKeyboardNavigation && !Kt(t.startOfWeek(), t.props.selected) && Kt(t.startOfWeek(), t.props.preSelection)
        }
        ,
        t
    }
    return Object.defineProperty(e, "defaultProps", {
        get: function() {
            return {
                shouldCloseOnSelect: !0
            }
        },
        enumerable: !1,
        configurable: !0
    }),
    e.prototype.render = function() {
        var t = {
            "react-datepicker__week": !0,
            "react-datepicker__week--selected": Kt(this.startOfWeek(), this.props.selected),
            "react-datepicker__week--keyboard-selected": this.isKeyboardSelected()
        }
          , r = this.props.weekClassName ? this.props.weekClassName(this.startOfWeek()) : void 0;
        return ye.createElement("div", {
            className: Jn(t, r),
            role: "row"
        }, this.renderDays())
    }
    ,
    e
}
)(V.Component), og, D6e = 6, zp = {
    TWO_COLUMNS: "two_columns",
    THREE_COLUMNS: "three_columns",
    FOUR_COLUMNS: "four_columns"
}, IA = (og = {},
og[zp.TWO_COLUMNS] = {
    grid: [[0, 1], [2, 3], [4, 5], [6, 7], [8, 9], [10, 11]],
    verticalNavigationOffset: 2
},
og[zp.THREE_COLUMNS] = {
    grid: [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10, 11]],
    verticalNavigationOffset: 3
},
og[zp.FOUR_COLUMNS] = {
    grid: [[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]],
    verticalNavigationOffset: 4
},
og), hw = 1;
function XP(n, e) {
    return n ? zp.FOUR_COLUMNS : e ? zp.TWO_COLUMNS : zp.THREE_COLUMNS
}
var T6e = (function(n) {
    _s(e, n);
    function e() {
        var t = n !== null && n.apply(this, arguments) || this;
        return t.MONTH_REFS = Ka([], Array(12), !0).map(function() {
            return V.createRef()
        }),
        t.QUARTER_REFS = Ka([], Array(4), !0).map(function() {
            return V.createRef()
        }),
        t.isDisabled = function(r) {
            return Mo(r, {
                minDate: t.props.minDate,
                maxDate: t.props.maxDate,
                excludeDates: t.props.excludeDates,
                excludeDateIntervals: t.props.excludeDateIntervals,
                includeDateIntervals: t.props.includeDateIntervals,
                includeDates: t.props.includeDates,
                filterDate: t.props.filterDate,
                disabled: t.props.disabled
            })
        }
        ,
        t.isExcluded = function(r) {
            return kk(r, {
                excludeDates: t.props.excludeDates,
                excludeDateIntervals: t.props.excludeDateIntervals
            })
        }
        ,
        t.handleDayClick = function(r, s) {
            var i, o;
            (o = (i = t.props).onDayClick) === null || o === void 0 || o.call(i, r, s, t.props.orderInDisplay)
        }
        ,
        t.handleDayMouseEnter = function(r) {
            var s, i;
            (i = (s = t.props).onDayMouseEnter) === null || i === void 0 || i.call(s, r)
        }
        ,
        t.handleMouseLeave = function() {
            var r, s;
            (s = (r = t.props).onMouseLeave) === null || s === void 0 || s.call(r)
        }
        ,
        t.isRangeStartMonth = function(r) {
            var s = t.props
              , i = s.day
              , o = s.startDate
              , a = s.endDate;
            return !o || !a ? !1 : Gs(Xi(i, r), o)
        }
        ,
        t.isRangeStartQuarter = function(r) {
            var s = t.props
              , i = s.day
              , o = s.startDate
              , a = s.endDate;
            return !o || !a ? !1 : dv(up(i, r), o)
        }
        ,
        t.isRangeEndMonth = function(r) {
            var s = t.props
              , i = s.day
              , o = s.startDate
              , a = s.endDate;
            return !o || !a ? !1 : Gs(Xi(i, r), a)
        }
        ,
        t.isRangeEndQuarter = function(r) {
            var s = t.props
              , i = s.day
              , o = s.startDate
              , a = s.endDate;
            return !o || !a ? !1 : dv(up(i, r), a)
        }
        ,
        t.isInSelectingRangeMonth = function(r) {
            var s, i = t.props, o = i.day, a = i.selectsStart, l = i.selectsEnd, u = i.selectsRange, d = i.startDate, h = i.endDate, p = (s = t.props.selectingDate) !== null && s !== void 0 ? s : t.props.preSelection;
            return !(a || l || u) || !p ? !1 : a && h ? cw(p, h, r, o) : l && d || u && d && !h ? cw(d, p, r, o) : !1
        }
        ,
        t.isSelectingMonthRangeStart = function(r) {
            var s;
            if (!t.isInSelectingRangeMonth(r))
                return !1;
            var i = t.props
              , o = i.day
              , a = i.startDate
              , l = i.selectsStart
              , u = Xi(o, r)
              , d = (s = t.props.selectingDate) !== null && s !== void 0 ? s : t.props.preSelection;
            return l ? Gs(u, d) : Gs(u, a)
        }
        ,
        t.isSelectingMonthRangeEnd = function(r) {
            var s;
            if (!t.isInSelectingRangeMonth(r))
                return !1;
            var i = t.props
              , o = i.day
              , a = i.endDate
              , l = i.selectsEnd
              , u = i.selectsRange
              , d = Xi(o, r)
              , h = (s = t.props.selectingDate) !== null && s !== void 0 ? s : t.props.preSelection;
            return l || u ? Gs(d, h) : Gs(d, a)
        }
        ,
        t.isInSelectingRangeQuarter = function(r) {
            var s, i = t.props, o = i.day, a = i.selectsStart, l = i.selectsEnd, u = i.selectsRange, d = i.startDate, h = i.endDate, p = (s = t.props.selectingDate) !== null && s !== void 0 ? s : t.props.preSelection;
            return !(a || l || u) || !p ? !1 : a && h ? fw(p, h, r, o) : l && d || u && d && !h ? fw(d, p, r, o) : !1
        }
        ,
        t.isWeekInMonth = function(r) {
            var s = t.props.day
              , i = ca(r, 6);
            return Gs(r, s) || Gs(i, s)
        }
        ,
        t.isCurrentMonth = function(r, s) {
            return Ut(r) === Ut(vn()) && s === Fs(vn())
        }
        ,
        t.isCurrentQuarter = function(r, s) {
            return Ut(r) === Ut(vn()) && s === Cf(vn())
        }
        ,
        t.isSelectedMonth = function(r, s, i) {
            return Fs(i) === s && Ut(r) === Ut(i)
        }
        ,
        t.isSelectMonthInList = function(r, s, i) {
            return i.some(function(o) {
                return t.isSelectedMonth(r, s, o)
            })
        }
        ,
        t.isSelectedQuarter = function(r, s, i) {
            return Cf(r) === s && Ut(r) === Ut(i)
        }
        ,
        t.isMonthSelected = function() {
            var r = t.props
              , s = r.day
              , i = r.selected
              , o = r.selectedDates
              , a = r.selectsMultiple
              , l = Fs(s);
            return a ? o?.some(function(u) {
                return t.isSelectedMonth(s, l, u)
            }) : !!i && t.isSelectedMonth(s, l, i)
        }
        ,
        t.renderWeeks = function() {
            for (var r = [], s = t.props.fixedHeight, i = 0, o = !1, a = Wu(Ec(t.props.day), t.props.locale, t.props.calendarStartDay), l = function(w) {
                return t.props.showWeekPicker ? Wu(w, t.props.locale, t.props.calendarStartDay) : t.props.preSelection
            }, u = function(w) {
                return t.props.showWeekPicker ? Wu(w, t.props.locale, t.props.calendarStartDay) : t.props.selected
            }, d = t.props.selected ? u(t.props.selected) : void 0, h = t.props.preSelection ? l(t.props.preSelection) : void 0; r.push(ye.createElement(N6e, Xt({}, t.props, {
                ariaLabelPrefix: t.props.weekAriaLabelPrefix,
                key: i,
                day: a,
                month: Fs(t.props.day),
                onDayClick: t.handleDayClick,
                onDayMouseEnter: t.handleDayMouseEnter,
                selected: d,
                preSelection: h,
                showWeekNumber: t.props.showWeekNumbers
            }))),
            !o; ) {
                i++,
                a = ev(a, 1);
                var p = s && i >= D6e
                  , g = !s && !t.isWeekInMonth(a);
                if (p || g)
                    if (t.props.peekNextMonth)
                        o = !0;
                    else
                        break
            }
            return r
        }
        ,
        t.onMonthClick = function(r, s) {
            var i = t.isMonthDisabledForLabelDate(s)
              , o = i.isDisabled
              , a = i.labelDate;
            o || t.handleDayClick(Ec(a), r)
        }
        ,
        t.onMonthMouseEnter = function(r) {
            var s = t.isMonthDisabledForLabelDate(r)
              , i = s.isDisabled
              , o = s.labelDate;
            i || t.handleDayMouseEnter(Ec(o))
        }
        ,
        t.handleMonthNavigation = function(r, s) {
            var i, o, a, l;
            (o = (i = t.props).setPreSelection) === null || o === void 0 || o.call(i, s),
            (l = (a = t.MONTH_REFS[r]) === null || a === void 0 ? void 0 : a.current) === null || l === void 0 || l.focus()
        }
        ,
        t.handleKeyboardNavigation = function(r, s, i) {
            var o, a = t.props, l = a.selected, u = a.preSelection, d = a.setPreSelection, h = a.minDate, p = a.maxDate, g = a.showFourColumnMonthYearPicker, w = a.showTwoColumnMonthYearPicker;
            if (u) {
                var b = XP(g, w)
                  , v = t.getVerticalOffset(b)
                  , S = (o = IA[b]) === null || o === void 0 ? void 0 : o.grid
                  , N = function(P, M, R) {
                    var L, q, H = M, j = R;
                    switch (P) {
                    case Ye.ArrowRight:
                        H = ha(M, hw),
                        j = R === 11 ? 0 : R + hw;
                        break;
                    case Ye.ArrowLeft:
                        H = _f(M, hw),
                        j = R === 0 ? 11 : R - hw;
                        break;
                    case Ye.ArrowUp:
                        H = _f(M, v),
                        j = !((L = S?.[0]) === null || L === void 0) && L.includes(R) ? R + 12 - v : R - v;
                        break;
                    case Ye.ArrowDown:
                        H = ha(M, v),
                        j = !((q = S?.[S.length - 1]) === null || q === void 0) && q.includes(R) ? R - 12 + v : R + v;
                        break
                    }
                    return {
                        newCalculatedDate: H,
                        newCalculatedMonth: j
                    }
                }
                  , _ = function(P, M, R) {
                    for (var L = 40, q = P, H = !1, j = 0, A = N(q, M, R), E = A.newCalculatedDate, C = A.newCalculatedMonth; !H; ) {
                        if (j >= L) {
                            E = M,
                            C = R;
                            break
                        }
                        if (h && E < h) {
                            q = Ye.ArrowRight;
                            var O = N(q, E, C);
                            E = O.newCalculatedDate,
                            C = O.newCalculatedMonth
                        }
                        if (p && E > p) {
                            q = Ye.ArrowLeft;
                            var O = N(q, E, C);
                            E = O.newCalculatedDate,
                            C = O.newCalculatedMonth
                        }
                        if (m6e(E, t.props)) {
                            var O = N(q, E, C);
                            E = O.newCalculatedDate,
                            C = O.newCalculatedMonth
                        } else
                            H = !0;
                        j++
                    }
                    return {
                        newCalculatedDate: E,
                        newCalculatedMonth: C
                    }
                };
                if (s === Ye.Enter) {
                    t.isMonthDisabled(i) || (t.onMonthClick(r, i),
                    d?.(l));
                    return
                }
                var I = _(s, u, i)
                  , k = I.newCalculatedDate
                  , B = I.newCalculatedMonth;
                switch (s) {
                case Ye.ArrowRight:
                case Ye.ArrowLeft:
                case Ye.ArrowUp:
                case Ye.ArrowDown:
                    t.handleMonthNavigation(B, k);
                    break
                }
            }
        }
        ,
        t.getVerticalOffset = function(r) {
            var s, i;
            return (i = (s = IA[r]) === null || s === void 0 ? void 0 : s.verticalNavigationOffset) !== null && i !== void 0 ? i : 0
        }
        ,
        t.onMonthKeyDown = function(r, s) {
            var i = t.props
              , o = i.disabledKeyboardNavigation
              , a = i.handleOnMonthKeyDown
              , l = r.key;
            l !== Ye.Tab && r.preventDefault(),
            o || t.handleKeyboardNavigation(r, l, s),
            a && a(r)
        }
        ,
        t.onQuarterClick = function(r, s) {
            var i = up(t.props.day, s);
            uw(i, t.props) || t.handleDayClick(PP(i), r)
        }
        ,
        t.onQuarterMouseEnter = function(r) {
            var s = up(t.props.day, r);
            uw(s, t.props) || t.handleDayMouseEnter(PP(s))
        }
        ,
        t.handleQuarterNavigation = function(r, s) {
            var i, o, a, l;
            t.isDisabled(s) || t.isExcluded(s) || ((o = (i = t.props).setPreSelection) === null || o === void 0 || o.call(i, s),
            (l = (a = t.QUARTER_REFS[r - 1]) === null || a === void 0 ? void 0 : a.current) === null || l === void 0 || l.focus())
        }
        ,
        t.onQuarterKeyDown = function(r, s) {
            var i, o, a = r.key;
            if (!t.props.disabledKeyboardNavigation)
                switch (a) {
                case Ye.Enter:
                    t.onQuarterClick(r, s),
                    (o = (i = t.props).setPreSelection) === null || o === void 0 || o.call(i, t.props.selected);
                    break;
                case Ye.ArrowRight:
                    if (!t.props.preSelection)
                        break;
                    t.handleQuarterNavigation(s === 4 ? 1 : s + 1, mk(t.props.preSelection, 1));
                    break;
                case Ye.ArrowLeft:
                    if (!t.props.preSelection)
                        break;
                    t.handleQuarterNavigation(s === 1 ? 4 : s - 1, zq(t.props.preSelection));
                    break
                }
        }
        ,
        t.isMonthDisabledForLabelDate = function(r) {
            var s, i = t.props, o = i.day, a = i.disabled, l = i.minDate, u = i.maxDate, d = i.excludeDates, h = i.includeDates, p = Xi(o, r);
            return a ? {
                isDisabled: !0,
                labelDate: Xi(o, r)
            } : {
                isDisabled: (s = (l || u || d || h) && nG(p, t.props)) !== null && s !== void 0 ? s : !1,
                labelDate: p
            }
        }
        ,
        t.isMonthDisabled = function(r) {
            var s = t.isMonthDisabledForLabelDate(r).isDisabled;
            return s
        }
        ,
        t.getMonthClassNames = function(r) {
            var s = t.props
              , i = s.day
              , o = s.startDate
              , a = s.endDate
              , l = s.preSelection
              , u = s.monthClassName
              , d = u ? u(Xi(i, r)) : void 0
              , h = t.getSelection();
            return Jn("react-datepicker__month-text", "react-datepicker__month-".concat(r), d, {
                "react-datepicker__month-text--disabled": t.isMonthDisabled(r),
                "react-datepicker__month-text--selected": h ? t.isSelectMonthInList(i, r, h) : void 0,
                "react-datepicker__month-text--keyboard-selected": !t.props.disabledKeyboardNavigation && l && t.isSelectedMonth(i, r, l) && !t.isMonthSelected() && !t.isMonthDisabled(r),
                "react-datepicker__month-text--in-selecting-range": t.isInSelectingRangeMonth(r),
                "react-datepicker__month-text--in-range": o && a ? cw(o, a, r, i) : void 0,
                "react-datepicker__month-text--range-start": t.isRangeStartMonth(r),
                "react-datepicker__month-text--range-end": t.isRangeEndMonth(r),
                "react-datepicker__month-text--selecting-range-start": t.isSelectingMonthRangeStart(r),
                "react-datepicker__month-text--selecting-range-end": t.isSelectingMonthRangeEnd(r),
                "react-datepicker__month-text--today": t.isCurrentMonth(i, r)
            })
        }
        ,
        t.getTabIndex = function(r) {
            if (t.props.preSelection == null)
                return "-1";
            var s = Fs(t.props.preSelection)
              , i = t.isMonthDisabledForLabelDate(s).isDisabled
              , o = r === s && !(i || t.props.disabledKeyboardNavigation) ? "0" : "-1";
            return o
        }
        ,
        t.getQuarterTabIndex = function(r) {
            if (t.props.preSelection == null)
                return "-1";
            var s = Cf(t.props.preSelection)
              , i = uw(t.props.day, t.props)
              , o = r === s && !(i || t.props.disabledKeyboardNavigation) ? "0" : "-1";
            return o
        }
        ,
        t.getAriaLabel = function(r) {
            var s = t.props
              , i = s.chooseDayAriaLabelPrefix
              , o = i === void 0 ? "Choose" : i
              , a = s.disabledDayAriaLabelPrefix
              , l = a === void 0 ? "Not available" : a
              , u = s.day
              , d = s.locale
              , h = Xi(u, r)
              , p = t.isDisabled(h) || t.isExcluded(h) ? l : o;
            return "".concat(p, " ").concat(Kn(h, "MMMM yyyy", d))
        }
        ,
        t.getQuarterClassNames = function(r) {
            var s = t.props
              , i = s.day
              , o = s.startDate
              , a = s.endDate
              , l = s.selected
              , u = s.minDate
              , d = s.maxDate
              , h = s.excludeDates
              , p = s.includeDates
              , g = s.filterDate
              , w = s.preSelection
              , b = s.disabledKeyboardNavigation
              , v = s.disabled
              , S = (u || d || h || p || g || v) && uw(up(i, r), t.props);
            return Jn("react-datepicker__quarter-text", "react-datepicker__quarter-".concat(r), {
                "react-datepicker__quarter-text--disabled": S,
                "react-datepicker__quarter-text--selected": l ? t.isSelectedQuarter(i, r, l) : void 0,
                "react-datepicker__quarter-text--keyboard-selected": !b && w && t.isSelectedQuarter(i, r, w) && !S,
                "react-datepicker__quarter-text--in-selecting-range": t.isInSelectingRangeQuarter(r),
                "react-datepicker__quarter-text--in-range": o && a ? fw(o, a, r, i) : void 0,
                "react-datepicker__quarter-text--range-start": t.isRangeStartQuarter(r),
                "react-datepicker__quarter-text--range-end": t.isRangeEndQuarter(r),
                "react-datepicker__quarter-text--today": t.isCurrentQuarter(i, r)
            })
        }
        ,
        t.getMonthContent = function(r) {
            var s = t.props
              , i = s.showFullMonthYearPicker
              , o = s.renderMonthContent
              , a = s.locale
              , l = s.day
              , u = tG(r, a)
              , d = _k(r, a);
            return o ? o(r, u, d, l) : i ? d : u
        }
        ,
        t.getQuarterContent = function(r) {
            var s, i = t.props, o = i.renderQuarterContent, a = i.locale, l = p6e(r, a);
            return (s = o?.(r, l)) !== null && s !== void 0 ? s : l
        }
        ,
        t.renderMonths = function() {
            var r, s = t.props, i = s.showTwoColumnMonthYearPicker, o = s.showFourColumnMonthYearPicker, a = s.day, l = s.selected, u = (r = IA[XP(o, i)]) === null || r === void 0 ? void 0 : r.grid;
            return u?.map(function(d, h) {
                return ye.createElement("div", {
                    className: "react-datepicker__month-wrapper",
                    key: h
                }, d.map(function(p, g) {
                    return ye.createElement("div", {
                        ref: t.MONTH_REFS[p],
                        key: g,
                        onClick: function(w) {
                            t.onMonthClick(w, p)
                        },
                        onKeyDown: function(w) {
                            iG(w) && (w.preventDefault(),
                            w.key = Ye.Enter),
                            t.onMonthKeyDown(w, p)
                        },
                        onMouseEnter: t.props.usePointerEvent ? void 0 : function() {
                            return t.onMonthMouseEnter(p)
                        }
                        ,
                        onPointerEnter: t.props.usePointerEvent ? function() {
                            return t.onMonthMouseEnter(p)
                        }
                        : void 0,
                        tabIndex: Number(t.getTabIndex(p)),
                        className: t.getMonthClassNames(p),
                        "aria-disabled": t.isMonthDisabled(p),
                        role: "option",
                        "aria-label": t.getAriaLabel(p),
                        "aria-current": t.isCurrentMonth(a, p) ? "date" : void 0,
                        "aria-selected": l ? t.isSelectedMonth(a, p, l) : void 0
                    }, t.getMonthContent(p))
                }))
            })
        }
        ,
        t.renderQuarters = function() {
            var r = t.props
              , s = r.day
              , i = r.selected
              , o = [1, 2, 3, 4];
            return ye.createElement("div", {
                className: "react-datepicker__quarter-wrapper"
            }, o.map(function(a, l) {
                return ye.createElement("div", {
                    key: l,
                    ref: t.QUARTER_REFS[l],
                    role: "option",
                    onClick: function(u) {
                        t.onQuarterClick(u, a)
                    },
                    onKeyDown: function(u) {
                        t.onQuarterKeyDown(u, a)
                    },
                    onMouseEnter: t.props.usePointerEvent ? void 0 : function() {
                        return t.onQuarterMouseEnter(a)
                    }
                    ,
                    onPointerEnter: t.props.usePointerEvent ? function() {
                        return t.onQuarterMouseEnter(a)
                    }
                    : void 0,
                    className: t.getQuarterClassNames(a),
                    "aria-selected": i ? t.isSelectedQuarter(s, a, i) : void 0,
                    tabIndex: Number(t.getQuarterTabIndex(a)),
                    "aria-current": t.isCurrentQuarter(s, a) ? "date" : void 0
                }, t.getQuarterContent(a))
            }))
        }
        ,
        t.getClassNames = function() {
            var r = t.props
              , s = r.selectingDate
              , i = r.selectsStart
              , o = r.selectsEnd
              , a = r.showMonthYearPicker
              , l = r.showQuarterYearPicker
              , u = r.showWeekPicker;
            return Jn("react-datepicker__month", {
                "react-datepicker__month--selecting-range": s && (i || o)
            }, {
                "react-datepicker__monthPicker": a
            }, {
                "react-datepicker__quarterPicker": l
            }, {
                "react-datepicker__weekPicker": u
            })
        }
        ,
        t
    }
    return e.prototype.getSelection = function() {
        var t = this.props
          , r = t.selected
          , s = t.selectedDates
          , i = t.selectsMultiple;
        if (i)
            return s;
        if (r)
            return [r]
    }
    ,
    e.prototype.render = function() {
        var t = this.props
          , r = t.showMonthYearPicker
          , s = t.showQuarterYearPicker
          , i = t.day
          , o = t.ariaLabelPrefix
          , a = o === void 0 ? "Month " : o
          , l = a ? a.trim() + " " : ""
          , u = r || s;
        return u ? ye.createElement("div", {
            className: this.getClassNames(),
            onMouseLeave: this.props.usePointerEvent ? void 0 : this.handleMouseLeave,
            onPointerLeave: this.props.usePointerEvent ? this.handleMouseLeave : void 0,
            "aria-label": "".concat(l).concat(Kn(i, "MMMM, yyyy", this.props.locale)),
            role: "listbox"
        }, r ? this.renderMonths() : this.renderQuarters()) : ye.createElement("div", {
            role: "table"
        }, this.props.dayNamesHeader && ye.createElement("div", {
            role: "rowgroup"
        }, this.props.dayNamesHeader), ye.createElement("div", {
            className: this.getClassNames(),
            onMouseLeave: this.props.usePointerEvent ? void 0 : this.handleMouseLeave,
            onPointerLeave: this.props.usePointerEvent ? this.handleMouseLeave : void 0,
            "aria-label": "".concat(l).concat(Kn(i, "MMMM, yyyy", this.props.locale)),
            role: "rowgroup"
        }, this.renderWeeks()))
    }
    ,
    e
}
)(V.Component)
  , I6e = (function(n) {
    _s(e, n);
    function e() {
        var t = n !== null && n.apply(this, arguments) || this;
        return t.monthOptionButtonsRef = {},
        t.isSelectedMonth = function(r) {
            return t.props.month === r
        }
        ,
        t.handleOptionKeyDown = function(r, s) {
            var i;
            switch (s.key) {
            case "Enter":
                s.preventDefault(),
                t.onChange(r);
                break;
            case "Escape":
                s.preventDefault(),
                t.props.onCancel();
                break;
            case "ArrowUp":
            case "ArrowDown":
                {
                    s.preventDefault();
                    var o = (r + (s.key === "ArrowUp" ? -1 : 1) + t.props.monthNames.length) % t.props.monthNames.length;
                    (i = t.monthOptionButtonsRef[o]) === null || i === void 0 || i.focus();
                    break
                }
            }
        }
        ,
        t.renderOptions = function() {
            return t.monthOptionButtonsRef = {},
            t.props.monthNames.map(function(r, s) {
                return ye.createElement("div", {
                    ref: function(i) {
                        t.monthOptionButtonsRef[s] = i,
                        t.isSelectedMonth(s) && i?.focus()
                    },
                    role: "button",
                    tabIndex: 0,
                    className: t.isSelectedMonth(s) ? "react-datepicker__month-option react-datepicker__month-option--selected_month" : "react-datepicker__month-option",
                    key: r,
                    onClick: t.onChange.bind(t, s),
                    onKeyDown: t.handleOptionKeyDown.bind(t, s),
                    "aria-selected": t.isSelectedMonth(s) ? "true" : void 0
                }, t.isSelectedMonth(s) ? ye.createElement("span", {
                    className: "react-datepicker__month-option--selected"
                }, "") : "", r)
            })
        }
        ,
        t.onChange = function(r) {
            return t.props.onChange(r)
        }
        ,
        t.handleClickOutside = function() {
            return t.props.onCancel()
        }
        ,
        t
    }
    return e.prototype.render = function() {
        return ye.createElement(Ux, {
            className: "react-datepicker__month-dropdown",
            onClickOutside: this.handleClickOutside
        }, this.renderOptions())
    }
    ,
    e
}
)(V.Component)
  , M6e = (function(n) {
    _s(e, n);
    function e() {
        var t = n !== null && n.apply(this, arguments) || this;
        return t.state = {
            dropdownVisible: !1
        },
        t.renderSelectOptions = function(r) {
            return r.map(function(s, i) {
                return ye.createElement("option", {
                    key: s,
                    value: i
                }, s)
            })
        }
        ,
        t.renderSelectMode = function(r) {
            return ye.createElement("select", {
                value: t.props.month,
                className: "react-datepicker__month-select",
                onChange: function(s) {
                    return t.onChange(parseInt(s.target.value))
                }
            }, t.renderSelectOptions(r))
        }
        ,
        t.renderReadView = function(r, s) {
            return ye.createElement("button", {
                key: "read",
                type: "button",
                style: {
                    visibility: r ? "visible" : "hidden"
                },
                className: "react-datepicker__month-read-view",
                onClick: t.toggleDropdown
            }, ye.createElement("span", {
                className: "react-datepicker__month-read-view--down-arrow"
            }), ye.createElement("span", {
                className: "react-datepicker__month-read-view--selected-month"
            }, s[t.props.month]))
        }
        ,
        t.renderDropdown = function(r) {
            return ye.createElement(I6e, Xt({
                key: "dropdown"
            }, t.props, {
                monthNames: r,
                onChange: t.onChange,
                onCancel: t.toggleDropdown
            }))
        }
        ,
        t.renderScrollMode = function(r) {
            var s = t.state.dropdownVisible
              , i = [t.renderReadView(!s, r)];
            return s && i.unshift(t.renderDropdown(r)),
            i
        }
        ,
        t.onChange = function(r) {
            t.toggleDropdown(),
            r !== t.props.month && t.props.onChange(r)
        }
        ,
        t.toggleDropdown = function() {
            return t.setState({
                dropdownVisible: !t.state.dropdownVisible
            })
        }
        ,
        t
    }
    return e.prototype.render = function() {
        var t = this, r = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11].map(this.props.useShortMonthInDropdown ? function(i) {
            return tG(i, t.props.locale)
        }
        : function(i) {
            return _k(i, t.props.locale)
        }
        ), s;
        switch (this.props.dropdownMode) {
        case "scroll":
            s = this.renderScrollMode(r);
            break;
        case "select":
            s = this.renderSelectMode(r);
            break
        }
        return ye.createElement("div", {
            className: "react-datepicker__month-dropdown-container react-datepicker__month-dropdown-container--".concat(this.props.dropdownMode)
        }, s)
    }
    ,
    e
}
)(V.Component);
function B6e(n, e) {
    for (var t = [], r = Ec(n), s = Ec(e); !rd(r, s); )
        t.push(vn(r)),
        r = ha(r, 1);
    return t
}
var R6e = (function(n) {
    _s(e, n);
    function e(t) {
        var r = n.call(this, t) || this;
        return r.renderOptions = function() {
            return r.state.monthYearsList.map(function(s) {
                var i = JC(s)
                  , o = $a(r.props.date, s) && Gs(r.props.date, s);
                return ye.createElement("div", {
                    className: o ? "react-datepicker__month-year-option--selected_month-year" : "react-datepicker__month-year-option",
                    key: i,
                    onClick: r.onChange.bind(r, i),
                    "aria-selected": o ? "true" : void 0
                }, o ? ye.createElement("span", {
                    className: "react-datepicker__month-year-option--selected"
                }, "") : "", Kn(s, r.props.dateFormat, r.props.locale))
            })
        }
        ,
        r.onChange = function(s) {
            return r.props.onChange(s)
        }
        ,
        r.handleClickOutside = function() {
            r.props.onCancel()
        }
        ,
        r.state = {
            monthYearsList: B6e(r.props.minDate, r.props.maxDate)
        },
        r
    }
    return e.prototype.render = function() {
        var t = Jn({
            "react-datepicker__month-year-dropdown": !0,
            "react-datepicker__month-year-dropdown--scrollable": this.props.scrollableMonthYearDropdown
        });
        return ye.createElement(Ux, {
            className: t,
            onClickOutside: this.handleClickOutside
        }, this.renderOptions())
    }
    ,
    e
}
)(V.Component)
  , O6e = (function(n) {
    _s(e, n);
    function e() {
        var t = n !== null && n.apply(this, arguments) || this;
        return t.state = {
            dropdownVisible: !1
        },
        t.renderSelectOptions = function() {
            for (var r = Ec(t.props.minDate), s = Ec(t.props.maxDate), i = []; !rd(r, s); ) {
                var o = JC(r);
                i.push(ye.createElement("option", {
                    key: o,
                    value: o
                }, Kn(r, t.props.dateFormat, t.props.locale))),
                r = ha(r, 1)
            }
            return i
        }
        ,
        t.onSelectChange = function(r) {
            t.onChange(parseInt(r.target.value))
        }
        ,
        t.renderSelectMode = function() {
            return ye.createElement("select", {
                value: JC(Ec(t.props.date)),
                className: "react-datepicker__month-year-select",
                onChange: t.onSelectChange
            }, t.renderSelectOptions())
        }
        ,
        t.renderReadView = function(r) {
            var s = Kn(t.props.date, t.props.dateFormat, t.props.locale);
            return ye.createElement("div", {
                key: "read",
                style: {
                    visibility: r ? "visible" : "hidden"
                },
                className: "react-datepicker__month-year-read-view",
                onClick: t.toggleDropdown
            }, ye.createElement("span", {
                className: "react-datepicker__month-year-read-view--down-arrow"
            }), ye.createElement("span", {
                className: "react-datepicker__month-year-read-view--selected-month-year"
            }, s))
        }
        ,
        t.renderDropdown = function() {
            return ye.createElement(R6e, Xt({
                key: "dropdown"
            }, t.props, {
                onChange: t.onChange,
                onCancel: t.toggleDropdown
            }))
        }
        ,
        t.renderScrollMode = function() {
            var r = t.state.dropdownVisible
              , s = [t.renderReadView(!r)];
            return r && s.unshift(t.renderDropdown()),
            s
        }
        ,
        t.onChange = function(r) {
            t.toggleDropdown();
            var s = vn(r);
            $a(t.props.date, s) && Gs(t.props.date, s) || t.props.onChange(s)
        }
        ,
        t.toggleDropdown = function() {
            return t.setState({
                dropdownVisible: !t.state.dropdownVisible
            })
        }
        ,
        t
    }
    return e.prototype.render = function() {
        var t;
        switch (this.props.dropdownMode) {
        case "scroll":
            t = this.renderScrollMode();
            break;
        case "select":
            t = this.renderSelectMode();
            break
        }
        return ye.createElement("div", {
            className: "react-datepicker__month-year-dropdown-container react-datepicker__month-year-dropdown-container--".concat(this.props.dropdownMode)
        }, t)
    }
    ,
    e
}
)(V.Component)
  , P6e = (function(n) {
    _s(e, n);
    function e() {
        var t = n !== null && n.apply(this, arguments) || this;
        return t.state = {
            height: null
        },
        t.scrollToTheSelectedTime = function() {
            requestAnimationFrame(function() {
                var r, s, i;
                t.list && (t.list.scrollTop = (i = t.centerLi && e.calcCenterPosition(t.props.monthRef ? t.props.monthRef.clientHeight - ((s = (r = t.header) === null || r === void 0 ? void 0 : r.clientHeight) !== null && s !== void 0 ? s : 0) : t.list.clientHeight, t.centerLi)) !== null && i !== void 0 ? i : 0)
            })
        }
        ,
        t.handleClick = function(r) {
            var s, i;
            (t.props.minTime || t.props.maxTime) && zP(r, t.props) || (t.props.excludeTimes || t.props.includeTimes || t.props.filterTime) && UP(r, t.props) || (i = (s = t.props).onChange) === null || i === void 0 || i.call(s, r)
        }
        ,
        t.isSelectedTime = function(r) {
            return t.props.selected && A6e(t.props.selected, r)
        }
        ,
        t.isDisabledTime = function(r) {
            return (t.props.minTime || t.props.maxTime) && zP(r, t.props) || (t.props.excludeTimes || t.props.includeTimes || t.props.filterTime) && UP(r, t.props)
        }
        ,
        t.liClasses = function(r) {
            var s, i = ["react-datepicker__time-list-item", t.props.timeClassName ? t.props.timeClassName(r) : void 0];
            return t.isSelectedTime(r) && i.push("react-datepicker__time-list-item--selected"),
            t.isDisabledTime(r) && i.push("react-datepicker__time-list-item--disabled"),
            t.props.injectTimes && (vc(r) * 3600 + xc(r) * 60 + Gu(r)) % (((s = t.props.intervals) !== null && s !== void 0 ? s : e.defaultProps.intervals) * 60) !== 0 && i.push("react-datepicker__time-list-item--injected"),
            i.join(" ")
        }
        ,
        t.handleOnKeyDown = function(r, s) {
            var i, o;
            r.key === Ye.Space && (r.preventDefault(),
            r.key = Ye.Enter),
            (r.key === Ye.ArrowUp || r.key === Ye.ArrowLeft) && r.target instanceof HTMLElement && r.target.previousSibling && (r.preventDefault(),
            r.target.previousSibling instanceof HTMLElement && r.target.previousSibling.focus()),
            (r.key === Ye.ArrowDown || r.key === Ye.ArrowRight) && r.target instanceof HTMLElement && r.target.nextSibling && (r.preventDefault(),
            r.target.nextSibling instanceof HTMLElement && r.target.nextSibling.focus()),
            r.key === Ye.Enter && t.handleClick(s),
            (o = (i = t.props).handleOnKeyDown) === null || o === void 0 || o.call(i, r)
        }
        ,
        t.renderTimes = function() {
            for (var r, s = [], i = typeof t.props.format == "string" ? t.props.format : "p", o = (r = t.props.intervals) !== null && r !== void 0 ? r : e.defaultProps.intervals, a = t.props.selected || t.props.openToDate || vn(), l = t2(a), u = t.props.injectTimes && t.props.injectTimes.sort(function(v, S) {
                return v.getTime() - S.getTime()
            }), d = 60 * S6e(a), h = d / o, p = 0; p < h; p++) {
                var g = XC(l, p * o);
                if (s.push(g),
                u) {
                    var w = E6e(l, g, p, o, u);
                    s = s.concat(w)
                }
            }
            var b = s.reduce(function(v, S) {
                return S.getTime() <= a.getTime() ? S : v
            }, s[0]);
            return s.map(function(v) {
                return ye.createElement("li", {
                    key: v.valueOf(),
                    onClick: t.handleClick.bind(t, v),
                    className: t.liClasses(v),
                    ref: function(S) {
                        v === b && (t.centerLi = S)
                    },
                    onKeyDown: function(S) {
                        t.handleOnKeyDown(S, v)
                    },
                    tabIndex: v === b ? 0 : -1,
                    role: "option",
                    "aria-selected": t.isSelectedTime(v) ? "true" : void 0,
                    "aria-disabled": t.isDisabledTime(v) ? "true" : void 0
                }, Kn(v, i, t.props.locale))
            })
        }
        ,
        t.renderTimeCaption = function() {
            return t.props.showTimeCaption === !1 ? ye.createElement(ye.Fragment, null) : ye.createElement("div", {
                className: "react-datepicker__header react-datepicker__header--time ".concat(t.props.showTimeSelectOnly ? "react-datepicker__header--time--only" : ""),
                ref: function(r) {
                    t.header = r
                }
            }, ye.createElement("div", {
                className: "react-datepicker-time__header"
            }, t.props.timeCaption))
        }
        ,
        t
    }
    return Object.defineProperty(e, "defaultProps", {
        get: function() {
            return {
                intervals: 30,
                todayButton: null,
                timeCaption: "Time",
                showTimeCaption: !0
            }
        },
        enumerable: !1,
        configurable: !0
    }),
    e.prototype.componentDidMount = function() {
        this.scrollToTheSelectedTime(),
        this.observeDatePickerHeightChanges()
    }
    ,
    e.prototype.componentWillUnmount = function() {
        var t;
        (t = this.resizeObserver) === null || t === void 0 || t.disconnect()
    }
    ,
    e.prototype.observeDatePickerHeightChanges = function() {
        var t = this
          , r = this.props.monthRef;
        this.updateContainerHeight(),
        r && (this.resizeObserver = new ResizeObserver(function() {
            t.updateContainerHeight()
        }
        ),
        this.resizeObserver.observe(r))
    }
    ,
    e.prototype.updateContainerHeight = function() {
        this.props.monthRef && this.header && this.setState({
            height: this.props.monthRef.clientHeight - this.header.clientHeight
        })
    }
    ,
    e.prototype.render = function() {
        var t = this, r, s = this.state.height;
        return ye.createElement("div", {
            className: "react-datepicker__time-container ".concat(((r = this.props.todayButton) !== null && r !== void 0 ? r : e.defaultProps.todayButton) ? "react-datepicker__time-container--with-today-button" : "")
        }, this.renderTimeCaption(), ye.createElement("div", {
            className: "react-datepicker__time"
        }, ye.createElement("div", {
            className: "react-datepicker__time-box"
        }, ye.createElement("ul", {
            className: "react-datepicker__time-list",
            ref: function(i) {
                t.list = i
            },
            style: s ? {
                height: s
            } : {},
            role: "listbox",
            "aria-label": this.props.timeCaption
        }, this.renderTimes()))))
    }
    ,
    e.calcCenterPosition = function(t, r) {
        return r.offsetTop - (t / 2 - r.clientHeight / 2)
    }
    ,
    e
}
)(V.Component)
  , QP = 3
  , j6e = (function(n) {
    _s(e, n);
    function e(t) {
        var r = n.call(this, t) || this;
        return r.YEAR_REFS = Ka([], Array(r.props.yearItemNumber), !0).map(function() {
            return V.createRef()
        }),
        r.isDisabled = function(s) {
            return Mo(s, {
                minDate: r.props.minDate,
                maxDate: r.props.maxDate,
                excludeDates: r.props.excludeDates,
                includeDates: r.props.includeDates,
                filterDate: r.props.filterDate
            })
        }
        ,
        r.isExcluded = function(s) {
            return kk(s, {
                excludeDates: r.props.excludeDates
            })
        }
        ,
        r.selectingDate = function() {
            var s;
            return (s = r.props.selectingDate) !== null && s !== void 0 ? s : r.props.preSelection
        }
        ,
        r.updateFocusOnPaginate = function(s) {
            var i = function() {
                var o, a;
                (a = (o = r.YEAR_REFS[s]) === null || o === void 0 ? void 0 : o.current) === null || a === void 0 || a.focus()
            };
            window.requestAnimationFrame(i)
        }
        ,
        r.handleYearClick = function(s, i) {
            r.props.onDayClick && r.props.onDayClick(s, i)
        }
        ,
        r.handleYearNavigation = function(s, i) {
            var o, a, l, u, d = r.props, h = d.date, p = d.yearItemNumber;
            if (!(h === void 0 || p === void 0)) {
                var g = fc(h, p).startPeriod;
                r.isDisabled(i) || r.isExcluded(i) || ((a = (o = r.props).setPreSelection) === null || a === void 0 || a.call(o, i),
                s - g < 0 ? r.updateFocusOnPaginate(p - (g - s)) : s - g >= p ? r.updateFocusOnPaginate(Math.abs(p - (s - g))) : (u = (l = r.YEAR_REFS[s - g]) === null || l === void 0 ? void 0 : l.current) === null || u === void 0 || u.focus())
            }
        }
        ,
        r.isSameDay = function(s, i) {
            return Kt(s, i)
        }
        ,
        r.isCurrentYear = function(s) {
            return s === Ut(vn())
        }
        ,
        r.isRangeStart = function(s) {
            return r.props.startDate && r.props.endDate && $a(La(vn(), s), r.props.startDate)
        }
        ,
        r.isRangeEnd = function(s) {
            return r.props.startDate && r.props.endDate && $a(La(vn(), s), r.props.endDate)
        }
        ,
        r.isInRange = function(s) {
            return dw(s, r.props.startDate, r.props.endDate)
        }
        ,
        r.isInSelectingRange = function(s) {
            var i = r.props
              , o = i.selectsStart
              , a = i.selectsEnd
              , l = i.selectsRange
              , u = i.startDate
              , d = i.endDate;
            return !(o || a || l) || !r.selectingDate() ? !1 : o && d ? dw(s, r.selectingDate(), d) : a && u || l && u && !d ? dw(s, u, r.selectingDate()) : !1
        }
        ,
        r.isSelectingRangeStart = function(s) {
            var i;
            if (!r.isInSelectingRange(s))
                return !1;
            var o = r.props
              , a = o.startDate
              , l = o.selectsStart
              , u = La(vn(), s);
            return l ? $a(u, (i = r.selectingDate()) !== null && i !== void 0 ? i : null) : $a(u, a ?? null)
        }
        ,
        r.isSelectingRangeEnd = function(s) {
            var i;
            if (!r.isInSelectingRange(s))
                return !1;
            var o = r.props
              , a = o.endDate
              , l = o.selectsEnd
              , u = o.selectsRange
              , d = La(vn(), s);
            return l || u ? $a(d, (i = r.selectingDate()) !== null && i !== void 0 ? i : null) : $a(d, a ?? null)
        }
        ,
        r.isKeyboardSelected = function(s) {
            if (!(r.props.disabledKeyboardNavigation || r.props.date === void 0 || r.props.preSelection == null)) {
                var i = r.props
                  , o = i.minDate
                  , a = i.maxDate
                  , l = i.excludeDates
                  , u = i.includeDates
                  , d = i.filterDate
                  , h = i.selected
                  , p = xg(La(r.props.date, s))
                  , g = (o || a || l || u || d) && n2(s, r.props)
                  , w = !!h && Kt(p, xg(h))
                  , b = Kt(p, xg(r.props.preSelection));
                return !r.props.inline && !w && b && !g
            }
        }
        ,
        r.isSelectedYear = function(s) {
            var i = r.props
              , o = i.selectsMultiple
              , a = i.selected
              , l = i.selectedDates;
            return o ? l?.some(function(u) {
                return s === Ut(u)
            }) : !!a && s === Ut(a)
        }
        ,
        r.onYearClick = function(s, i) {
            var o = r.props.date;
            o !== void 0 && r.handleYearClick(xg(La(o, i)), s)
        }
        ,
        r.onYearKeyDown = function(s, i) {
            var o, a, l = s.key, u = r.props, d = u.date, h = u.yearItemNumber, p = u.handleOnKeyDown;
            if (l !== Ye.Tab && s.preventDefault(),
            !r.props.disabledKeyboardNavigation)
                switch (l) {
                case Ye.Enter:
                    if (r.props.selected == null)
                        break;
                    r.onYearClick(s, i),
                    (a = (o = r.props).setPreSelection) === null || a === void 0 || a.call(o, r.props.selected);
                    break;
                case Ye.ArrowRight:
                    if (r.props.preSelection == null)
                        break;
                    r.handleYearNavigation(i + 1, bc(r.props.preSelection, 1));
                    break;
                case Ye.ArrowLeft:
                    if (r.props.preSelection == null)
                        break;
                    r.handleYearNavigation(i - 1, u0(r.props.preSelection, 1));
                    break;
                case Ye.ArrowUp:
                    {
                        if (d === void 0 || h === void 0 || r.props.preSelection == null)
                            break;
                        var g = fc(d, h).startPeriod
                          , w = QP
                          , b = i - w;
                        if (b < g) {
                            var v = h % w;
                            i >= g && i < g + v ? w = v : w += v,
                            b = i - w
                        }
                        r.handleYearNavigation(b, u0(r.props.preSelection, w));
                        break
                    }
                case Ye.ArrowDown:
                    {
                        if (d === void 0 || h === void 0 || r.props.preSelection == null)
                            break;
                        var S = fc(d, h).endPeriod
                          , w = QP
                          , b = i + w;
                        if (b > S) {
                            var v = h % w;
                            i <= S && i > S - v ? w = v : w += v,
                            b = i + w
                        }
                        r.handleYearNavigation(b, bc(r.props.preSelection, w));
                        break
                    }
                }
            p && p(s)
        }
        ,
        r.getYearClassNames = function(s) {
            var i = r.props
              , o = i.date
              , a = i.disabled
              , l = i.minDate
              , u = i.maxDate
              , d = i.excludeDates
              , h = i.includeDates
              , p = i.filterDate
              , g = i.yearClassName;
            return Jn("react-datepicker__year-text", "react-datepicker__year-".concat(s), o ? g?.(La(o, s)) : void 0, {
                "react-datepicker__year-text--selected": r.isSelectedYear(s),
                "react-datepicker__year-text--disabled": (l || u || d || h || p || a) && n2(s, r.props),
                "react-datepicker__year-text--keyboard-selected": r.isKeyboardSelected(s),
                "react-datepicker__year-text--range-start": r.isRangeStart(s),
                "react-datepicker__year-text--range-end": r.isRangeEnd(s),
                "react-datepicker__year-text--in-range": r.isInRange(s),
                "react-datepicker__year-text--in-selecting-range": r.isInSelectingRange(s),
                "react-datepicker__year-text--selecting-range-start": r.isSelectingRangeStart(s),
                "react-datepicker__year-text--selecting-range-end": r.isSelectingRangeEnd(s),
                "react-datepicker__year-text--today": r.isCurrentYear(s)
            })
        }
        ,
        r.getYearTabIndex = function(s) {
            if (r.props.disabledKeyboardNavigation || r.props.preSelection == null)
                return "-1";
            var i = Ut(r.props.preSelection)
              , o = n2(s, r.props);
            return s === i && !o ? "0" : "-1"
        }
        ,
        r.getYearContent = function(s) {
            return r.props.renderYearContent ? r.props.renderYearContent(s) : s
        }
        ,
        r
    }
    return e.prototype.render = function() {
        var t = this
          , r = []
          , s = this.props
          , i = s.date
          , o = s.yearItemNumber
          , a = s.onYearMouseEnter
          , l = s.onYearMouseLeave;
        if (i === void 0)
            return null;
        for (var u = fc(i, o), d = u.startPeriod, h = u.endPeriod, p = function(b) {
            r.push(ye.createElement("div", {
                ref: g.YEAR_REFS[b - d],
                onClick: function(v) {
                    t.onYearClick(v, b)
                },
                onKeyDown: function(v) {
                    iG(v) && (v.preventDefault(),
                    v.key = Ye.Enter),
                    t.onYearKeyDown(v, b)
                },
                tabIndex: Number(g.getYearTabIndex(b)),
                className: g.getYearClassNames(b),
                onMouseEnter: g.props.usePointerEvent ? void 0 : function(v) {
                    return a(v, b)
                }
                ,
                onPointerEnter: g.props.usePointerEvent ? function(v) {
                    return a(v, b)
                }
                : void 0,
                onMouseLeave: g.props.usePointerEvent ? void 0 : function(v) {
                    return l(v, b)
                }
                ,
                onPointerLeave: g.props.usePointerEvent ? function(v) {
                    return l(v, b)
                }
                : void 0,
                key: b,
                "aria-current": g.isCurrentYear(b) ? "date" : void 0
            }, g.getYearContent(b)))
        }, g = this, w = d; w <= h; w++)
            p(w);
        return ye.createElement("div", {
            className: "react-datepicker__year"
        }, ye.createElement("div", {
            className: "react-datepicker__year-wrapper",
            onMouseLeave: this.props.usePointerEvent ? void 0 : this.props.clearSelectingDate,
            onPointerLeave: this.props.usePointerEvent ? this.props.clearSelectingDate : void 0
        }, r))
    }
    ,
    e
}
)(V.Component);
function L6e(n, e, t, r) {
    for (var s = [], i = 0; i < 2 * e + 1; i++) {
        var o = n + e - i
          , a = !0;
        t && (a = Ut(t) <= o),
        r && a && (a = Ut(r) >= o),
        a && s.push(o)
    }
    return s
}
var F6e = (function(n) {
    _s(e, n);
    function e(t) {
        var r = n.call(this, t) || this;
        r.yearOptionButtonsRef = {},
        r.handleOptionKeyDown = function(a, l) {
            var u;
            switch (l.key) {
            case "Enter":
                l.preventDefault(),
                r.onChange(a);
                break;
            case "Escape":
                l.preventDefault(),
                r.props.onCancel();
                break;
            case "ArrowUp":
            case "ArrowDown":
                {
                    l.preventDefault();
                    var d = a + (l.key === "ArrowUp" ? 1 : -1);
                    r.yearOptionButtonsRef[d] && ((u = r.yearOptionButtonsRef[d]) === null || u === void 0 || u.focus());
                    break
                }
            }
        }
        ,
        r.renderOptions = function() {
            r.yearOptionButtonsRef = {};
            var a = r.props.year
              , l = r.state.yearsList.map(function(h) {
                return ye.createElement("div", {
                    ref: function(p) {
                        r.yearOptionButtonsRef[h] = p,
                        h === a && p?.focus()
                    },
                    role: "button",
                    tabIndex: 0,
                    className: a === h ? "react-datepicker__year-option react-datepicker__year-option--selected_year" : "react-datepicker__year-option",
                    key: h,
                    onClick: r.onChange.bind(r, h),
                    onKeyDown: r.handleOptionKeyDown.bind(r, h),
                    "aria-selected": a === h ? "true" : void 0
                }, a === h ? ye.createElement("span", {
                    className: "react-datepicker__year-option--selected"
                }, "") : "", h)
            })
              , u = r.props.minDate ? Ut(r.props.minDate) : null
              , d = r.props.maxDate ? Ut(r.props.maxDate) : null;
            return (!d || !r.state.yearsList.find(function(h) {
                return h === d
            })) && l.unshift(ye.createElement("div", {
                className: "react-datepicker__year-option",
                key: "upcoming",
                onClick: r.incrementYears
            }, ye.createElement("a", {
                className: "react-datepicker__navigation react-datepicker__navigation--years react-datepicker__navigation--years-upcoming"
            }))),
            (!u || !r.state.yearsList.find(function(h) {
                return h === u
            })) && l.push(ye.createElement("div", {
                className: "react-datepicker__year-option",
                key: "previous",
                onClick: r.decrementYears
            }, ye.createElement("a", {
                className: "react-datepicker__navigation react-datepicker__navigation--years react-datepicker__navigation--years-previous"
            }))),
            l
        }
        ,
        r.onChange = function(a) {
            r.props.onChange(a)
        }
        ,
        r.handleClickOutside = function() {
            r.props.onCancel()
        }
        ,
        r.shiftYears = function(a) {
            var l = r.state.yearsList.map(function(u) {
                return u + a
            });
            r.setState({
                yearsList: l
            })
        }
        ,
        r.incrementYears = function() {
            return r.shiftYears(1)
        }
        ,
        r.decrementYears = function() {
            return r.shiftYears(-1)
        }
        ;
        var s = t.yearDropdownItemNumber
          , i = t.scrollableYearDropdown
          , o = s || (i ? 10 : 5);
        return r.state = {
            yearsList: L6e(r.props.year, o, r.props.minDate, r.props.maxDate)
        },
        r.dropdownRef = V.createRef(),
        r
    }
    return e.prototype.componentDidMount = function() {
        var t = this.dropdownRef.current;
        if (t) {
            var r = t.children ? Array.from(t.children) : null
              , s = r ? r.find(function(i) {
                return i.ariaSelected
            }) : null;
            t.scrollTop = s && s instanceof HTMLElement ? s.offsetTop + (s.clientHeight - t.clientHeight) / 2 : (t.scrollHeight - t.clientHeight) / 2
        }
    }
    ,
    e.prototype.render = function() {
        var t = Jn({
            "react-datepicker__year-dropdown": !0,
            "react-datepicker__year-dropdown--scrollable": this.props.scrollableYearDropdown
        });
        return ye.createElement(Ux, {
            className: t,
            containerRef: this.dropdownRef,
            onClickOutside: this.handleClickOutside
        }, this.renderOptions())
    }
    ,
    e
}
)(V.Component)
  , U6e = (function(n) {
    _s(e, n);
    function e() {
        var t = n !== null && n.apply(this, arguments) || this;
        return t.state = {
            dropdownVisible: !1
        },
        t.renderSelectOptions = function() {
            for (var r = t.props.minDate ? Ut(t.props.minDate) : 1900, s = t.props.maxDate ? Ut(t.props.maxDate) : 2100, i = [], o = r; o <= s; o++)
                i.push(ye.createElement("option", {
                    key: o,
                    value: o
                }, o));
            return i
        }
        ,
        t.onSelectChange = function(r) {
            t.onChange(parseInt(r.target.value))
        }
        ,
        t.renderSelectMode = function() {
            return ye.createElement("select", {
                value: t.props.year,
                className: "react-datepicker__year-select",
                onChange: t.onSelectChange
            }, t.renderSelectOptions())
        }
        ,
        t.renderReadView = function(r) {
            return ye.createElement("button", {
                key: "read",
                type: "button",
                style: {
                    visibility: r ? "visible" : "hidden"
                },
                className: "react-datepicker__year-read-view",
                onClick: t.toggleDropdown
            }, ye.createElement("span", {
                className: "react-datepicker__year-read-view--down-arrow"
            }), ye.createElement("span", {
                className: "react-datepicker__year-read-view--selected-year"
            }, t.props.year))
        }
        ,
        t.renderDropdown = function() {
            return ye.createElement(F6e, Xt({
                key: "dropdown"
            }, t.props, {
                onChange: t.onChange,
                onCancel: t.toggleDropdown
            }))
        }
        ,
        t.renderScrollMode = function() {
            var r = t.state.dropdownVisible
              , s = [t.renderReadView(!r)];
            return r && s.unshift(t.renderDropdown()),
            s
        }
        ,
        t.onChange = function(r) {
            t.toggleDropdown(),
            r !== t.props.year && t.props.onChange(r)
        }
        ,
        t.toggleDropdown = function(r) {
            t.setState({
                dropdownVisible: !t.state.dropdownVisible
            }, function() {
                t.props.adjustDateOnChange && t.handleYearChange(t.props.date, r)
            })
        }
        ,
        t.handleYearChange = function(r, s) {
            var i;
            (i = t.onSelect) === null || i === void 0 || i.call(t, r, s),
            t.setOpen()
        }
        ,
        t.onSelect = function(r, s) {
            var i, o;
            (o = (i = t.props).onSelect) === null || o === void 0 || o.call(i, r, s)
        }
        ,
        t.setOpen = function() {
            var r, s;
            (s = (r = t.props).setOpen) === null || s === void 0 || s.call(r, !0)
        }
        ,
        t
    }
    return e.prototype.render = function() {
        var t;
        switch (this.props.dropdownMode) {
        case "scroll":
            t = this.renderScrollMode();
            break;
        case "select":
            t = this.renderSelectMode();
            break
        }
        return ye.createElement("div", {
            className: "react-datepicker__year-dropdown-container react-datepicker__year-dropdown-container--".concat(this.props.dropdownMode)
        }, t)
    }
    ,
    e
}
)(V.Component)
  , z6e = ["react-datepicker__year-select", "react-datepicker__month-select", "react-datepicker__month-year-select"]
  , oG = "react-datepicker-ignore-onclickoutside"
  , $6e = function(n) {
    var e = (n.className || "").split(/\s+/);
    return z6e.some(function(t) {
        return e.indexOf(t) >= 0
    })
}
  , H6e = (function(n) {
    _s(e, n);
    function e(t) {
        var r = n.call(this, t) || this;
        return r.monthContainer = void 0,
        r.handleClickOutside = function(s) {
            r.props.onClickOutside(s)
        }
        ,
        r.setClickOutsideRef = function() {
            return r.containerRef.current
        }
        ,
        r.handleDropdownFocus = function(s) {
            var i, o;
            $6e(s.target) && ((o = (i = r.props).onDropdownFocus) === null || o === void 0 || o.call(i, s))
        }
        ,
        r.getDateInView = function() {
            var s = r.props
              , i = s.preSelection
              , o = s.selected
              , a = s.openToDate
              , l = rG(r.props)
              , u = sG(r.props)
              , d = vn()
              , h = a || o || i;
            return h || (l && Ya(d, l) ? l : u && rd(d, u) ? u : d)
        }
        ,
        r.increaseMonth = function() {
            r.setState(function(s) {
                var i = s.date;
                return {
                    date: ha(i, 1)
                }
            }, function() {
                return r.handleMonthChange(r.state.date)
            })
        }
        ,
        r.decreaseMonth = function() {
            r.setState(function(s) {
                var i = s.date;
                return {
                    date: _f(i, 1)
                }
            }, function() {
                return r.handleMonthChange(r.state.date)
            })
        }
        ,
        r.handleDayClick = function(s, i, o) {
            r.props.onSelect(s, i, o),
            r.props.setPreSelection && r.props.setPreSelection(s)
        }
        ,
        r.handleDayMouseEnter = function(s) {
            r.setState({
                selectingDate: s
            }),
            r.props.onDayMouseEnter && r.props.onDayMouseEnter(s)
        }
        ,
        r.handleMonthMouseLeave = function() {
            r.setState({
                selectingDate: void 0
            }),
            r.props.onMonthMouseLeave && r.props.onMonthMouseLeave()
        }
        ,
        r.handleYearMouseEnter = function(s, i) {
            r.setState({
                selectingDate: La(vn(), i)
            }),
            r.props.onYearMouseEnter && r.props.onYearMouseEnter(s, i)
        }
        ,
        r.handleYearMouseLeave = function(s, i) {
            r.props.onYearMouseLeave && r.props.onYearMouseLeave(s, i)
        }
        ,
        r.handleYearChange = function(s) {
            var i, o, a, l;
            (o = (i = r.props).onYearChange) === null || o === void 0 || o.call(i, s),
            r.setState({
                isRenderAriaLiveMessage: !0
            }),
            r.props.adjustDateOnChange && (r.props.onSelect(s),
            (l = (a = r.props).setOpen) === null || l === void 0 || l.call(a, !0)),
            r.props.setPreSelection && r.props.setPreSelection(s)
        }
        ,
        r.getEnabledPreSelectionDateForMonth = function(s) {
            if (!Mo(s, r.props))
                return s;
            for (var i = Ec(s), o = u6e(s), a = xCe(o, i), l = null, u = 0; u <= a; u++) {
                var d = ca(i, u);
                if (!Mo(d, r.props)) {
                    l = d;
                    break
                }
            }
            return l
        }
        ,
        r.handleMonthChange = function(s) {
            var i, o, a, l = (i = r.getEnabledPreSelectionDateForMonth(s)) !== null && i !== void 0 ? i : s;
            r.handleCustomMonthChange(l),
            r.props.adjustDateOnChange && (r.props.onSelect(l),
            (a = (o = r.props).setOpen) === null || a === void 0 || a.call(o, !0)),
            r.props.setPreSelection && r.props.setPreSelection(l)
        }
        ,
        r.handleCustomMonthChange = function(s) {
            var i, o;
            (o = (i = r.props).onMonthChange) === null || o === void 0 || o.call(i, s),
            r.setState({
                isRenderAriaLiveMessage: !0
            })
        }
        ,
        r.handleMonthYearChange = function(s) {
            r.handleYearChange(s),
            r.handleMonthChange(s)
        }
        ,
        r.changeYear = function(s) {
            r.setState(function(i) {
                var o = i.date;
                return {
                    date: La(o, Number(s))
                }
            }, function() {
                return r.handleYearChange(r.state.date)
            })
        }
        ,
        r.changeMonth = function(s) {
            r.setState(function(i) {
                var o = i.date;
                return {
                    date: Xi(o, Number(s))
                }
            }, function() {
                return r.handleMonthChange(r.state.date)
            })
        }
        ,
        r.changeMonthYear = function(s) {
            r.setState(function(i) {
                var o = i.date;
                return {
                    date: La(Xi(o, Fs(s)), Ut(s))
                }
            }, function() {
                return r.handleMonthYearChange(r.state.date)
            })
        }
        ,
        r.header = function(s) {
            s === void 0 && (s = r.state.date);
            var i = r.props.disabled
              , o = Wu(s, r.props.locale, r.props.calendarStartDay)
              , a = [];
            return r.props.showWeekNumbers && a.push(ye.createElement("div", {
                key: "W",
                className: "react-datepicker__day-name ".concat(i ? "react-datepicker__day-name--disabled" : ""),
                role: "columnheader"
            }, ye.createElement("span", {
                className: "react-datepicker__sr-only"
            }, "Week number"), ye.createElement("span", {
                "aria-hidden": "true"
            }, r.props.weekLabel || "#"))),
            a.concat([0, 1, 2, 3, 4, 5, 6].map(function(l) {
                var u = ca(o, l)
                  , d = r.formatWeekday(u, r.props.locale)
                  , h = r.props.weekDayClassName ? r.props.weekDayClassName(u) : void 0;
                return ye.createElement("div", {
                    key: l,
                    role: "columnheader",
                    className: Jn("react-datepicker__day-name", h, i ? "react-datepicker__day-name--disabled" : "")
                }, ye.createElement("span", {
                    className: "react-datepicker__sr-only"
                }, Kn(u, "EEEE", r.props.locale)), ye.createElement("span", {
                    "aria-hidden": "true"
                }, d))
            }))
        }
        ,
        r.formatWeekday = function(s, i) {
            return r.props.formatWeekDay ? d6e(s, r.props.formatWeekDay, i) : r.props.useWeekdaysShort ? h6e(s, i) : f6e(s, i)
        }
        ,
        r.decreaseYear = function() {
            r.setState(function(s) {
                var i, o = s.date;
                return {
                    date: u0(o, r.props.showYearPicker ? (i = r.props.yearItemNumber) !== null && i !== void 0 ? i : e.defaultProps.yearItemNumber : 1)
                }
            }, function() {
                return r.handleYearChange(r.state.date)
            })
        }
        ,
        r.clearSelectingDate = function() {
            r.setState({
                selectingDate: void 0
            })
        }
        ,
        r.renderPreviousButton = function() {
            var s, i, o;
            if (!r.props.renderCustomHeader) {
                var a = (s = r.props.monthsShown) !== null && s !== void 0 ? s : e.defaultProps.monthsShown, l = r.props.showPreviousMonths ? a - 1 : 0, u = (i = r.props.monthSelectedIn) !== null && i !== void 0 ? i : l, d = _f(r.state.date, u), h;
                switch (!0) {
                case r.props.disabled:
                    h = !0;
                    break;
                case r.props.showMonthYearPicker:
                    h = VP(r.state.date, r.props);
                    break;
                case r.props.showYearPicker:
                    h = b6e(r.state.date, r.props);
                    break;
                case r.props.showQuarterYearPicker:
                    h = g6e(r.state.date, r.props);
                    break;
                default:
                    h = $P(d, r.props);
                    break
                }
                if (!(!((o = r.props.forceShowMonthNavigation) !== null && o !== void 0 ? o : e.defaultProps.forceShowMonthNavigation) && !r.props.showDisabledMonthNavigation && h || r.props.showTimeSelectOnly)) {
                    var p = ["react-datepicker__navigation-icon", "react-datepicker__navigation-icon--previous"]
                      , g = ["react-datepicker__navigation", "react-datepicker__navigation--previous"]
                      , w = r.decreaseMonth;
                    (r.props.showMonthYearPicker || r.props.showQuarterYearPicker || r.props.showYearPicker) && (w = r.decreaseYear),
                    h && r.props.showDisabledMonthNavigation && (g.push("react-datepicker__navigation--previous--disabled"),
                    w = void 0);
                    var b = r.props.showMonthYearPicker || r.props.showQuarterYearPicker || r.props.showYearPicker
                      , v = r.props
                      , S = v.previousMonthButtonLabel
                      , N = S === void 0 ? e.defaultProps.previousMonthButtonLabel : S
                      , _ = v.previousYearButtonLabel
                      , I = _ === void 0 ? e.defaultProps.previousYearButtonLabel : _
                      , k = r.props
                      , B = k.previousMonthAriaLabel
                      , P = B === void 0 ? typeof N == "string" ? N : "Previous Month" : B
                      , M = k.previousYearAriaLabel
                      , R = M === void 0 ? typeof I == "string" ? I : "Previous Year" : M;
                    return ye.createElement("button", {
                        type: "button",
                        className: g.join(" "),
                        onClick: w,
                        onKeyDown: r.props.handleOnKeyDown,
                        "aria-label": b ? R : P
                    }, ye.createElement("span", {
                        className: p.join(" ")
                    }, b ? I : N))
                }
            }
        }
        ,
        r.increaseYear = function() {
            r.setState(function(s) {
                var i, o = s.date;
                return {
                    date: bc(o, r.props.showYearPicker ? (i = r.props.yearItemNumber) !== null && i !== void 0 ? i : e.defaultProps.yearItemNumber : 1)
                }
            }, function() {
                return r.handleYearChange(r.state.date)
            })
        }
        ,
        r.renderNextButton = function() {
            var s;
            if (!r.props.renderCustomHeader) {
                var i;
                switch (!0) {
                case r.props.disabled:
                    i = !0;
                    break;
                case r.props.showMonthYearPicker:
                    i = qP(r.state.date, r.props);
                    break;
                case r.props.showYearPicker:
                    i = w6e(r.state.date, r.props);
                    break;
                case r.props.showQuarterYearPicker:
                    i = y6e(r.state.date, r.props);
                    break;
                default:
                    i = HP(r.state.date, r.props);
                    break
                }
                if (!(!((s = r.props.forceShowMonthNavigation) !== null && s !== void 0 ? s : e.defaultProps.forceShowMonthNavigation) && !r.props.showDisabledMonthNavigation && i || r.props.showTimeSelectOnly)) {
                    var o = ["react-datepicker__navigation", "react-datepicker__navigation--next"]
                      , a = ["react-datepicker__navigation-icon", "react-datepicker__navigation-icon--next"];
                    r.props.showTimeSelect && o.push("react-datepicker__navigation--next--with-time"),
                    r.props.todayButton && o.push("react-datepicker__navigation--next--with-today-button");
                    var l = r.increaseMonth;
                    (r.props.showMonthYearPicker || r.props.showQuarterYearPicker || r.props.showYearPicker) && (l = r.increaseYear),
                    i && r.props.showDisabledMonthNavigation && (o.push("react-datepicker__navigation--next--disabled"),
                    l = void 0);
                    var u = r.props.showMonthYearPicker || r.props.showQuarterYearPicker || r.props.showYearPicker
                      , d = r.props
                      , h = d.nextMonthButtonLabel
                      , p = h === void 0 ? e.defaultProps.nextMonthButtonLabel : h
                      , g = d.nextYearButtonLabel
                      , w = g === void 0 ? e.defaultProps.nextYearButtonLabel : g
                      , b = r.props
                      , v = b.nextMonthAriaLabel
                      , S = v === void 0 ? typeof p == "string" ? p : "Next Month" : v
                      , N = b.nextYearAriaLabel
                      , _ = N === void 0 ? typeof w == "string" ? w : "Next Year" : N;
                    return ye.createElement("button", {
                        type: "button",
                        className: o.join(" "),
                        onClick: l,
                        onKeyDown: r.props.handleOnKeyDown,
                        "aria-label": u ? _ : S
                    }, ye.createElement("span", {
                        className: a.join(" ")
                    }, u ? w : p))
                }
            }
        }
        ,
        r.renderCurrentMonth = function(s) {
            s === void 0 && (s = r.state.date);
            var i = ["react-datepicker__current-month"];
            return r.props.showYearDropdown && i.push("react-datepicker__current-month--hasYearDropdown"),
            r.props.showMonthDropdown && i.push("react-datepicker__current-month--hasMonthDropdown"),
            r.props.showMonthYearDropdown && i.push("react-datepicker__current-month--hasMonthYearDropdown"),
            ye.createElement("h2", {
                className: i.join(" ")
            }, Kn(s, r.props.dateFormat, r.props.locale))
        }
        ,
        r.renderYearDropdown = function(s) {
            if (s === void 0 && (s = !1),
            !(!r.props.showYearDropdown || s))
                return ye.createElement(U6e, Xt({}, e.defaultProps, r.props, {
                    date: r.state.date,
                    onChange: r.changeYear,
                    year: Ut(r.state.date)
                }))
        }
        ,
        r.renderMonthDropdown = function(s) {
            if (s === void 0 && (s = !1),
            !(!r.props.showMonthDropdown || s))
                return ye.createElement(M6e, Xt({}, e.defaultProps, r.props, {
                    month: Fs(r.state.date),
                    onChange: r.changeMonth
                }))
        }
        ,
        r.renderMonthYearDropdown = function(s) {
            if (s === void 0 && (s = !1),
            !(!r.props.showMonthYearDropdown || s))
                return ye.createElement(O6e, Xt({}, e.defaultProps, r.props, {
                    date: r.state.date,
                    onChange: r.changeMonthYear
                }))
        }
        ,
        r.handleTodayButtonClick = function(s) {
            r.props.onSelect(jP(), s),
            r.props.setPreSelection && r.props.setPreSelection(jP())
        }
        ,
        r.renderTodayButton = function() {
            if (!(!r.props.todayButton || r.props.showTimeSelectOnly))
                return ye.createElement("div", {
                    className: "react-datepicker__today-button",
                    onClick: r.handleTodayButtonClick
                }, r.props.todayButton)
        }
        ,
        r.renderDayNamesHeader = function(s) {
            return ye.createElement("div", {
                className: "react-datepicker__day-names",
                role: "row"
            }, r.header(s))
        }
        ,
        r.renderDefaultHeader = function(s) {
            var i = s.monthDate
              , o = s.i;
            return ye.createElement("div", {
                className: "react-datepicker__header ".concat(r.props.showTimeSelect ? "react-datepicker__header--has-time-select" : "")
            }, r.renderCurrentMonth(i), ye.createElement("div", {
                className: "react-datepicker__header__dropdown react-datepicker__header__dropdown--".concat(r.props.dropdownMode),
                onFocus: r.handleDropdownFocus
            }, r.renderMonthDropdown(o !== 0), r.renderMonthYearDropdown(o !== 0), r.renderYearDropdown(o !== 0)))
        }
        ,
        r.renderCustomHeader = function(s) {
            var i, o, a = s.monthDate, l = s.i;
            if (r.props.showTimeSelect && !r.state.monthContainer || r.props.showTimeSelectOnly)
                return null;
            var u = r.props, d = u.showYearPicker, h = u.yearItemNumber, p;
            if (d) {
                var g = fc(a, h)
                  , w = g.startPeriod
                  , b = g.endPeriod;
                p = {
                    startYear: w,
                    endYear: b
                }
            }
            var v = $P(r.state.date, r.props)
              , S = HP(r.state.date, r.props)
              , N = VP(r.state.date, r.props)
              , _ = qP(r.state.date, r.props);
            return ye.createElement("div", {
                className: "react-datepicker__header react-datepicker__header--custom",
                onFocus: r.props.onDropdownFocus
            }, (o = (i = r.props).renderCustomHeader) === null || o === void 0 ? void 0 : o.call(i, Xt(Xt(Xt({}, r.state), d && {
                visibleYearsRange: p
            }), {
                customHeaderCount: l,
                monthDate: a,
                changeMonth: r.changeMonth,
                changeYear: r.changeYear,
                decreaseMonth: r.decreaseMonth,
                increaseMonth: r.increaseMonth,
                decreaseYear: r.decreaseYear,
                increaseYear: r.increaseYear,
                prevMonthButtonDisabled: v,
                nextMonthButtonDisabled: S,
                prevYearButtonDisabled: N,
                nextYearButtonDisabled: _
            })))
        }
        ,
        r.renderYearHeader = function(s) {
            var i = s.monthDate
              , o = r.props
              , a = o.showYearPicker
              , l = o.yearItemNumber
              , u = l === void 0 ? e.defaultProps.yearItemNumber : l
              , d = fc(i, u)
              , h = d.startPeriod
              , p = d.endPeriod;
            return ye.createElement("div", {
                className: "react-datepicker__header react-datepicker-year-header"
            }, a ? "".concat(h, " - ").concat(p) : Ut(i))
        }
        ,
        r.renderHeader = function(s) {
            var i = s.monthDate
              , o = s.i
              , a = o === void 0 ? 0 : o
              , l = {
                monthDate: i,
                i: a
            };
            switch (!0) {
            case r.props.renderCustomHeader !== void 0:
                return r.renderCustomHeader(l);
            case (r.props.showMonthYearPicker || r.props.showQuarterYearPicker || r.props.showYearPicker):
                return r.renderYearHeader(l);
            default:
                return r.renderDefaultHeader(l)
            }
        }
        ,
        r.renderMonths = function() {
            var s, i;
            if (!(r.props.showTimeSelectOnly || r.props.showYearPicker)) {
                for (var o = [], a = (s = r.props.monthsShown) !== null && s !== void 0 ? s : e.defaultProps.monthsShown, l = r.props.showPreviousMonths ? a - 1 : 0, u = r.props.showMonthYearPicker || r.props.showQuarterYearPicker ? bc(r.state.date, l) : _f(r.state.date, l), d = (i = r.props.monthSelectedIn) !== null && i !== void 0 ? i : l, h = 0; h < a; ++h) {
                    var p = h - d + l
                      , g = r.props.showMonthYearPicker || r.props.showQuarterYearPicker ? bc(u, p) : ha(u, p)
                      , w = "month-".concat(h)
                      , b = h < a - 1
                      , v = h > 0;
                    o.push(ye.createElement("div", {
                        key: w,
                        ref: function(S) {
                            r.monthContainer = S ?? void 0
                        },
                        className: "react-datepicker__month-container"
                    }, r.renderHeader({
                        monthDate: g,
                        i: h
                    }), ye.createElement(T6e, Xt({}, e.defaultProps, r.props, {
                        containerRef: r.containerRef,
                        ariaLabelPrefix: r.props.monthAriaLabelPrefix,
                        day: g,
                        onDayClick: r.handleDayClick,
                        handleOnKeyDown: r.props.handleOnDayKeyDown,
                        handleOnMonthKeyDown: r.props.handleOnKeyDown,
                        onDayMouseEnter: r.handleDayMouseEnter,
                        onMouseLeave: r.handleMonthMouseLeave,
                        orderInDisplay: h,
                        selectingDate: r.state.selectingDate,
                        monthShowsDuplicateDaysEnd: b,
                        monthShowsDuplicateDaysStart: v,
                        dayNamesHeader: r.renderDayNamesHeader(g)
                    }))))
                }
                return o
            }
        }
        ,
        r.renderYears = function() {
            if (!r.props.showTimeSelectOnly && r.props.showYearPicker)
                return ye.createElement("div", {
                    className: "react-datepicker__year--container"
                }, r.renderHeader({
                    monthDate: r.state.date
                }), ye.createElement(j6e, Xt({}, e.defaultProps, r.props, {
                    selectingDate: r.state.selectingDate,
                    date: r.state.date,
                    onDayClick: r.handleDayClick,
                    clearSelectingDate: r.clearSelectingDate,
                    onYearMouseEnter: r.handleYearMouseEnter,
                    onYearMouseLeave: r.handleYearMouseLeave
                })))
        }
        ,
        r.renderTimeSection = function() {
            if (r.props.showTimeSelect && (r.state.monthContainer || r.props.showTimeSelectOnly))
                return ye.createElement(P6e, Xt({}, e.defaultProps, r.props, {
                    onChange: r.props.onTimeChange,
                    format: r.props.timeFormat,
                    intervals: r.props.timeIntervals,
                    monthRef: r.state.monthContainer
                }))
        }
        ,
        r.renderInputTimeSection = function() {
            var s = r.props.selected ? new Date(r.props.selected) : void 0
              , i = s && zx(s) && !!r.props.selected
              , o = i ? "".concat(WP(s.getHours()), ":").concat(WP(s.getMinutes())) : "";
            if (r.props.showTimeInput)
                return ye.createElement(C6e, Xt({}, e.defaultProps, r.props, {
                    date: s,
                    timeString: o,
                    onChange: r.props.onTimeChange
                }))
        }
        ,
        r.renderAriaLiveRegion = function() {
            var s, i = fc(r.state.date, (s = r.props.yearItemNumber) !== null && s !== void 0 ? s : e.defaultProps.yearItemNumber), o = i.startPeriod, a = i.endPeriod, l;
            return r.props.showYearPicker ? l = "".concat(o, " - ").concat(a) : r.props.showMonthYearPicker || r.props.showQuarterYearPicker ? l = Ut(r.state.date) : l = "".concat(_k(Fs(r.state.date), r.props.locale), " ").concat(Ut(r.state.date)),
            ye.createElement("span", {
                role: "alert",
                "aria-live": "polite",
                className: "react-datepicker__aria-live"
            }, r.state.isRenderAriaLiveMessage && l)
        }
        ,
        r.renderChildren = function() {
            if (r.props.children)
                return ye.createElement("div", {
                    className: "react-datepicker__children-container"
                }, r.props.children)
        }
        ,
        r.containerRef = V.createRef(),
        r.state = {
            date: r.getDateInView(),
            selectingDate: void 0,
            monthContainer: void 0,
            isRenderAriaLiveMessage: !1
        },
        r
    }
    return Object.defineProperty(e, "defaultProps", {
        get: function() {
            return {
                monthsShown: 1,
                forceShowMonthNavigation: !1,
                outsideClickIgnoreClass: oG,
                timeCaption: "Time",
                previousYearButtonLabel: "Previous Year",
                nextYearButtonLabel: "Next Year",
                previousMonthButtonLabel: "Previous Month",
                nextMonthButtonLabel: "Next Month",
                yearItemNumber: nb
            }
        },
        enumerable: !1,
        configurable: !0
    }),
    e.prototype.componentDidMount = function() {
        var t = this;
        this.props.showTimeSelect && (this.assignMonthContainer = (function() {
            t.setState({
                monthContainer: t.monthContainer
            })
        }
        )())
    }
    ,
    e.prototype.componentDidUpdate = function(t) {
        var r = this;
        if (this.props.preSelection && (!Kt(this.props.preSelection, t.preSelection) || this.props.monthSelectedIn !== t.monthSelectedIn)) {
            var s = !Gs(this.state.date, this.props.preSelection);
            this.setState({
                date: this.props.preSelection
            }, function() {
                return s && r.handleCustomMonthChange(r.state.date)
            })
        } else
            this.props.openToDate && !Kt(this.props.openToDate, t.openToDate) && this.setState({
                date: this.props.openToDate
            })
    }
    ,
    e.prototype.render = function() {
        var t = this.props.container || r6e;
        return ye.createElement(Ux, {
            onClickOutside: this.handleClickOutside,
            style: {
                display: "contents"
            },
            ignoreClass: this.props.outsideClickIgnoreClass
        }, ye.createElement("div", {
            style: {
                display: "contents"
            },
            ref: this.containerRef
        }, ye.createElement(t, {
            className: Jn("react-datepicker", this.props.className, {
                "react-datepicker--time-only": this.props.showTimeSelectOnly
            }),
            showTime: this.props.showTimeSelect || this.props.showTimeInput,
            showTimeSelectOnly: this.props.showTimeSelectOnly
        }, this.renderAriaLiveRegion(), this.renderPreviousButton(), this.renderNextButton(), this.renderMonths(), this.renderYears(), this.renderTodayButton(), this.renderTimeSection(), this.renderInputTimeSection(), this.renderChildren())))
    }
    ,
    e
}
)(V.Component)
  , V6e = function(n) {
    var e = n.icon
      , t = n.className
      , r = t === void 0 ? "" : t
      , s = n.onClick
      , i = "react-datepicker__calendar-icon";
    if (typeof e == "string")
        return ye.createElement("i", {
            className: "".concat(i, " ").concat(e, " ").concat(r),
            "aria-hidden": "true",
            onClick: s
        });
    if (ye.isValidElement(e)) {
        var o = e;
        return ye.cloneElement(o, {
            className: "".concat(o.props.className || "", " ").concat(i, " ").concat(r),
            onClick: function(a) {
                typeof o.props.onClick == "function" && o.props.onClick(a),
                typeof s == "function" && s(a)
            }
        })
    }
    return ye.createElement("svg", {
        className: "".concat(i, " ").concat(r),
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 448 512",
        onClick: s
    }, ye.createElement("path", {
        d: "M96 32V64H48C21.5 64 0 85.5 0 112v48H448V112c0-26.5-21.5-48-48-48H352V32c0-17.7-14.3-32-32-32s-32 14.3-32 32V64H160V32c0-17.7-14.3-32-32-32S96 14.3 96 32zM448 192H0V464c0 26.5 21.5 48 48 48H400c26.5 0 48-21.5 48-48V192z"
    }))
}
  , aG = (function(n) {
    _s(e, n);
    function e(t) {
        var r = n.call(this, t) || this;
        return r.portalRoot = null,
        r.el = document.createElement("div"),
        r
    }
    return e.prototype.componentDidMount = function() {
        this.portalRoot = (this.props.portalHost || document).getElementById(this.props.portalId),
        this.portalRoot || (this.portalRoot = document.createElement("div"),
        this.portalRoot.setAttribute("id", this.props.portalId),
        (this.props.portalHost || document.body).appendChild(this.portalRoot)),
        this.portalRoot.appendChild(this.el)
    }
    ,
    e.prototype.componentWillUnmount = function() {
        this.portalRoot && this.portalRoot.removeChild(this.el)
    }
    ,
    e.prototype.render = function() {
        return $Q.createPortal(this.props.children, this.el)
    }
    ,
    e
}
)(V.Component)
  , q6e = "[tabindex], a, button, input, select, textarea"
  , G6e = function(n) {
    return (n instanceof HTMLAnchorElement || !n.disabled) && n.tabIndex !== -1
}
  , lG = (function(n) {
    _s(e, n);
    function e(t) {
        var r = n.call(this, t) || this;
        return r.getTabChildren = function() {
            var s;
            return Array.prototype.slice.call((s = r.tabLoopRef.current) === null || s === void 0 ? void 0 : s.querySelectorAll(q6e), 1, -1).filter(G6e)
        }
        ,
        r.handleFocusStart = function() {
            var s = r.getTabChildren();
            s && s.length > 1 && s[s.length - 1].focus()
        }
        ,
        r.handleFocusEnd = function() {
            var s = r.getTabChildren();
            s && s.length > 1 && s[0].focus()
        }
        ,
        r.tabLoopRef = V.createRef(),
        r
    }
    return e.prototype.render = function() {
        var t;
        return ((t = this.props.enableTabLoop) !== null && t !== void 0 ? t : e.defaultProps.enableTabLoop) ? ye.createElement("div", {
            className: "react-datepicker__tab-loop",
            ref: this.tabLoopRef
        }, ye.createElement("div", {
            className: "react-datepicker__tab-loop__start",
            tabIndex: 0,
            onFocus: this.handleFocusStart
        }), this.props.children, ye.createElement("div", {
            className: "react-datepicker__tab-loop__end",
            tabIndex: 0,
            onFocus: this.handleFocusEnd
        })) : this.props.children
    }
    ,
    e.defaultProps = {
        enableTabLoop: !0
    },
    e
}
)(V.Component);
function W6e(n) {
    function e(t) {
        var r, s = typeof t.hidePopper == "boolean" ? t.hidePopper : !0, i = V.useRef(null), o = n6e(Xt({
            open: !s,
            whileElementsMounted: Rke,
            placement: t.popperPlacement,
            middleware: Ka([Hke({
                padding: 15
            }), $ke(10), Vke({
                element: i
            })], (r = t.popperModifiers) !== null && r !== void 0 ? r : [], !0)
        }, t.popperProps)), a = Xt(Xt({}, t), {
            hidePopper: s,
            popperProps: Xt(Xt({}, o), {
                arrowRef: i
            })
        });
        return ye.createElement(n, Xt({}, a))
    }
    return e.displayName = "withFloating(".concat(n.displayName || n.name || "Component", ")"),
    e
}
var Y6e = function(n) {
    var e = n.className
      , t = n.wrapperClassName
      , r = n.hidePopper
      , s = r === void 0 ? !0 : r
      , i = n.popperComponent
      , o = n.targetComponent
      , a = n.enableTabLoop
      , l = n.popperOnKeyDown
      , u = n.portalId
      , d = n.portalHost
      , h = n.popperProps
      , p = n.showArrow
      , g = void 0;
    if (!s) {
        var w = Jn("react-datepicker-popper", e);
        g = ye.createElement(lG, {
            enableTabLoop: a
        }, ye.createElement("div", {
            ref: h.refs.setFloating,
            style: h.floatingStyles,
            className: w,
            "data-placement": h.placement,
            onKeyDown: l
        }, i, p && ye.createElement(Kke, {
            ref: h.arrowRef,
            context: h.context,
            fill: "currentColor",
            strokeWidth: 1,
            height: 8,
            width: 16,
            style: {
                transform: "translateY(-1px)"
            },
            className: "react-datepicker__triangle"
        })))
    }
    n.popperContainer && (g = V.createElement(n.popperContainer, {}, g)),
    u && !s && (g = ye.createElement(aG, {
        portalId: u,
        portalHost: d
    }, g));
    var b = Jn("react-datepicker-wrapper", t);
    return ye.createElement(ye.Fragment, null, ye.createElement("div", {
        ref: h.refs.setReference,
        className: b
    }, o), g)
}
  , K6e = W6e(Y6e);
function X6e(n, e) {
    return n && e ? Fs(n) !== Fs(e) || Ut(n) !== Ut(e) : n !== e
}
var MA = "Date input not valid."
  , Q6e = (function(n) {
    _s(e, n);
    function e(t) {
        var r = n.call(this, t) || this;
        return r.calendar = null,
        r.input = null,
        r.getPreSelection = function() {
            return r.props.openToDate ? r.props.openToDate : r.props.selectsEnd && r.props.startDate ? r.props.startDate : r.props.selectsStart && r.props.endDate ? r.props.endDate : vn()
        }
        ,
        r.modifyHolidays = function() {
            var s;
            return (s = r.props.holidays) === null || s === void 0 ? void 0 : s.reduce(function(i, o) {
                var a = new Date(o.date);
                return zx(a) ? Ka(Ka([], i, !0), [Xt(Xt({}, o), {
                    date: a
                })], !1) : i
            }, [])
        }
        ,
        r.calcInitialState = function() {
            var s, i = r.getPreSelection(), o = rG(r.props), a = sG(r.props), l = o && Ya(i, t2(o)) ? o : a && rd(i, LP(a)) ? a : i;
            return {
                open: r.props.startOpen || !1,
                preventFocus: !1,
                inputValue: null,
                preSelection: (s = r.props.selectsRange ? r.props.startDate : r.props.selected) !== null && s !== void 0 ? s : l,
                highlightDates: GP(r.props.highlightDates),
                focused: !1,
                shouldFocusDayInline: !1,
                isRenderAriaLiveMessage: !1,
                wasHidden: !1
            }
        }
        ,
        r.getInputValue = function() {
            var s, i = r.props, o = i.locale, a = i.startDate, l = i.endDate, u = i.rangeSeparator, d = i.selected, h = i.selectedDates, p = i.selectsMultiple, g = i.selectsRange, w = i.value, b = (s = r.props.dateFormat) !== null && s !== void 0 ? s : e.defaultProps.dateFormat, v = r.state.inputValue;
            return typeof w == "string" ? w : typeof v == "string" ? v : g ? i6e(a, l, {
                dateFormat: b,
                locale: o,
                rangeSeparator: u
            }) : p ? o6e(h ?? [], {
                dateFormat: b,
                locale: o
            }) : Wi(d, {
                dateFormat: b,
                locale: o
            })
        }
        ,
        r.resetHiddenStatus = function() {
            r.setState(Xt(Xt({}, r.state), {
                wasHidden: !1
            }))
        }
        ,
        r.setHiddenStatus = function() {
            r.setState(Xt(Xt({}, r.state), {
                wasHidden: !0
            }))
        }
        ,
        r.setHiddenStateOnVisibilityHidden = function() {
            document.visibilityState === "hidden" && r.setHiddenStatus()
        }
        ,
        r.clearPreventFocusTimeout = function() {
            r.preventFocusTimeout && clearTimeout(r.preventFocusTimeout)
        }
        ,
        r.setFocus = function() {
            var s, i;
            (i = (s = r.input) === null || s === void 0 ? void 0 : s.focus) === null || i === void 0 || i.call(s, {
                preventScroll: !0
            })
        }
        ,
        r.setBlur = function() {
            var s, i;
            (i = (s = r.input) === null || s === void 0 ? void 0 : s.blur) === null || i === void 0 || i.call(s),
            r.cancelFocusInput()
        }
        ,
        r.deferBlur = function() {
            requestAnimationFrame(function() {
                r.setBlur()
            })
        }
        ,
        r.setOpen = function(s, i) {
            i === void 0 && (i = !1),
            r.setState({
                open: s,
                preSelection: s && r.state.open ? r.state.preSelection : r.calcInitialState().preSelection,
                lastPreSelectChange: BA
            }, function() {
                s || r.setState(function(o) {
                    return {
                        focused: i ? o.focused : !1
                    }
                }, function() {
                    !i && r.deferBlur(),
                    r.setState({
                        inputValue: null
                    })
                })
            })
        }
        ,
        r.inputOk = function() {
            return wc(r.state.preSelection)
        }
        ,
        r.isCalendarOpen = function() {
            return r.props.open === void 0 ? r.state.open && !r.props.disabled && !r.props.readOnly : r.props.open
        }
        ,
        r.handleFocus = function(s) {
            var i, o, a = r.state.wasHidden, l = a ? r.state.open : !0;
            a && r.resetHiddenStatus(),
            r.state.preventFocus || ((o = (i = r.props).onFocus) === null || o === void 0 || o.call(i, s),
            l && !r.props.preventOpenOnFocus && !r.props.readOnly && r.setOpen(!0)),
            r.setState({
                focused: !0
            })
        }
        ,
        r.sendFocusBackToInput = function() {
            r.preventFocusTimeout && r.clearPreventFocusTimeout(),
            r.setState({
                preventFocus: !0
            }, function() {
                r.preventFocusTimeout = setTimeout(function() {
                    r.setFocus(),
                    r.setState({
                        preventFocus: !1
                    })
                })
            })
        }
        ,
        r.cancelFocusInput = function() {
            clearTimeout(r.inputFocusTimeout),
            r.inputFocusTimeout = void 0
        }
        ,
        r.deferFocusInput = function() {
            r.cancelFocusInput(),
            r.inputFocusTimeout = setTimeout(function() {
                return r.setFocus()
            }, 1)
        }
        ,
        r.handleDropdownFocus = function() {
            r.cancelFocusInput()
        }
        ,
        r.resetInputValue = function() {
            r.setState(Xt(Xt({}, r.state), {
                inputValue: null
            }))
        }
        ,
        r.handleBlur = function(s) {
            var i, o;
            (!r.state.open || r.props.withPortal || r.props.showTimeInput) && ((o = (i = r.props).onBlur) === null || o === void 0 || o.call(i, s)),
            r.resetInputValue(),
            r.state.open && r.props.open === !1 && r.setOpen(!1),
            r.setState({
                focused: !1
            })
        }
        ,
        r.handleCalendarClickOutside = function(s) {
            var i, o;
            r.props.inline || r.setOpen(!1),
            (o = (i = r.props).onClickOutside) === null || o === void 0 || o.call(i, s),
            r.props.withPortal && s.preventDefault()
        }
        ,
        r.handleChange = function() {
            for (var s, i, o, a, l, u = [], d = 0; d < arguments.length; d++)
                u[d] = arguments[d];
            var h = u[0];
            if (!(r.props.onChangeRaw && (r.props.onChangeRaw.apply(r, u),
            !h || typeof h.isDefaultPrevented != "function" || h.isDefaultPrevented()))) {
                r.setState({
                    inputValue: h?.target instanceof HTMLInputElement ? h.target.value : null,
                    lastPreSelectChange: Z6e
                });
                var p = r.props
                  , g = p.selectsRange
                  , w = p.startDate
                  , b = p.endDate
                  , v = (s = r.props.dateFormat) !== null && s !== void 0 ? s : e.defaultProps.dateFormat
                  , S = (i = r.props.strictParsing) !== null && i !== void 0 ? i : e.defaultProps.strictParsing
                  , N = h?.target instanceof HTMLInputElement ? h.target.value : "";
                if (g) {
                    var _ = r.props.rangeSeparator
                      , I = _.trim()
                      , k = N.split(v.includes(I) ? _ : I, 2).map(function(j) {
                        return j.trim()
                    })
                      , B = k[0]
                      , P = k[1]
                      , M = NA(B ?? "", v, r.props.locale, S)
                      , R = M ? NA(P ?? "", v, r.props.locale, S) : null
                      , L = w?.getTime() !== M?.getTime()
                      , q = b?.getTime() !== R?.getTime();
                    if (!L && !q || M && Mo(M, r.props) || R && Mo(R, r.props))
                        return;
                    (a = (o = r.props).onChange) === null || a === void 0 || a.call(o, [M, R], h)
                } else {
                    var H = NA(N, v, r.props.locale, S, (l = r.props.selected) !== null && l !== void 0 ? l : void 0);
                    (H || !N) && r.setSelected(H, h, !0)
                }
            }
        }
        ,
        r.handleSelect = function(s, i, o) {
            var a;
            if (!r.props.readOnly) {
                var l = r.props
                  , u = l.selectsRange
                  , d = l.startDate
                  , h = l.endDate
                  , p = l.locale
                  , g = l.swapRange
                  , w = (a = r.props.dateFormat) !== null && a !== void 0 ? a : e.defaultProps.dateFormat
                  , b = !u || d && !h && (g || !TA(s, d));
                if (r.props.shouldCloseOnSelect && !r.props.showTimeSelect && b && r.sendFocusBackToInput(),
                r.props.onChangeRaw) {
                    var v = Wi(s, {
                        dateFormat: w,
                        locale: p
                    });
                    r.props.onChangeRaw(i, {
                        date: s,
                        formattedDate: v
                    })
                }
                r.setSelected(s, i, !1, o),
                r.props.showDateSelect && r.setState({
                    isRenderAriaLiveMessage: !0
                }),
                !r.props.shouldCloseOnSelect || r.props.showTimeSelect ? r.setPreSelection(s) : b && r.setOpen(!1)
            }
        }
        ,
        r.setSelected = function(s, i, o, a) {
            var l, u, d = s;
            if (r.props.showYearPicker) {
                if (d !== null && n2(Ut(d), r.props))
                    return
            } else if (r.props.showMonthYearPicker) {
                if (d !== null && nG(d, r.props))
                    return
            } else if (d !== null && Mo(d, r.props))
                return;
            var h = r.props
              , p = h.onChange
              , g = h.selectsRange
              , w = h.startDate
              , b = h.endDate
              , v = h.selectsMultiple
              , S = h.selectedDates
              , N = h.minTime
              , _ = h.swapRange;
            if (!yf(r.props.selected, d) || r.props.allowSameDay || g || v)
                if (d !== null && (r.props.selected && (!o || !r.props.showTimeSelect && !r.props.showTimeSelectOnly && !r.props.showTimeInput) && (d = DA(d, {
                    hour: vc(r.props.selected),
                    minute: xc(r.props.selected),
                    second: Gu(r.props.selected)
                })),
                !o && (r.props.showTimeSelect || r.props.showTimeSelectOnly) && N && (d = DA(d, {
                    hour: N.getHours(),
                    minute: N.getMinutes(),
                    second: N.getSeconds()
                })),
                r.props.inline || r.setState({
                    preSelection: d
                }),
                r.props.focusSelectedMonth || r.setState({
                    monthSelectedIn: a
                })),
                g) {
                    var I = !w && !b
                      , k = w && !b
                      , B = !w && !!b
                      , P = w && b;
                    I ? p?.([d, null], i) : k ? d === null ? p?.([null, null], i) : TA(d, w) ? p?.(_ ? [d, w] : [d, null], i) : p?.([w, d], i) : B && (d && TA(d, b) ? p?.([d, b], i) : p?.([d, null], i)),
                    P && p?.([d, null], i)
                } else if (v) {
                    if (d !== null)
                        if (!S?.length)
                            p?.([d], i);
                        else {
                            var M = S.some(function(L) {
                                return Kt(L, d)
                            });
                            if (M) {
                                var R = S.filter(function(L) {
                                    return !Kt(L, d)
                                });
                                p?.(R, i)
                            } else
                                p?.(Ka(Ka([], S, !0), [d], !1), i)
                        }
                } else
                    p?.(d, i);
            o || ((u = (l = r.props).onSelect) === null || u === void 0 || u.call(l, d, i),
            r.setState({
                inputValue: null
            }))
        }
        ,
        r.setPreSelection = function(s) {
            if (!r.props.readOnly) {
                var i = wc(r.props.minDate)
                  , o = wc(r.props.maxDate)
                  , a = !0;
                if (s) {
                    var l = t2(s);
                    if (i && o)
                        a = Gd(s, r.props.minDate, r.props.maxDate);
                    else if (i) {
                        var u = t2(r.props.minDate);
                        a = rd(s, u) || yf(l, u)
                    } else if (o) {
                        var d = LP(r.props.maxDate);
                        a = Ya(s, d) || yf(l, d)
                    }
                }
                a && r.setState({
                    preSelection: s
                })
            }
        }
        ,
        r.toggleCalendar = function() {
            r.setOpen(!r.state.open)
        }
        ,
        r.handleTimeChange = function(s) {
            var i, o;
            if (!(r.props.selectsRange || r.props.selectsMultiple)) {
                var a = r.props.selected ? r.props.selected : r.getPreSelection()
                  , l = r.props.selected ? s : DA(a, {
                    hour: vc(s),
                    minute: xc(s)
                });
                r.setState({
                    preSelection: l
                }),
                (o = (i = r.props).onChange) === null || o === void 0 || o.call(i, l),
                r.props.shouldCloseOnSelect && !r.props.showTimeInput && (r.sendFocusBackToInput(),
                r.setOpen(!1)),
                r.props.showTimeInput && r.setOpen(!0),
                (r.props.showTimeSelectOnly || r.props.showTimeSelect) && r.setState({
                    isRenderAriaLiveMessage: !0
                }),
                r.setState({
                    inputValue: null
                })
            }
        }
        ,
        r.onInputClick = function() {
            var s, i;
            !r.props.disabled && !r.props.readOnly && r.setOpen(!0),
            (i = (s = r.props).onInputClick) === null || i === void 0 || i.call(s)
        }
        ,
        r.onInputKeyDown = function(s) {
            var i, o, a, l, u, d;
            (o = (i = r.props).onKeyDown) === null || o === void 0 || o.call(i, s);
            var h = s.key;
            if (!r.state.open && !r.props.inline && !r.props.preventOpenOnFocus) {
                (h === Ye.ArrowDown || h === Ye.ArrowUp || h === Ye.Enter) && ((a = r.onInputClick) === null || a === void 0 || a.call(r));
                return
            }
            if (r.state.open) {
                if (h === Ye.ArrowDown || h === Ye.ArrowUp) {
                    s.preventDefault();
                    var p = r.props.showTimeSelectOnly ? ".react-datepicker__time-list-item[tabindex='0']" : r.props.showWeekPicker && r.props.showWeekNumbers ? '.react-datepicker__week-number[tabindex="0"]' : r.props.showFullMonthYearPicker || r.props.showMonthYearPicker ? '.react-datepicker__month-text[tabindex="0"]' : '.react-datepicker__day[tabindex="0"]'
                      , g = ((l = r.calendar) === null || l === void 0 ? void 0 : l.containerRef.current)instanceof Element && r.calendar.containerRef.current.querySelector(p);
                    g instanceof HTMLElement && g.focus({
                        preventScroll: !0
                    });
                    return
                }
                var w = vn(r.state.preSelection);
                h === Ye.Enter ? (s.preventDefault(),
                s.target.blur(),
                r.inputOk() && r.state.lastPreSelectChange === BA ? (r.handleSelect(w, s),
                !r.props.shouldCloseOnSelect && r.setPreSelection(w)) : r.setOpen(!1)) : h === Ye.Escape ? (s.preventDefault(),
                s.target.blur(),
                r.sendFocusBackToInput(),
                r.setOpen(!1)) : h === Ye.Tab && r.setOpen(!1),
                r.inputOk() || (d = (u = r.props).onInputError) === null || d === void 0 || d.call(u, {
                    code: 1,
                    msg: MA
                })
            }
        }
        ,
        r.onPortalKeyDown = function(s) {
            var i = s.key;
            i === Ye.Escape && (s.preventDefault(),
            r.setState({
                preventFocus: !0
            }, function() {
                r.setOpen(!1),
                setTimeout(function() {
                    r.setFocus(),
                    r.setState({
                        preventFocus: !1
                    })
                })
            }))
        }
        ,
        r.onDayKeyDown = function(s) {
            var i, o, a, l, u, d, h = r.props, p = h.minDate, g = h.maxDate, w = h.disabledKeyboardNavigation, b = h.showWeekPicker, v = h.shouldCloseOnSelect, S = h.locale, N = h.calendarStartDay, _ = h.adjustDateOnChange, I = h.inline;
            if ((o = (i = r.props).onKeyDown) === null || o === void 0 || o.call(i, s),
            !w) {
                var k = s.key
                  , B = s.shiftKey
                  , P = vn(r.state.preSelection)
                  , M = function(E, C) {
                    var O = C;
                    switch (E) {
                    case Ye.ArrowRight:
                        O = b ? ev(C, 1) : ca(C, 1);
                        break;
                    case Ye.ArrowLeft:
                        O = b ? AP(C) : x_e(C);
                        break;
                    case Ye.ArrowUp:
                        O = AP(C);
                        break;
                    case Ye.ArrowDown:
                        O = ev(C, 1);
                        break;
                    case Ye.PageUp:
                        O = B ? u0(C, 1) : _f(C, 1);
                        break;
                    case Ye.PageDown:
                        O = B ? bc(C, 1) : ha(C, 1);
                        break;
                    case Ye.Home:
                        O = Wu(C, S, N);
                        break;
                    case Ye.End:
                        O = c6e(C);
                        break
                    }
                    return O
                }
                  , R = function(E, C) {
                    for (var O = 40, z = E, G = !1, Y = 0, $ = M(E, C); !G; ) {
                        if (Y >= O) {
                            $ = C;
                            break
                        }
                        p && $ < p && (z = Ye.ArrowRight,
                        $ = Mo(p, r.props) ? M(z, $) : p),
                        g && $ > g && (z = Ye.ArrowLeft,
                        $ = Mo(g, r.props) ? M(z, $) : g),
                        Mo($, r.props) ? ((z === Ye.PageUp || z === Ye.Home) && (z = Ye.ArrowRight),
                        (z === Ye.PageDown || z === Ye.End) && (z = Ye.ArrowLeft),
                        $ = M(z, $)) : G = !0,
                        Y++
                    }
                    return $
                };
                if (k === Ye.Enter) {
                    s.preventDefault(),
                    r.handleSelect(P, s),
                    !v && r.setPreSelection(P);
                    return
                } else if (k === Ye.Escape) {
                    s.preventDefault(),
                    r.setOpen(!1),
                    r.inputOk() || (l = (a = r.props).onInputError) === null || l === void 0 || l.call(a, {
                        code: 1,
                        msg: MA
                    });
                    return
                }
                var L = null;
                switch (k) {
                case Ye.ArrowLeft:
                case Ye.ArrowRight:
                case Ye.ArrowUp:
                case Ye.ArrowDown:
                case Ye.PageUp:
                case Ye.PageDown:
                case Ye.Home:
                case Ye.End:
                    L = R(k, P);
                    break
                }
                if (!L) {
                    (d = (u = r.props).onInputError) === null || d === void 0 || d.call(u, {
                        code: 1,
                        msg: MA
                    });
                    return
                }
                if (s.preventDefault(),
                r.setState({
                    lastPreSelectChange: BA
                }),
                _ && r.setSelected(L),
                r.setPreSelection(L),
                I) {
                    var q = Fs(P)
                      , H = Fs(L)
                      , j = Ut(P)
                      , A = Ut(L);
                    q !== H || j !== A ? r.setState({
                        shouldFocusDayInline: !0
                    }) : r.setState({
                        shouldFocusDayInline: !1
                    })
                }
            }
        }
        ,
        r.onPopperKeyDown = function(s) {
            var i = s.key;
            i === Ye.Escape && (s.preventDefault(),
            r.sendFocusBackToInput(),
            r.setOpen(!1))
        }
        ,
        r.onClearClick = function(s) {
            s && s.preventDefault && s.preventDefault(),
            r.sendFocusBackToInput();
            var i = r.props
              , o = i.selectsRange
              , a = i.onChange;
            a?.(o ? [null, null] : null, s),
            r.setState({
                inputValue: null
            })
        }
        ,
        r.clear = function() {
            r.onClearClick()
        }
        ,
        r.onScroll = function(s) {
            typeof r.props.closeOnScroll == "boolean" && r.props.closeOnScroll ? (s.target === document || s.target === document.documentElement || s.target === document.body) && r.setOpen(!1) : typeof r.props.closeOnScroll == "function" && r.props.closeOnScroll(s) && r.setOpen(!1)
        }
        ,
        r.renderCalendar = function() {
            var s, i;
            return !r.props.inline && !r.isCalendarOpen() ? null : ye.createElement(H6e, Xt({
                showMonthYearDropdown: void 0,
                ref: function(o) {
                    r.calendar = o
                }
            }, r.props, r.state, {
                setOpen: r.setOpen,
                dateFormat: (s = r.props.dateFormatCalendar) !== null && s !== void 0 ? s : e.defaultProps.dateFormatCalendar,
                onSelect: r.handleSelect,
                onClickOutside: r.handleCalendarClickOutside,
                holidays: x6e(r.modifyHolidays()),
                outsideClickIgnoreClass: r.props.outsideClickIgnoreClass,
                onDropdownFocus: r.handleDropdownFocus,
                onTimeChange: r.handleTimeChange,
                className: r.props.calendarClassName,
                container: r.props.calendarContainer,
                handleOnKeyDown: r.props.onKeyDown,
                handleOnDayKeyDown: r.onDayKeyDown,
                setPreSelection: r.setPreSelection,
                dropdownMode: (i = r.props.dropdownMode) !== null && i !== void 0 ? i : e.defaultProps.dropdownMode
            }), r.props.children)
        }
        ,
        r.renderAriaLiveRegion = function() {
            var s, i = r.props.locale, o = (s = r.props.dateFormat) !== null && s !== void 0 ? s : e.defaultProps.dateFormat, a = r.props.showTimeInput || r.props.showTimeSelect, l = a ? "PPPPp" : "PPPP", u;
            return r.props.selectsRange ? u = "Selected start date: ".concat(Wi(r.props.startDate, {
                dateFormat: l,
                locale: i
            }), ". ").concat(r.props.endDate ? "End date: " + Wi(r.props.endDate, {
                dateFormat: l,
                locale: i
            }) : "") : r.props.showTimeSelectOnly ? u = "Selected time: ".concat(Wi(r.props.selected, {
                dateFormat: o,
                locale: i
            })) : r.props.showYearPicker ? u = "Selected year: ".concat(Wi(r.props.selected, {
                dateFormat: "yyyy",
                locale: i
            })) : r.props.showMonthYearPicker ? u = "Selected month: ".concat(Wi(r.props.selected, {
                dateFormat: "MMMM yyyy",
                locale: i
            })) : r.props.showQuarterYearPicker ? u = "Selected quarter: ".concat(Wi(r.props.selected, {
                dateFormat: "yyyy, QQQ",
                locale: i
            })) : u = "Selected date: ".concat(Wi(r.props.selected, {
                dateFormat: l,
                locale: i
            })),
            ye.createElement("span", {
                role: "alert",
                "aria-live": "polite",
                className: "react-datepicker__aria-live"
            }, u)
        }
        ,
        r.renderDateInput = function() {
            var s, i, o = Jn(r.props.className, (s = {},
            s[r.props.outsideClickIgnoreClass || e.defaultProps.outsideClickIgnoreClass] = r.state.open,
            s)), a = r.props.customInput || ye.createElement("input", {
                type: "text"
            }), l = r.props.customInputRef || "ref";
            return V.cloneElement(a, (i = {},
            i[l] = function(u) {
                r.input = u
            }
            ,
            i.value = r.getInputValue(),
            i.onBlur = r.handleBlur,
            i.onChange = r.handleChange,
            i.onClick = r.onInputClick,
            i.onFocus = r.handleFocus,
            i.onKeyDown = r.onInputKeyDown,
            i.id = r.props.id,
            i.name = r.props.name,
            i.form = r.props.form,
            i.autoFocus = r.props.autoFocus,
            i.placeholder = r.props.placeholderText,
            i.disabled = r.props.disabled,
            i.autoComplete = r.props.autoComplete,
            i.className = Jn(a.props.className, o),
            i.title = r.props.title,
            i.readOnly = r.props.readOnly,
            i.required = r.props.required,
            i.tabIndex = r.props.tabIndex,
            i["aria-describedby"] = r.props.ariaDescribedBy,
            i["aria-invalid"] = r.props.ariaInvalid,
            i["aria-labelledby"] = r.props.ariaLabelledBy,
            i["aria-required"] = r.props.ariaRequired,
            i))
        }
        ,
        r.renderClearButton = function() {
            var s = r.props
              , i = s.isClearable
              , o = s.disabled
              , a = s.selected
              , l = s.startDate
              , u = s.endDate
              , d = s.clearButtonTitle
              , h = s.clearButtonClassName
              , p = h === void 0 ? "" : h
              , g = s.ariaLabelClose
              , w = g === void 0 ? "Close" : g
              , b = s.selectedDates
              , v = s.readOnly;
            return i && !v && (a != null || l != null || u != null || b?.length) ? ye.createElement("button", {
                type: "button",
                className: Jn("react-datepicker__close-icon", p, {
                    "react-datepicker__close-icon--disabled": o
                }),
                disabled: o,
                "aria-label": w,
                onClick: r.onClearClick,
                title: d,
                tabIndex: -1
            }) : null
        }
        ,
        r.state = r.calcInitialState(),
        r.preventFocusTimeout = void 0,
        r
    }
    return Object.defineProperty(e, "defaultProps", {
        get: function() {
            return {
                allowSameDay: !1,
                dateFormat: "MM/dd/yyyy",
                dateFormatCalendar: "LLLL yyyy",
                disabled: !1,
                disabledKeyboardNavigation: !1,
                dropdownMode: "scroll",
                preventOpenOnFocus: !1,
                monthsShown: 1,
                outsideClickIgnoreClass: oG,
                readOnly: !1,
                rangeSeparator: eG,
                withPortal: !1,
                selectsDisabledDaysInRange: !1,
                shouldCloseOnSelect: !0,
                showTimeSelect: !1,
                showTimeInput: !1,
                showPreviousMonths: !1,
                showMonthYearPicker: !1,
                showFullMonthYearPicker: !1,
                showTwoColumnMonthYearPicker: !1,
                showFourColumnMonthYearPicker: !1,
                showYearPicker: !1,
                showQuarterYearPicker: !1,
                showWeekPicker: !1,
                strictParsing: !1,
                swapRange: !1,
                timeIntervals: 30,
                timeCaption: "Time",
                previousMonthAriaLabel: "Previous Month",
                previousMonthButtonLabel: "Previous Month",
                nextMonthAriaLabel: "Next Month",
                nextMonthButtonLabel: "Next Month",
                previousYearAriaLabel: "Previous Year",
                previousYearButtonLabel: "Previous Year",
                nextYearAriaLabel: "Next Year",
                nextYearButtonLabel: "Next Year",
                timeInputLabel: "Time",
                enableTabLoop: !0,
                yearItemNumber: nb,
                focusSelectedMonth: !1,
                showPopperArrow: !0,
                excludeScrollbar: !0,
                customTimeInput: null,
                calendarStartDay: void 0,
                toggleCalendarOnIconClick: !1,
                usePointerEvent: !1
            }
        },
        enumerable: !1,
        configurable: !0
    }),
    e.prototype.componentDidMount = function() {
        window.addEventListener("scroll", this.onScroll, !0),
        document.addEventListener("visibilitychange", this.setHiddenStateOnVisibilityHidden)
    }
    ,
    e.prototype.componentDidUpdate = function(t, r) {
        var s, i, o, a;
        t.inline && X6e(t.selected, this.props.selected) && this.setPreSelection(this.props.selected),
        this.state.monthSelectedIn !== void 0 && t.monthsShown !== this.props.monthsShown && this.setState({
            monthSelectedIn: 0
        }),
        t.highlightDates !== this.props.highlightDates && this.setState({
            highlightDates: GP(this.props.highlightDates)
        }),
        !r.focused && !yf(t.selected, this.props.selected) && this.setState({
            inputValue: null
        }),
        r.open !== this.state.open && (r.open === !1 && this.state.open === !0 && ((i = (s = this.props).onCalendarOpen) === null || i === void 0 || i.call(s)),
        r.open === !0 && this.state.open === !1 && ((a = (o = this.props).onCalendarClose) === null || a === void 0 || a.call(o)))
    }
    ,
    e.prototype.componentWillUnmount = function() {
        this.clearPreventFocusTimeout(),
        window.removeEventListener("scroll", this.onScroll, !0),
        document.removeEventListener("visibilitychange", this.setHiddenStateOnVisibilityHidden)
    }
    ,
    e.prototype.renderInputContainer = function() {
        var t = this.props
          , r = t.showIcon
          , s = t.icon
          , i = t.calendarIconClassname
          , o = t.calendarIconClassName
          , a = t.toggleCalendarOnIconClick
          , l = this.state.open;
        return i && console.warn("calendarIconClassname props is deprecated. should use calendarIconClassName props."),
        ye.createElement("div", {
            className: "react-datepicker__input-container".concat(r ? " react-datepicker__view-calendar-icon" : "")
        }, r && ye.createElement(V6e, Xt({
            icon: s,
            className: Jn(o, !o && i, l && "react-datepicker-ignore-onclickoutside")
        }, a ? {
            onClick: this.toggleCalendar
        } : null)), this.state.isRenderAriaLiveMessage && this.renderAriaLiveRegion(), this.renderDateInput(), this.renderClearButton())
    }
    ,
    e.prototype.render = function() {
        var t = this.renderCalendar();
        if (this.props.inline)
            return t;
        if (this.props.withPortal) {
            var r = this.state.open ? ye.createElement(lG, {
                enableTabLoop: this.props.enableTabLoop
            }, ye.createElement("div", {
                className: "react-datepicker__portal",
                tabIndex: -1,
                onKeyDown: this.onPortalKeyDown
            }, t)) : null;
            return this.state.open && this.props.portalId && (r = ye.createElement(aG, Xt({
                portalId: this.props.portalId
            }, this.props), r)),
            ye.createElement("div", null, this.renderInputContainer(), r)
        }
        return ye.createElement(K6e, Xt({}, this.props, {
            className: this.props.popperClassName,
            hidePopper: !this.isCalendarOpen(),
            targetComponent: this.renderInputContainer(),
            popperComponent: t,
            popperOnKeyDown: this.onPopperKeyDown,
            showArrow: this.props.showPopperArrow
        }))
    }
    ,
    e
}
)(V.Component)
  , Z6e = "input"
  , BA = "navigate";
const J6e = ({isOpen: n, onClose: e}) => (V.useEffect( () => {
    if (n) {
        const t = document.body.style.overflow || "";
        return document.body.style.overflow = "hidden",
        () => {
            document.body.style.overflow = t
        }
    }
}
, [n]),
n ? m.jsxs("div", {
    className: "fixed inset-0 flex items-start py-10 justify-center z-50 overflow-auto",
    onClick: e,
    children: [m.jsx("div", {
        className: "fixed inset-0 bg-black/70 backdrop-blur-md"
    }), m.jsxs("div", {
        className: "relative bg-gradient-to-br from-[#1A1F2E] via-[#2A3441] to-[#1A1F2E] rounded-2xl shadow-2xl border-2 border-[#FFC12C]/30 max-w-2xl w-full mx-4 z-50 overflow-hidden",
        onClick: t => t.stopPropagation(),
        children: [m.jsx("div", {
            className: "absolute inset-0 bg-gradient-to-r from-[#FF6B35]/10 via-[#FFC12C]/10 to-[#FF6B35]/10 animate-pulse pointer-events-none"
        }), m.jsx("button", {
            onClick: t => {
                t.stopPropagation(),
                e()
            }
            ,
            className: "absolute right-4 top-4 z-20 w-10 h-10 flex items-center justify-center text-[#A8B8CC] hover:text-white transition-colors rounded-full hover:bg-white/10 cursor-pointer",
            type: "button",
            children: m.jsx("svg", {
                xmlns: "http://www.w3.org/2000/svg",
                fill: "none",
                viewBox: "0 0 24 24",
                strokeWidth: 2,
                stroke: "currentColor",
                className: "size-6",
                children: m.jsx("path", {
                    strokeLinecap: "round",
                    strokeLinejoin: "round",
                    d: "M6 18 18 6M6 6l12 12"
                })
            })
        }), m.jsxs("div", {
            className: "relative z-10 p-8",
            children: [m.jsxs("div", {
                className: "text-center mb-8",
                children: [m.jsxs("div", {
                    className: "flex items-center justify-center gap-3 mb-4",
                    children: [m.jsx("img", {
                        src: Cq,
                        alt: "Coin",
                        className: "w-10 h-10"
                    }), m.jsx("h2", {
                        className: "text-3xl font-bold text-[#FFE559]",
                        children: "Reward Distribution"
                    })]
                }), m.jsx("p", {
                    className: "text-[#A8B8CC] text-sm",
                    children: "How rewards are distributed among winners"
                })]
            }), m.jsx("div", {
                className: "mb-8 p-6 rounded-xl bg-gradient-to-r from-[#2B3A4F] to-[#1F2A3A] border border-[#FFC12C]/20",
                children: m.jsxs("div", {
                    className: "flex items-center justify-between",
                    children: [m.jsxs("div", {
                        className: "flex items-center gap-3",
                        children: [m.jsx("div", {
                            className: "w-12 h-12 rounded-full bg-gradient-to-br from-[#FF6B35] to-[#FFC12C] flex items-center justify-center",
                            children: m.jsx("svg", {
                                xmlns: "http://www.w3.org/2000/svg",
                                fill: "none",
                                viewBox: "0 0 24 24",
                                strokeWidth: 2,
                                stroke: "currentColor",
                                className: "size-6 text-white",
                                children: m.jsx("path", {
                                    strokeLinecap: "round",
                                    strokeLinejoin: "round",
                                    d: "M12 21a9.004 9.004 0 0 0 8.716-6.747M12 21a9.004 9.004 0 0 1-8.716-6.747M12 21c2.485 0 4.5-4.03 4.5-9S14.485 3 12 3m0 18c-2.485 0-4.5-4.03-4.5-9S9.515 3 12 3m0 0a8.997 8.997 0 0 1 7.843 4.582M12 3a8.997 8.997 0 0 0-7.843 4.582m15.686 0A11.953 11.953 0 0 1 12 10.5c-2.998 0-5.74-1.1-7.843-2.918m15.686 0A8.959 8.959 0 0 1 21 12c0 .778-.099 1.533-.284 2.253m-2.715-1.671a8.959 8.959 0 0 0 1.71-1.582M7.157 7.582a8.959 8.959 0 0 0-1.71 1.582m0 0A11.953 11.953 0 0 0 12 13.5c2.998 0 5.74-1.1 7.843-2.918m-15.686 0A8.997 8.997 0 0 1 12 3"
                                })
                            })
                        }), m.jsxs("div", {
                            children: [m.jsx("h3", {
                                className: "text-lg font-semibold text-white",
                                children: "Platform"
                            }), m.jsx("p", {
                                className: "text-sm text-[#A8B8CC]",
                                children: "Platform Share"
                            })]
                        })]
                    }), m.jsxs("div", {
                        className: "text-right",
                        children: [m.jsx("div", {
                            className: "text-2xl font-bold text-[#FFC12C]",
                            children: "20%"
                        }), m.jsx("div", {
                            className: "text-xs text-[#A8B8CC]",
                            children: "of the total rewards"
                        })]
                    })]
                })
            }), m.jsxs("div", {
                className: "mb-6",
                children: [m.jsxs("div", {
                    className: "flex items-center gap-2 mb-6",
                    children: [m.jsx("div", {
                        className: "h-px flex-1 bg-gradient-to-r from-transparent via-[#FFC12C]/50 to-transparent"
                    }), m.jsx("h3", {
                        className: "text-xl font-semibold text-[#FFE559] px-4",
                        children: "User Reward Split"
                    }), m.jsx("div", {
                        className: "h-px flex-1 bg-gradient-to-r from-transparent via-[#FFC12C]/50 to-transparent"
                    })]
                }), m.jsxs("p", {
                    className: "text-center text-sm text-[#A8B8CC] mb-6",
                    children: ["The remaining ", m.jsx("span", {
                        className: "text-[#FFC12C] font-semibold",
                        children: "80%"
                    }), " of the total reward is distributed among the top 3 players based on their final rankings:"]
                }), m.jsxs("div", {
                    className: "space-y-4",
                    children: [m.jsx("div", {
                        className: "relative p-5 rounded-xl bg-gradient-to-r from-[#77633B] to-[#8B7548] border-2 border-[#FFC12C]/40 shadow-lg",
                        children: m.jsxs("div", {
                            className: "flex items-center justify-between",
                            children: [m.jsxs("div", {
                                className: "flex items-center gap-4",
                                children: [m.jsx("img", {
                                    src: Eq,
                                    alt: "1st Place",
                                    className: "w-12 h-12"
                                }), m.jsxs("div", {
                                    children: [m.jsx("h4", {
                                        className: "text-lg font-bold text-white",
                                        children: "1st Place"
                                    }), m.jsx("p", {
                                        className: "text-sm text-[#FFE559]",
                                        children: "Champion"
                                    })]
                                })]
                            }), m.jsxs("div", {
                                className: "text-right",
                                children: [m.jsx("div", {
                                    className: "text-2xl font-bold text-white",
                                    children: "50%"
                                }), m.jsx("div", {
                                    className: "text-xs text-[#FFE559]",
                                    children: "of 80% pool"
                                })]
                            })]
                        })
                    }), m.jsx("div", {
                        className: "relative p-5 rounded-xl bg-gradient-to-r from-[#8F1916] to-[#A52A26] border-2 border-[#FF6B35]/40 shadow-lg",
                        children: m.jsxs("div", {
                            className: "flex items-center justify-between",
                            children: [m.jsxs("div", {
                                className: "flex items-center gap-4",
                                children: [m.jsx("img", {
                                    src: Sq,
                                    alt: "2nd Place",
                                    className: "w-12 h-12"
                                }), m.jsxs("div", {
                                    children: [m.jsx("h4", {
                                        className: "text-lg font-bold text-white",
                                        children: "2nd Place"
                                    }), m.jsx("p", {
                                        className: "text-sm text-[#FFE559]",
                                        children: "Runner-up"
                                    })]
                                })]
                            }), m.jsxs("div", {
                                className: "text-right",
                                children: [m.jsx("div", {
                                    className: "text-2xl font-bold text-white",
                                    children: "20%"
                                }), m.jsx("div", {
                                    className: "text-xs text-[#FFE559]",
                                    children: "of 80% pool"
                                })]
                            })]
                        })
                    }), m.jsx("div", {
                        className: "relative p-5 rounded-xl bg-gradient-to-r from-[#A06418] to-[#B8751F] border-2 border-[#FFC12C]/40 shadow-lg",
                        children: m.jsxs("div", {
                            className: "flex items-center justify-between",
                            children: [m.jsxs("div", {
                                className: "flex items-center gap-4",
                                children: [m.jsx("img", {
                                    src: Aq,
                                    alt: "3rd Place",
                                    className: "w-12 h-12"
                                }), m.jsxs("div", {
                                    children: [m.jsx("h4", {
                                        className: "text-lg font-bold text-white",
                                        children: "3rd Place"
                                    }), m.jsx("p", {
                                        className: "text-sm text-[#FFE559]",
                                        children: "Third place"
                                    })]
                                })]
                            }), m.jsxs("div", {
                                className: "text-right",
                                children: [m.jsx("div", {
                                    className: "text-2xl font-bold text-white",
                                    children: "10%"
                                }), m.jsx("div", {
                                    className: "text-xs text-[#FFE559]",
                                    children: "of 80% pool"
                                })]
                            })]
                        })
                    })]
                })]
            }), m.jsx("div", {
                className: "mt-8 p-4 rounded-lg bg-[#1F2A3A]/50 border border-[#FFC12C]/20",
                children: m.jsxs("p", {
                    className: "text-sm text-[#A8B8CC] text-center",
                    children: [m.jsx("span", {
                        className: "text-[#FFE559] font-semibold",
                        children: "Note:"
                    }), " Higher rank means a higher share of the reward pool. Rankings are determined by final scores at the end of each competition period."]
                })
            })]
        }), m.jsx("div", {
            className: "absolute top-0 left-0 w-24 h-24 bg-gradient-to-br from-[#FFC12C]/20 to-transparent rounded-br-full"
        }), m.jsx("div", {
            className: "absolute bottom-0 right-0 w-24 h-24 bg-gradient-to-tl from-[#FF6B35]/20 to-transparent rounded-tl-full"
        })]
    })]
}) : null)
  , eNe = n => n === "all-games" ? "all-time" : n === "today" ? "today" : n === "jackpot-winners" ? "jackpot-winners" : n === "awebo" ? "awebo" : "all-time"
  , ZP = [{
    id: "all-time",
    label: "All Games"
}, {
    id: "today",
    label: "Biscuit Run"
}, {
    id: "awebo",
    label: "Awebo Bird"
}, {
    id: "jackpot-winners",
    label: "Jackpot Winners"
}]
  , tNe = (n, e) => !n || !e ? !1 : new Date(n).toDateString() === new Date(e).toDateString()
  , ag = ({initialTab: n}) => {
    const e = kr()
      , [t,r] = V.useState([])
      , [s,i] = V.useState(null)
      , [o,a] = V.useState(null)
      , [l] = V.useState(Pp)
      , [u,d] = V.useState(1)
      , h = 10
      , [p,g] = V.useState(1)
      , [w,b] = V.useState(!0)
      , [v,S] = V.useState(eNe(n))
      , [N,_] = V.useState(null)
      , [I,k] = V.useState(!1)
      , [B,P] = V.useState(!1)
      , M = V.useRef(null)
      , R = V.useMemo( () => ZP.find(ie => ie.id === v)?.label || "Select Tab", [v])
      , [L,q] = V.useState(!1)
      , [H,j] = V.useState({
        hours: 23,
        minutes: 48,
        seconds: 57
    });
    V.useEffect( () => {
        const ie = () => {
            const ue = new Date
              , ce = ue.getUTCFullYear()
              , me = ue.getUTCMonth()
              , Ee = ue.getUTCDate();
            return new Date(Date.UTC(ce, me, Ee + 1, 0, 0, 0, 0)).getTime()
        }
          , ae = () => {
            const ce = new Date().getTime()
              , Ee = ie() - ce;
            if (Ee <= 0)
                j({
                    hours: 24,
                    minutes: 0,
                    seconds: 0
                });
            else {
                const Oe = Math.floor(Ee / 36e5)
                  , mt = Math.floor(Ee % (1e3 * 60 * 60) / (1e3 * 60))
                  , st = Math.floor(Ee % (1e3 * 60) / 1e3);
                j({
                    hours: Oe,
                    minutes: mt,
                    seconds: st
                })
            }
        }
        ;
        ae();
        const xe = setInterval(ae, 1e3);
        return () => clearInterval(xe)
    }
    , []),
    V.useEffect( () => {
        const ie = ae => {
            M.current && !M.current.contains(ae.target) && P(!1)
        }
        ;
        return document.addEventListener("mousedown", ie),
        () => document.removeEventListener("mousedown", ie)
    }
    , []);
    const A = ie => String(ie).padStart(2, "0")
      , E = ie => ie ? ie.toLocaleDateString("en-IN", {
        day: "2-digit",
        month: "short",
        year: "numeric"
    }) : "";
    function C(ie) {
        if (!ie)
            return "";
        const ae = new Date(ie)
          , xe = ae.getFullYear()
          , ue = String(ae.getMonth() + 1).padStart(2, "0")
          , ce = String(ae.getDate()).padStart(2, "0");
        return `${xe}-${ue}-${ce}`
    }
    const O = V.useCallback(async (ie=1, ae, xe) => {
        try {
            b(!0);
            let ue;
            const ce = ae ? C(ae) : null;
            if (xe === "jackpot-winners" ? ue = await YV(ie, h) : xe === "all-time" ? ue = await O7(ie, h, null, null) : (xe === "awebo" || xe === "today") && ce ? ue = await O7(ie, h, xe === "today" ? Pp : X2, ce) : (xe === "awebo" || xe === "today") && !ce && (ue = await USe(ie, h, xe === "today" ? Pp : X2)),
            ue?.status === "success") {
                const me = ue.data;
                if (r(me.data || []),
                xe === "jackpot-winners")
                    i(null),
                    a(null),
                    g(me.meta?.lastPage || 1),
                    d(me.meta?.currentPage || 1);
                else if ((xe === "awebo" || xe === "today") && !ce)
                    i(me.stats),
                    a(null),
                    g(me.meta?.lastPage || 1),
                    d(me.meta?.currentPage || 1);
                else if ((xe === "awebo" || xe === "today") && ce) {
                    let Ee = Number(me?.meta?.totalRewards ?? me?.stats?.totalRewards ?? me?.meta?.total_reward ?? me?.stats?.total_reward ?? me?.meta?.distributionAmount ?? me?.stats?.distributionAmount ?? NaN);
                    (!Number.isFinite(Ee) || Ee <= 0) && (Ee = me?.data?.reduce( (Oe, mt) => Oe + Number(mt?.total_win_amount || 0), 0)),
                    ie === 1 && Number.isFinite(Ee) && a(Ee),
                    g(me.meta?.lastPage || 1),
                    d(me.meta?.currentPage || 1)
                } else
                    a(null),
                    g(me.meta?.lastPage || 1),
                    d(me.meta?.currentPage || 1)
            }
        } catch (ue) {
            console.error(" Leaderboard Fetch Error", ue)
        } finally {
            b(!1)
        }
    }
    , [l, h]);
    V.useEffect( () => {
        O(1, N, v)
    }
    , []);
    const z = () => u !== 1 && O(1, N, v)
      , G = () => u > 1 && O(u - 1, N, v)
      , Y = () => u < p && O(u + 1, N, v)
      , $ = () => u !== p && O(p, N, v)
      , D = ie => {
        S(ie),
        ie === "all-time" ? (e("/leaderboard/all-games"),
        k(!1),
        _(null)) : ie === "today" ? e("/leaderboard/biscuit-run") : ie === "awebo" ? e("/leaderboard/awebo-bird") : ie === "jackpot-winners" && (e("/leaderboard/jackpot-winners"),
        k(!1),
        _(null)),
        O(1, N, ie)
    }
      , U = !!N
      , W = ie => Number(ie?.total_sessions ?? ie?.games_played ?? ie?.total_games ?? 0)
      , J = (o ?? 0) * 1.2
      , ne = V.useMemo( () => w ? null : (v === "today" || v === "awebo") && U ? Vd(J, {
        currency: ""
    }) : Vd(Number(s?.totalWinAmount || 0), {
        currency: ""
    }), [w, v, U, J, s]);
    return m.jsxs("div", {
        className: "",
        children: [m.jsxs("div", {
            className: "text-center my-14",
            children: [m.jsx("h1", {
                className: "text-6xl font-jura text-[#FFE559] mb-2",
                children: "Leaderboard"
            }), m.jsx("p", {
                className: "text-lg font-jura mb-2",
                children: "Top players competing for glory and rewards"
            }), m.jsx("img", {
                src: lCe,
                className: "mx-auto"
            })]
        }), m.jsxs("div", {
            className: "container mx-auto px-4 pb-12",
            children: [m.jsxs("div", {
                className: "lg:flex items-center gap-4 md:justify-between mb-5",
                children: [m.jsxs("div", {
                    ref: M,
                    className: "relative mb-3 lg:mb-0",
                    children: [m.jsxs("button", {
                        onClick: () => P(ie => !ie),
                        className: "flex items-center gap-6 bg-[#22354D] cursor-pointer px-4 py-2.5 rounded-md font-jura text-sm font-medium text-white hover:bg-[#1f3347] transition-all duration-200",
                        children: [R, m.jsx("svg", {
                            className: `w-4 h-4 transition-transform duration-200 ${B ? "rotate-180" : ""}`,
                            fill: "none",
                            stroke: "currentColor",
                            strokeWidth: "2",
                            viewBox: "0 0 24 24",
                            children: m.jsx("path", {
                                strokeLinecap: "round",
                                strokeLinejoin: "round",
                                d: "M6 9l6 6 6-6"
                            })
                        })]
                    }), B && m.jsx("div", {
                        className: "absolute z-20 mt-2 w-52  border border-[#2c3d52] rounded-xl shadow-xl overflow-hidden dropdown-main-div",
                        children: ZP.map(ie => m.jsx("button", {
                            onClick: () => {
                                D(ie.id),
                                P(!1)
                            }
                            ,
                            className: `w-full cursor-pointer  text-left px-4 py-2.5 font-jura text-sm transition-colors duration-150 border-t border-[#25313f] ${v === ie.id ? " text-white activebtn" : "text-white hover:bg-[#22354D]"}`,
                            children: ie.label
                        }, ie.id))
                    })]
                }), (v === "today" || v == "awebo") && !w && m.jsxs("div", {
                    className: "lg:flex items-center gap-4 lg:flex-wrap block",
                    children: [m.jsx("div", {
                        className: "flex-1 w-full min-w-0",
                        children: m.jsxs("div", {
                            className: "relative bg-gradient-to-br from-[#1A1F2E] via-[#2A3441] to-[#1A1F2E] rounded-2xl px-4 py-2 shadow-2xl border-2 border-[#FFC12C]/30 ",
                            children: [m.jsx("div", {
                                className: "absolute inset-0 bg-gradient-to-r from-[#FF6B35]/10 via-[#FFC12C]/10 to-[#FF6B35]/10 animate-pulse"
                            }), m.jsxs("div", {
                                className: "relative z-10 flex flex-col md:flex-row items-start justify-between gap-6",
                                children: [m.jsxs("div", {
                                    className: "flex-1.5 flex items-center gap-3",
                                    children: [m.jsxs("div", {
                                        className: "relative",
                                        children: [m.jsx("div", {
                                            className: "absolute inset-0 bg-[#FFC12C] rounded-full blur-xl opacity-50 animate-pulse"
                                        }), m.jsx("img", {
                                            src: Cq,
                                            alt: "Coin",
                                            className: "relative w-8 h-8 drop-shadow-2xl"
                                        })]
                                    }), m.jsxs("div", {
                                        className: "flex flex-col ",
                                        children: [m.jsxs("div", {
                                            className: "flex items-center gap-2",
                                            children: [m.jsx("span", {
                                                className: "text-[#FFE559] text-sm font-semibold uppercase tracking-wider",
                                                children: (v === "today" || v === "awebo") && U ? "Winning Amount Distributed" : "Current Winning Amount"
                                            }), m.jsxs("span", {
                                                className: "relative group cursor-pointer",
                                                children: [m.jsx("svg", {
                                                    xmlns: "http://www.w3.org/2000/svg",
                                                    fill: "none",
                                                    viewBox: "0 0 24 24",
                                                    strokeWidth: 2,
                                                    stroke: "currentColor",
                                                    className: "size-4 text-[#FFE559] hover:text-[#FFC12C] transition-colors",
                                                    children: m.jsx("path", {
                                                        strokeLinecap: "round",
                                                        strokeLinejoin: "round",
                                                        d: "m11.25 11.25.041-.02a.75.75 0 0 1 1.063.852l-.708 2.836a.75.75 0 0 0 1.063.853l.041-.021M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Zm-9-3.75h.008v.008H12V8.25Z"
                                                    })
                                                }), m.jsxs("div", {
                                                    className: "absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 w-72 p-3 bg-[#1A2332] text-white text-xs rounded-lg shadow-xl opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all duration-200 pointer-events-none z-50 border border-[#283E5C]",
                                                    children: [m.jsx("p", {
                                                        className: "text-center leading-relaxed",
                                                        children: "As more players join the game, the prize pool grows creating bigger rewards for winners as participation increases."
                                                    }), m.jsx("div", {
                                                        className: "absolute top-full left-1/2 transform -translate-x-1/2 -mt-1",
                                                        children: m.jsx("div", {
                                                            className: "w-2 h-2 bg-[#1A2332] border-r border-b border-[#283E5C] transform rotate-45"
                                                        })
                                                    })]
                                                })]
                                            })]
                                        }), m.jsxs("div", {
                                            className: "flex items-baseline gap-x-2",
                                            children: [m.jsx("span", {
                                                className: "text-white text-2xl font-bold tracking-tight leading-0",
                                                children: w ? m.jsx(Fp, {}) : ne
                                            }), m.jsx("span", {
                                                className: "text-[#FFE559] text-xl font-bold",
                                                children: "L1XP"
                                            }), m.jsx("span", {
                                                className: "text-sm text-white cursor-pointer border-b border-white ml-1 leading-4 hover:text-[#FFE559] transition-colors",
                                                onClick: () => q(!0),
                                                children: "Check Distribution"
                                            })]
                                        })]
                                    })]
                                }), m.jsx("div", {
                                    className: "hidden md:block w-px h-10 bg-gradient-to-b from-transparent via-[#FFC12C]/50 to-transparent"
                                }), m.jsx("div", {
                                    className: "flex-1 flex items-center gap-4 justify-end",
                                    children: v === "today" && U ? m.jsxs("div", {
                                        className: "flex flex-col gap-0.5 text-right",
                                        children: [m.jsx("span", {
                                            className: "text-[#FFE559] text-sm font-semibold uppercase tracking-wider",
                                            children: "Selected Date"
                                        }), m.jsx("span", {
                                            className: "text-[#FFC12C] text-xl font-bold tracking-wider",
                                            children: E(N)
                                        })]
                                    }) : m.jsxs("div", {
                                        className: "flex flex-col gap-0.5",
                                        children: [m.jsx("span", {
                                            className: "text-[#FFE559] text-sm font-semibold uppercase tracking-wider",
                                            children: "Next winner announced in"
                                        }), m.jsx("div", {
                                            className: "flex items-center gap-1",
                                            children: m.jsx("div", {
                                                className: "",
                                                children: m.jsxs("span", {
                                                    className: "text-[#FFC12C] text-xl font-bold tracking-wider font-mono",
                                                    children: [A(H.hours), ":", A(H.minutes), ":", A(H.seconds)]
                                                })
                                            })
                                        })]
                                    })
                                })]
                            }), m.jsx("div", {
                                className: "absolute top-0 left-0 w-16 h-16 bg-gradient-to-br from-[#FFC12C]/20 to-transparent rounded-br-full"
                            }), m.jsx("div", {
                                className: "absolute bottom-0 right-0 w-16 h-16 bg-gradient-to-tl from-[#FF6B35]/20 to-transparent rounded-tl-full"
                            })]
                        })
                    }), m.jsxs("div", {
                        className: "relative",
                        children: [m.jsxs("button", {
                            onClick: () => {
                                k(!I)
                            }
                            ,
                            className: "mt-3 md:mt-0 flex items-center gap-2 px-3 md:px-6 py-3 rounded-lg font-jura text-sm transition-all duration-200 cursor-pointer bg-[#182637] text-white hover:bg-[#1f3347]",
                            children: [m.jsx("span", {
                                children: N ? E(N) : "Select Date"
                            }), m.jsx("svg", {
                                xmlns: "http://www.w3.org/2000/svg",
                                fill: "none",
                                viewBox: "0 0 24 24",
                                strokeWidth: 1.5,
                                stroke: "currentColor",
                                className: "size-5",
                                children: m.jsx("path", {
                                    strokeLinecap: "round",
                                    strokeLinejoin: "round",
                                    d: `M6.75 3v2.25M17.25 3v2.25M3 18.75V7.5a2.25 2.25 0 0 1 
                       2.25-2.25h13.5A2.25 2.25 0 0 1 21 7.5v11.25m-18 0A2.25 
                       2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75m-18 
                       0v-7.5A2.25 2.25 0 0 1 5.25 9h13.5A2.25 2.25 0 0 1 
                       21 11.25v7.5`
                                })
                            })]
                        }), I && m.jsx("div", {
                            className: "absolute mt-2 z-50 bg-[#182637] p-3 rounded-xl shadow-xl right-0",
                            children: m.jsx(Q6e, {
                                selected: N,
                                onChange: ie => {
                                    const ae = new Date;
                                    k(!1),
                                    ie && tNe(ie, ae) ? (_(null),
                                    a(null),
                                    O(1, null, v)) : (_(ie),
                                    O(1, ie, v))
                                }
                                ,
                                inline: !0,
                                minDate: null,
                                maxDate: null
                            })
                        })]
                    })]
                })]
            }), m.jsxs("div", {
                className: "mb-12 leaderboard-table",
                children: [m.jsx(Fp, {}), m.jsx("div", {
                    className: "overflow-x-auto",
                    children: m.jsxs("table", {
                        className: "w-full",
                        children: [m.jsx("thead", {
                            className: "bg-[#394759]",
                            children: m.jsxs("tr", {
                                children: [m.jsx("th", {
                                    className: "py-3 rounded-bl-xl rounded-tl-xl px-7 text-md font-semibold text-left",
                                    children: "Rank"
                                }), m.jsx("th", {
                                    className: "py-3 px-7 text-md font-semibold text-left",
                                    children: "Player"
                                }), m.jsx("th", {
                                    className: "py-3 px-7 text-md font-semibold text-left",
                                    children: v === "jackpot-winners" ? "Reward Amount" : v === "today" || v === "awebo" ? "Total Points" : "Total Rewards"
                                }), (v === "today" || v === "awebo") && U && m.jsx("th", {
                                    className: "py-3 px-7 text-md font-semibold text-left",
                                    children: "Reward"
                                }), v === "jackpot-winners" ? m.jsx("th", {
                                    className: "py-3 rounded-br-xl rounded-tr-xl px-7 text-md font-semibold text-left",
                                    children: "Reward Date"
                                }) : m.jsxs(m.Fragment, {
                                    children: [m.jsx("th", {
                                        className: "py-3 px-7 text-md font-semibold text-left",
                                        children: "Games Played"
                                    }), ["all-time"].includes(v) && m.jsx("th", {
                                        className: "py-3 rounded-br-xl rounded-tr-xl px-7 text-md font-semibold text-left",
                                        children: "Best Game"
                                    })]
                                })]
                            })
                        }), m.jsx("tbody", {
                            children: w ? Array.from({
                                length: 10
                            }).map( (ie, ae) => m.jsxs("tr", {
                                className: "border-t-4 border-[#0e131a]",
                                children: [m.jsx("td", {
                                    className: "bg-[#263446] py-4 px-7",
                                    children: m.jsx("div", {
                                        className: "animate-pulse h-5 w-10 bg-gray-700 rounded"
                                    })
                                }), m.jsx("td", {
                                    className: "bg-[#263446] py-4 px-7",
                                    children: m.jsxs("div", {
                                        className: "animate-pulse flex items-center gap-3",
                                        children: [m.jsx("div", {
                                            className: "h-8 w-8 bg-gray-700 rounded-full"
                                        }), m.jsx("div", {
                                            className: "h-4 w-24 bg-gray-700 rounded"
                                        })]
                                    })
                                }), m.jsx("td", {
                                    className: "bg-[#263446] py-4 px-7",
                                    children: m.jsx("div", {
                                        className: "animate-pulse h-6 w-32 bg-gray-700 rounded"
                                    })
                                }), m.jsx("td", {
                                    className: "bg-[#263446] py-4 px-7",
                                    children: m.jsx("div", {
                                        className: "animate-pulse h-6 w-24 bg-gray-700 rounded"
                                    })
                                }), v !== "today" && m.jsx("td", {
                                    className: "bg-[#263446] py-4 px-7",
                                    children: m.jsx("div", {
                                        className: "animate-pulse h-6 w-24 bg-gray-700 rounded"
                                    })
                                })]
                            }, ae)) : m.jsx(m.Fragment, {
                                children: t.map( (ie, ae) => {
                                    let xe = v === "jackpot-winners" ? 4 : ae < 3 && u <= 1 ? ae : 4;
                                    const ue = JP[xe] || JP.default
                                      , ce = (u - 1) * h + (ae + 1);
                                    return m.jsxs("tr", {
                                        className: ue.rowClass,
                                        children: [m.jsx("td", {
                                            className: `${ue.colClass} py-2 px-7 text-sm rounded-bl-xl rounded-tl-xl`,
                                            children: v !== "jackpot-winners" && ue.priceImg && u <= 1 ? m.jsx("img", {
                                                src: ue.priceImg,
                                                className: "w-7"
                                            }) : m.jsx("span", {
                                                children: ce
                                            })
                                        }), m.jsx("td", {
                                            className: `${ue.colClass} py-2 px-7 text-sm`,
                                            children: m.jsxs("div", {
                                                className: "flex items-center gap-3",
                                                children: [m.jsxs("div", {
                                                    className: "relative",
                                                    children: [v !== "jackpot-winners" && ue.crown && u <= 1 && m.jsx("img", {
                                                        src: cCe,
                                                        className: "absolute -top-4 left-1 w-10"
                                                    }), m.jsx("div", {
                                                        className: "w-8 h-8 rounded-full overflow-hidden bg-[#1a1f2e]",
                                                        children: m.jsx(Z2, {
                                                            diameter: 90,
                                                            seed: ay.jsNumberForAddress(ie?.wallet_address || ie?.walletAddress || "")
                                                        })
                                                    })]
                                                }), m.jsx("p", {
                                                    className: " text-sm",
                                                    children: ie.username || ie?.wallet_address?.slice(0, 6) + "..." + ie?.wallet_address?.slice(-4) || "Anonymous"
                                                })]
                                            })
                                        }), m.jsx("td", {
                                            className: `${ue.colClass} py-2 px-7 text-sm`,
                                            children: v === "jackpot-winners" ? m.jsxs("div", {
                                                className: `relative inline-block py-[1px] pl-6 pr-2 ${ue.starBg} font-semibold rounded-md text-center`,
                                                children: [m.jsx("img", {
                                                    src: hP,
                                                    className: "absolute -left-2 top-0"
                                                }), Vd(ie?.reward_amount, {
                                                    currency: ""
                                                }), " ", m.jsx("span", {
                                                    className: "text-[#fff]",
                                                    children: "L1XP"
                                                })]
                                            }) : m.jsxs("div", {
                                                className: `relative inline-block py-[1px] pl-6 pr-2 ${ue.starBg} font-semibold rounded-md text-center`,
                                                children: [m.jsx("img", {
                                                    src: hP,
                                                    className: "absolute -left-2 top-0"
                                                }), v === "today" || v === "awebo" ? Vd(ie?.total_outcome_value, {
                                                    currency: ""
                                                }) : m.jsxs(m.Fragment, {
                                                    children: [Vd(ie?.total_win_amount, {
                                                        currency: ""
                                                    }), " ", m.jsx("span", {
                                                        className: "text-[#fff]",
                                                        children: "L1XP"
                                                    })]
                                                })]
                                            })
                                        }), (v === "today" || v === "awebo") && U && m.jsx("td", {
                                            className: `${ue.colClass} py-2 px-7 text-sm`,
                                            children: m.jsxs("div", {
                                                className: "relative inline-block py-[1px] font-semibold rounded-md text-center reward-amountUser",
                                                children: [Vd(ie?.total_win_amount, {
                                                    currency: ""
                                                }), " L1XP"]
                                            })
                                        }), v === "jackpot-winners" ? m.jsx("td", {
                                            className: `${ue.colClass} py-2 px-7 text-sm rounded-br-xl rounded-tr-xl`,
                                            children: m.jsx("div", {
                                                className: "relative inline-block py-[1px] font-semibold rounded-md text-center",
                                                children: ie?.reward_date ? E(new Date(ie.reward_date)) : "-"
                                            })
                                        }) : m.jsxs(m.Fragment, {
                                            children: [m.jsx("td", {
                                                className: `${ue.colClass} py-2 px-7 text-sm`,
                                                children: m.jsx("div", {
                                                    className: "relative inline-block py-[1px] font-semibold rounded-md text-center",
                                                    children: W(ie)
                                                })
                                            }), ["all-time"].includes(v) && m.jsx("td", {
                                                className: `${ue.colClass} py-2 px-7 text-sm rounded-br-xl rounded-tr-xl`,
                                                children: m.jsx("div", {
                                                    className: "relative inline-block py-[1px] font-semibold rounded-md text-center",
                                                    children: ie?.best_game_name
                                                })
                                            })]
                                        })]
                                    }, ae)
                                }
                                )
                            })
                        })]
                    })
                }), w ? m.jsx("div", {
                    className: "text-right",
                    children: m.jsxs("div", {
                        className: "inline-flex items-center gap-2 mt-6 animate-pulse",
                        children: [m.jsx("div", {
                            className: "h-9 w-16 bg-gray-700 rounded-lg"
                        }), m.jsx("div", {
                            className: "h-9 w-9 bg-gray-700 rounded-lg"
                        }), m.jsx("div", {
                            className: "h-9 w-9 bg-gray-700 rounded-lg"
                        }), m.jsx("div", {
                            className: "h-4 w-20 bg-gray-700 rounded"
                        }), m.jsx("div", {
                            className: "h-9 w-9 bg-gray-700 rounded-lg"
                        }), m.jsx("div", {
                            className: "h-9 w-16 bg-gray-700 rounded-lg"
                        })]
                    })
                }) : m.jsx("div", {
                    className: "text-right",
                    children: m.jsxs("ul", {
                        className: "inline-flex items-center gap-2 mt-6",
                        children: [m.jsx("li", {
                            children: m.jsx("button", {
                                disabled: u === 1,
                                onClick: z,
                                className: "cursor-pointer border border-[#455263] hover:border-[#2F80ED] hover:bg-[#2F80ED] rounded-lg py-2 px-4",
                                children: "First"
                            })
                        }), m.jsx("li", {
                            children: m.jsx("button", {
                                disabled: u === 1,
                                onClick: G,
                                className: "cursor-pointer border border-[#455263] hover:border-[#2F80ED] hover:bg-[#2F80ED] rounded-lg py-2 px-2 block",
                                children: m.jsx("svg", {
                                    xmlns: "http://www.w3.org/2000/svg",
                                    fill: "none",
                                    viewBox: "0 0 24 24",
                                    strokeWidth: 2,
                                    stroke: "currentColor",
                                    className: "size-4",
                                    children: m.jsx("path", {
                                        strokeLinecap: "round",
                                        strokeLinejoin: "round",
                                        d: "M15.75 19.5 8.25 12l7.5-7.5"
                                    })
                                })
                            })
                        }), m.jsxs("li", {
                            children: [" ", m.jsx(Us, {
                                to: "",
                                className: "cursor-pointer border border-[#2F80ED] bg-[#2F80ED] text-white rounded-lg py-2 px-3 block",
                                children: u
                            }), " "]
                        }), m.jsxs("li", {
                            children: [" of ", p, " "]
                        }), m.jsx("li", {
                            children: m.jsx("button", {
                                disabled: u === p,
                                onClick: Y,
                                className: "cursor-pointer border border-[#455263] hover:border-[#2F80ED] hover:bg-[#2F80ED] rounded-lg py-2 px-2 block",
                                children: m.jsx("svg", {
                                    xmlns: "http://www.w3.org/2000/svg",
                                    fill: "none",
                                    viewBox: "0 0 24 24",
                                    strokeWidth: 2,
                                    stroke: "currentColor",
                                    className: "size-4",
                                    children: m.jsx("path", {
                                        strokeLinecap: "round",
                                        strokeLinejoin: "round",
                                        d: "m8.25 4.5 7.5 7.5-7.5 7.5"
                                    })
                                })
                            })
                        }), m.jsx("li", {
                            children: m.jsx("button", {
                                disabled: u === p,
                                onClick: $,
                                className: "cursor-pointer border border-[#455263] rounded-lg py-2 px-4 hover:border-[#2F80ED] hover:bg-[#2F80ED]",
                                children: "Last"
                            })
                        })]
                    })
                })]
            })]
        }), m.jsx(J6e, {
            isOpen: L,
            onClose: () => q(!1)
        })]
    })
}
  , JP = {
    0: {
        rowClass: "border-t-4 border-[#0e131a]",
        colClass: "one-col",
        bgColor: "bg-[#77633B]",
        priceImg: Eq,
        coinBg: "bg-[#77633B]",
        starBg: "bg-[#77633B]",
        crown: !0,
        textColor: "text-black"
    },
    1: {
        rowClass: "border-t-4 border-[#0e131a]",
        colClass: "secound-col",
        priceImg: Sq,
        coinBg: "bg-[#8F1916]",
        starBg: "bg-[#8F1916]",
        crown: !0,
        textColor: "text-black"
    },
    2: {
        rowClass: "border-t-4 border-[#0e131a]",
        colClass: "three-col",
        priceImg: Aq,
        coinBg: "bg-[#A06418]",
        starBg: "bg-[#A06418]",
        crown: !0,
        textColor: "text-black"
    },
    default: {
        rowClass: "border-t-4 border-[#0e131a]",
        colClass: "bg-[#263446] text-white",
        coinBg: "bg-[#48556A]",
        starBg: "bg-[#48556A]",
        crown: !1,
        textColor: "text-white"
    }
}
  , nNe = "/assets/bisc-C_QTTZIE.png"
  , rNe = "/assets/JackpotWinner01-CNqQpwwV.png"
  , sNe = "/assets/TaskOnIcon-YUPpZATI.png"
  , iNe = "/assets/why-l1x-play-img-CRXyIgH7.png"
  , RA = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHwAAABxCAYAAAAXgMdgAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAN7SURBVHgB7dxLaxNRGMbxd+acuSWdVo1FUMSVK0FFXAm69Wv5tbq1IF2UYuumErBUe8FWbNpJm7mcmTFHULLThS+iz/OD0K4ymfMPmc17joiS8XicvN4ar4qinZ3962tr20NR9ObtpzuiaHPzaLA+vw9RtLhOoRAUBgfD4GAYHAyDg2FwMAwOhsHBMDgYBgfD4GAYHAyDg2FwMAwOhsHBMDgYBgfD4GACP3smCg7qlehG0g0GfXEuSs67Ye7OLuvRSCpRcnqZ3lwdll9EyXk4StPYmKQ8uRQli+sUaA0a1rUJ09iaTqpGlKSJNf5vWblWlNj5XbiurEXJ/7JOnFr9TZxaJVUMDobBwTA4GAYHw+BgGBwMg4NhcDAMDobBwTA4GAYHw+BgGBwMg4NhcDAMDobBwQQbG+NlUdAMYpOYLukKdyVK2ixPV25kbnp44kRJl6Z5WJaFKJkGWZSl1phZUYqSxXWyQn9V5kpTd81gmI/Ufm1dVYb+Sv7/QJT4qdXjQpZfPLl/Kkr8NObx8aR++fKR2ky3n1p99vjuoSjZ3T3Nz2bTUR/ZC1FiAxefHVwUfp34DAfD4GAYHAyDg2FwMAwOhsHBMDgYBgfD4GAYHAyDg2FwMAwOhsHBMDgYBgfD4GAYHAyDg2FwMAwOhsdn/4L28dn7X91SkoUriYnVNmxYsxTWk8nUr5P1s+OioK2nYVFZM6+t8v5eKC6yWZaeN3rHQodBEGitkRebzLrGhZlJYlFSlmVrczs4LlzyT29EePfh862mDk3pSrVtOnFglp4+uP1RlPjjs2dxkzx/eO9MlCxu2OAzHAyDg2FwMAwOhsHBMDgYBgfD4GAYHAyDg2FwMAwOhsHBMDgYBgfD4GAYHAyDg2FwMAwOhsHBBOs7+9dFQTUz4bU8iWfuSm2iNDBRHtvGtlddJ0qiOOlmbaN2QH4/qW2bWmPTUG223pVdMitdm1+Lnc1uRioXcu+ruEptm61GajdSnV5FoR10y5neNSZVtaJ5D7P5K0+iXnK9zRRSiP9CtVqtv/Nz6a+3xquiyM9br61tD0WRPyBfFPm5dK1f2R8W14nPcDAMDobBwTA4GAYHw+BgGBwMg4NhcDAMDobBwTA4GAYHw+BgGBwMg4NhcDAMTn/Gq1d9uLfXp6Ko7/t4/jKiaPPoaCCK/OfXOuB44Ro/1+kb+udjUruRhesAAAAASUVORK5CYII="
  , oNe = "/assets/tech-pattern-disImkDm.png"
  , aNe = "/assets/tech-pattern-rb-C4Z6sgjt.png"
  , lNe = "/assets/gif600-DEA9Y1lb.gif"
  , cNe = "/assets/x-talk-game-Bf5sT6h4.png"
  , uNe = "data:image/svg+xml,%3csvg%20width='30'%20height='50'%20viewBox='0%200%2030%2050'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20clip-path='url(%23clip0_298_22347)'%3e%3cpath%20d='M20.7318%200C21.3802%200.352407%2021.7503%200.948888%2021.6112%201.74376L17.8028%2019.398H28.9485C28.9919%2019.398%2029.5777%2019.7635%2029.6543%2019.8496C30.0895%2020.343%2030.106%2021.117%2029.7564%2021.6561C22.7216%2030.4427%2016.3938%2040.0843%209.31944%2048.807C8.78979%2049.4596%208.61622%2050.0026%207.67688%2050.0026C6.73755%2050.0026%206.27426%2049.3709%206.26916%2048.4233L11.9447%2030.5941H1.05304C1.00965%2030.5941%200.423842%2030.2287%200.347266%2030.1425C-0.11602%2029.6178%20-0.0981523%2028.8164%200.296215%2028.2591C6.62524%2019.445%2012.2204%2010.0371%2018.5903%201.26083C18.9323%200.789652%2019.2373%200.344576%2019.7134%200H20.7318ZM25.7004%2022.2617H15.7008C15.2771%2022.2617%2014.4858%2021.2736%2014.6121%2020.7711C15.2235%2016.9338%2016.5852%2012.9581%2017.1328%209.1443C17.1545%208.99551%2017.2438%208.68095%2017.1034%208.59351L4.17352%2027.7292H14.3007C14.764%2027.7292%2015.5757%2028.806%2015.3779%2029.3411C14.4207%2032.5245%2013.2516%2035.644%2012.2932%2038.8248C12.1272%2039.3743%2011.872%2040.0491%2011.8809%2040.6168L25.7016%2022.2617H25.7004Z'%20fill='%23F56027'/%3e%3c/g%3e%3cdefs%3e%3cclipPath%20id='clip0_298_22347'%3e%3crect%20width='30'%20height='50'%20fill='white'/%3e%3c/clipPath%3e%3c/defs%3e%3c/svg%3e"
  , dNe = "data:image/svg+xml,%3csvg%20width='40'%20height='57'%20viewBox='0%200%2040%2057'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20clip-path='url(%23clip0_298_22363)'%3e%3cpath%20d='M0%2031.7714C0.288926%2030.1163%200.955885%2028.7542%202.43292%2027.8444C2.68404%2027.6892%203.91265%2027.0991%204.10436%2027.0991H6.05529V12.7504C7.80234%20-4.32242%2032.199%20-4.22207%2033.7732%2012.8842V27.0991H35.7255C35.9172%2027.0991%2037.1458%2027.6892%2037.397%2027.8444C38.9159%2028.7796%2039.6517%2030.2487%2039.8123%2031.9881C40.3929%2038.2807%2039.4086%2045.3574%2039.8353%2051.733C39.8056%2054.33%2037.9087%2056.6849%2035.2543%2057.0007H4.57556C2.7934%2056.6086%201.26371%2055.7496%200.514396%2054.0209C0.243022%2053.3934%200.182266%2052.8315%200%2052.1946L0%2031.7714ZM31.3525%2027.0991V12.4828C31.3525%206.80169%2024.8962%202.04377%2019.4377%202.26454C14.3491%202.47059%208.4774%207.19239%208.4774%2012.4828V27.0991H11.5719V12.349C11.5719%2011.7831%2012.3536%209.99014%2012.6749%209.43888C15.8518%203.97049%2023.9768%203.96647%2027.155%209.43888C27.4763%209.99148%2028.258%2011.7831%2028.258%2012.349V27.0991H31.3525ZM25.8345%2027.0991V12.4828C25.8345%2012.155%2025.2135%2010.8505%2025.0002%2010.5066C22.7144%206.81641%2017.2383%206.76423%2014.8783%2010.425C14.6474%2010.7836%2013.9926%2012.1323%2013.9926%2012.4828V27.0991H25.8332H25.8345ZM4.40409%2029.5329C3.25379%2029.8995%202.58818%2030.7973%202.42212%2031.9721C2.84065%2038.4012%201.86857%2045.5193%202.41806%2051.8668C2.55308%2053.4215%203.45631%2054.4344%205.04135%2054.6043H34.7899C36.3776%2054.4344%2037.2782%2053.4188%2037.4132%2051.8668C36.9919%2045.522%2037.9573%2038.4988%2037.4132%2032.2343C37.3025%2030.9646%2036.7651%2030.0159%2035.5284%2029.565L4.40544%2029.5316L4.40409%2029.5329Z'%20fill='%23F56027'/%3e%3cpath%20d='M18.2976%2034.0408C18.3543%2034.0983%2019.857%2034.097%2019.9137%2034.0408C19.9812%2033.9739%2019.7598%2033.1631%2020.1067%2032.6961C20.4537%2032.2292%2021.0356%2032.078%2021.5635%2032.3362C22.6207%2032.8513%2021.9632%2033.6782%2022.2656%2034.1759C22.325%2034.2723%2023.8169%2034.9172%2024.2179%2035.3092C25.5639%2036.6285%2025.8407%2039.2523%2025.0023%2040.89C24.8457%2041.1964%2024.2584%2041.7704%2024.2381%2042.0046C24.2287%2042.1183%2024.8727%2042.9305%2025.0077%2043.2021C26.0419%2045.288%2025.4087%2048.1821%2023.3214%2049.3662C23.1135%2049.484%2022.2683%2049.7409%2022.2237%2049.8118C21.9713%2050.2185%2022.6355%2052.2376%2020.717%2051.7291C19.4789%2051.4013%2020.0851%2049.9576%2019.8354%2049.9215C19.5883%2049.9656%2018.3529%2049.868%2018.2976%2049.9228C18.2179%2050.0018%2018.5744%2051.507%2017.393%2051.7666C15.6554%2052.1479%2015.9767%2050.0218%2015.8755%2049.9242C15.8093%2049.8599%2014.574%2049.9683%2014.3984%2049.0531L14.4241%2034.9346C14.6212%2034.0609%2015.7499%2034.1599%2015.8633%2034.0261C16.0307%2033.8281%2015.6027%2032.3964%2016.9475%2032.2265C18.5447%2032.0244%2018.2058%2033.9445%2018.2976%2034.0395V34.0408ZM16.8179%2040.8472H21.4596C21.7822%2040.8472%2022.622%2040.2063%2022.7935%2039.9012C23.0851%2039.3834%2023.0932%2038.2247%2022.9177%2037.6641C22.7516%2037.1343%2021.8673%2036.4412%2021.3246%2036.4412H16.8165V40.8459L16.8179%2040.8472ZM16.8179%2047.5225H21.5946C21.7579%2047.5225%2022.3884%2047.1518%2022.5424%2046.9953C23.2485%2046.2728%2023.2161%2044.4063%2022.4762%2043.7119C22.3844%2043.6249%2021.7768%2043.2516%2021.7296%2043.2516H16.8179V47.5238V47.5225Z'%20fill='%23F56027'/%3e%3c/g%3e%3cdefs%3e%3cclipPath%20id='clip0_298_22363'%3e%3crect%20width='40'%20height='57'%20fill='white'/%3e%3c/clipPath%3e%3c/defs%3e%3c/svg%3e"
  , fNe = "data:image/svg+xml,%3csvg%20width='50'%20height='50'%20viewBox='0%200%2050%2050'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M25.0013%2045.8346C36.5072%2045.8346%2045.8346%2036.5072%2045.8346%2025.0013C45.8346%2013.4954%2036.5072%204.16797%2025.0013%204.16797C13.4954%204.16797%204.16797%2013.4954%204.16797%2025.0013C4.16797%2036.5072%2013.4954%2045.8346%2025.0013%2045.8346Z'%20stroke='white'%20stroke-width='3'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M4.16797%2025H45.8346'%20stroke='white'%20stroke-width='3'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M25.0013%204.16797C30.2123%209.87287%2033.1737%2017.2764%2033.3346%2025.0013C33.1737%2032.7262%2030.2123%2040.1297%2025.0013%2045.8346C19.7903%2040.1297%2016.8289%2032.7262%2016.668%2025.0013C16.8289%2017.2764%2019.7903%209.87287%2025.0013%204.16797Z'%20stroke='white'%20stroke-width='3'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e"
  , hNe = "data:image/svg+xml,%3csvg%20width='43'%20height='52'%20viewBox='0%200%2043%2052'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20clip-path='url(%23clip0_298_22368)'%3e%3cpath%20d='M0.013203%2047.0828C0.232513%2045.477%201.55893%2043.8126%203.15743%2043.4393C3.3052%2042.1364%202.83491%2040.2876%203.63944%2039.1784C3.84937%2038.8896%204.64334%2038.1818%204.98345%2038.1818H20.3633V35.0195H22.703V38.1818H38.0828C38.4229%2038.1818%2039.2169%2038.8884%2039.4268%2039.1784C40.2314%2040.2876%2039.7611%2042.1364%2039.9089%2043.4393C44.4123%2044.727%2043.8353%2051.3649%2039.1935%2052.0023H38.0242C35.0113%2051.3896%2033.2791%2048.2719%2034.8178%2045.4536C35.4417%2044.3103%2036.3178%2043.8361%2037.4402%2043.2773V40.5247H22.703V43.2773C27.2147%2044.8714%2026.8523%2051.082%2022.1178%2052.0023H20.9485C16.2081%2051.0621%2015.8551%2044.8772%2020.3633%2043.2773V40.5247H5.6273V43.2773C6.74966%2043.8361%207.62572%2044.3103%208.24964%2045.4536C9.78833%2048.2731%208.05613%2051.3896%205.04326%2052.0023H3.874C1.82867%2051.6114%200.428367%2050.1688%200.0143758%2048.1369C0.0460409%2047.8012%20-0.0301899%2047.4068%200.0143758%2047.0828H0.013203ZM3.95961%2045.7059C1.72664%2046.0898%202.08433%2049.9822%204.84037%2049.5138C7.13081%2049.1241%206.77663%2045.2223%203.95961%2045.7059ZM21.0341%2045.7048C20.1205%2045.8738%2019.4825%2046.9091%2019.5705%2047.8094C19.7054%2049.184%2021.3848%2050.0232%2022.581%2049.2438C24.4024%2048.0559%2023.3422%2045.2775%2021.0341%2045.7048ZM38.111%2045.7048C36.2533%2046.0898%2036.224%2049.2638%2038.328%2049.5314C41.4077%2049.9235%2041.2728%2045.0486%2038.111%2045.7048Z'%20fill='white'/%3e%3cpath%20d='M20.2239%205.89096C30.8059%204.8134%2036.3978%2017.8604%2028.3736%2024.5922C20.8748%2030.8827%209.5915%2024.4959%2011.0411%2014.8483C11.7236%2010.3045%2015.5985%206.36166%2020.2251%205.89096H20.2239ZM20.3389%208.34893C14.74%208.98162%2011.6931%2015.4681%2014.3389%2020.3817C17.5828%2026.4057%2026.6648%2025.8857%2029.1394%2019.5037C31.4732%2013.4879%2026.6543%207.63525%2020.3389%208.34893Z'%20fill='white'/%3e%3cpath%20d='M21.5352%200C24.6383%200.0199549%2027.677%200.882709%2030.297%202.5284C38.9064%207.93499%2040.587%2020.138%2033.582%2027.5823C33.84%2027.7466%2035.2192%2027.486%2035.2192%2027.8159V30.1001H29.4878V24.3614H31.8275L31.8849%2025.8838C33.0331%2024.5691%2033.9877%2023.1065%2034.6046%2021.4632C38.0749%2012.2194%2031.3103%202.48379%2021.5352%202.46149V0Z'%20fill='white'/%3e%3cpath%20d='M13.5811%202.80977V8.54855H11.2414L11.184%207.02611C10.9049%207.32543%2010.6199%207.64588%2010.3748%207.9722C3.39555%2017.2853%2010.0628%2030.4285%2021.5338%2030.4484V32.9076C14.3822%2032.9416%207.89199%2028.0996%205.83024%2021.2856C4.15082%2015.7335%205.48779%209.52164%209.48579%205.32643C9.22778%205.16209%207.84859%205.42268%207.84859%205.09284V2.80859H13.58L13.5811%202.80977Z'%20fill='white'/%3e%3cpath%20d='M22.7055%2010.5404C22.7606%2010.5956%2022.6445%2011.5217%2022.7102%2011.5898C22.7418%2011.6227%2023.3411%2011.6884%2023.6027%2011.8081C24.5866%2012.2612%2025.2621%2013.4468%2025.1613%2014.522H22.8216C22.8016%2014.522%2022.7876%2014.2379%2022.716%2014.1335C22.5319%2013.8647%2020.1441%2013.5923%2020.1406%2014.5795C20.1371%2015.5374%2021.9819%2015.1594%2022.6339%2015.2369C25.8438%2015.6207%2026.4337%2019.9732%2023.1722%2021.2585C23.0362%2021.3125%2022.7313%2021.2996%2022.7113%2021.3196C22.6492%2021.3818%2022.7583%2022.369%2022.7066%2022.369H20.367C20.3153%2022.369%2020.4326%2021.4158%2020.3552%2021.3266C20.3236%2021.2902%2019.6562%2021.1494%2019.4252%2021.0285C18.4659%2020.5296%2017.8091%2019.4943%2017.9111%2018.3874H20.1922C20.279%2018.3874%2020.435%2018.8757%2020.6813%2018.9508C21.2442%2019.1245%2023.5428%2019.0682%2022.831%2017.9707C22.5131%2017.48%2021.3544%2017.7336%2020.7786%2017.6831C17.401%2017.3873%2016.5108%2013.2285%2019.6211%2011.726C19.8146%2011.6321%2020.2368%2011.5945%2020.3153%2011.4842C20.4479%2011.2975%2020.3189%2010.5404%2020.367%2010.5404C20.6988%2010.5404%2022.6234%2010.4583%2022.7066%2010.5404H22.7055Z'%20fill='white'/%3e%3c/g%3e%3cdefs%3e%3cclipPath%20id='clip0_298_22368'%3e%3crect%20width='43'%20height='52'%20fill='white'/%3e%3c/clipPath%3e%3c/defs%3e%3c/svg%3e"
  , pNe = "data:image/svg+xml,%3csvg%20width='46'%20height='46'%20viewBox='0%200%2046%2046'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M32.582%201.91797L40.2487%209.58463L32.582%2017.2513'%20stroke='%23F56027'%20stroke-width='3'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M5.75%2021.082V17.2487C5.75%2015.2154%206.55774%2013.2653%207.99551%2011.8275C9.43329%2010.3898%2011.3833%209.58203%2013.4167%209.58203H40.25'%20stroke='%23F56027'%20stroke-width='3'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M13.4167%2044.0833L5.75%2036.4167L13.4167%2028.75'%20stroke='%23F56027'%20stroke-width='3'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M40.25%2024.918V28.7513C40.25%2030.7846%2039.4423%2032.7347%2038.0045%2034.1725C36.5667%2035.6102%2034.6167%2036.418%2032.5833%2036.418H5.75'%20stroke='%23F56027'%20stroke-width='3'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e"
  , mNe = "data:image/svg+xml,%3csvg%20width='45'%20height='45'%20viewBox='0%200%2045%2045'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M43.125%2011.25L25.3125%2029.0625L15.9375%2019.6875L1.875%2033.75'%20stroke='%23F56027'%20stroke-width='3'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M31.875%2011.25H43.125V22.5'%20stroke='%23F56027'%20stroke-width='3'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e"
  , gNe = ({isOpenWhitelist: n, onCloseWhitelist: e}) => {
    const [t,r] = V.useState("")
      , [s,i] = V.useState("")
      , [o,a] = V.useState(!1)
      , [l,u] = V.useState("")
      , [d,h] = V.useState(!1)
      , [p,g] = V.useState(!1)
      , [w,b] = V.useState(!1);
    if (!n)
        return null;
    const v = async S => {
        if (S.preventDefault(),
        u(""),
        h(!1),
        !s && !t) {
            u("Please provide either an email address or wallet address");
            return
        }
        if (s && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(s)) {
            u("Please enter a valid email address");
            return
        }
        a(!0);
        try {
            const _ = S0("userInfo")?.authToken || null
              , I = {
                Accept: "application/json",
                "Content-Type": "application/json;charset=UTF-8"
            };
            _ && (I.Authorization = "Bearer " + _);
            const B = await (await fetch("https://v2-api.l1xapp.com/api/v2/generals/l1x_processEarlyAccessRequest", {
                method: "POST",
                headers: I,
                body: JSON.stringify({
                    email: s || "",
                    walletAddress: t || ""
                })
            })).json();
            if (B?.success || B?.status === "success")
                h(!0),
                i(""),
                r(""),
                setTimeout( () => {
                    h(!1),
                    e()
                }
                , 1e4);
            else {
                let P = B?.message || "Failed to submit request. Please try again.";
                P = P.replace(/Ethereum address/gi, " address"),
                u(P)
            }
        } catch {
            u("An error occurred. Please try again later.")
        } finally {
            a(!1)
        }
    }
    ;
    return m.jsxs("div", {
        className: "",
        children: [m.jsx("div", {
            className: "bg-[#27364b] max-w-lg w-full rounded-3xl fixed top-12 left-0 right-0 mx-auto z-50 text-white overflow-hidden",
            children: d ? m.jsxs("div", {
                className: "bg-[#27364b] p-7 relative",
                children: [m.jsx("div", {
                    onClick: e,
                    className: "cursor-pointer w-12 h-12 flex items-center justify-center absolute right-3 top-3",
                    children: m.jsx("svg", {
                        xmlns: "http://www.w3.org/2000/svg",
                        fill: "none",
                        viewBox: "0 0 24 24",
                        strokeWidth: 1.5,
                        stroke: "#A8B8CC",
                        className: "size-6",
                        children: m.jsx("path", {
                            strokeLinecap: "round",
                            strokeLinejoin: "round",
                            d: "M6 18 18 6M6 6l12 12"
                        })
                    })
                }), m.jsx("div", {
                    children: m.jsx("img", {
                        src: ik,
                        className: "mx-auto",
                        alt: "Success"
                    })
                }), m.jsx("h3", {
                    className: "text-3xl font-normal tracking-[0.3px] text-center mb-3",
                    children: "Awesome"
                }), m.jsx("p", {
                    className: "text-center text-base mb-10",
                    children: "You've been successfully added to the whitelist."
                })]
            }) : m.jsxs("div", {
                className: "bg-[#27364b] p-7 relative",
                children: [m.jsxs("div", {
                    className: " mb-10",
                    children: [m.jsx("h3", {
                        className: "text-2xl font-semibold tracking-[0.3px]",
                        children: "Get Whitelisted for Exclusive Access"
                    }), m.jsx("div", {
                        onClick: e,
                        className: "cursor-pointer w-12 h-12 flex items-center justify-center absolute right-4 top-4",
                        children: m.jsx("svg", {
                            xmlns: "http://www.w3.org/2000/svg",
                            fill: "none",
                            viewBox: "0 0 24 24",
                            strokeWidth: 1.5,
                            stroke: "#A8B8CC",
                            className: "size-6",
                            children: m.jsx("path", {
                                strokeLinecap: "round",
                                strokeLinejoin: "round",
                                d: "M6 18 18 6M6 6l12 12"
                            })
                        })
                    })]
                }), m.jsxs("form", {
                    onSubmit: v,
                    children: [m.jsxs("div", {
                        className: `relative ${p || t ? "filled" : ""}`,
                        children: [m.jsx("input", {
                            type: "text",
                            placeholder: " ",
                            value: t,
                            onFocus: () => g(!0),
                            onBlur: () => g(!1),
                            onChange: S => r(S.target.value),
                            className: "w-full px-4 py-5 rounded-xl bg-[#19222f] focus:outline-none focus:ring-1 focus:ring-[#FF6717] peer"
                        }), m.jsx("label", {
                            className: "absolute left-4 top-5 text-sm text-[#8FA1B8] font-light transition-all duration-200 peer-focus:top-[-10px] peer-focus:left-2 peer-focus:text-xs peer-[:not(:placeholder-shown)]:top-[-10px] peer-[:not(:placeholder-shown)]:left-2 peer-[:not(:placeholder-shown)]:text-xs peer-focus:text-[#FF6717] ",
                            children: "Wallet Address"
                        })]
                    }), m.jsxs("p", {
                        className: "flex items-center gap-3 w-full my-5",
                        children: [m.jsx("span", {
                            className: "h-[1px] bg-white/10 block w-full"
                        }), " ", m.jsx("span", {
                            className: "w-8 min-w-8 h-8 rounded-4xl bg-white/10 p-1 flex items-center justify-center flex-col text-white ",
                            children: "OR"
                        }), m.jsx("span", {
                            className: "h-[1px] bg-white/10 block w-full"
                        })]
                    }), m.jsxs("div", {
                        className: `mb-7 relative ${w || s ? "filled" : ""}`,
                        children: [m.jsx("input", {
                            type: "email",
                            placeholder: " ",
                            value: s,
                            onFocus: () => b(!0),
                            onBlur: () => b(!1),
                            onChange: S => i(S.target.value),
                            className: "w-full px-4 py-5 rounded-xl bg-[#19222f] focus:outline-none focus:ring-1 focus:ring-[#FF6717] peer"
                        }), m.jsx("label", {
                            className: "absolute left-4 top-5 text-sm text-[#8FA1B8] font-light transition-all duration-200 peer-focus:top-[-10px] peer-focus:left-2 peer-focus:text-xs peer-[:not(:placeholder-shown)]:top-[-10px] peer-[:not(:placeholder-shown)]:left-2 peer-[:not(:placeholder-shown)]:text-xs",
                            children: "Email Address"
                        })]
                    }), l && m.jsx("div", {
                        className: "mb-4 text-red-400 text-sm text-center",
                        children: l
                    }), m.jsx("div", {
                        className: "text-center mt-8",
                        children: m.jsx("button", {
                            type: "submit",
                            disabled: o,
                            className: "cursor-pointer text-white rounded-4xl brand-gradient-bg flex gap-4 items-center text-sm xl:text-base font-medium justify-center py-4 px-32 text-center w-full whitespace-nowrap mx-auto disabled:opacity-50 disabled:cursor-not-allowed",
                            children: o ? "Submitting..." : "Submit"
                        })
                    })]
                })]
            })
        }), m.jsx("div", {
            className: "fixed bg-black/70 w-full h-full top-0 left-0 z-40 backdrop-blur-md"
        })]
    })
}
  , $p = "/assets/behindAnima-5fu2OcYO.gif"
  , yNe = "/assets/seven-Cd7WdIol.png"
  , bNe = "/assets/cherry-C34G03V8.png"
  , wNe = "/assets/grapes-Bv2zMDYR.png"
  , vNe = "/assets/lemon-dKTJD9y-.png"
  , xNe = "/assets/marker-B60tMeE9.png"
  , ENe = "/assets/slot-machine-frame-Cdy794kj.png"
  , SNe = "/assets/Congratuation-QjgdDKMy.png"
  , ANe = "/assets/l1xp-VNhcBB0p.png"
  , CNe = "/assets/betterLuck-DR5Hvbz3.png"
  , _Ne = "/assets/0-DzXfQRMg.png"
  , kNe = "/assets/1-DxVAS34t.png"
  , NNe = "/assets/2-DU8FagwD.png"
  , DNe = "/assets/3-Bsx8pHLB.png"
  , TNe = "/assets/4-odN8dBq0.png"
  , INe = "/assets/5-GoCkAi35.png"
  , MNe = "/assets/6-CK5cI76t.png"
  , BNe = "/assets/7-bzs45puw.png"
  , RNe = "/assets/8-Djf4zDog.png"
  , ONe = "/assets/9-BvOB9Iah.png"
  , PNe = "/assets/xLogo-vkbTZ4gt.png"
  , Fl = "/assets/share100-CI9NttJj.png"
  , OA = "/assets/JW5-jJVVSPx7.png"
  , PA = "/assets/JW10-BQkW_Grc.png"
  , jA = "/assets/JW15-BdQQg_r2.png"
  , LA = "/assets/JW20-tV_Te7-G.png"
  , FA = "/assets/JW50-DH416rKk.png";
function cG({text: n="Check this out!", url: e="", hashtags: t=[], via: r="", openInNewTab: s=!0, winAmount: i=null, imageIndex: o=0, onShare: a=null, onShareSuccess: l=null}) {
    const [u,d] = V.useState(!1)
      , h = B => {
        if (B == null)
            return Fl;
        const P = Number(B);
        return console.log("winValue", P),
        P === 5 ? OA : P === 10 ? PA : P === 15 ? jA : P === 20 ? LA : P === 50 ? FA : Fl
    }
      , p = [OA, PA, jA, LA, FA, Fl, Fl, Fl, Fl, Fl]
      , g = B => {
        if (B == null)
            return o;
        const P = Number(B);
        return P === 5 ? 0 : P === 10 ? 1 : P === 15 ? 2 : P === 20 ? 3 : P === 50 ? 4 : 5
    }
    ;
    console.log("winAmount", i),
    console.log("calculateImageIndex", g(i));
    const w = i != null ? h(i) : p[g(i)]
      , b = i != null ? g(i) : o
      , v = async B => {
        if (B.preventDefault(),
        !u) {
            d(!0);
            try {
                console.log("Step 1: Initiating Twitter OAuth...");
                const P = await aZ();
                if (console.log("OAuth Response:", P),
                P?.status === "success" && P?.data?.authUrl) {
                    const M = P.data.oauthToken || P.data.oauth_token
                      , R = P.data.oauthTokenSecret || P.data.oauth_token_secret;
                    console.log("OAuth tokens received:", {
                        oauthToken: M ? "present" : "missing",
                        oauthTokenSecret: R ? "present" : "missing"
                    });
                    const L = window.open(P.data.authUrl, "Twitter OAuth", "width=600,height=700,scrollbars=yes,resizable=yes");
                    let q = !1
                      , H = !1;
                    const j = async O => {
                        if (console.log("OAuth callback received:", O.data),
                        O.data && (O.data.type === "TWITTER_OAUTH_SUCCESS" || O.data.oauth_verifier || O.data.oauthVerifier)) {
                            if (q || H) {
                                console.log("OAuth callback already processed, ignoring duplicate");
                                return
                            }
                            if (q = !0,
                            H = !0,
                            window.removeEventListener("message", j),
                            L && !L.closed)
                                try {
                                    L.close(),
                                    console.log("OAuth popup window closed")
                                } catch (G) {
                                    console.log("Could not close popup window:", G)
                                }
                            const z = O.data.oauth_verifier || O.data.oauthVerifier;
                            console.log("OAuth verifier:", z ? "received" : "missing"),
                            await N(M, R, z)
                        }
                        if (O.data && O.data.type === "CLOSE_WINDOW" && (console.log("Received close window message from callback page"),
                        L && !L.closed))
                            try {
                                L.close(),
                                console.log("Closed popup window via message")
                            } catch (z) {
                                console.log("Could not close popup:", z)
                            }
                    }
                    ;
                    window.addEventListener("message", j);
                    const A = Date.now();
                    let E = !1;
                    const C = setInterval( () => {
                        try {
                            if (L && L.closed && !q && !H) {
                                if (clearInterval(C),
                                window.removeEventListener("message", j),
                                H) {
                                    console.log("Share already initiated, skipping window close handler");
                                    return
                                }
                                H = !0,
                                console.log("OAuth window closed, waiting for backend to process..."),
                                setTimeout(async () => {
                                    q || (console.log("Proceeding with share (backend should have stored tokens)..."),
                                    await N(null, null, null))
                                }
                                , 2e3);
                                return
                            }
                            const O = Date.now() - A;
                            if (L && !L.closed && !q && !H && O > 15e3 && !E) {
                                if (console.log("Popup open for 15+ seconds, attempting to close (OAuth likely completed)..."),
                                E = !0,
                                H) {
                                    console.log("Share already initiated, skipping timeout handler");
                                    return
                                }
                                try {
                                    L.close(),
                                    console.log("Attempted to close popup window (method 1)")
                                } catch (z) {
                                    console.log("Method 1 failed:", z)
                                }
                                try {
                                    L.postMessage({
                                        type: "CLOSE_WINDOW",
                                        action: "close"
                                    }, "*"),
                                    console.log("Sent close message to popup")
                                } catch (z) {
                                    console.log("Method 2 failed:", z)
                                }
                                try {
                                    L.focus(),
                                    L.close(),
                                    console.log("Attempted focus + close")
                                } catch (z) {
                                    console.log("Method 3 failed:", z)
                                }
                                setTimeout(async () => {
                                    if (!q && !H) {
                                        H = !0,
                                        clearInterval(C),
                                        window.removeEventListener("message", j);
                                        try {
                                            L && !L.closed && L.close()
                                        } catch {}
                                        console.log("Proceeding with share after timeout..."),
                                        await N(null, null, null)
                                    }
                                }
                                , 2e3)
                            }
                            if (L && !L.closed && !q && !H)
                                try {
                                    const z = L.location.href;
                                    if (z.includes("oauth_verifier") || z.includes("oauth/callback") || z.includes("success") || z.includes("authorized")) {
                                        if (H) {
                                            console.log("Share already initiated, skipping URL detection");
                                            return
                                        }
                                        H = !0,
                                        console.log("OAuth callback detected in URL, closing popup..."),
                                        q = !0,
                                        clearInterval(C),
                                        window.removeEventListener("message", j);
                                        try {
                                            L.close()
                                        } catch ($) {
                                            console.log("Could not close via close():", $)
                                        }
                                        const Y = new URLSearchParams(z.split("?")[1] || "").get("oauth_verifier");
                                        setTimeout(async () => {
                                            await N(M, R, Y)
                                        }
                                        , 1e3)
                                    }
                                } catch {}
                        } catch {}
                    }
                    , 1e3);
                    setTimeout( () => {
                        clearInterval(C),
                        window.removeEventListener("message", j),
                        d(!1)
                    }
                    , 3e5)
                } else
                    P?.status === "success" && P?.data?.alreadyAuthorized ? (console.log("User already authorized, proceeding with share..."),
                    await N(null, null, null)) : (console.log("OAuth initiation failed, trying fallback:", P),
                    await _(),
                    d(!1))
            } catch (P) {
                console.error("Error initiating OAuth:", P),
                await _(),
                d(!1)
            }
        }
    }
      , S = V.useRef(!1)
      , N = async (B=null, P=null, M=null) => {
        if (S.current) {
            console.log("Share already in progress, skipping duplicate call");
            return
        }
        S.current = !0;
        try {
            d(!0),
            console.log("Step 2: Starting share process..."),
            console.log("Current image source:", w),
            console.log("Image type:", typeof w),
            console.log("Converting image to base64...");
            let R;
            try {
                if (console.log("winAmount 444", i),
                i === 5 ? R = await I(OA) : i === 10 ? R = await I(PA) : i === 15 ? R = await I(jA) : i === 20 ? R = await I(LA) : i === 50 ? R = await I(FA) : i === 100 && (R = await I(Fl)),
                R = await I(w),
                console.log("Image converted successfully, base64 length:", R?.length || 0),
                console.log("Base64 preview (first 100 chars):", R?.substring(0, 100) || "N/A"),
                !R || R.length === 0)
                    throw new Error("Image base64 conversion returned empty result")
            } catch (A) {
                throw console.error("Error converting image to base64:", A),
                new Error(`Failed to convert image to base64: ${A.message}`)
            }
            let L = n;
            if (e && (L += ` ${e}`),
            t && t.length > 0) {
                const A = t.map(E => `#${E}`).join(" ");
                L += ` ${A}`
            }
            r && (L += ` via @${r}`);
            const q = {
                imageBase64: R,
                text: L,
                url: e || "",
                hashtags: t || [],
                via: r || "",
                imageIndex: b
            };
            B && (q.oauthToken = B),
            P && (q.oauthTokenSecret = P),
            M && (q.oauthVerifier = M),
            console.log("Calling shareJackpotRewardToSocialMedia API..."),
            console.log("Payload keys:", Object.keys(q)),
            console.log("Image base64 present:", !!q.imageBase64),
            console.log("Image base64 length:", q.imageBase64?.length || 0);
            const H = await lZ(q);
            console.log("Share API response:", H);
            const j = H && (H.status === "success" || H.status === "Success" || H.success === !0 || H.data && H.data.tweetId || H.data && H.data.tweetUrl || H.data && H.data.transactionId);
            if (console.log("Share success check:", {
                response: H,
                status: H?.status,
                isSuccess: j,
                hasOnShare: !!a,
                onShareType: typeof a
            }),
            j) {
                if (a && typeof a == "function") {
                    console.log("Calling onShare(true) callback...");
                    try {
                        a(!0),
                        console.log("onShare callback executed successfully")
                    } catch (A) {
                        console.error("Error in onShare callback:", A)
                    }
                } else
                    console.warn("onShare callback not provided or not a function");
                console.log("Successfully shared to X!", H.data?.tweetUrl || H.data?.tweetId || H.data?.transactionId || "Tweet posted"),
                l();
                return
            } else {
                console.error("Share API failed:", H),
                alert("Failed to share. Please try again later.");
                return
            }
        } catch (R) {
            console.error("Error sharing to X:", R),
            console.error("Error stack:", R.stack),
            alert("Failed to share. Please try again later.");
            return
        } finally {
            d(!1),
            S.current = !1
        }
    }
    ;
    async function _() {
        k()
    }
    async function I(B) {
        return console.log("imageToBase64 called with:", B),
        new Promise( (P, M) => {
            fetch(B).then(R => {
                if (!R.ok)
                    throw new Error(`Failed to fetch image: ${R.statusText}`);
                return R.blob()
            }
            ).then(R => {
                console.log("Image fetched as blob, size:", R.size, "type:", R.type);
                const L = new FileReader;
                L.onloadend = () => {
                    const q = L.result
                      , H = q.split(",")[1] || q;
                    console.log("Image converted to base64, length:", H.length),
                    P(H)
                }
                ,
                L.onerror = q => {
                    console.error("FileReader error:", q),
                    M(new Error("Failed to read image as base64"))
                }
                ,
                L.readAsDataURL(R)
            }
            ).catch(R => {
                console.log("Fetch method failed, trying canvas method:", R);
                const L = new Image;
                L.crossOrigin = "anonymous",
                L.onload = () => {
                    try {
                        console.log("Image loaded in canvas, dimensions:", L.width, "x", L.height);
                        const q = document.createElement("canvas");
                        q.width = L.width,
                        q.height = L.height,
                        q.getContext("2d").drawImage(L, 0, 0);
                        const j = q.toDataURL("image/png")
                          , A = j.split(",")[1] || j;
                        console.log("Image converted to base64 via canvas, length:", A.length),
                        P(A)
                    } catch (q) {
                        console.error("Canvas conversion error:", q),
                        M(new Error(`Canvas conversion failed: ${q.message}`))
                    }
                }
                ,
                L.onerror = q => {
                    console.error("Image load error:", q),
                    M(new Error(`Failed to load image: ${B}`))
                }
                ,
                L.src = B
            }
            )
        }
        )
    }
    function k() {
        const B = new URLSearchParams;
        n && B.set("text", n);
        const P = e || window.location.href;
        P && B.set("url", P),
        r && B.set("via", r),
        t && t.length && B.set("hashtags", t.join(","));
        const M = `https://x.com/intent/tweet?${B.toString()}`;
        s ? window.open(M, "_blank", "noopener,noreferrer") : window.location.href = M
    }
    return m.jsx("button", {
        onClick: v,
        disabled: u,
        className: `text-base font-medium border bg-white text-black px-3 py-1.5 rounded-full border-white inline-block w-auto mx-auto cursor-pointer transition-colors ${u ? "opacity-50 cursor-not-allowed" : "hover:opacity-80"}`,
        "aria-label": "Share on X",
        children: u ? m.jsxs("span", {
            className: "flex items-center gap-2",
            children: [m.jsxs("svg", {
                className: "animate-spin h-4 w-4",
                xmlns: "http://www.w3.org/2000/svg",
                fill: "none",
                viewBox: "0 0 24 24",
                children: [m.jsx("circle", {
                    className: "opacity-25",
                    cx: "12",
                    cy: "12",
                    r: "10",
                    stroke: "currentColor",
                    strokeWidth: "4"
                }), m.jsx("path", {
                    className: "opacity-75",
                    fill: "currentColor",
                    d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                })]
            }), "Sharing..."]
        }) : m.jsxs(m.Fragment, {
            children: ["Share on ", m.jsx("img", {
                src: PNe,
                alt: "X Logo",
                className: "w-5 h-5 inline-block ml-1"
            })]
        })
    })
}
const jNe = "/assets/reel-spin-CzJrpKIW.mp3"
  , LNe = "/assets/win-sound-cOMlD--x.wav"
  , uG = {
    cabinet: ENe,
    seven: yNe,
    cherry: bNe,
    grapes: wNe,
    mango: vNe,
    handle: xNe
}
  , dp = ["cherry", "seven", "grapes", "mango"]
  , pw = 112
  , FNe = {
    0: _Ne,
    1: kNe,
    2: NNe,
    3: DNe,
    4: TNe,
    5: INe,
    6: MNe,
    7: BNe,
    8: RNe,
    9: ONe
}
  , UNe = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
  , mw = 160;
function zNe() {
    const [n,e] = V.useState([])
      , [t,r] = V.useState(!0)
      , s = ["bg-gradient-to-br from-[#FFC12C] to-[#FF6B35]", "bg-gradient-to-br from-[#4A90E2] to-[#357ABD]", "bg-gradient-to-br from-[#50C878] to-[#2E8B57]", "bg-gradient-to-br from-[#FF6B9D] to-[#C44569]", "bg-gradient-to-br from-[#9B59B6] to-[#6C3483]", "bg-gradient-to-br from-[#F39C12] to-[#D68910]", "bg-gradient-to-br from-[#1ABC9C] to-[#16A085]", "bg-gradient-to-br from-[#E74C3C] to-[#C0392B]"];
    if (V.useEffect( () => {
        async function u() {
            try {
                r(!0);
                const d = await YV(1, 10);
                if (d?.status === "success" && d?.data?.data) {
                    const h = d.data.data.map(p => ({
                        address: p.walletAddress || p.wallet_address || p.address || "",
                        amount: p.rewardAmount || p.reward_amount || p.amount || p.winAmount || p.win_amount || 0
                    })).filter(p => p.address && p.amount > 0);
                    e(h.length > 0 ? h : [])
                } else
                    e([])
            } catch (d) {
                console.error("Error fetching jackpot winners:", d),
                e([])
            } finally {
                r(!1)
            }
        }
        u()
    }
    , []),
    t || n.length === 0)
        return null;
    const i = 72
      , o = 3
      , a = .5
      , l = n.length * (o + a);
    return m.jsxs("div", {
        className: "relative w-full max-w-md mx-auto mt-0 mb-4 h-[68px] overflow-hidden z-50",
        children: [m.jsx("div", {
            className: "flex flex-col animate-vertical-slider-step",
            children: n.map( (u, d) => {
                const h = d % s.length
                  , p = s[h]
                  , g = u.address.substring(2, 4).toUpperCase();
                return m.jsxs("div", {
                    className: "shrink-0 flex items-center gap-3 px-4 py-3 my-1 bg-gradient-to-r from-[#1a1a1a]/90 to-[#2d2d2d]/90 border border-[#FFC12C]/30 rounded-lg backdrop-blur-sm shadow-lg h-16",
                    children: [m.jsx("div", {
                        className: `${p} w-12 h-12 rounded-full flex items-center justify-center text-black font-bold text-sm shadow-lg shrink-0`,
                        children: g
                    }), m.jsxs("div", {
                        className: "flex flex-col min-w-0 flex-1",
                        children: [m.jsx("span", {
                            className: "text-white text-sm font-medium",
                            children: zo(u.address, 5)
                        }), m.jsxs("span", {
                            className: "text-[#FFE559] text-xs font-semibold",
                            children: ["Won: $", Number(u.amount || 0).toFixed(2)]
                        })]
                    }), m.jsx("div", {
                        className: "shrink-0",
                        children: m.jsx("svg", {
                            xmlns: "http://www.w3.org/2000/svg",
                            fill: "none",
                            viewBox: "0 0 24 24",
                            strokeWidth: 2,
                            stroke: "#FFC12C",
                            className: "w-5 h-5",
                            children: m.jsx("path", {
                                strokeLinecap: "round",
                                strokeLinejoin: "round",
                                d: "M16.5 18.75h-9m9 0a3 3 0 013 3h-15a3 3 0 013-3m9 0v-3.375c0-.621-.503-1.125-1.125-1.125h-.871M7.5 18.75v-3.375c0-.621.504-1.125 1.125-1.125h.872m5.007 0H9.497m5.007 0a7.454 7.454 0 01-.982-3.172M9.497 14.25a7.454 7.454 0 00.981-3.172M5.25 4.236c-.982.143-1.954.317-2.916.52A6.003 6.003 0 007.73 9.728M5.25 4.236v4.983m6-4.824v2.251m0 0c0 1.893.393 3.683 1.101 5.25M12.75 4.236c1.893 0 3.683.393 5.25 1.101m-5.25 0v2.25m0 0c0 1.893.393 3.683 1.101 5.25M12.75 7.236c-1.893 0-3.683.393-5.25 1.101"
                            })
                        })
                    })]
                }, `winner-${d}`)
            }
            )
        }), m.jsx("style", {
            children: `
        @keyframes vertical-slider-step {
          ${n.map( (u, d) => {
                const h = d / n.length * 100
                  , p = (d + 1) / n.length * 100
                  , g = o / (o + a) * 100
                  , w = h + (p - h) * g / 100;
                return `
              ${h}% {
                transform: translateY(-${d * i}px);
              }
              ${w}% {
                transform: translateY(-${d * i}px);
              }
              ${p}% {
                transform: translateY(-${(d + 1) * i}px);
              }
            `
            }
            ).join("")}
        }
        .animate-vertical-slider-step {
          animation: vertical-slider-step ${l}s linear infinite;
        }
      `
        })]
    })
}
function $Ne({symbol: n, isSpinning: e, onStop: t, reelIndex: r}) {
    const s = ye.useMemo( () => {
        const b = [];
        for (let v = 0; v < 20; v++)
            dp.forEach(S => b.push(S));
        return b
    }
    , [])
      , i = s.findIndex(b => b === n)
      , o = i !== -1 ? i * pw : 0
      , [a,l] = V.useState(o)
      , u = V.useRef(o)
      , d = V.useRef(n)
      , h = V.useRef(null)
      , p = V.useRef(null)
      , g = V.useRef(null)
      , w = V.useRef(n);
    return V.useEffect( () => {
        if (!e && w.current !== n) {
            d.current = n,
            w.current = n;
            const b = s.findIndex(v => v === n);
            if (b !== -1) {
                const v = b * pw;
                setTimeout( () => {
                    u.current = v,
                    l(v)
                }
                , 0)
            }
        } else
            e || (d.current = n)
    }
    , [n, e, s]),
    V.useEffect( () => {
        if (e) {
            p.current = Date.now();
            const b = () => {
                if (!e) {
                    h.current && cancelAnimationFrame(h.current);
                    return
                }
                const v = Date.now() - p.current
                  , S = Math.max(2, 20 - v / 100);
                l(N => {
                    const _ = N + S;
                    return u.current = _,
                    _
                }
                ),
                h.current = requestAnimationFrame(b)
            }
            ;
            h.current = requestAnimationFrame(b)
        } else {
            h.current && (cancelAnimationFrame(h.current),
            h.current = null);
            const b = u.current
              , v = d.current;
            let S = -1;
            for (let N = 0; N < s.length; N++) {
                const _ = N * pw;
                if (s[N] === v && _ >= b) {
                    S = N;
                    break
                }
            }
            if (S === -1 && (S = s.findIndex(N => N === v)),
            S !== -1) {
                const N = S * pw
                  , _ = b
                  , I = N - _
                  , k = 500
                  , B = Date.now()
                  , P = () => {
                    const M = Date.now() - B
                      , R = Math.min(M / k, 1)
                      , L = 1 - Math.pow(1 - R, 3)
                      , q = _ + I * L;
                    u.current = q,
                    l(q),
                    R < 1 ? g.current = requestAnimationFrame(P) : (g.current = null,
                    t())
                }
                ;
                g.current = requestAnimationFrame(P)
            } else
                t()
        }
        return () => {
            h.current && cancelAnimationFrame(h.current),
            g.current && cancelAnimationFrame(g.current)
        }
    }
    , [e, r, t, s]),
    m.jsxs("div", {
        className: "w-28 h-28 overflow-hidden relative bg-transparent rounded-md",
        children: [m.jsx("div", {
            className: "absolute inset-0 flex items-center justify-center z-10 pointer-events-none",
            children: m.jsx("div", {
                className: "w-full h-full  rounded-md"
            })
        }), m.jsx("div", {
            className: "flex flex-col transition-none",
            style: {
                transform: `translateY(-${a}px)`,
                willChange: e ? "transform" : "auto"
            },
            children: s.map( (b, v) => m.jsx("div", {
                className: "w-28 h-28 flex items-center justify-center shrink-0",
                children: m.jsx("img", {
                    src: uG[b],
                    alt: b,
                    className: "max-w-full max-h-full object-contain"
                })
            }, v))
        })]
    })
}
function HNe({targetNumber: n, isSpinning: e, onStop: t}) {
    const r = ye.useMemo( () => {
        const g = [];
        for (let w = 0; w < 15; w++)
            UNe.forEach(b => g.push(b));
        return g
    }
    , [])
      , s = r.findIndex(g => g === n)
      , i = s !== -1 ? s * mw : 0
      , [o,a] = V.useState(i)
      , l = V.useRef(i)
      , u = V.useRef(n)
      , d = V.useRef(null)
      , h = V.useRef(null)
      , p = V.useRef(null);
    return V.useEffect( () => {
        if (u.current = n,
        !e) {
            const g = r.findIndex(w => w === n);
            if (g !== -1) {
                const w = g * mw;
                setTimeout( () => {
                    l.current = w,
                    a(w)
                }
                , 0)
            }
        }
    }
    , [n, e, r]),
    V.useEffect( () => {
        if (e) {
            h.current = Date.now();
            const g = () => {
                if (!e) {
                    d.current && cancelAnimationFrame(d.current);
                    return
                }
                const w = Date.now() - h.current
                  , b = Math.max(2, 20 - w / 100);
                a(v => {
                    const S = v + b;
                    return l.current = S,
                    S
                }
                ),
                d.current = requestAnimationFrame(g)
            }
            ;
            d.current = requestAnimationFrame(g)
        } else {
            d.current && (cancelAnimationFrame(d.current),
            d.current = null);
            const g = l.current
              , w = u.current;
            let b = -1;
            for (let v = 0; v < r.length; v++) {
                const S = v * mw;
                if (r[v] === w && S >= g) {
                    b = v;
                    break
                }
            }
            if (b === -1 && (b = r.findIndex(v => v === w)),
            b !== -1) {
                const v = b * mw
                  , S = g
                  , N = v - S
                  , _ = 500
                  , I = Date.now()
                  , k = () => {
                    const B = Date.now() - I
                      , P = Math.min(B / _, 1)
                      , M = 1 - Math.pow(1 - P, 3)
                      , R = S + N * M;
                    l.current = R,
                    a(R),
                    P < 1 ? p.current = requestAnimationFrame(k) : (p.current = null,
                    t())
                }
                ;
                p.current = requestAnimationFrame(k)
            } else
                t()
        }
        return () => {
            d.current && cancelAnimationFrame(d.current),
            p.current && cancelAnimationFrame(p.current)
        }
    }
    , [e, t, r]),
    m.jsxs("div", {
        className: "w-40 h-40 overflow-hidden relative bg-transparent rounded-md",
        children: [m.jsx("div", {
            className: "absolute inset-0 flex items-center justify-center z-10 pointer-events-none",
            children: m.jsx("div", {
                className: "w-full h-full rounded-md"
            })
        }), m.jsx("div", {
            className: "flex flex-col transition-none",
            style: {
                transform: `translateY(-${o}px)`,
                willChange: e ? "transform" : "auto"
            },
            children: r.map( (g, w) => m.jsx("div", {
                className: "w-40 h-40 flex items-center justify-center shrink-0",
                children: m.jsx("img", {
                    src: FNe[g],
                    alt: g.toString(),
                    className: "max-w-full max-h-full object-contain"
                })
            }, w))
        })]
    })
}
function VNe({show: n, onClose: e}) {
    return n ? m.jsx("div", {
        className: "fixed inset-0 z-[100] flex items-center justify-center backdrop-blur-lg",
        onClick: e,
        children: m.jsxs("div", {
            className: "relative bg-gradient-to-br from-[#1a1a1a] via-[#2d2d2d] to-[#1a1a1a] rounded-2xl p-6 md:p-8 max-w-md w-[90%] border-2 border-[#FFC12C]/50 shadow-2xl",
            onClick: t => t.stopPropagation(),
            children: [m.jsx("div", {
                className: "flex justify-center mb-4",
                children: m.jsx("div", {
                    className: "w-20 h-20 rounded-full bg-gradient-to-br from-[#FFC12C] to-[#FF6B35] flex items-center justify-center shadow-lg border-4 border-[#FFE559]/50",
                    children: m.jsx("svg", {
                        xmlns: "http://www.w3.org/2000/svg",
                        fill: "none",
                        viewBox: "0 0 24 24",
                        strokeWidth: 3,
                        stroke: "currentColor",
                        className: "w-12 h-12 text-white",
                        children: m.jsx("path", {
                            strokeLinecap: "round",
                            strokeLinejoin: "round",
                            d: "M4.5 12.75l6 6 9-13.5"
                        })
                    })
                })
            }), m.jsx("h2", {
                className: "text-2xl md:text-3xl font-extrabold text-center mb-4 bg-gradient-to-r from-[#FFC12C] via-[#FFE559] to-[#FFC12C] bg-clip-text text-transparent",
                children: "Successfully Shared!"
            }), m.jsxs("div", {
                className: "text-center mb-6",
                children: [m.jsxs("p", {
                    className: "text-white text-base md:text-lg",
                    children: ["Your jackpot win has been shared on ", m.jsx("span", {
                        className: "text-[#FFE559] font-semibold",
                        children: "X (Twitter)"
                    }), "!"]
                }), m.jsx("p", {
                    className: "text-gray-300 text-sm mt-2",
                    children: "Your social reward will be unlocked soon."
                })]
            }), m.jsx("div", {
                className: "flex justify-center",
                children: m.jsx("button", {
                    onClick: e,
                    className: "px-8 py-3 bg-gradient-to-r from-[#FFC12C] to-[#FF6B35] text-black font-bold rounded-full hover:from-[#FFE559] hover:to-[#FFC12C] transition-all shadow-lg border-2 border-[#FFE559]/50 transform hover:scale-105",
                    children: "Awesome!"
                })
            }), m.jsx("div", {
                className: "absolute top-2 left-2 w-6 h-6 border-t-2 border-l-2 border-[#FFC12C]/50"
            }), m.jsx("div", {
                className: "absolute top-2 right-2 w-6 h-6 border-t-2 border-r-2 border-[#FFC12C]/50"
            }), m.jsx("div", {
                className: "absolute bottom-2 left-2 w-6 h-6 border-b-2 border-l-2 border-[#FFC12C]/50"
            }), m.jsx("div", {
                className: "absolute bottom-2 right-2 w-6 h-6 border-b-2 border-r-2 border-[#FFC12C]/50"
            })]
        })
    }) : null
}
function qNe({show: n, onClose: e, winAmount: t, winAmountValue: r, upFrontRewardAmount: s, socialRewardAmount: i, showText: o, onShareSuccess: a}) {
    if (console.log("CongratulationsDisplay winAmount", t),
    !n)
        return null;
    const [l,u] = V.useState(t)
      , [d,h] = V.useState([!1, !1, !1])
      , p = V.useRef(0);
    V.useEffect( () => {
        n && (h([!0, !0, !0]),
        p.current = 0,
        u(t),
        [800, 1200, 1600].forEach( (b, v) => {
            setTimeout( () => {
                h(S => {
                    const N = [...S];
                    return N[v] = !1,
                    N
                }
                )
            }
            , b)
        }
        ))
    }
    , [n]);
    function g() {
        p.current += 1,
        p.current === 3 && (p.current = 0)
    }
    return m.jsx("div", {
        className: "fixed inset-0 z-90 flex items-center justify-center backdrop-blur-lg",
        children: m.jsxs("div", {
            className: "relative flex flex-col items-center justify-center md:scale-100 scale-75",
            children: [m.jsx("div", {
                className: "mb-6",
                children: m.jsx("img", {
                    src: SNe,
                    alt: "Congratulations",
                    className: "max-w-md w-full h-auto object-contain animate-bounce"
                })
            }), m.jsx("div", {
                className: "flex gap-2 items-center justify-center mb-2",
                children: l.map( (w, b) => m.jsx(HNe, {
                    targetNumber: w,
                    isSpinning: d[b],
                    onStop: g
                }, b))
            }), m.jsx("div", {
                className: "mb-0",
                children: m.jsx("img", {
                    src: ANe,
                    alt: "L1XP",
                    className: "max-w-xs w-full h-auto object-contain"
                })
            }), o && m.jsxs("p", {
                className: "text-white text-sm font-semibold mt-2 text-center",
                children: [" Total Win:", m.jsxs("span", {
                    className: "font-bold text-base",
                    children: [Number(r) || 0, " L1XP "]
                }), "  Credited Now: ", m.jsxs("span", {
                    className: "font-bold text-base",
                    children: [(Number(s) || 0).toFixed(2), " L1XP"]
                }), "  Unlock Remaining: ", m.jsxs("span", {
                    className: "font-bold text-base",
                    children: [(Number(i) || 0).toFixed(2), " L1XP"]
                })]
            }), m.jsxs("div", {
                className: "flex items-center gap-6 mt-5",
                children: [m.jsx(cG, {
                    text: " I just won $100 on L1X-Plays Jackpot Spin with @LayerOneXTry your luck  https://play.l1xapp.com#LayerOneX #L1XPlay",
                    url: "",
                    hashtags: [],
                    openInNewTab: !0,
                    winAmount: r,
                    onShareSuccess: a
                }), m.jsx("button", {
                    onClick: e,
                    className: " px-6 py-2 bg-red-600 hover:bg-red-700 text-white font-semibold rounded-full transition-colors",
                    children: "Close"
                })]
            })]
        })
    })
}
function GNe({show: n, onClose: e}) {
    return n ? m.jsx("div", {
        className: "fixed inset-0 z-90 flex items-center justify-center backdrop-blur-lg",
        children: m.jsxs("div", {
            className: "relative flex flex-col items-center justify-center",
            children: [m.jsx("div", {
                className: "mb-6",
                children: m.jsx("img", {
                    src: CNe,
                    alt: "Better Luck Next Time",
                    className: "max-w-2xl w-full h-auto object-contain"
                })
            }), m.jsx("button", {
                onClick: e,
                className: "mt-4 px-6 py-2 bg-red-600 hover:bg-red-700 text-white font-semibold rounded-lg transition-colors",
                children: "Close"
            })]
        })
    }) : null
}
function WNe({show: n, onClose: e}) {
    return n ? m.jsx("div", {
        className: "fixed inset-0 z-[100] flex items-center justify-center backdrop-blur-lg",
        onClick: e,
        children: m.jsxs("div", {
            className: "relative bg-gradient-to-br from-[#1a1a1a] via-[#2d2d2d] to-[#1a1a1a] rounded-2xl p-6 md:p-8 max-w-lg w-[90%] border-2 border-[#FFC12C]/50 shadow-2xl",
            onClick: t => t.stopPropagation(),
            children: [m.jsx("div", {
                className: "absolute inset-0 bg-gradient-to-r from-[#FFC12C]/20 via-[#FF6B35]/20 to-[#FFC12C]/20 rounded-2xl blur-xl animate-pulse"
            }), m.jsx("button", {
                onClick: e,
                className: "absolute top-4 right-4 text-[#FFE559] hover:text-[#FFC12C] transition-colors z-10 cursor-pointer",
                children: m.jsx("svg", {
                    xmlns: "http://www.w3.org/2000/svg",
                    fill: "none",
                    viewBox: "0 0 24 24",
                    strokeWidth: 2.5,
                    stroke: "currentColor",
                    className: "w-6 h-6",
                    children: m.jsx("path", {
                        strokeLinecap: "round",
                        strokeLinejoin: "round",
                        d: "M6 18 18 6M6 6l12 12"
                    })
                })
            }), m.jsxs("div", {
                className: "relative z-10",
                children: [m.jsx("h2", {
                    className: "text-2xl md:text-3xl font-extrabold text-center mb-6 bg-gradient-to-r from-[#FFC12C] via-[#FFE559] to-[#FFC12C] bg-clip-text text-transparent",
                    children: "Participation Instruction"
                }), m.jsxs("p", {
                    className: "text-white text-sm md:text-lg flex-1 my-10",
                    children: ["Play at least ", m.jsx("span", {
                        className: "text-[#FFE559] font-semibold",
                        children: "one game"
                    }), " on L1X-Play to unlock ", m.jsx("span", {
                        className: "text-[#FFE559] font-semibold",
                        children: "todays Jackpot Spin."
                    })]
                }), m.jsx("div", {
                    className: "mt-6 mb-4",
                    children: m.jsx("div", {
                        className: "relative bg-[#1a1a1a]/50 border border-[#FFC12C]/30 rounded-lg p-3 flex items-start gap-3",
                        children: m.jsx("div", {
                            className: "flex-1",
                            children: m.jsxs("p", {
                                className: "text-[#FFE559] text-sm font-semibold",
                                children: ["Note: ", m.jsx("span", {
                                    className: "font-normal text-white",
                                    children: "Daily resets follow UTC time."
                                })]
                            })
                        })
                    })
                }), m.jsx("div", {
                    className: "flex justify-center",
                    children: m.jsx("button", {
                        onClick: e,
                        className: "px-8 py-3 bg-gradient-to-r from-[#FFC12C] to-[#FF6B35] hover:from-[#FFD700] hover:to-[#FF8C42] text-black font-bold rounded-lg transition-all duration-300 shadow-lg hover:shadow-xl transform hover:scale-105",
                        children: "Got It"
                    })
                })]
            }), m.jsx("div", {
                className: "absolute top-2 left-2 w-4 h-4 border-t-2 border-l-2 border-[#FFC12C]/50 rounded-tl-lg"
            }), m.jsx("div", {
                className: "absolute top-2 right-2 w-4 h-4 border-t-2 border-r-2 border-[#FFC12C]/50 rounded-tr-lg"
            }), m.jsx("div", {
                className: "absolute bottom-2 left-2 w-4 h-4 border-b-2 border-l-2 border-[#FFC12C]/50 rounded-bl-lg"
            }), m.jsx("div", {
                className: "absolute bottom-2 right-2 w-4 h-4 border-b-2 border-r-2 border-[#FFC12C]/50 rounded-br-lg"
            })]
        })
    }) : null
}
function YNe({handleClose: n, canPlayJackpot: e, countdown: t, isConnected: r, isEligible: s, rewardValue: i, upfrontRewardValue: o, socialRewardValue: a, isPostShared: l, showTextValue: u, isUserPlayed: d}) {
    const h = () => {
        const Xe = () => dp[Math.floor(Math.random() * dp.length)];
        return [Xe(), Xe(), Xe()]
    }
      , [p,g] = V.useState(h)
      , [w,b] = V.useState(!1)
      , [v,S] = V.useState([!1, !1, !1])
      , [N,_] = V.useState("Good luck!")
      , [I,k] = V.useState(0)
      , B = V.useRef(0)
      , [P,M] = V.useState(!1)
      , [R,L] = V.useState(!1)
      , [q,H] = V.useState(!1)
      , j = V.useRef(!1)
      , [A,E] = V.useState(!1)
      , [C,O] = V.useState(i || 0);
    console.log("winAmount", C);
    const [z,G] = V.useState(o || 0)
      , [Y,$] = V.useState(a || 0)
      , [D,U] = V.useState(l || !1)
      , [W,Q] = V.useState(!1)
      , [J,ne] = V.useState(!1)
      , [ie,ae] = V.useState(!1)
      , [xe,ue] = V.useState(u || !1)
      , [ce,me] = V.useState(!1)
      , Ee = V.useRef(null)
      , Oe = V.useRef(null)
      , mt = kr()
      , st = () => dp[Math.floor(Math.random() * dp.length)];
    function ot(Xe) {
        return Xe[0] === "seven" && Xe[1] === "seven" && Xe[2] === "seven"
    }
    function Ct(Xe) {
        S(Et => {
            const St = [...Et];
            return St[Xe] = !1,
            St
        }
        ),
        B.current += 1,
        B.current === 3 && !j.current && (b(!1),
        B.current = 0,
        j.current = !0,
        Ee.current && (Ee.current.pause(),
        Ee.current.currentTime = 0),
        C > 0 && ne(!0),
        setTimeout( () => {
            if (ot(p) && q) {
                if (M(!0),
                L(!1),
                k(C),
                Oe.current)
                    try {
                        Oe.current.currentTime = 0,
                        Oe.current.play().catch(Et => {
                            console.log("Could not play win sound:", Et)
                        }
                        )
                    } catch (Et) {
                        console.log("Error playing win sound:", Et)
                    }
            } else
                q && L(!0),
                M(!1),
                k(0),
                _("Try again!")
        }
        , 800))
    }
    async function ct() {
        if (w)
            return;
        H(!0),
        S([!1, !1, !1]),
        b(!0),
        _("Spinning..."),
        k(0),
        B.current = 0,
        j.current = !1,
        M(!1),
        L(!1),
        U(!1),
        ne(!1),
        Ee.current && (Ee.current.pause(),
        Ee.current.currentTime = 0),
        Oe.current && (Oe.current.pause(),
        Oe.current.currentTime = 0);
        const Xe = await oZ()
          , Et = [];
        for (let ut = 0; ut < 3; ut++) {
            const cn = Xe?.data?.isWon ? "seven" : st();
            O(Number(Xe?.data?.winAmount) || 0),
            setTimeout( () => {
                ue(!0)
            }
            , 2400),
            setTimeout( () => {
                ae(!0)
            }
            , 5e3),
            G(Number(Xe?.data?.upfrontRewardAmount) || 0),
            $(Number(Xe?.data?.socialRewardAmount) || 0),
            Et.push(cn)
        }
        if (!Xe?.data?.isWon && Et[0] === "seven" && Et[1] === "seven" && Et[2] === "seven") {
            const ut = dp.filter(cn => cn !== "seven");
            Et[2] = ut[Math.floor(Math.random() * ut.length)]
        }
        if (g(Et),
        S([!0, !0, !0]),
        Ee.current)
            try {
                Ee.current.currentTime = 0,
                Ee.current.play().catch(ut => {
                    console.log("Could not play reel spin sound:", ut)
                }
                )
            } catch (ut) {
                console.log("Error playing reel spin sound:", ut)
            }
        [1200, 1800, 2400].forEach( (ut, cn) => {
            setTimeout( () => {
                S(_t => {
                    const ee = [..._t];
                    return ee[cn] = !1,
                    ee
                }
                )
            }
            , ut)
        }
        )
    }
    return V.useEffect( () => () => {
        B.current = 0
    }
    , []),
    V.useEffect( () => (Ee.current = new Audio(jNe),
    Ee.current.loop = !0,
    Ee.current.volume = .5,
    Oe.current = new Audio(LNe),
    Oe.current.volume = .7,
    () => {
        Ee.current && (Ee.current.pause(),
        Ee.current = null),
        Oe.current && (Oe.current.pause(),
        Oe.current = null)
    }
    ), []),
    m.jsx(m.Fragment, {
        children: m.jsxs("div", {
            className: "w-[500px] h-[500px] flex items-center justify-center flex-col relative mx-auto px-4",
            children: [m.jsx(qNe, {
                show: P,
                winAmount: C?.toString()?.split("")?.map(Number) || [1, 0],
                winAmountValue: C,
                upFrontRewardAmount: z,
                socialRewardAmount: Y,
                onClose: () => {
                    n(),
                    H(!1),
                    M(!1),
                    j.current = !0
                }
                ,
                showText: ie,
                onShareSuccess: () => {
                    me(!0),
                    M(!1)
                }
            }), m.jsx(GNe, {
                show: R,
                onClose: () => {
                    n(),
                    H(!1),
                    L(!1),
                    j.current = !0
                }
            }), m.jsx(WNe, {
                show: A,
                onClose: () => E(!1)
            }), m.jsx(VNe, {
                show: W || ce,
                onClose: () => {
                    Q(!1),
                    me(!1),
                    n()
                }
            }), m.jsxs("div", {
                className: `relative w-full flex  z-50 ${P || R ? "opacity-0 pointer-events-none" : ""}`,
                children: [m.jsx("img", {
                    src: uG.cabinet,
                    alt: "slot cabinet",
                    className: "w-full h-full object-contain rounded-3xl"
                }), m.jsx("div", {
                    className: "absolute flex flex-col items-center justify-center top-[55%] left-[50%] -translate-x-1/2 w-full",
                    children: m.jsx("div", {
                        className: "pointer-events-auto md:transform-none transform md:scale-[0.90] scale-75 md:mt-0 -mt-4",
                        children: m.jsx("div", {
                            className: "flex gap-3 items-center justify-center",
                            children: p.map( (Xe, Et) => m.jsx($Ne, {
                                symbol: Xe,
                                isSpinning: v[Et],
                                onStop: () => Ct(Et),
                                reelIndex: Et
                            }, Et))
                        })
                    })
                })]
            }), m.jsxs("div", {
                className: `-mt-[30px] pointer-events-auto flex flex-col justify-center gap-y-4 z-50 min-w-[300px] ${P || R ? "opacity-0 pointer-events-none" : ""}`,
                children: [m.jsx("button", {
                    onClick: () => {
                        r ? e && s && ct() : mt("/login")
                    }
                    ,
                    disabled: w,
                    className: `px-6 py-1.5 text-yellow-200 text-2xl uppercase font-extrabold rounded-lg shadow-[0_4px_0_rgba(0,0,0,0.6)] border-2 border-red-800 transition-transform ${w ? "bg-red-500 cursor-not-allowed opacity-80 animate-pulse" : "bg-red-600 hover:bg-red-700 active:scale-95"}`,
                    style: {
                        boxShadow: w || !s || !r || !e ? "0 0 12px 3px rgba(250,204,21,0.25)" : "0 4px 0 rgba(0,0,0,0.6)"
                    },
                    children: m.jsx("span", {
                        className: `${w ? "animate-pulse" : ""}`,
                        children: r ? d ? t : s ? e ? "Try your luck" : t : "Not eligible yet" : "Connect Wallet"
                    })
                }), !D && C > 0 && xe && m.jsxs("p", {
                    className: "text-white text-sm font-semibold mt-2 text-center",
                    children: [" Total Win:", m.jsxs("span", {
                        className: "font-bold text-base",
                        children: [(Number(C) || 0).toFixed(2), " L1XP "]
                    }), "  Credited Now: ", m.jsxs("span", {
                        className: "font-bold text-base",
                        children: [(Number(z) || 0).toFixed(2), " L1XP"]
                    }), "  Unlock Remaining: ", m.jsxs("span", {
                        className: "font-bold text-base",
                        children: [(Number(Y) || 0).toFixed(2), " L1XP"]
                    })]
                }), m.jsx("div", {
                    className: "flex items-center gap-6",
                    children: !D && C > 0 ? m.jsx(cG, {
                        text: ` I just won $${C || 100} on L1X-Play's Jackpot Spin with @LayerOneXTry your luck  https://play.l1xapp.com#LayerOneX #L1XPlay`,
                        url: "",
                        hashtags: [],
                        openInNewTab: !0,
                        winAmount: C,
                        onShare: Xe => {
                            U(Xe),
                            Xe && Q(!0)
                        }
                        ,
                        onShareSuccess: () => me(!0)
                    }) : m.jsx("button", {
                        onClick: () => E(!0),
                        className: "text-base font-medium text-white border-b border-white inline-block w-auto mx-auto cursor-pointer hover:text-[#FFE559] hover:border-[#FFE559] transition-colors",
                        children: "How to Participate"
                    })
                }), m.jsx(zNe, {})]
            }), m.jsx("img", {
                src: $p,
                alt: "behind animation",
                className: "w-full h-full object-contain rounded-3xl absolute top-0 left-0 scale-250 blur-sm pointer-events-none"
            }), m.jsx("img", {
                src: $p,
                alt: "behind animation",
                className: "w-full h-full object-contain rounded-3xl absolute top-0 left-0 scale-250 blur-sm pointer-events-none"
            }), m.jsx("img", {
                src: $p,
                alt: "behind animation",
                className: "w-full h-full object-contain rounded-3xl absolute top-0 left-0 scale-300 blur-sm pointer-events-none"
            })]
        })
    })
}
const KNe = "/assets/slotIcon-B8kaS4lJ.png"
  , ej = [{
    date: "10 November 2025",
    title: "Official Launch",
    description: "Launch of L1X-Play with wallet deposits, withdrawals, and the Biscuit Run debut. Daily leaderboards go live to reward top players."
}, {
    date: "21 November 2025",
    title: "Onboarding Upgrades",
    description: "Email-based logins plus card deposit and withdrawal options roll out, making L1X-Play more accessible and convenient."
}, {
    date: "28 November 2025",
    title: "Arcade Expansion",
    description: "Crash game launch, broadening the L1X-Play arcade with new gameplay dynamics and fresh reward possibilities. WL1X Support for L1X-Play. "
}, {
    date: "9 December 2025",
    title: "Plinko and X-Talk Dash Release",
    description: "The fast-paced X-Talk Dash game drops, bringing a new competitive mode to the expanding L1X-Play arcade."
}]
  , UA = () => {
    const [n,e] = V.useState(!1)
      , [t,r] = V.useState(!0)
      , [s,i] = V.useState([])
      , o = kr()
      , a = Ti()
      , l = B0()
      , {emailAddress: u, walletAddress: d, backendConfig: h} = Hs()
      , [p,g] = V.useState(!1)
      , [w,b] = V.useState(!1)
      , [v,S] = V.useState(!0)
      , [N,_] = V.useState(!0)
      , [I,k] = V.useState(!1)
      , [B,P] = V.useState("")
      , [M,R] = V.useState("jackpot-spin")
      , [L,q] = V.useState(0)
      , [H,j] = V.useState(0)
      , [A,E] = V.useState(0)
      , [C,O] = V.useState(!1)
      , [z,G] = V.useState(0)
      , {isSharedSuccess: Y} = E0();
    V.useEffect( () => {
        const J = localStorage.getItem("nextJackpotTime");
        J && (new Date().getTime() < parseInt(J, 10) ? _(!1) : localStorage.removeItem("nextJackpotTime"));
        const ne = () => {
            if (N)
                return;
            const ae = localStorage.getItem("nextJackpotTime");
            if (!ae)
                return;
            const xe = new Date().getTime()
              , ue = parseInt(ae, 10) - xe;
            if (ue <= 0) {
                _(!0),
                P(""),
                localStorage.removeItem("nextJackpotTime");
                return
            }
            const ce = Math.floor(ue / (1e3 * 60 * 60))
              , me = Math.floor(ue / (1e3 * 60) % 60)
              , Ee = Math.floor(ue / 1e3 % 60);
            P(`${ce}h ${me}m ${Ee}s`)
        }
          , ie = setInterval(ne, 1e3);
        return ne(),
        () => clearInterval(ie)
    }
    , [N]),
    V.useEffect( () => {
        D()
    }
    , []);
    const $ = async () => {
        try {
            S(!0);
            const J = await iZ();
            if (k(J?.data?.hasUserPlayed),
            q(J?.data?.rewardData?.rewardAmount),
            j(J?.data?.rewardData?.upfrontReward),
            E(J?.data?.rewardData?.socialReward),
            O(J?.data?.isShared),
            G(!J?.data?.isShared && J?.data?.hasUserPlayed),
            J?.data?.hasUserPlayed) {
                const ne = new Date
                  , ie = new Date(Date.UTC(ne.getUTCFullYear(), ne.getUTCMonth(), ne.getUTCDate() + 1, 0, 0, 0)).getTime();
                localStorage.setItem("nextJackpotTime", ie.toString()),
                _(!1)
            } else
                localStorage.removeItem("nextJackpotTime"),
                _(!0),
                P("");
            if (Y && (G(!0),
            g(!0)),
            J?.status === "success" && J?.data?.isEligible)
                return b(!0);
            b(!1)
        } catch {
            b(!1)
        } finally {
            S(!1)
        }
    }
    ;
    V.useEffect( () => {
        a.hash === "#howItWorks" ? setTimeout( () => {
            const J = document.getElementById("howItWorks");
            J && J.scrollIntoView({
                behavior: "smooth",
                block: "start"
            })
        }
        , 300) : a.hash === "#activeGames" && setTimeout( () => {
            const J = document.getElementById("activeGames");
            J && J.scrollIntoView({
                behavior: "smooth",
                block: "start"
            })
        }
        , 300)
    }
    , [a.hash]);
    const D = async () => {
        try {
            const J = await sZ(1, 10);
            J?.status === "success" ? i(J?.data?.data) : i([])
        } catch {
            i([])
        } finally {
            r(!1)
        }
    }
      , U = J => {
        l?.walletAddress || u ? o(J) : o("/login")
    }
      , W = () => {
        a.pathname === "/landing" || a.pathname === "/" ? setTimeout( () => {
            const J = document.getElementById("activeGames");
            J && J.scrollIntoView({
                behavior: "smooth",
                block: "start"
            })
        }
        , 100) : o("/landing#activeGames")
    }
      , Q = (J, ne) => {
        switch (J) {
        case "Crash":
            return "/crash-game/" + ne;
        case "Plinko":
            return "/plinko-game/" + ne;
        case "AWEBO":
            return "/awebo-bird/" + ne;
        default:
            return "/biscuit-run/" + ne
        }
    }
    ;
    return m.jsxs(m.Fragment, {
        children: [m.jsxs("div", {
            className: " relative lg:overflow-x-hidden",
            children: [m.jsx("div", {
                className: "container mx-auto lg:overflow-hidden",
                children: m.jsxs("div", {
                    className: "grid grid-cols-1 md:grid-cols-2 gap-4 pb-20 xl:overflow-hidden text-center items-center md:text-left xl:h-[700px] px-4 mt-10",
                    children: [m.jsx("div", {
                        className: "text-white relative flex flex-col align-middle justify-center order-2 md:order-1",
                        children: m.jsxs("div", {
                            className: "md:px-0 md:px-4",
                            children: [m.jsx("h1", {
                                className: "text-[60px] xl:text-9xl font-bold relative inline-block xl:mb-3",
                                children: "L1XPlay "
                            }), m.jsx("h4", {
                                className: "text-xl xl:text-4xl font-semibold mt-2.5 mb-5",
                                children: "On-Chain Gaming Arcade"
                            }), m.jsx("div", {
                                className: "w-[150px] h-[5px] brand-gradient-bg rounded-full md:my-5 my-3 inline-block"
                            }), m.jsx("h3", {
                                className: " md:block hidden text-base xl:text-2xl mt-4",
                                children: " Simple, high frequency skill and chance games"
                            }), m.jsx("h3", {
                                className: " md:block hidden text-base xl:text-2xl mt-4",
                                children: " On-chain gameplay with seamless connectivity"
                            }), m.jsx("h3", {
                                className: " md:block text-base xl:text-2xl mt-4",
                                children: " Real time rewards, leaderboards, and token utility"
                            }), m.jsx("div", {
                                className: "mt-8 block ",
                                children: m.jsxs("div", {
                                    className: "group relative rounded-4xl sm:inline-flex items-center sm:gap-4 mb-4",
                                    children: [m.jsxs("div", {
                                        onClick: () => {
                                            l?.walletAddress || u ? s?.find(ne => ne?.gameUuid === Io)?.gameUuid && o(`/crash-game/${Io}`) : o("/login")
                                        }
                                        ,
                                        className: "relative cursor-pointer text-white rounded-4xl brand-gradient-bg inline-flex gap-4 items-center text-lg xl:text-lg font-medium py-2 pr-2 pl-4 whitespace-nowrap border border-white",
                                        children: [l?.walletAddress || u ? "Play Crash" : "Get Started", m.jsx("span", {
                                            className: "bg-white w-7 h-7 md:w-10 md:h-10 rounded-4xl p-1 flex items-center justify-center flex-col",
                                            children: m.jsx("svg", {
                                                xmlns: "http://www.w3.org/2000/svg",
                                                fill: "none",
                                                viewBox: "0 0 24 24",
                                                strokeWidth: 1.5,
                                                stroke: "#000000",
                                                className: "size-6",
                                                children: m.jsx("path", {
                                                    strokeLinecap: "round",
                                                    strokeLinejoin: "round",
                                                    d: "M13.5 4.5 21 12m0 0-7.5 7.5M21 12H3"
                                                })
                                            })
                                        })]
                                    }), m.jsx("button", {
                                        className: "bg-transparent border border-white text-white rounded-4xl inline-flex gap-4 items-center text-lg xl:text-lg font-medium py-2 md:py-3.5 px-6 whitespace-nowrap hover:bg-white hover:text-black transition-all duration-300 mt-4 sm:mt-0 cursor-pointer",
                                        onClick: () => o("/landing#howItWorks"),
                                        children: "How L1X Play Works"
                                    })]
                                })
                            })]
                        })
                    }), m.jsxs("div", {
                        className: "order-1 md:order-2 relative",
                        children: [m.jsxs("div", {
                            className: "inline-flex border border-white border-b-0 rounded-t-2xl bg-[#2B3747] pb-2 -mb-3 overflow-hidden",
                            children: [m.jsx("button", {
                                onClick: () => R("jackpot-spin"),
                                className: `px-4 py-2 pb-3 cursor-pointer text-lg font-semibold transition-all duration-200 ${M === "jackpot-spin" ? "text-black bg-[#FFC12C]" : "text-yellow/60 hover:text-yellow"}`,
                                children: "Jackpot Spin"
                            }), m.jsx("button", {
                                onClick: () => R("challenge"),
                                className: `px-4 py-2 pb-3 cursor-pointer text-lg font-semibold transition-all duration-200 ${M === "challenge" ? "text-black bg-[#FFC12C]" : "text-yellow/60 hover:text-yellow"}`,
                                children: "$500 Challenge"
                            })]
                        }), M === "jackpot-spin" && m.jsx("img", {
                            src: rNe,
                            onClick: () => {
                                $(),
                                g(!0)
                            }
                            ,
                            className: "mx-auto md:mx-0 md:w-full cursor-pointer"
                        }), M === "challenge" && m.jsxs("div", {
                            className: "relative",
                            children: [m.jsx("div", {
                                className: "cursor-pointer md:mb-0 mb-5",
                                onClick: () => {
                                    if (l?.walletAddress || u) {
                                        const J = s?.find(ne => ne?.gameUuid === Pp);
                                        J?.gameUuid && o(`/biscuit-run/${J.gameUuid}`)
                                    } else
                                        o("/login")
                                }
                                ,
                                children: m.jsx("img", {
                                    src: nNe,
                                    className: "mx-auto md:mx-0 md:w-full"
                                })
                            }), m.jsxs(Us, {
                                to: "https://taskon.xyz/quest/320734149",
                                target: "_blank",
                                className: "flex items-center md:justify-start justify-center gap-2 md:absolute bottom-4 left-4 text-base underline",
                                children: ["Learn More About Quest ", m.jsx("img", {
                                    src: sNe,
                                    className: "w-7"
                                })]
                            })]
                        })]
                    })]
                })
            }), m.jsxs("div", {
                className: "py-16 pt-10",
                id: "activeGames",
                children: [m.jsxs("div", {
                    className: "container mx-auto px-4 mb-8",
                    children: [m.jsx("div", {
                        className: "flex items-center gap-3 mb-6",
                        children: m.jsx("h4", {
                            className: "font-jira text-3xl font-semibold text-left",
                            children: "Active Games"
                        })
                    }), m.jsx("div", {
                        className: "grid grid-cols-1 sm:grid-cols-2 gap-8",
                        children: t ? "Loading..." : s?.map(J => {
                            const ne = Q(J?.name, J?.gameUuid);
                            return m.jsxs("div", {
                                className: "bg-brandDark rounded-2xl p-5 border-2 border-transparent hover:border-[#7900FF] transition-all duration-300 hover:shadow-[0_0_30px_rgba(121,0,255,0.5)] hover:-translate-y-1 relative group cursor-pointer overflow-hidden",
                                children: [m.jsxs("div", {
                                    className: "absolute top-4 left-4 z-10 bg-brandGreen text-white text-xs font-semibold px-3 py-1.5 rounded-full flex items-center gap-1.5 shadow-lg animate-pulse",
                                    children: [m.jsx("span", {
                                        className: "w-2 h-2 bg-white rounded-full animate-ping"
                                    }), m.jsx("span", {
                                        className: "w-2 h-2 bg-white rounded-full absolute left-2.5"
                                    }), "LIVE"]
                                }), m.jsxs("div", {
                                    className: "h-[310px] overflow-hidden w-full rounded-xl relative",
                                    children: [m.jsx("img", {
                                        src: J?.image,
                                        className: "object-cover w-full h-full  transition-opacity duration-300"
                                    }), J?.name === "Biscuit Run" && m.jsx("img", {
                                        src: lNe,
                                        className: "absolute inset-0 object-cover w-full h-full opacity-0 group-hover:opacity-100 transition-opacity duration-300"
                                    })]
                                }), m.jsxs("div", {
                                    className: "relative",
                                    children: [m.jsxs("button", {
                                        onClick: () => U(ne),
                                        to: ne,
                                        className: "text-white rounded-4xl button-color inline-flex gap-2 items-center text-base font-medium py-2.5 px-7 absolute right-8 -top-8 border-2 border-white cursor-pointer hover:scale-110 hover:shadow-[0_0_20px_rgba(121,0,255,0.6)] transition-all duration-200 active:scale-95",
                                        children: [m.jsx("svg", {
                                            xmlns: "http://www.w3.org/2000/svg",
                                            viewBox: "0 0 24 24",
                                            fill: "currentColor",
                                            className: "size-6",
                                            children: m.jsx("path", {
                                                fillRule: "evenodd",
                                                d: "M4.5 5.653c0-1.427 1.529-2.33 2.779-1.643l11.54 6.347c1.295.712 1.295 2.573 0 3.286L7.28 19.99c-1.25.687-2.779-.217-2.779-1.643V5.653Z",
                                                clipRule: "evenodd"
                                            })
                                        }), "Play"]
                                    }), m.jsx("h4", {
                                        className: "text-3xl font-medium mt-2.5 mb-1 line-clamp-1 group-hover:text-white transition-colors",
                                        children: J?.name
                                    }), m.jsx("p", {
                                        className: "text-txtGray text-base font-light line-clamp-2",
                                        children: J?.description
                                    })]
                                })]
                            })
                        }
                        )
                    })]
                }), m.jsxs("div", {
                    className: "container mx-auto px-4",
                    children: [m.jsx("div", {
                        className: "flex items-center gap-3 mb-6",
                        children: m.jsx("h4", {
                            className: "font-jira text-3xl font-semibold text-left text-white/70",
                            children: "Coming Soon"
                        })
                    }), m.jsx("div", {
                        className: "grid grid-cols-1 sm:grid-cols-2 gap-8",
                        children: m.jsxs("div", {
                            className: "bg-brandDark rounded-2xl p-5 grayscale-[0.1] relative cursor-not-allowed",
                            children: [m.jsxs("div", {
                                className: "absolute top-4 left-4 z-10 bg-[#6B7280] text-white text-xs font-semibold px-3 py-1.5 rounded-full flex items-center gap-1.5 shadow-lg",
                                children: [m.jsx("svg", {
                                    xmlns: "http://www.w3.org/2000/svg",
                                    viewBox: "0 0 24 24",
                                    fill: "currentColor",
                                    className: "size-3",
                                    children: m.jsx("path", {
                                        fillRule: "evenodd",
                                        d: "M12 1.5a5.25 5.25 0 0 0-5.25 5.25v3a3 3 0 0 0-3 3v6.75a3 3 0 0 0 3 3h10.5a3 3 0 0 0 3-3v-6.75a3 3 0 0 0-3-3v-3c0-2.9-2.35-5.25-5.25-5.25Zm3.75 8.25v-3a3.75 3.75 0 1 0-7.5 0v3h7.5Z",
                                        clipRule: "evenodd"
                                    })
                                }), "Coming Soon"]
                            }), m.jsx("div", {
                                className: "h-[310px] overflow-hidden w-full rounded-xl relative",
                                children: m.jsx("img", {
                                    src: cNe,
                                    className: "object-cover w-full h-full"
                                })
                            }), m.jsxs("div", {
                                className: "relative",
                                children: [m.jsx("h4", {
                                    className: "text-3xl font-medium mt-2.5 mb-1.5 line-clamp-1 text-white",
                                    children: "X-Talk Dash"
                                }), m.jsx("p", {
                                    className: "text-txtGray text-base font-light line-clamp-2",
                                    children: "Race in turbocharged go-karts powered by X-Talk. Drift, dodge, and win tokens in this cross-chain competitive speed challenge."
                                })]
                            })]
                        })
                    })]
                })]
            }), m.jsx("div", {
                className: "container mx-auto px-4 mt-14",
                children: m.jsx("div", {
                    className: "why-bg-img overflow-hidden rounded-4xl",
                    children: m.jsxs("div", {
                        className: "grid grid-cols-1 lg:grid-cols-12 gap-4 overflow-hidden text-center lg:text-left",
                        children: [m.jsx("div", {
                            className: "lg:col-span-4",
                            children: m.jsx("img", {
                                src: iNe,
                                className: "w-[200px] mx-auto lg:mx-0 md:w-auto"
                            })
                        }), m.jsxs("div", {
                            className: "py-12 px-5 xl:px-16 lg:col-span-8",
                            children: [m.jsx("h3", {
                                className: "font-jura text-5xl mb-8",
                                children: "What is L1XPlay?"
                            }), m.jsx("p", {
                                className: "text-base mb-7",
                                children: "L1X Play is the next evolution of onchain gaming, blending fast paced skill and chance based games with provably fair mechanics and token rewards."
                            }), m.jsx("p", {
                                className: "text-base mb-7",
                                children: "Powered by Layer One X and integrated with Quantum DeX, L1X Play delivers frictionless gameplay that prioritizes fun while rewarding players only where it truly adds value."
                            }), m.jsx("p", {
                                className: "text-base mb-7",
                                children: "Our launch titles are inspired by top performing tokens on Quantum DeX including BISCUIT, AWEBO, and XTALK creating immersive, community driven game ecosystems around each token."
                            })]
                        })]
                    })
                })
            }), m.jsxs("div", {
                className: "py-24 px-4 bg-gradient-to-b to-[#171E29] from-[#0e131a]",
                id: "howItWorks",
                children: [m.jsx("div", {
                    className: "text-center mb-14",
                    children: m.jsx("h2", {
                        className: "text-4xl font-light mb-5",
                        children: "How It Works"
                    })
                }), m.jsx("div", {
                    className: "container mx-auto",
                    children: m.jsxs("div", {
                        className: "grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-8",
                        children: [m.jsxs("div", {
                            className: "bg-gradient-to-br from-[#232E3E] to-[#171E29] border border-[#222A38] rounded-2xl p-6 overflow-hidden relative",
                            children: [m.jsx("img", {
                                src: RA,
                                className: "-top-8 -right-4 absolute w-[124px] "
                            }), m.jsxs("div", {
                                className: "min-h-60 h-full flex flex-col justify-between",
                                children: [m.jsx("h5", {
                                    className: "text-5xl font-bold ",
                                    children: "1"
                                }), m.jsxs("div", {
                                    children: [m.jsx("h2", {
                                        className: "text-2xl font-medium mb-3",
                                        children: "Buy L1XG (L1X Gold)"
                                    }), m.jsx("p", {
                                        className: "text-base/relaxed font-light text-[#9FA8B3]",
                                        children: "Start by purchasing L1XG using any major chain token. This is your in game token for participation."
                                    })]
                                })]
                            })]
                        }), m.jsxs("div", {
                            className: "bg-gradient-to-br from-[#232E3E] to-[#171E29] border border-[#222A38] rounded-2xl p-6 overflow-hidden relative",
                            children: [m.jsx("img", {
                                src: RA,
                                className: "-top-8 -right-4 absolute w-[124px] "
                            }), m.jsxs("div", {
                                className: "min-h-60 h-full flex flex-col justify-between",
                                children: [m.jsx("h5", {
                                    className: "text-5xl font-bold ",
                                    children: "2"
                                }), m.jsxs("div", {
                                    children: [m.jsx("h2", {
                                        className: "text-2xl font-medium mb-3",
                                        children: "Get Bonus L1XP"
                                    }), m.jsx("p", {
                                        className: "text-base/relaxed font-light text-[#9FA8B3]",
                                        children: "For every L1XG you hold, you receive L1XP. The token used to enter games, win prizes, and cash out rewards."
                                    })]
                                })]
                            })]
                        }), m.jsxs("div", {
                            className: "bg-gradient-to-br from-[#232E3E] to-[#171E29] border border-[#222A38] rounded-2xl p-6 overflow-hidden relative",
                            children: [m.jsx("img", {
                                src: RA,
                                className: "-top-8 -right-4 absolute w-[124px] "
                            }), m.jsxs("div", {
                                className: "min-h-60 h-full flex flex-col justify-between",
                                children: [m.jsx("h5", {
                                    className: "text-5xl font-bold ",
                                    children: "3"
                                }), m.jsxs("div", {
                                    children: [m.jsx("h2", {
                                        className: "text-2xl font-medium mb-3",
                                        children: "Unlock More L1XP"
                                    }), m.jsx("p", {
                                        className: "text-base/relaxed font-light text-[#9FA8B3]",
                                        children: "Continue unlocking additional L1XP by logging in daily. Every login unlocks a portion of your L1XP. Its that simple."
                                    })]
                                })]
                            })]
                        })]
                    })
                })]
            }), m.jsxs("div", {
                className: "relative bg-[#171E29] pt-28",
                children: [m.jsx("div", {
                    className: "top-0 left-0 absolute",
                    children: m.jsx("img", {
                        src: oNe
                    })
                }), m.jsx("div", {
                    className: "bottom-0 right-0 absolute",
                    children: m.jsx("img", {
                        src: aNe
                    })
                }), m.jsxs("div", {
                    className: "container mx-auto",
                    children: [m.jsx("div", {
                        className: "text-center mb-14 max-w-2xl mx-auto",
                        children: m.jsxs("h2", {
                            className: "text-5xl font-light mb-5",
                            children: ["Technology Behind ", m.jsx("span", {
                                className: "font-bold",
                                children: "L1XPlay"
                            })]
                        })
                    }), m.jsxs("div", {
                        className: "grid grid-cols-1 lg:grid-cols-3 gap-8 px-4",
                        children: [m.jsxs("div", {
                            className: "px-4 xl:px-0 md:pt-14",
                            children: [m.jsxs("div", {
                                className: "bg-gradient-to-br from-[#232E3E] to-[#171E29] border border-[#222A38] rounded-2xl py-6 px-8 relative flex gap-9 mb-6",
                                children: [m.jsx("img", {
                                    src: uNe
                                }), m.jsxs("div", {
                                    children: [m.jsx("h3", {
                                        className: "text-2xl font-semibold mb-3.5",
                                        children: "High Performance WASM + eBPF VM"
                                    }), m.jsx("p", {
                                        className: "text-base text-[#9FA8B3]",
                                        children: "Native L1X VM for ultra fast and low latency on chain game execution."
                                    })]
                                })]
                            }), m.jsxs("div", {
                                className: "bg-gradient-to-br from-[#232E3E] to-[#171E29] border border-[#222A38] rounded-2xl py-6 px-8 relative flex gap-9 mb-6",
                                children: [m.jsx("img", {
                                    src: dNe
                                }), m.jsxs("div", {
                                    children: [m.jsx("h3", {
                                        className: "text-2xl font-semibold mb-3.5",
                                        children: "Smart Contract based fairness logic with X-Talk"
                                    }), m.jsx("p", {
                                        className: "text-base text-[#9FA8B3]",
                                        children: "Every provable fairness uses Native X-Talk oracle which is secure, fast and random."
                                    })]
                                })]
                            })]
                        }), m.jsxs("div", {
                            className: "vertical-gradient rounded-t-4xl py-5 md:py-20",
                            children: [m.jsxs("div", {
                                className: "text-white py-6 px-8 relative flex items-start gap-9 mb-6",
                                children: [m.jsx("img", {
                                    src: fNe
                                }), m.jsxs("div", {
                                    children: [m.jsx("h3", {
                                        className: "text-2xl font-semibold mb-3.5",
                                        children: "Bridgeless cross chain interoperability"
                                    }), m.jsx("p", {
                                        className: "text-base",
                                        children: "Move into L1X-Play and Move out with ease with the power of L1X-Swap."
                                    })]
                                })]
                            }), m.jsxs("div", {
                                className: "text-white py-6 px-8 relative flex gap-9 mb-6",
                                children: [m.jsx("img", {
                                    src: hNe
                                }), m.jsxs("div", {
                                    className: "",
                                    children: [m.jsx("h3", {
                                        className: "text-2xl font-semibold mb-3.5",
                                        children: "Token flow and reward structures"
                                    }), m.jsx("p", {
                                        className: "text-base",
                                        children: "Optimized for sustainability and fairness"
                                    })]
                                })]
                            })]
                        }), m.jsxs("div", {
                            className: "pt-14 px-4 md:px-0",
                            children: [m.jsxs("div", {
                                className: "bg-gradient-to-br from-[#232E3E] to-[#171E29] border border-[#222A38] rounded-2xl py-6 px-8 relative flex gap-9 mb-6",
                                children: [m.jsx("img", {
                                    src: pNe
                                }), m.jsxs("div", {
                                    children: [m.jsx("h3", {
                                        className: "text-2xl font-semibold mb-3.5",
                                        children: "L1X-Swap integration"
                                    }), m.jsx("p", {
                                        className: "text-base text-[#9FA8B3]",
                                        children: "Allows users to enter games and claim prizes using any supported token"
                                    })]
                                })]
                            }), m.jsxs("div", {
                                className: "bg-gradient-to-br from-[#232E3E] to-[#171E29] border border-[#222A38] rounded-2xl py-6 px-8 relative flex gap-9 mb-6",
                                children: [m.jsx("img", {
                                    src: mNe
                                }), m.jsxs("div", {
                                    children: [m.jsx("h3", {
                                        className: "text-2xl font-semibold mb-3.5",
                                        children: "Quantum DeX liquidity integration"
                                    }), m.jsx("p", {
                                        className: "text-base text-[#9FA8B3]",
                                        children: "For token enabled bonuses creating maximum engagement "
                                    })]
                                })]
                            })]
                        })]
                    })]
                })]
            }), m.jsxs("div", {
                className: "roadmap relative py-24 pb-10 overflow-hidden",
                children: [m.jsx("div", {
                    className: "absolute inset-0 bg-gradient-to-b from-transparent via-[#111823] to-transparent opacity-60 pointer-events-none"
                }), m.jsxs("div", {
                    className: "container mx-auto px-4 relative z-10",
                    children: [m.jsxs("div", {
                        className: "text-center mb-16 max-w-3xl mx-auto",
                        children: [m.jsxs("span", {
                            className: "inline-flex items-center gap-2 text-xs uppercase tracking-[0.35em] text-[#8FA1B8] mb-4",
                            children: [m.jsx("span", {
                                className: "w-2 h-2 rounded-full bg-[#FFC12C]"
                            }), "Roadmap"]
                        }), m.jsxs("h2", {
                            className: "text-4xl md:text-5xl font-light text-white",
                            children: ["Upcoming ", m.jsx("span", {
                                className: "font-semibold",
                                children: "Milestones"
                            })]
                        }), m.jsx("p", {
                            className: "text-[#9FA8B3] text-base md:text-xl mt-4",
                            children: "Stay ahead with the rollout plan for new features, games, and upgrade releases across L1X-Play."
                        })]
                    }), m.jsxs("div", {
                        className: "max-w-4xl mx-auto relative",
                        children: [m.jsx("div", {
                            className: "absolute hidden md:block left-1/2 -translate-x-1/2 top-0 bottom-0 w-px bg-gradient-to-b from-[#FFC12C]/0 via-[#FFC12C]/60 to-[#FF6B35]/0"
                        }), m.jsx("div", {
                            className: "space-y-16",
                            children: ej.map( (J, ne) => {
                                const ie = ne % 2 === 0
                                  , ae = ne === ej.length - 1
                                  , xe = m.jsxs("div", {
                                    className: "bg-[#1B2532] border border-[#283548] rounded-2xl p-6 shadow-xl backdrop-blur-sm",
                                    children: [m.jsx("h3", {
                                        className: "text-xl md:text-2xl font-semibold text-white mb-2",
                                        children: J.title
                                    }), m.jsx("p", {
                                        className: "text-[#A8B8CC] text-sm md:text-base leading-relaxed",
                                        children: J.description
                                    })]
                                })
                                  , ue = m.jsx("span", {
                                    className: "inline-flex items-center gap-2 bg-[#1B2532] border border-[#283548] rounded-full px-4 py-1 text-[11px] font-medium uppercase tracking-[0.3em] text-[#FFC12C] whitespace-nowrap",
                                    children: J.date
                                });
                                return m.jsxs("div", {
                                    className: "relative md:grid md:grid-cols-[1fr_auto_1fr] md:items-start gap-6",
                                    children: [m.jsx("div", {
                                        className: `hidden md:flex md:flex-col md:items-end md:gap-4 ${ie ? "" : "md:opacity-0 md:pointer-events-none"}`,
                                        children: ie && m.jsxs(m.Fragment, {
                                            children: [ue, xe]
                                        })
                                    }), m.jsxs("div", {
                                        className: "flex flex-col items-center",
                                        children: [m.jsx("div", {
                                            className: "relative z-10 w-12 h-12 rounded-full bg-gradient-to-br from-[#FF6B35] via-[#FFC12C] to-[#FF6B35] flex items-center justify-center shadow-[0_0_25px_rgba(255,193,44,0.65)]",
                                            children: m.jsx("span", {
                                                className: "text-[#0F141D] text-base font-semibold",
                                                children: ne + 1
                                            })
                                        }), !ae && m.jsx("div", {
                                            className: "hidden md:block w-px flex-1 mt-3 bg-gradient-to-b from-[#FF6B35] to-transparent opacity-50"
                                        })]
                                    }), m.jsx("div", {
                                        className: `hidden md:flex md:flex-col md:items-start md:gap-4 ${ie ? "md:opacity-0 md:pointer-events-none" : ""}`,
                                        children: !ie && m.jsxs(m.Fragment, {
                                            children: [ue, xe]
                                        })
                                    }), m.jsxs("div", {
                                        className: "md:hidden w-full mt-6 flex flex-col gap-3",
                                        children: [ue, xe]
                                    })]
                                }, J.date)
                            }
                            )
                        })]
                    })]
                })]
            }), m.jsx("div", {
                className: "container mx-auto pt-14 md:-mb-40",
                children: m.jsxs("div", {
                    className: "md:grid md:grid-cols-2 gap-8 px-4",
                    children: [m.jsx("div", {
                        children: m.jsx("img", {
                            src: HQ
                        })
                    }), m.jsx("div", {
                        className: "flex flex-col justify-center",
                        children: m.jsxs("div", {
                            className: "text-center md:text-left",
                            children: [m.jsx("h3", {
                                className: "text-2xl md:text-4xl mb-3.5",
                                children: "Ultimate Arcade of Web3 Gaming World"
                            }), m.jsx("p", {
                                className: "text-txtGray text-sm/6 md:text-base/7 font-light mb-4",
                                children: "Step into the next era of gaming with L1X Play  where innovation meets adventure. Explore a dynamic multiverse of skill-based games, immersive challenges, and competitive arenas built on Web3 technology. Whether youre chasing high scores, earning real rewards, or simply enjoying the thrill of play, L1X Play brings the ultimate arcade experience right to your screen."
                            }), m.jsx("p", {
                                className: "text-txtGray text-sm/6 md:text-base/7 font-light",
                                children: "Every click, every victory, and every mission takes you deeper into a world powered by blockchain, creativity, and community."
                            })]
                        })
                    })]
                })
            }), m.jsx("div", {
                className: "footer-bg md:h-[900px] flex items-center justify-center w-full px-4  pb-6 md:pb-0 ",
                children: m.jsxs("div", {
                    className: "bg-[#FFC517] rounded-3xl p-6 relative text-black max-w-5xl w-full lg:mx-auto mx-4 text-center md:text-left mt-4 md:mt-0",
                    children: [m.jsx("h4", {
                        className: "font-jura text-4xl mb-3.5",
                        children: "Join the gaming world"
                    }), m.jsxs("button", {
                        onClick: W,
                        className: "inline-flex items-center gap-2.5 bg-black text-white font-medium rounded-xl py-3 px-8 hover:bg-gray-800 transition-colors",
                        children: ["Start Playing ", m.jsx("svg", {
                            xmlns: "http://www.w3.org/2000/svg",
                            fill: "none",
                            viewBox: "0 0 24 24",
                            strokeWidth: 1.5,
                            stroke: "currentColor",
                            className: "size-6",
                            children: m.jsx("path", {
                                strokeLinecap: "round",
                                strokeLinejoin: "round",
                                d: "M13.5 4.5 21 12m0 0-7.5 7.5M21 12H3"
                            })
                        })]
                    }), m.jsx("img", {
                        src: VQ,
                        className: "absolute -right-[200px] -top-[200px] hidden md:block"
                    })]
                })
            })]
        }), m.jsx(gNe, {
            isOpenWhitelist: n,
            onCloseWhitelist: () => e(!1)
        }), m.jsxs("button", {
            className: "fixed md:top-40 top-auto bottom-4 md:bottom-auto md:-translate-y-1/2 flex flex-col items-center text-center right-4 md:right-2 z-50 group cursor-pointer transition-all duration-300 hover:scale-110 active:scale-95",
            onClick: () => {
                $(),
                g(!0)
            }
            ,
            children: [m.jsx("style", {
                children: `
                    @keyframes spin-slow {
                        from { transform: rotate(0deg); }
                        to { transform: rotate(360deg); }
                    }
                    @keyframes shimmer {
                        0% { transform: translateX(-100%) skewX(-12deg); }
                        100% { transform: translateX(200%) skewX(-12deg); }
                    }
                `
            }), m.jsxs("div", {
                className: "relative z-10 w-24 h-24 md:w-28 md:h-28 -left-3 flex items-center justify-center",
                children: [m.jsx("div", {
                    className: "absolute inset-0 rounded-full bg-gradient-to-r from-yellow-400 via-orange-500 to-red-500 opacity-75 blur-xl animate-pulse group-hover:opacity-100 group-hover:blur-2xl transition-all duration-500"
                }), m.jsx("img", {
                    src: $p,
                    alt: "behind animation",
                    className: "absolute inset-0 w-full h-full object-contain rounded-full blur-md scale-150 opacity-60",
                    style: {
                        animation: "spin-slow 8s linear infinite"
                    }
                }), m.jsx("img", {
                    src: $p,
                    alt: "behind animation",
                    className: "absolute inset-0 w-full h-full object-contain rounded-full blur-lg scale-200 opacity-40",
                    style: {
                        animation: "spin-slow 12s linear infinite reverse"
                    }
                }), m.jsx("img", {
                    src: $p,
                    alt: "behind animation",
                    className: "absolute inset-0 w-full h-full object-contain rounded-full blur-xl scale-250 opacity-30",
                    style: {
                        animation: "spin-slow 15s linear infinite"
                    }
                }), m.jsxs("div", {
                    className: "relative z-20 transform group-hover:rotate-6 transition-transform duration-300",
                    children: [m.jsx("img", {
                        src: KNe,
                        className: "w-20 h-auto md:w-24 md:h-auto drop-shadow-2xl filter brightness-110 group-hover:brightness-125 transition-all duration-300",
                        alt: "Slot Machine"
                    }), m.jsx("div", {
                        className: "absolute inset-0 bg-gradient-to-r from-yellow-300/50 via-orange-400/50 to-red-500/50 rounded-full blur-2xl -z-10 group-hover:blur-3xl transition-all duration-300"
                    })]
                }), m.jsx("div", {
                    className: "absolute top-0 left-1/2 w-2 h-2 bg-yellow-300 rounded-full blur-sm animate-ping opacity-75"
                }), m.jsx("div", {
                    className: "absolute top-1/4 right-0 w-1.5 h-1.5 bg-orange-400 rounded-full blur-sm animate-ping opacity-75",
                    style: {
                        animationDelay: "0.5s"
                    }
                }), m.jsx("div", {
                    className: "absolute bottom-1/4 left-0 w-1.5 h-1.5 bg-red-400 rounded-full blur-sm animate-ping opacity-75",
                    style: {
                        animationDelay: "1s"
                    }
                })]
            }), m.jsx("div", {
                className: "relative z-20 -top-4  overflow-hidden rounded-full md:block hidden",
                children: m.jsxs("div", {
                    className: "relative",
                    children: [m.jsx("div", {
                        className: "absolute inset-0 bg-gradient-to-r from-yellow-400 via-orange-500 to-red-500 rounded-full  opacity-75 group-hover:opacity-100 group-hover:blur-lg transition-all duration-300"
                    }), m.jsx("div", {
                        className: "relative uppercase font-extrabold text-base md:text-base text-white px-3 py-1.5 md:px-4 md:py-1.5 rounded-full border-2 border-yellow-400/50 group-hover:border-yellow-300 group-hover:shadow-[0_0_20px_rgba(251,191,36,0.6)] transition-all duration-300",
                        children: m.jsx("span", {
                            className: "drop-shadow-lg",
                            children: "Free Spin"
                        })
                    }), m.jsx("div", {
                        className: "absolute inset-0 bg-gradient-to-r from-transparent via-white/30 to-transparent rounded-full -skew-x-12 opacity-0 group-hover:opacity-100",
                        style: {
                            animation: "shimmer 2s ease-in-out infinite"
                        }
                    })]
                })
            }), m.jsx("div", {
                className: "absolute inset-0 rounded-full border-2 border-yellow-400/30 animate-ping opacity-0 group-hover:opacity-100 transition-opacity duration-300"
            })]
        }), p && m.jsxs("div", {
            className: "fixed bottom-0 left-0 right-0 top-0 z-999 flex items-center justify-center  bg-black/50 backdrop-blur-sm",
            children: [m.jsx("button", {
                onClick: () => {
                    g(!1),
                    _(!1);
                    const J = new Date
                      , ne = new Date(Date.UTC(J.getUTCFullYear(), J.getUTCMonth(), J.getUTCDate() + 1, 0, 0, 0)).getTime();
                    localStorage.setItem("nextJackpotTime", ne.toString())
                }
                ,
                className: "absolute top-4 right-4 z-[1000] w-10 h-10 flex items-center justify-center rounded-full bg-[#1a1a1a] hover:bg-[#FFC12C] border-2 border-[#FFC12C] hover:border-[#FFE559] text-[#FFE559] hover:text-black transition-all duration-200 cursor-pointer group shadow-lg hover:shadow-[#FFC12C]/50",
                "aria-label": "Close slot machine",
                children: m.jsx("svg", {
                    xmlns: "http://www.w3.org/2000/svg",
                    fill: "none",
                    viewBox: "0 0 24 24",
                    strokeWidth: 3,
                    stroke: "currentColor",
                    className: "w-6 h-6 group-hover:scale-110 transition-transform",
                    children: m.jsx("path", {
                        strokeLinecap: "round",
                        strokeLinejoin: "round",
                        d: "M6 18 18 6M6 6l12 12"
                    })
                })
            }), m.jsx(YNe, {
                canPlayJackpot: N,
                countdown: B,
                handleClose: () => {
                    g(!1),
                    _(!1);
                    const J = new Date
                      , ne = new Date(Date.UTC(J.getUTCFullYear(), J.getUTCMonth(), J.getUTCDate() + 1, 0, 0, 0)).getTime();
                    localStorage.setItem("nextJackpotTime", ne.toString())
                }
                ,
                winAmount: h?.JACKPOT_DAILY_REWARD_AMOUNT,
                isConnected: u || l?.walletAddress,
                isEligible: w,
                isUserPlayed: I,
                rewardValue: wn(L, 2),
                upfrontRewardValue: wn(H, 2),
                socialRewardValue: wn(A, 2),
                isPostShared: C,
                showTextValue: z
            })]
        })]
    })
}
  , XNe = () => {
    const [n,e] = V.useState([])
      , [t,r] = V.useState(null)
      , [s,i] = V.useState(!0)
      , o = Pp;
    V.useEffect( () => {
        a(1)
    }
    , []);
    const a = async (u=1) => {
        try {
            i(!0);
            const d = await TSe(u, o);
            e(d.data.data),
            r(d.data.meta)
        } catch (d) {
            console.error("Error fetching game history:", d)
        } finally {
            i(!1)
        }
    }
      , l = u => new Date(u).toLocaleString("en-US", {
        day: "2-digit",
        month: "short",
        year: "numeric",
        hour: "2-digit",
        minute: "2-digit",
        hour12: !0
    });
    return m.jsx("div", {
        className: "container mx-auto",
        children: m.jsxs("div", {
            className: "bg-[#1D2938] px-2 md:px-8 pb-8 pt-20 rounded-4xl",
            children: [m.jsxs("div", {
                className: "overflow-x-auto",
                children: [s && m.jsx("div", {
                    className: "text-center py-10 text-white text-lg",
                    children: m.jsx(KC, {
                        rows: 10,
                        cols: 4
                    })
                }), !s && n?.length === 0 && m.jsx("div", {
                    className: "text-center py-10 text-white text-lg",
                    children: "No game history found."
                }), !s && n?.length > 0 && m.jsxs("table", {
                    className: "w-full",
                    children: [m.jsx("thead", {
                        children: m.jsxs("tr", {
                            children: [m.jsx("th", {
                                className: "py-2 px-4 md:py-4 md:px-8 font-semibold text-sm text-left",
                                children: "Bet Amount"
                            }), m.jsx("th", {
                                className: "py-2 px-4 md:py-4 md:px-8 font-semibold text-sm text-left",
                                children: "Time"
                            }), m.jsx("th", {
                                className: "py-2 px-4 md:py-4 md:px-8 font-semibold text-sm text-left",
                                children: "Score"
                            }), m.jsx("th", {
                                className: "py-2 px-4 md:py-4 md:px-8 font-semibold text-sm text-left",
                                children: "Win Amount"
                            })]
                        })
                    }), m.jsx("tbody", {
                        children: n.map( (u, d) => m.jsxs("tr", {
                            children: [m.jsx("td", {
                                className: "py-2 px-4 md:py-4 md:px-8 font-semibold text-sm bg-[#263446] rounded-l-2xl border-b-4 border-[#1D2938]",
                                children: m.jsxs("div", {
                                    className: "flex items-center gap-2",
                                    children: [m.jsx("img", {
                                        src: ri,
                                        className: "w-6 max-w-6"
                                    }), Number(u.betAmount), " L1XP"]
                                })
                            }), m.jsx("td", {
                                className: "py-2 px-4 md:py-4 md:px-8 font-semibold text-sm text-[#73849B] bg-[#263446] border-b-4 border-[#1D2938]",
                                children: l(u.createdAt)
                            }), m.jsx("td", {
                                className: "py-2 px-4 md:py-4 md:px-8 font-normal text-sm bg-[#263446] border-b-4 border-[#1D2938]",
                                children: u.outcomeValue ? `${Number(u.outcomeValue)}` : "-"
                            }), m.jsx("td", {
                                className: "py-2 px-4 md:py-4 md:px-8 font-semibold text-sm bg-[#263446] rounded-r-2xl border-b-4 border-[#1D2938]",
                                children: m.jsxs("div", {
                                    className: "flex items-center gap-2",
                                    children: [m.jsx("img", {
                                        src: ri,
                                        className: "w-6 max-w-6"
                                    }), u.winAmount ? Number(u.winAmount) + " L1XP" : "-"]
                                })
                            })]
                        }, d))
                    })]
                })]
            }), t && m.jsxs("div", {
                className: "flex justify-center gap-4 mt-6 text-white",
                children: [m.jsx("button", {
                    disabled: !t.previousPageUrl,
                    className: "px-4 py-2 bg-[#263446] rounded-lg disabled:opacity-40",
                    onClick: () => a(t.currentPage - 1),
                    children: "Prev"
                }), m.jsxs("span", {
                    className: "px-4 py-2",
                    children: [t.currentPage, " / ", t.lastPage]
                }), m.jsx("button", {
                    disabled: !t.nextPageUrl,
                    className: "px-4 py-2 bg-[#263446] rounded-lg disabled:opacity-40",
                    onClick: () => a(t.currentPage + 1),
                    children: "Next"
                })]
            })]
        })
    })
}
  , QNe = "/assets/game-icon-Btm55mh5.png"
  , ZNe = "/assets/wl1x-icon-new-BTPjLy6j.svg"
  , JNe = ({isOpen: n, onClose: e}) => {
    const [t,r] = V.useState({
        oldpassword: "",
        createnewpassword: "",
        confirmnewpassword: ""
    })
      , s = o => {
        r({
            ...t,
            [o.target.name]: o.target.value
        })
    }
      , i = o => o && o.trim() !== "";
    return n ? m.jsxs("div", {
        className: "",
        children: [m.jsx("div", {
            className: "bg-[#27364b] max-w-md w-full rounded-3xl absolute top-12 left-0 right-0 mx-auto z-50 text-white overflow-hidden",
            children: m.jsxs("div", {
                className: "bg-brandGray p-8 relative",
                children: [m.jsx("h2", {
                    className: "text-2xl font-light mb-8",
                    children: "Change Password"
                }), m.jsx("div", {
                    className: "cursor-pointer w-12 h-12 absolute right-1 top-1 flex items-center justify-center flex-col opacity-55",
                    onClick: e,
                    children: m.jsx("svg", {
                        xmlns: "http://www.w3.org/2000/svg",
                        fill: "none",
                        viewBox: "0 0 24 24",
                        strokeWidth: 1.5,
                        stroke: "currentColor",
                        className: "size-6",
                        children: m.jsx("path", {
                            strokeLinecap: "round",
                            strokeLinejoin: "round",
                            d: "M6 18 18 6M6 6l12 12"
                        })
                    })
                }), m.jsxs("div", {
                    className: "rounded-2xl mt-5",
                    children: [m.jsxs("div", {
                        className: "relative mb-8",
                        children: [m.jsx("input", {
                            type: "password",
                            id: "oldpassword",
                            name: "oldpassword",
                            placeholder: " ",
                            value: t.oldpassword,
                            onChange: s,
                            className: `peer w-full px-4 py-3 bg-transparent border-1 ${i(t.oldpassword) ? "border-orange-400" : "border-[#3F4E63]"} rounded-lg text-white text-base focus:outline-none focus:border-orange-400 transition-colors`
                        }), m.jsx("label", {
                            htmlFor: "oldpassword",
                            className: `absolute left-4 -top-3 text-sm bg-brandGray px-2 ${i(t.oldpassword) ? "text-orange-500" : "text-[#8FA1B8]"} peer-focus:text-orange-500 transition-all duration-200 pointer-events-none peer-placeholder-shown:top-3.5 peer-placeholder-shown:text-sm peer-focus:-top-3 peer-focus:text-sm`,
                            children: "Old Password"
                        }), m.jsx("button", {
                            type: "button",
                            className: "absolute cursor-pointer right-3 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-white transition-colors",
                            children: m.jsx("svg", {
                                xmlns: "http://www.w3.org/2000/svg",
                                fill: "none",
                                viewBox: "0 0 24 24",
                                strokeWidth: 1.5,
                                stroke: "currentColor",
                                className: "size-6",
                                children: m.jsx("path", {
                                    strokeLinecap: "round",
                                    strokeLinejoin: "round",
                                    d: "M3.98 8.223A10.477 10.477 0 0 0 1.934 12C3.226 16.338 7.244 19.5 12 19.5c.993 0 1.953-.138 2.863-.395M6.228 6.228A10.451 10.451 0 0 1 12 4.5c4.756 0 8.773 3.162 10.065 7.498a10.522 10.522 0 0 1-4.293 5.774M6.228 6.228 3 3m3.228 3.228 3.65 3.65m7.894 7.894L21 21m-3.228-3.228-3.65-3.65m0 0a3 3 0 1 0-4.243-4.243m4.242 4.242L9.88 9.88"
                                })
                            })
                        })]
                    }), m.jsxs("div", {
                        className: "relative mb-8",
                        children: [m.jsx("input", {
                            type: "password",
                            id: "createnewpassword",
                            name: "createnewpassword",
                            placeholder: " ",
                            value: t.createnewpassword,
                            onChange: s,
                            className: `peer w-full px-4 py-3 bg-transparent border-1 ${i(t.createnewpassword) ? "border-orange-400" : "border-[#3F4E63]"} rounded-lg text-white text-base focus:outline-none focus:border-orange-400 transition-colors`
                        }), m.jsx("label", {
                            htmlFor: "createnewpassword",
                            className: `absolute left-4 -top-3 text-sm bg-brandGray px-2 ${i(t.createnewpassword) ? "text-orange-500" : "text-[#8FA1B8]"} peer-focus:text-orange-500 transition-all duration-200 pointer-events-none peer-placeholder-shown:top-3.5 peer-placeholder-shown:text-sm peer-focus:-top-3 peer-focus:text-sm`,
                            children: "Create New Password"
                        }), m.jsx("button", {
                            type: "button",
                            className: "absolute cursor-pointer right-3 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-white transition-colors",
                            children: m.jsxs("svg", {
                                xmlns: "http://www.w3.org/2000/svg",
                                fill: "none",
                                viewBox: "0 0 24 24",
                                strokeWidth: 1.5,
                                stroke: "currentColor",
                                className: "size-6",
                                children: [m.jsx("path", {
                                    strokeLinecap: "round",
                                    strokeLinejoin: "round",
                                    d: "M2.036 12.322a1.012 1.012 0 0 1 0-.639C3.423 7.51 7.36 4.5 12 4.5c4.638 0 8.573 3.007 9.963 7.178.07.207.07.431 0 .639C20.577 16.49 16.64 19.5 12 19.5c-4.638 0-8.573-3.007-9.963-7.178Z"
                                }), m.jsx("path", {
                                    strokeLinecap: "round",
                                    strokeLinejoin: "round",
                                    d: "M15 12a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z"
                                })]
                            })
                        })]
                    }), m.jsxs("div", {
                        className: "relative mb-8",
                        children: [m.jsx("input", {
                            type: "password",
                            id: "confirmnewpassword",
                            name: "confirmnewpassword",
                            placeholder: " ",
                            value: t.confirmnewpassword,
                            onChange: s,
                            className: `peer w-full px-4 py-3 bg-transparent border-1 ${i(t.confirmnewpassword) ? "border-orange-400" : "border-[#3F4E63]"} rounded-lg text-white text-base focus:outline-none focus:border-orange-400 transition-colors`
                        }), m.jsx("label", {
                            htmlFor: "confirmnewpassword",
                            className: `absolute left-4 -top-3 text-sm bg-brandGray px-2 ${i(t.confirmnewpassword) ? "text-orange-500" : "text-[#8FA1B8]"} peer-focus:text-orange-500 transition-all duration-200 pointer-events-none peer-placeholder-shown:top-3.5 peer-placeholder-shown:text-sm peer-focus:-top-3 peer-focus:text-sm`,
                            children: "Confirm New Password"
                        }), m.jsx("button", {
                            type: "button",
                            className: "absolute cursor-pointer right-3 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-white transition-colors",
                            children: m.jsxs("svg", {
                                xmlns: "http://www.w3.org/2000/svg",
                                fill: "none",
                                viewBox: "0 0 24 24",
                                strokeWidth: 1.5,
                                stroke: "currentColor",
                                className: "size-6",
                                children: [m.jsx("path", {
                                    strokeLinecap: "round",
                                    strokeLinejoin: "round",
                                    d: "M2.036 12.322a1.012 1.012 0 0 1 0-.639C3.423 7.51 7.36 4.5 12 4.5c4.638 0 8.573 3.007 9.963 7.178.07.207.07.431 0 .639C20.577 16.49 16.64 19.5 12 19.5c-4.638 0-8.573-3.007-9.963-7.178Z"
                                }), m.jsx("path", {
                                    strokeLinecap: "round",
                                    strokeLinejoin: "round",
                                    d: "M15 12a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z"
                                })]
                            })
                        })]
                    })]
                }), m.jsx("div", {
                    className: "mt-8",
                    children: m.jsx("button", {
                        className: "cursor-pointer w-full gap-3 btn-clr py-4 px-5 rounded-xl text-base font-semibold hover:brightness-90 hover:scale-[1.02] transition-all duration-200",
                        children: "Submit"
                    })
                })]
            })
        }), m.jsx("div", {
            className: "fixed bg-black/70 w-full h-full top-0 left-0 z-40 backdrop-blur-lg"
        })]
    }) : null
}
  , eDe = ({emailAddress: n}) => {
    const e = B0()
      , [t,r] = V.useState(!1)
      , [s,i] = V.useState(null)
      , [o,a] = V.useState(!1)
      , [l,u] = V.useState(!0)
      , [d,h] = V.useState(!1)
      , [p,g] = V.useState(null)
      , [w,b] = V.useState(null)
      , [v,S] = V.useState(null)
      , [N,_] = V.useState({
        username: "",
        firstname: "",
        lastname: "",
        email: ""
    })
      , I = Uo();
    V.useEffect( () => {
        (async () => {
            try {
                u(!0);
                const L = (await NSe()).data;
                L && (_(L),
                L.profileImage && S(L.profileImage))
            } catch (R) {
                console.error("Profile fetch error:", R),
                g("Failed to load profile.")
            } finally {
                u(!1)
            }
        }
        )()
    }
    , []);
    const k = M => {
        const {name: R, value: L} = M.target;
        let q = L;
        R === "username" && (q = q.toLowerCase(),
        q = q.replace(/\s+/g, "")),
        _(H => ({
            ...H,
            [R]: q
        })),
        R === "username" && (usernameRegex.test(q) ? g(null) : g("Username must be 3-8 characters, lowercase letters, numbers, dots, or underscores. No spaces."))
    }
      , B = M => M && M.trim() !== ""
      , P = async () => {
        if (p) {
            Ze.error("Fix username before saving.");
            return
        }
        h(!0);
        try {
            const M = await I.executeV3("action")
              , R = await DSe({
                name: N.username
            }, M);
            R?.status === "success" ? (Ze.success("Profile updated successfully!"),
            a(!1)) : Ze.error(R?.message || "Failed to submit username.")
        } catch (M) {
            console.error("Profile update error:", M),
            Ze.error("Failed to update profile")
        } finally {
            h(!1)
        }
    }
    ;
    return m.jsxs(m.Fragment, {
        children: [m.jsxs("div", {
            className: "grid grid-cols-1 md:grid-cols-2",
            children: [o ? m.jsxs("div", {
                className: "bg-[#2c3747] md:rounded-l-4xl pb-8 p-8 text-left flex flex-col items-center profileedit-section",
                children: [m.jsx("div", {
                    className: "flex flex-col items-center mb-8 w-full",
                    children: m.jsx("div", {
                        className: "relative mb-6",
                        children: m.jsx("div", {
                            className: "w-40 h-40 rounded-full overflow-hidden shadow-lg",
                            children: v ? m.jsx("img", {
                                src: v,
                                className: "w-full h-full object-cover"
                            }) : m.jsx(Z2, {
                                diameter: 90,
                                seed: ay.jsNumberForAddress(e?.walletAddress || "")
                            })
                        })
                    })
                }), m.jsx("div", {
                    className: "grid grid-cols-1 gap-7 w-full",
                    children: m.jsxs("div", {
                        className: "relative mb-8",
                        children: [m.jsx("input", {
                            type: "text",
                            id: "username",
                            name: "username",
                            value: N?.username,
                            onChange: k,
                            placeholder: " ",
                            className: `peer w-full px-4 py-3 bg-transparent border ${B(N.username) ? "border-orange-400" : "border-[#3F4E63]"} rounded-lg text-white`
                        }), m.jsx("label", {
                            className: `absolute left-4 -top-3 bg-brandGray px-2 ${B(N.username) ? "text-orange-500" : "text-[#8FA1B8]"}`,
                            children: "Username"
                        }), p && m.jsx("p", {
                            className: "text-red-400 text-center mb-4",
                            children: p
                        })]
                    })
                })]
            }) : m.jsxs("div", {
                className: "bg-[#2c3747] md:bg-[#1c2837] md:rounded-l-4xl rounded-t-2xl p-8 text-center flex flex-col items-center profileview-section",
                children: [m.jsx("div", {
                    className: "w-44 h-44 frame-profile flex items-center justify-center flex-col mx-auto mb-8 md:mt-0 mt-10",
                    children: m.jsx(Z2, {
                        diameter: 90,
                        seed: ay.jsNumberForAddress(e?.walletAddress || n || "")
                    })
                }), m.jsx("h3", {
                    className: "text-2xl font-semibold mb-2",
                    children: l ? m.jsx(Fp, {
                        type: "balanceamount"
                    }) : N.username
                }), n ? m.jsx("p", {
                    className: "text-[#8FA1B8] text-xl",
                    children: n
                }) : ""]
            }), m.jsxs("div", {
                className: "bg-[#2c3747] md:bg-[#151E29] md:rounded-r-4xl rounded-b-2xl px-8 pb-16 pt-6 md:pt-24",
                children: [m.jsxs("div", {
                    className: "bg-[#F76125] rounded-3xl py-4 px-6 flex items-center justify-between shadow-[inset_0_-6px_0_#d9530f] mb-5 max-w-5/6 mx-auto",
                    children: [m.jsx("img", {
                        src: QNe,
                        className: "w-14"
                    }), m.jsxs("div", {
                        className: "text-right",
                        children: [m.jsx("p", {
                            className: "text-sm mb-1",
                            children: "Total Game Play"
                        }), m.jsx("h3", {
                            className: "font-bold text-3xl",
                            children: l ? m.jsx(Fp, {
                                type: "balanceamount"
                            }) : N?.totalSessions
                        })]
                    })]
                }), m.jsxs("div", {
                    className: "bg-[#7E04F7] rounded-3xl py-4 px-6 flex items-center justify-between shadow-[inset_0_-6px_0_#5F03B9] max-w-5/6 mx-auto",
                    children: [m.jsx("img", {
                        src: ZNe,
                        className: "w-14"
                    }), m.jsxs("div", {
                        className: "text-right",
                        children: [m.jsx("p", {
                            className: "text-sm mb-1",
                            children: "Rewards Earned"
                        }), m.jsxs("h3", {
                            className: "font-bold text-2xl md:text-3xl d-flex",
                            children: [l ? m.jsx(Fp, {
                                type: "balanceamount"
                            }) : Vd(N?.totalWin, {
                                decimals: 2,
                                currency: ""
                            }), " L1XP"]
                        })]
                    })]
                })]
            })]
        }), m.jsx("div", {
            className: "mt-10 text-center",
            children: m.jsx("button", {
                className: "text-white rounded-4xl brand-gradient-bg py-4 px-22 text-base",
                disabled: d || o && p,
                onClick: () => {
                    o ? P() : a(!0)
                }
                ,
                children: d ? "Updating..." : o ? "Save Profile" : "Edit Profile"
            })
        }), m.jsx(JNe, {
            isOpen: t,
            onClose: () => r(!1)
        })]
    })
}
  , tDe = () => {
    const n = Ti()
      , {tab: e, emailAddress: t} = n.state || {}
      , [r,s] = V.useState(e || "profile");
    return V.useEffect( () => {
        e !== r && s(e)
    }
    , [e]),
    m.jsx("div", {
        className: "",
        children: m.jsx("div", {
            className: "py-20 px-4",
            children: m.jsxs("div", {
                className: "container mx-auto relative",
                children: [m.jsx("div", {
                    className: "text-center absolute -top-6 left-0 right-0 mx-auto",
                    children: m.jsxs("ul", {
                        className: "bg-[#283647] border border-white inline-flex items-center mx-auto rounded-4xl",
                        children: [m.jsx("li", {
                            onClick: () => s("profile"),
                            className: `py-2 md:py-4 px-10 rounded-4xl text-base cursor-pointer transition-all duration-300 ${r === "profile" ? "bg-[#F76125] text-white" : "text-white/70 hover:text-white"}`,
                            children: "My Profile"
                        }), m.jsx("li", {
                            onClick: () => s("history"),
                            className: `py-2 md:py-4 px-10 rounded-4xl text-base cursor-pointer transition-all duration-300 ${r === "history" ? "bg-[#F76125] text-white" : "text-white/70 hover:text-white"}`,
                            children: "Game History"
                        })]
                    })
                }), r === "profile" && m.jsx(eDe, {
                    emailAddress: t
                }), r === "history" && m.jsx(XNe, {})]
            })
        })
    })
}
  , nDe = () => {
    const [n,e] = V.useState(!1)
      , [t,r] = V.useState(!1)
      , [s,i] = V.useState(!1);
    kr();
    const [o,a] = V.useState(!1)
      , u = Ti().state?.email || ""
      , [d,h] = V.useState({
        email: u || "",
        password: "",
        confirmPassword: ""
    })
      , p = () => {
        h({
            email: "",
            password: "",
            confirmPassword: ""
        })
    }
      , g = () => {
        r(!t)
    }
      , w = () => {
        i(!s)
    }
      , b = N => {
        h({
            ...d,
            [N.target.name]: N.target.value
        })
    }
      , v = async () => {
        try {
            if (a(!0),
            d.password == "") {
                Ze.error("Password is required"),
                a(!1);
                return
            }
            if (d.password !== d.confirmPassword) {
                Ze.error("Passwords do not match"),
                a(!1);
                return
            }
            if (d?.email === "") {
                Ze.error("Email is required"),
                a(!1);
                return
            }
            const N = {
                email: d.email,
                name: "",
                password: d.password,
                confirmPassword: d.confirmPassword,
                isPlay: !0
            }
              , _ = await N5e(N);
            _.status === "success" ? (Ze.success("Account created successfully!"),
            e(!0)) : Ze.error(_.message || "Signup failed")
        } catch {} finally {
            a(!1)
        }
    }
      , S = N => N && N.trim() !== "";
    return m.jsxs(m.Fragment, {
        children: [m.jsxs("div", {
            className: "grid grid-cols-12 bg-login-img",
            children: [m.jsx("div", {
                className: "col-span-12 md:col-span-7 xl:col-span-8 md:h-screen justify-center items-center bg-brandGray md:bg-transparent",
                children: m.jsxs("div", {
                    className: "p-5",
                    children: [m.jsx(Us, {
                        to: "/",
                        className: "mb-4 lg:mb-0 inline-block",
                        children: m.jsx("img", {
                            className: "w-20 md:w-auto",
                            src: _x
                        })
                    }), m.jsx("div", {
                        className: "text-center flex-col justify-center items-center md:h-[calc(100vh-100px)] hidden md:flex",
                        children: m.jsxs("div", {
                            children: [m.jsx("img", {
                                src: $V,
                                className: "mx-auto mb-6 max-w-[100px] md:max-w-sm"
                            }), m.jsx("h3", {
                                className: "text-2xl md:text-5xl font-semibold mb-2 md:mb-4",
                                children: "Ready to win?"
                            }), m.jsx("p", {
                                className: "text-sm md:text-lg font-light uppercase",
                                children: "Log in or sign up to get started"
                            })]
                        })
                    })]
                })
            }), m.jsx("div", {
                className: "col-span-12 md:col-span-5 xl:col-span-4 bg-brandGray p-4 flex justify-center items-center md:h-screen mobile-height",
                children: m.jsxs("div", {
                    className: "lg:min-w-[400px] px-3 text-center",
                    children: [m.jsx("h2", {
                        className: "text-3xl md:text-4xl font-light mb-3 md:mb-5",
                        children: "Sign Up"
                    }), m.jsx("p", {
                        className: "text-sm font-light mb-6",
                        children: "Sign up now to unlock rewards, ranks, and endless fun."
                    }), m.jsxs("div", {
                        className: "relative mb-8",
                        children: [m.jsx("input", {
                            type: "email",
                            id: "email",
                            name: "email",
                            placeholder: " ",
                            value: d.email,
                            onChange: b,
                            className: `peer w-full px-4 py-3 bg-transparent border-1 ${S(d.email) ? "border-orange-400" : "border-[#3F4E63]"} rounded-lg text-white text-base focus:outline-none focus:border-orange-400 transition-colors`
                        }), m.jsx("label", {
                            htmlFor: "email",
                            className: `absolute left-4 -top-3 text-sm bg-brandGray px-2 ${S(d.email) ? "text-orange-500" : "text-[#8FA1B8]"} peer-focus:text-orange-500 transition-all duration-200 pointer-events-none peer-placeholder-shown:top-3.5 peer-placeholder-shown:text-sm peer-focus:-top-3.5 peer-focus:text-sm`,
                            children: "Email Address"
                        })]
                    }), m.jsxs("div", {
                        className: "relative mb-8",
                        children: [m.jsx("input", {
                            type: t ? "text" : "password",
                            id: "password",
                            name: "password",
                            placeholder: " ",
                            value: d.password,
                            onChange: b,
                            className: `peer w-full px-4 py-3 bg-transparent border-1 ${S(d.password) ? "border-orange-400" : "border-[#3F4E63]"} rounded-lg text-white text-base focus:outline-none focus:border-orange-400 transition-colors`
                        }), m.jsx("label", {
                            htmlFor: "password",
                            className: `absolute left-4 -top-3 text-sm bg-brandGray px-2 ${S(d.password) ? "text-orange-500" : "text-[#8FA1B8]"} peer-focus:text-orange-500 transition-all duration-200 pointer-events-none peer-placeholder-shown:top-3.5 peer-placeholder-shown:text-sm peer-focus:-top-3.5 peer-focus:text-sm`,
                            children: "Password"
                        }), m.jsx("button", {
                            type: "button",
                            onClick: g,
                            className: "absolute cursor-pointer right-3 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-white transition-colors",
                            children: t ? m.jsx("svg", {
                                xmlns: "http://www.w3.org/2000/svg",
                                fill: "none",
                                viewBox: "0 0 24 24",
                                strokeWidth: 1.5,
                                stroke: "currentColor",
                                className: "size-6",
                                children: m.jsx("path", {
                                    strokeLinecap: "round",
                                    strokeLinejoin: "round",
                                    d: "M3.98 8.223A10.477 10.477 0 0 0 1.934 12C3.226 16.338 7.244 19.5 12 19.5c.993 0 1.953-.138 2.863-.395M6.228 6.228A10.451 10.451 0 0 1 12 4.5c4.756 0 8.773 3.162 10.065 7.498a10.522 10.522 0 0 1-4.293 5.774M6.228 6.228 3 3m3.228 3.228 3.65 3.65m7.894 7.894L21 21m-3.228-3.228-3.65-3.65m0 0a3 3 0 1 0-4.243-4.243m4.242 4.242L9.88 9.88"
                                })
                            }) : m.jsxs("svg", {
                                xmlns: "http://www.w3.org/2000/svg",
                                fill: "none",
                                viewBox: "0 0 24 24",
                                strokeWidth: 1.5,
                                stroke: "currentColor",
                                className: "size-6",
                                children: [m.jsx("path", {
                                    strokeLinecap: "round",
                                    strokeLinejoin: "round",
                                    d: "M2.036 12.322a1.012 1.012 0 0 1 0-.639C3.423 7.51 7.36 4.5 12 4.5c4.638 0 8.573 3.007 9.963 7.178.07.207.07.431 0 .639C20.577 16.49 16.64 19.5 12 19.5c-4.638 0-8.573-3.007-9.963-7.178Z"
                                }), m.jsx("path", {
                                    strokeLinecap: "round",
                                    strokeLinejoin: "round",
                                    d: "M15 12a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z"
                                })]
                            })
                        })]
                    }), m.jsxs("div", {
                        className: "relative mb-8",
                        children: [m.jsx("input", {
                            type: s ? "text" : "password",
                            id: "ConfirmPassword",
                            name: "confirmPassword",
                            placeholder: " ",
                            value: d.confirmPassword,
                            onChange: b,
                            className: `peer w-full px-4 py-3 bg-transparent border-1 ${S(d.confirmPassword) ? "border-orange-400" : "border-[#3F4E63]"} rounded-lg text-white text-base focus:outline-none focus:border-orange-400 transition-colors`
                        }), m.jsx("label", {
                            htmlFor: "confirmpassword",
                            className: `absolute left-4 -top-3 text-sm bg-brandGray px-2 ${S(d.confirmPassword) ? "text-orange-500" : "text-[#8FA1B8]"} peer-focus:text-orange-500 transition-all duration-200 pointer-events-none peer-placeholder-shown:top-3.5 peer-placeholder-shown:text-sm peer-focus:-top-3.5 peer-focus:text-sm`,
                            children: "Confirm Password"
                        }), m.jsx("button", {
                            type: "button",
                            onClick: w,
                            className: "absolute right-3 cursor-pointer top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-white transition-colors",
                            children: s ? m.jsx("svg", {
                                xmlns: "http://www.w3.org/2000/svg",
                                fill: "none",
                                viewBox: "0 0 24 24",
                                strokeWidth: 1.5,
                                stroke: "currentColor",
                                className: "size-6",
                                children: m.jsx("path", {
                                    strokeLinecap: "round",
                                    strokeLinejoin: "round",
                                    d: "M3.98 8.223A10.477 10.477 0 0 0 1.934 12C3.226 16.338 7.244 19.5 12 19.5c.993 0 1.953-.138 2.863-.395M6.228 6.228A10.451 10.451 0 0 1 12 4.5c4.756 0 8.773 3.162 10.065 7.498a10.522 10.522 0 0 1-4.293 5.774M6.228 6.228 3 3m3.228 3.228 3.65 3.65m7.894 7.894L21 21m-3.228-3.228-3.65-3.65m0 0a3 3 0 1 0-4.243-4.243m4.242 4.242L9.88 9.88"
                                })
                            }) : m.jsxs("svg", {
                                xmlns: "http://www.w3.org/2000/svg",
                                fill: "none",
                                viewBox: "0 0 24 24",
                                strokeWidth: 1.5,
                                stroke: "currentColor",
                                className: "size-6",
                                children: [m.jsx("path", {
                                    strokeLinecap: "round",
                                    strokeLinejoin: "round",
                                    d: "M2.036 12.322a1.012 1.012 0 0 1 0-.639C3.423 7.51 7.36 4.5 12 4.5c4.638 0 8.573 3.007 9.963 7.178.07.207.07.431 0 .639C20.577 16.49 16.64 19.5 12 19.5c-4.638 0-8.573-3.007-9.963-7.178Z"
                                }), m.jsx("path", {
                                    strokeLinecap: "round",
                                    strokeLinejoin: "round",
                                    d: "M15 12a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z"
                                })]
                            })
                        })]
                    }), m.jsx("div", {
                        className: "relative",
                        children: m.jsx("button", {
                            disabled: o,
                            onClick: v,
                            type: "button",
                            className: "text-white rounded-lg button-color block text-medium font-medium py-4 px-3 md:px-10 text-xs md:text-base text-center relative z-10 shadow-2xl w-full cursor-pointer",
                            children: o ? "Submitting..." : "Continue"
                        })
                    }), m.jsxs("div", {
                        className: "flex items-center justify-between my-3.5",
                        children: [m.jsx("p", {
                            className: "text-txtGray",
                            children: "Already have an account?"
                        }), m.jsx(Us, {
                            to: "/login",
                            className: "underline hover:text-brandOrange",
                            children: "Login"
                        })]
                    })]
                })
            })]
        }), m.jsx(sk, {
            emailAddress: d?.email,
            isOpen: n,
            onClose: () => {
                p(),
                e(!1)
            }
        })]
    })
}
  , rDe = "/assets/helpIcon-EKYVTXQ1.png"
  , sDe = () => m.jsxs(m.Fragment, {
    children: [m.jsxs("div", {
        className: "md:flex md:flex-row flex-col md:gap-4 gap-2 items-center justify-between py-6 px-6 bg-[#171E29]",
        children: [m.jsx(Us, {
            to: "/",
            className: "md:mb-0 mb-4 block",
            children: m.jsx("img", {
                src: _x,
                alt: "logo",
                className: "w-20 md:w-28"
            })
        }), m.jsx("p", {
            className: "text-white text-sm opacity-50 md:mb-0 mb-4 block",
            children: "Copyright  2025 L1X-Play. All rights reserved."
        }), m.jsx(Us, {
            to: "/terms-and-conditions",
            className: "text-[#FF6717] md:mb-0 mb-4 block",
            children: "Terms and Conditions"
        })]
    }), m.jsx(Us, {
        to: "https://www.l1xapp.com/account/assistance?openModa=true&menuId=9&subMenuId=22&issueId=57",
        target: "_blank",
        className: "text-[#FF6717] md:mb-0 mb-4 block helpIcon  bottom-6 left-4 fixed lg:bottom-24 lg:left-4 z-10",
        children: m.jsx("img", {
            src: rDe,
            className: "w-12 h-12"
        })
    })]
})
  , iDe = () => m.jsxs("div", {
    className: "banner-bg",
    children: [m.jsx(pk, {}), m.jsx("div", {
        className: "min-h-[calc(100vh-88px-77.3px)]",
        children: m.jsx(lQ, {})
    }), m.jsx(sDe, {})]
})
  , Nk = "/assets/BiscuitRunLogo-Dr-2uiid.png"
  , oDe = "data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAYAAAA6/NlyAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAABwSURBVHgB7dlBDYBAEATBhaAF/3owA7i4pK/KQSfzm2Nm3lnjmQXO2YzgOsF1gusE1wmuE1wnuE5wneA6wXWC6wTXCa4TXHfNohfvd88CJl0nuE5wneA6wXWC6wTXCa4TXCe4TnCd4DrBdYLrtgv+AM4/A1NUddJ7AAAAAElFTkSuQmCC"
  , dG = "/assets/gameover-sonic-DskXhSI5.gif"
  , aDe = "/assets/biscuitLogo-Dq10NFt2.png"
  , lDe = () => m.jsx("div", {
    id: "loading",
    className: "loading-screen",
    style: {
        backgroundImage: `url(${oDe})`
    },
    children: m.jsxs("div", {
        className: "load",
        children: [m.jsx("img", {
            id: "loadIMG",
            src: dG,
            alt: "Loading..."
        }), m.jsx("img", {
            className: "biscuitLogo",
            src: aDe,
            alt: "Biscuit Logo"
        })]
    })
})
  , cDe = "/assets/sonic-idle-ctBp-QK6.gif"
  , uDe = "/assets/sonic-run-DcURe0cm.gif"
  , dDe = "/assets/sonic-run-DcURe0cm.gif"
  , fDe = "/assets/sonic-jump-BIbiT6Yh.gif"
  , hDe = "/assets/sonic-jump-BIbiT6Yh.gif"
  , pDe = "/assets/sonic-damage-D_78ExR3.gif"
  , mDe = "/assets/sonic-death-DFDByx6X.gif"
  , tj = {
    Sonic: {
        idle: cDe,
        start: uDe,
        run: dDe,
        jump: fDe,
        doublejump: hDe,
        damage: pDe,
        death: mDe
    }
}
  , fG = V.forwardRef( ({character: n}, e) => {
    const t = V.useMemo( () => tj[n] || tj.Sonic, [n]);
    V.useEffect( () => {
        const i = Object.values(t).map(o => {
            const a = new Image;
            return a.src = o,
            a
        }
        );
        return () => {
            i.forEach(o => {
                o.onload = null
            }
            )
        }
    }
    , [n, t]);
    const r = V.useMemo( () => ({
        "--Idle": `url(${t.idle})`,
        "--Start": `url(${t.start})`,
        "--Run": `url(${t.run})`,
        "--Jump": `url(${t.jump})`,
        "--DoubleJump": `url(${t.doublejump})`,
        "--Damage": `url(${t.damage})`,
        "--Death": `url(${t.death})`
    }), [t]);
    return m.jsx("div", {
        ref: e,
        id: "sonic",
        className: "player",
        "data-character": n,
        style: r
    })
}
);
fG.displayName = "Player";
const gDe = ye.memo(fG)
  , yDe = "/assets/badnik1-BcbFAHvN.gif"
  , bDe = "/assets/badnik2-B8Xtz2zv.gif"
  , wDe = ({gameStarted: n, playerRef: e, isGameOverRef: t, canLoseLifeRef: r, onCollision: s, onEnemyPassed: i, speedMultiplierRef: o, scoreRef: a}) => {
    const l = V.useRef(null)
      , u = V.useRef(null)
      , d = V.useRef(0)
      , h = V.useRef(!1)
      , p = V.useRef(!1)
      , g = () => {
        const b = a?.current || 0;
        return b < 1e3 ? 1 : b < 2e3 ? 2 : b < 3e3 ? 3 : b < 4e3 ? 4 : 5
    }
      , w = b => {
        const v = {
            1: {
                spawnDelayMin: 1800,
                spawnDelayMax: 2800,
                bothEnemiesChance: .1,
                speedMultiplier: 1
            },
            2: {
                spawnDelayMin: 1600,
                spawnDelayMax: 2400,
                bothEnemiesChance: .2,
                speedMultiplier: 1.15
            },
            3: {
                spawnDelayMin: 1400,
                spawnDelayMax: 2e3,
                bothEnemiesChance: .3,
                speedMultiplier: 1.35
            },
            4: {
                spawnDelayMin: 1200,
                spawnDelayMax: 1700,
                bothEnemiesChance: .4,
                speedMultiplier: 1.55
            },
            5: {
                spawnDelayMin: 1e3,
                spawnDelayMax: 1400,
                bothEnemiesChance: .5,
                speedMultiplier: 1.8
            }
        };
        return v[b] || v[1]
    }
    ;
    return V.useEffect( () => {
        if (!n)
            return;
        const b = l.current
          , v = u.current;
        if (!b || !v)
            return;
        const S = window.innerWidth <= 800
          , N = g()
          , _ = w(N);
        b.style.animationDuration = S ? `${2.8 / _.speedMultiplier}s` : `${3.6 / _.speedMultiplier}s`,
        v.style.animationDuration = S ? `${3.2 / _.speedMultiplier}s` : `${4 / _.speedMultiplier}s`;
        let I = Math.floor(Math.random() * 1e3) + 1500;
        const k = setInterval( () => {
            if (t.current) {
                b.classList.add("hidden"),
                v.classList.add("hidden");
                return
            }
            d.current += 10;
            const M = g()
              , R = w(M)
              , q = 1 / (o.current * R.speedMultiplier);
            if (d.current >= I) {
                const H = Math.random()
                  , j = R.bothEnemiesChance
                  , A = .35 - j * .3
                  , E = .35 - j * .3;
                if (H < A && !b.classList.contains("block"))
                    b.classList.add("block");
                else if (H < A + E && !v.classList.contains("flying"))
                    v.classList.add("flying");
                else if (H < A + E + j)
                    !b.classList.contains("block") && !v.classList.contains("flying") ? (b.classList.add("block"),
                    v.classList.add("flying")) : b.classList.contains("block") ? v.classList.contains("flying") || v.classList.add("flying") : b.classList.add("block");
                else if (!b.classList.contains("block") && !v.classList.contains("flying")) {
                    const z = Math.random();
                    z < .4 ? b.classList.add("block") : (z < .8 || b.classList.add("block"),
                    v.classList.add("flying"))
                } else
                    b.classList.contains("block") ? v.classList.contains("flying") || v.classList.add("flying") : b.classList.add("block");
                const C = R.spawnDelayMax - R.spawnDelayMin
                  , O = Math.floor(Math.random() * C) + R.spawnDelayMin;
                I = d.current + Math.floor(O * q)
            }
        }
        , 20)
          , B = () => {
            const M = window.innerWidth <= 800
              , R = g()
              , L = w(R)
              , H = 1 / (o.current * L.speedMultiplier)
              , j = M ? 2800 : 3600
              , A = Math.floor(j * .85 * H)
              , E = Math.floor(j * 1.15 * H)
              , O = `${(Math.floor(Math.random() * (E - A + 1)) + A) / 1e3}s`;
            b.style.animationDuration = O,
            b.classList.remove("block"),
            h.current = !1
        }
          , P = () => {
            const M = window.innerWidth <= 800
              , R = g()
              , L = w(R)
              , H = 1 / (o.current * L.speedMultiplier)
              , j = M ? 3200 : 4e3
              , A = Math.floor(j * .85 * H)
              , E = Math.floor(j * 1.15 * H)
              , O = `${(Math.floor(Math.random() * (E - A + 1)) + A) / 1e3}s`;
            v.style.animationDuration = O,
            v.classList.remove("flying"),
            p.current = !1
        }
        ;
        return b.addEventListener("animationend", B),
        v.addEventListener("animationend", P),
        () => {
            clearInterval(k),
            b.removeEventListener("animationend", B),
            v.removeEventListener("animationend", P)
        }
    }
    , [n, t, o]),
    V.useEffect( () => {
        if (!n)
            return;
        const b = l.current
          , v = u.current;
        if (!b || !v)
            return;
        let S = !1;
        const N = q => {
            S || t.current || (S = !0,
            console.error(" CHEAT DETECTED:", q),
            window.dispatchEvent(new CustomEvent("tamperDetected",{
                detail: {
                    reason: q
                }
            })),
            t.current = !0,
            s && (s(),
            setTimeout( () => s(), 100),
            setTimeout( () => s(), 200)))
        }
        ;
        let _ = 0;
        const I = 500
          , k = q => {
            const H = Date.now();
            if (H - _ < I)
                return;
            _ = H;
            const j = q.target
              , A = q.oldValue || ""
              , E = j.getAttribute(q.attributeName) || "";
            if (q.attributeName === "style") {
                if (E.includes("display:none") || E.includes("visibility:hidden")) {
                    const C = window.getComputedStyle(j);
                    (C.display === "none" || C.visibility === "hidden") && N("Style tampering detected on obstacle!")
                }
            } else if (q.attributeName === "class" && E.includes("hidden") && !A.includes("hidden")) {
                const C = window.getComputedStyle(j);
                (C.display === "none" || C.visibility === "hidden") && N("Class tampering detected on obstacle!")
            }
        }
          , B = new MutationObserver(q => {
            q.forEach(H => {
                H.type === "attributes" && (H.attributeName === "style" || H.attributeName === "class") && k(H)
            }
            )
        }
        );
        let P = 0;
        const M = 1e3
          , R = new MutationObserver(q => {
            const H = Date.now();
            if (H - P < M)
                return;
            let j = !1;
            q.forEach(A => {
                A.addedNodes.forEach(E => {
                    (E.nodeName === "STYLE" || E.nodeName === "LINK") && (j = !0)
                }
                )
            }
            ),
            j && (P = H,
            setTimeout( () => {
                if (t.current)
                    return;
                const A = window.getComputedStyle(b)
                  , E = window.getComputedStyle(v);
                (A.display === "none" || A.visibility === "hidden") && (E.display === "none" || E.visibility === "hidden") && N("Stylesheet injection detected!")
            }
            , 100))
        }
        );
        B.observe(b, {
            attributes: !0,
            attributeOldValue: !0,
            subtree: !1
        }),
        B.observe(v, {
            attributes: !0,
            attributeOldValue: !0,
            subtree: !1
        }),
        b.parentElement && B.observe(b.parentElement, {
            attributes: !0,
            subtree: !1
        }),
        v.parentElement && B.observe(v.parentElement, {
            attributes: !0,
            subtree: !1
        }),
        R.observe(document.head, {
            childList: !0,
            subtree: !0
        });
        const L = setInterval( () => {
            if (t.current)
                return;
            const q = window.getComputedStyle(b)
              , H = window.getComputedStyle(v)
              , j = q.display !== "none" && q.visibility !== "hidden" && parseFloat(q.width) > 0 && parseFloat(q.height) > 0
              , A = H.display !== "none" && H.visibility !== "hidden" && parseFloat(H.width) > 0 && parseFloat(H.height) > 0;
            !j && !A && N("Integrity check failed - obstacles modified!")
        }
        , 5e3);
        return () => {
            B.disconnect(),
            R.disconnect(),
            clearInterval(L)
        }
    }
    , [n, t, s]),
    V.useEffect( () => {
        if (!n)
            return;
        let b = {
            bug: null,
            fly: null,
            bugParent: null,
            flyParent: null,
            lastCheck: 0
        };
        const v = 500
          , N = setInterval( () => {
            if (!e.current || !l.current || !u.current || t.current)
                return;
            const _ = e.current
              , I = l.current
              , k = u.current
              , B = I.classList.contains("block")
              , P = k.classList.contains("flying")
              , M = Date.now();
            if (M - b.lastCheck > v) {
                b.bug = window.getComputedStyle(I),
                b.fly = window.getComputedStyle(k),
                b.bugParent = window.getComputedStyle(I.parentElement),
                b.flyParent = window.getComputedStyle(k.parentElement),
                b.lastCheck = M;
                const j = (A, E) => A.display === "none" || A.visibility === "hidden" || E.display === "none" || E.visibility === "hidden";
                if (j(b.bug, b.bugParent) && j(b.fly, b.flyParent)) {
                    console.error(" CHEAT DETECTED: Obstacles tampering detected!"),
                    t.current = !0,
                    s();
                    return
                }
            }
            if (!B && !P)
                return;
            let R = null
              , L = null;
            if (B && (R = I.getBoundingClientRect(),
            R.top < -5e3)) {
                console.error(" CHEAT DETECTED: Obstacles moved off-screen!"),
                t.current = !0,
                s();
                return
            }
            if (P && (L = k.getBoundingClientRect(),
            L.top < -5e3)) {
                console.error(" CHEAT DETECTED: Obstacles moved off-screen!"),
                t.current = !0,
                s();
                return
            }
            const q = _.getBoundingClientRect();
            B && !h.current && R && R.right < 0 && (h.current = !0,
            i && i("ground")),
            P && !p.current && L && L.right < 0 && (p.current = !0,
            i && i("flying"));
            const H = (j, A) => !(j.right < A.left || j.left > A.right || j.bottom < A.top || j.top > A.bottom);
            if (r.current) {
                if (P && L) {
                    const j = L.width * .15
                      , A = L.height * .15
                      , E = {
                        left: L.left + j,
                        right: L.right - j,
                        top: L.top + A,
                        bottom: L.bottom - A
                    };
                    H(q, E) && s()
                }
                if (B && R) {
                    const j = R.width * .1
                      , A = R.height * .1
                      , E = {
                        left: R.left + j,
                        right: R.right - j,
                        top: R.top + A,
                        bottom: R.bottom - A
                    };
                    H(q, E) && s()
                }
            }
        }
        , 50);
        return () => {
            clearInterval(N)
        }
    }
    , [n, e, t, r, s, i, o]),
    m.jsxs(m.Fragment, {
        children: [m.jsx("div", {
            className: "ground-enemy",
            children: m.jsx("div", {
                ref: l,
                className: "obstacle",
                id: "badnik1",
                style: {
                    backgroundImage: `url(${yDe})`
                }
            })
        }), m.jsx("div", {
            className: "flying-enemy",
            children: m.jsx("div", {
                ref: u,
                className: "obstacle",
                id: "badnik2",
                style: {
                    backgroundImage: `url(${bDe})`
                }
            })
        })]
    })
}
  , vDe = ye.memo(wDe)
  , xDe = "/assets/Object1-A7G7R-hT.png"
  , EDe = "/assets/Object2-32Ux_DG6.png"
  , SDe = "/assets/Object3-DzEsTlzC.gif"
  , ADe = "/assets/Object4-CGX23tfX.gif"
  , CDe = "/assets/Object5-xkDR8zy6.gif"
  , _De = "/assets/Object6-BOzfjq9x.png"
  , kDe = "/assets/Object7-Br5yAFXr.gif"
  , NDe = "/assets/Object8-CHzu33YS.gif"
  , nj = [xDe, EDe, SDe, ADe, CDe, _De, kDe, NDe]
  , DDe = ({gameStarted: n, isGameOverRef: e, gameTimeRef: t, speedMultiplierRef: r}) => {
    const s = V.useRef(null)
      , i = V.useRef(null)
      , o = V.useRef(null)
      , a = V.useRef(null)
      , l = V.useRef(null)
      , u = V.useRef(null)
      , d = V.useRef(null)
      , h = V.useRef(0)
      , p = V.useRef(0)
      , g = V.useRef(5500)
      , w = b => b[Math.floor(Math.random() * b.length)];
    return V.useEffect( () => {
        if (!n)
            return;
        const b = s.current
          , v = i.current
          , S = o.current
          , N = a.current
          , _ = l.current
          , I = u.current
          , k = d.current;
        if (!b || !v || !S || !N || !_ || !I || !k)
            return;
        const B = window.innerWidth <= 800 || window.innerHeight > window.innerWidth
          , P = document.querySelectorAll(".object")
          , M = B ? 5400 : 6600
          , R = B ? 5.4 : 3;
        g.current = M,
        P.forEach(E => {
            E.style.animationDuration = `${R}s`
        }
        );
        const L = setInterval( () => {
            if (e.current)
                return;
            const C = 1 / r.current
              , O = R * C;
            P.forEach(z => {
                z.style.animationDuration = `${O}s`
            }
            ),
            g.current = Math.floor(M * C)
        }
        , 1e3)
          , q = setInterval( () => {
            const E = w(nj);
            B ? (b.classList.add("hidden"),
            v.classList.add("hidden"),
            S.classList.add("hidden"),
            N.classList.add("hidden"),
            e.current ? _.classList.remove("move") : (h.current += 10,
            h.current === 2e3 && (h.current = 0,
            _.classList.add("move"),
            _.style.backgroundImage = `url(${E})`))) : e.current || (h.current += 10,
            h.current === 1800 && (b.classList.add("move"),
            b.style.backgroundImage = `url(${E})`),
            h.current === 2600 && (v.classList.add("move"),
            v.style.backgroundImage = `url(${E})`),
            h.current === 3e3 && (S.classList.add("move"),
            S.style.backgroundImage = `url(${E})`),
            h.current === 4e3 && (N.classList.add("move"),
            N.style.backgroundImage = `url(${E})`),
            h.current === 4400 && (h.current = 0,
            _.classList.add("move"),
            _.style.backgroundImage = `url(${E})`))
        }
        , 10)
          , H = setInterval( () => {
            const E = w(nj);
            B ? (I.classList.add("hidden"),
            e.current ? k.classList.remove("move") : (p.current += 10,
            p.current === 2e3 && (p.current = 0,
            k.classList.add("move"),
            k.style.backgroundImage = `url(${E})`))) : e.current || (p.current += 10,
            p.current === 3200 && (I.classList.add("move"),
            I.style.backgroundImage = `url(${E})`),
            p.current === 5e3 && (p.current = 0,
            k.classList.add("move"),
            k.style.backgroundImage = `url(${E})`))
        }
        , 10)
          , j = () => {
            setTimeout( () => {
                b.classList.remove("move"),
                v.classList.remove("move"),
                S.classList.remove("move"),
                N.classList.remove("move"),
                _.classList.remove("move")
            }
            , g.current)
        }
          , A = () => {
            setTimeout( () => {
                I.classList.remove("move"),
                k.classList.remove("move")
            }
            , g.current)
        }
        ;
        return _.addEventListener("animationend", j),
        k.addEventListener("animationend", A),
        () => {
            clearInterval(q),
            clearInterval(H),
            clearInterval(L),
            _.removeEventListener("animationend", j),
            k.removeEventListener("animationend", A)
        }
    }
    , [n, e, t, r]),
    m.jsxs("div", {
        className: "objects-bg",
        children: [m.jsx("div", {
            ref: u,
            className: "object",
            id: "bg-object1"
        }), m.jsx("div", {
            ref: d,
            className: "object",
            id: "bg-object2"
        }), m.jsx("div", {
            ref: s,
            className: "object",
            id: "object1"
        }), m.jsx("div", {
            ref: i,
            className: "object",
            id: "object2"
        }), m.jsx("div", {
            ref: o,
            className: "object",
            id: "object3"
        }), m.jsx("div", {
            ref: a,
            className: "object",
            id: "object4"
        }), m.jsx("div", {
            ref: l,
            className: "object",
            id: "object5"
        })]
    })
}
  , TDe = ye.memo(DDe)
  , IDe = "/assets/Extras%20Menu%20-%20Sonic%20Mega%20Collection%20_OST_-D1wnAIvQ.mp3"
  , MDe = "/assets/Green%20Hill%20(Modern)%20-%20Sonic%20Generations%20_OST_-DGKjMhyu.mp3"
  , BDe = "/assets/Sonic%20Advance%201%202%20and%203-Game%20Over-CGkx-ZuL.mp3"
  , RDe = "/assets/Sonic%20Heroes%20Select%20Sound-CpCENPqC.mp3"
  , ODe = "/assets/Sonic%20Mega%20Collection%20-%20Game%20Unlocked%20(Sound%20Effect)-BuS3ujea.mp3"
  , PDe = "/assets/Sonic%20CD%20Original%20Sound%20Track%20-%20Event-k9g8TAVA.mp3"
  , jDe = "/assets/Sonic%20Jump%20Sound%20Effect-Cba6rTeL.mp3"
  , LDe = "/assets/Modern%20Sonic%20jump%20sound%20effect-C_bFB9i5.mp3"
  , FDe = "/assets/Sonic%20Checkpoint%20SFX-BQcs99mY.mp3"
  , UDe = "/assets/Sonic%20the%20Hedgehog%20Cha%20Ching%20Sound%20Effect-ZZXQfZb8.mp3"
  , zDe = "/assets/Chaos%20emerald%20sound%20effect-CsQxi5YR.mp3"
  , $De = "/assets/Sonic%20Getting%20Hit%20(Sound%20Effect)-CZ1Yeprg.mp3"
  , HDe = "/assets/Sonic%20Feeling%20Good%20(Jason%20Griffith)%20sound%20effect%20(1080p%2060fps)-8S3wsQt7.mp3"
  , VDe = "/assets/Sega%20Intro-DzxzIJJT.mp3"
  , qDe = "/assets/Sega%20Saturn%20Sonic%20Team%20logo-BmWgiAeF.mp3"
  , hG = V.createContext()
  , r8 = () => {
    const n = V.useContext(hG);
    if (!n)
        throw new Error("useAudio must be used within AudioProvider");
    return n
}
  , GDe = ({children: n}) => {
    const [e,t] = V.useState(!1)
      , [r,s] = V.useState(!1)
      , i = V.useRef({
        menu: null,
        game: null,
        gameOver: null,
        select: null,
        return: null,
        selected: null,
        jump: null,
        doubleJump: null,
        startTrack: null,
        scoreHit: null,
        higherScoreHit: null,
        hitDamage: null,
        sonicR: null,
        sega: null,
        sonicTeam: null
    });
    V.useEffect( () => {
        i.current = {
            menu: new Audio(IDe),
            game: new Audio(MDe),
            gameOver: new Audio(BDe),
            select: new Audio(RDe),
            return: new Audio(ODe),
            selected: new Audio(PDe),
            jump: new Audio(jDe),
            doubleJump: new Audio(LDe),
            startTrack: new Audio(FDe),
            scoreHit: new Audio(UDe),
            higherScoreHit: new Audio(zDe),
            hitDamage: new Audio($De),
            sonicR: new Audio(HDe),
            sega: new Audio(VDe),
            sonicTeam: new Audio(qDe)
        },
        i.current.menu.volume = .7,
        i.current.game.volume = .5,
        i.current.gameOver.volume = .6,
        i.current.select.volume = .8,
        i.current.return.volume = 1,
        i.current.selected.volume = .6,
        i.current.jump.volume = 1,
        i.current.doubleJump.volume = 1,
        i.current.startTrack.volume = 1,
        i.current.scoreHit.volume = .8,
        i.current.higherScoreHit.volume = .8,
        i.current.hitDamage.volume = .5,
        i.current.sonicR.volume = 1,
        i.current.sega.volume = 1,
        i.current.sonicTeam.volume = 1,
        i.current.menu.loop = !0,
        i.current.game.loop = !0,
        i.current.gameOver.loop = !0;
        const p = localStorage.getItem("muted") === "true"
          , g = localStorage.getItem("mutedSound") === "true";
        return t(p),
        s(g),
        ["menu", "game", "gameOver"].forEach(w => {
            i.current[w] && (i.current[w].muted = p)
        }
        ),
        ["select", "return", "selected", "jump", "doubleJump", "startTrack", "scoreHit", "higherScoreHit", "hitDamage", "sonicR", "sega", "sonicTeam"].forEach(w => {
            i.current[w] && (i.current[w].muted = g)
        }
        ),
        p || i.current.menu.play().catch(w => console.log("Audio play prevented:", w)),
        () => {
            Object.values(i.current).forEach(w => {
                w && (w.pause(),
                w.currentTime = 0)
            }
            )
        }
    }
    , []);
    const h = {
        playSound: p => {
            if (r)
                return;
            const g = i.current[p];
            g && (g.currentTime = 0,
            g.play().catch(w => console.log("Sound play error:", w)))
        }
        ,
        playMusic: p => {
            if (e)
                return;
            const g = i.current[p];
            g && (g.currentTime = 0,
            g.play().catch(w => console.log("Music play error:", w)))
        }
        ,
        stopMusic: p => {
            const g = i.current[p];
            g && (g.pause(),
            g.currentTime = 0)
        }
        ,
        toggleMusicMute: () => {
            const p = !e;
            t(p),
            localStorage.setItem("muted", p.toString()),
            ["menu", "game", "gameOver"].forEach(g => {
                i.current[g] && (i.current[g].muted = p)
            }
            )
        }
        ,
        toggleSoundMute: () => {
            const p = !r;
            s(p),
            localStorage.setItem("mutedSound", p.toString()),
            ["select", "return", "selected", "jump", "doubleJump", "startTrack", "scoreHit", "higherScoreHit", "hitDamage", "sonicR", "sega", "sonicTeam"].forEach(g => {
                i.current[g] && (i.current[g].muted = p)
            }
            )
        }
        ,
        isMusicMuted: e,
        isSoundMuted: r
    };
    return m.jsx(hG.Provider, {
        value: h,
        children: n
    })
}
  , WDe = "/assets/score-Bhhmho0H.png"
  , pG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAPBAMAAAAfXVIcAAAAElBMVEUAAAAAAAD////Ozs6cnJxCQkIOAlPQAAAAAXRSTlMAQObYZgAAAC9JREFUCNdjYGAUBAIBMA1hCYoaKSkpBwoyCDopAYEKkKGkJAjE5DOAAJUBBXBLAQS2C201WTvTAAAAAElFTkSuQmCC"
  , mG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAAPAgMAAABGuH3ZAAAACVBMVEUAAAAAAAD///+D3c/SAAAAAXRSTlMAQObYZgAAACZJREFUCNdjYAgNZWBgDA11YGDMWgkjwoAEA5gQI0yIhgIJ1lAGAEiaDrqlQE58AAAAAElFTkSuQmCC"
  , gG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAPBAMAAAAfXVIcAAAAElBMVEUAAAAAAAD////Ozs6cnJxCQkIOAlPQAAAAAXRSTlMAQObYZgAAADlJREFUCNdjYBQEAQEGBiAJYQkqAYFyoCCEoaQiCJYCcpAZokZQKSeEYrh2sDJkBhggM6CAgRFqKQAEwQtZEh7OewAAAABJRU5ErkJggg=="
  , rj = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAPAgMAAACQHae8AAAADFBMVEUAAAAAAAD////Ozs532PMaAAAAAXRSTlMAQObYZgAAADRJREFUCNdjEA0NDWAIDQ0NYYhateoqiNgK5EYtBRFA1qpVU8EEiIuQWApSByVCgQBkSggAAG8bP/RY/P0AAAAASUVORK5CYII="
  , sj = "/assets/life-icon-BKB2nMxM.gif"
  , YDe = ({scoreRef: n, lifesRef: e, lifes: t, character: r, difficultyLevel: s}) => {
    const {toggleMusicMute: i, toggleSoundMute: o, isMusicMuted: a, isSoundMuted: l} = r8()
      , u = {
        0: pG,
        1: mG,
        2: gG,
        3: rj
    }
      , d = {
        Sonic: sj
    }
      , h = () => u[t] || rj
      , p = () => d[r] || sj
      , g = b => ({
        1: "Easy",
        2: "Normal",
        3: "Hard",
        4: "Very Hard",
        5: "Extreme"
    })[b] || "Normal"
      , w = b => ({
        1: "#4ade80",
        2: "#60a5fa",
        3: "#fbbf24",
        4: "#fb923c",
        5: "#ef4444"
    })[b] || "#60a5fa";
    return m.jsxs(m.Fragment, {
        children: [m.jsxs("div", {
            className: "layout",
            children: [m.jsx("div", {
                className: "column",
                children: m.jsxs("div", {
                    className: "score-container",
                    children: [m.jsx("img", {
                        loading: "lazy",
                        src: WDe,
                        alt: "Score"
                    }), m.jsx("span", {
                        className: "score",
                        id: "points",
                        ref: n,
                        children: "00"
                    })]
                })
            }), s && m.jsxs("div", {
                className: "difficulty-indicator",
                style: {
                    position: "absolute",
                    top: "12vh",
                    left: "2vw",
                    color: w(s),
                    fontSize: "2.5vh",
                    fontWeight: "bold",
                    textShadow: "2px 2px 4px rgba(0,0,0,0.8)",
                    zIndex: 10,
                    fontFamily: "Arial, sans-serif"
                },
                children: ["Level ", s, ": ", g(s)]
            })]
        }), m.jsx("div", {
            className: "alive",
            children: m.jsxs("div", {
                className: "row",
                children: [m.jsx("div", {
                    className: "rings",
                    children: m.jsx("img", {
                        loading: "lazy",
                        id: "life-icon",
                        src: p(),
                        alt: "Life icon"
                    })
                }), m.jsx("div", {
                    className: "rings",
                    id: "lifes",
                    ref: e,
                    style: {
                        backgroundImage: `url(${h()})`,
                        backgroundSize: "4vh 4vh",
                        height: "5.5vh",
                        width: "4vh",
                        backgroundRepeat: "no-repeat"
                    }
                })]
            })
        })]
    })
}
  , KDe = ye.memo(YDe)
  , XDe = "/assets/footer-bg-dark-DdzYwaVX.gif"
  , QDe = "/assets/gameover-Okz9BM_V.png"
  , ZDe = "/assets/play-again-DqEnMi16.png"
  , JDe = ({score: n, onRestart: e}) => {
    const [t,r] = V.useState(0)
      , [s,i] = V.useState(!1);
    V.useEffect( () => {
        const a = parseInt(localStorage.getItem("highScore") || "0");
        r(a),
        n > a && (localStorage.setItem("highScore", n.toString()),
        r(n),
        i(!0))
    }
    , [n]);
    const o = a => a >= 10 ? a : `0${a}`;
    return m.jsx("div", {
        className: "gameover",
        children: m.jsxs("div", {
            className: "restart",
            style: {
                background: `url(${XDe})`
            },
            children: [m.jsx("img", {
                src: dG,
                title: "Continue?",
                alt: "Continue?",
                style: {
                    width: "24vh"
                }
            }), m.jsx("img", {
                src: QDe,
                title: "Game Over!",
                alt: "Game Over",
                style: {
                    width: "45vh",
                    marginBottom: "2vh"
                }
            }), m.jsxs("a", {
                id: "earned-points",
                children: ["Score: ", o(n)]
            }), m.jsxs("a", {
                id: "highscore",
                children: ["HighScore: ", o(t)]
            }), s && m.jsx("a", {
                id: "newhighscore",
                className: "new-highscore",
                children: "NEW HIGHSCORE!"
            }), m.jsx("img", {
                src: ZDe,
                id: "restart",
                onClick: e,
                alt: "Play Again",
                style: {
                    width: "250px",
                    zIndex: 99,
                    cursor: "pointer",
                    marginTop: "2vh"
                }
            })]
        })
    })
}
  , eTe = ({onJump: n, onDoubleJump: e}) => {
    if (!(window.innerWidth <= 900 || "ontouchstart"in window))
        return null;
    const r = i => {
        i.preventDefault(),
        i.stopPropagation(),
        e()
    }
      , s = i => {
        i.preventDefault(),
        i.stopPropagation(),
        n()
    }
    ;
    return m.jsxs("div", {
        className: "mobile-controls",
        id: "mobileControls",
        children: [m.jsxs("button", {
            className: "mobile-doublejump-btn",
            id: "mobileDoubleJumpBtn",
            onTouchStart: r,
            onClick: r,
            "aria-label": "Double Jump",
            children: [m.jsx("i", {
                className: "fas fa-angle-double-up"
            }), m.jsx("span", {
                children: "DOUBLE"
            })]
        }), m.jsxs("button", {
            className: "mobile-jump-btn",
            id: "mobileJumpBtn",
            onTouchStart: s,
            onClick: s,
            "aria-label": "Jump",
            children: [m.jsx("i", {
                className: "fas fa-chevron-up"
            }), m.jsx("span", {
                children: "JUMP"
            })]
        })]
    })
}
;
class tTe {
    constructor(e, t) {
        this.onTamperDetected = e,
        this.isGameOverRef = t,
        this.tamperDetected = !1,
        this.observers = [],
        this.gameElementSelectors = [".player", "#sonic", ".obstacle", ".ground-enemy", ".flying-enemy", "#badnik1", "#badnik2", ".ground", "#ground", ".game", "#background", ".object", "#bg-object1", "#bg-object2", "#points", "#lifes"]
    }
    detectConsoleScriptExecution() {
        const e = document.querySelector
          , t = document.querySelectorAll
          , r = document.getElementById;
        let s = !1;
        const i = o => {
            if (!o || s)
                return;
            const a = o.style.display;
            o.style.visibility,
            setTimeout( () => {
                o.style.display !== a && o.style.display === "none" && (this.tamperDetected || (this.tamperDetected = !0,
                s = !0,
                this.onTamperDetected("Console script detected - Hiding game elements")))
            }
            , 50)
        }
        ;
        document.querySelector = function(o) {
            const a = e.call(document, o);
            return a && a.classList && (a.classList.contains("obstacle") || a.classList.contains("ground-enemy") || a.classList.contains("flying-enemy")) && i(a),
            a
        }
        ,
        document.querySelectorAll = function(o) {
            const a = t.call(document, o);
            return a.forEach(l => {
                l && l.classList && (l.classList.contains("obstacle") || l.classList.contains("ground-enemy") || l.classList.contains("flying-enemy")) && i(l)
            }
            ),
            a
        }
        ,
        document.getElementById = function(o) {
            const a = r.call(document, o);
            return a && (o === "badnik1" || o === "badnik2") && i(a),
            a
        }
        ,
        this.observers.push( () => {
            document.querySelector = e,
            document.querySelectorAll = t,
            document.getElementById = r
        }
        )
    }
    detectScriptExecution() {
        const e = window.eval;
        window.eval = (...t) => {
            const r = String(t[0]);
            if (this.gameElementSelectors.some(i => r.includes(i)) && !this.tamperDetected) {
                this.tamperDetected = !0,
                this.onTamperDetected("Script execution detected - Attempting to manipulate game elements");
                return
            }
            return e.apply(window, t)
        }
        ,
        this.observers.push( () => {
            window.eval = e
        }
        )
    }
    detectMaliciousManipulation() {
        if (window.innerWidth <= 800 || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent))
            return;
        const t = {
            attributes: !0,
            childList: !0,
            attributeOldValue: !0,
            subtree: !1
        }
          , r = o => {
            if (!o || !o.classList)
                return !1;
            const a = Array.from(o.classList)
              , l = o.id;
            return a.some(u => ["obstacle", "ground-enemy", "flying-enemy", "player", "ground", "game"].includes(u)) || ["badnik1", "badnik2", "sonic", "ground", "points", "lifes"].includes(l)
        }
          , s = o => {
            o.forEach(a => {
                if (!this.isGameOverRef.current) {
                    if (a.type === "attributes" && a.attributeName === "style") {
                        const l = a.target;
                        if (!r(l))
                            return;
                        const u = window.getComputedStyle(l)
                          , d = u.display === "none" || u.visibility === "hidden" || parseFloat(u.opacity) === 0 || parseFloat(u.width) === 0 || parseFloat(u.height) === 0
                          , h = l.getBoundingClientRect()
                          , p = h.top < -5e3 || h.left < -5e3;
                        (d || p) && !this.tamperDetected && (console.error(" MutationObserver detected tampering!", {
                            element: l.id,
                            isHidden: d,
                            isOffScreen: p,
                            display: u.display,
                            visibility: u.visibility
                        }),
                        this.tamperDetected = !0,
                        this.onTamperDetected("Enemy hidden or moved off-screen - Tampering detected"))
                    }
                    a.type === "childList" && a.removedNodes.length > 0 && a.removedNodes.forEach(l => {
                        r(l) && setTimeout( () => {
                            if (this.isGameOverRef.current)
                                return;
                            !document.body.contains(l) && !this.tamperDetected && (this.tamperDetected = !0,
                            this.onTamperDetected("Enemy element deleted - Tampering detected"))
                        }
                        , 100)
                    }
                    )
                }
            }
            )
        }
          , i = () => {
            const o = document.querySelectorAll(".obstacle, #badnik1, #badnik2, .player, #sonic, .ground, #ground, #points, #lifes");
            if (o.length === 0) {
                console.warn(" No critical elements found, retrying in 1s..."),
                setTimeout(i, 1e3);
                return
            }
            o.forEach(a => {
                const l = new MutationObserver(s);
                l.observe(a, t),
                this.observers.push( () => l.disconnect())
            }
            )
        }
        ;
        setTimeout(i, 500)
    }
    detectElementIntegrity() {
        if (window.innerWidth <= 800 || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent))
            return;
        const s = setInterval( () => {
            if (this.tamperDetected || this.isGameOverRef.current)
                return;
            const i = document.getElementById("badnik1")
              , o = document.getElementById("badnik2")
              , a = document.querySelector(".player") || document.getElementById("sonic")
              , l = document.querySelector(".ground") || document.getElementById("ground")
              , u = document.getElementById("points")
              , d = document.getElementById("lifes");
            if (!i || !o) {
                console.error(" Integrity check: Enemies missing!"),
                this.tamperDetected || (this.tamperDetected = !0,
                this.onTamperDetected("Enemy elements deleted from DOM - Tampering detected"));
                return
            }
            if (!a) {
                console.error(" Integrity check: Player (Sonic) missing!"),
                this.tamperDetected || (this.tamperDetected = !0,
                this.onTamperDetected("Player character deleted - Tampering detected"));
                return
            }
            if (!l) {
                console.error(" Integrity check: Ground missing!"),
                this.tamperDetected || (this.tamperDetected = !0,
                this.onTamperDetected("Ground element deleted - Tampering detected"));
                return
            }
            if (!u || !d) {
                console.error(" Integrity check: UI elements (score/lives) missing!"),
                this.tamperDetected || (this.tamperDetected = !0,
                this.onTamperDetected("UI elements deleted - Tampering detected"));
                return
            }
            if (!document.body.contains(i) || !document.body.contains(o)) {
                console.error(" Integrity check: Enemies removed from DOM tree!"),
                this.tamperDetected || (this.tamperDetected = !0,
                this.onTamperDetected("Enemy elements removed from DOM tree - Tampering detected"));
                return
            }
            if (!document.body.contains(a)) {
                console.error(" Integrity check: Player removed from DOM tree!"),
                this.tamperDetected || (this.tamperDetected = !0,
                this.onTamperDetected("Player character removed from DOM tree - Tampering detected"));
                return
            }
            if (!document.body.contains(l)) {
                console.error(" Integrity check: Ground removed from DOM tree!"),
                this.tamperDetected || (this.tamperDetected = !0,
                this.onTamperDetected("Ground element removed from DOM tree - Tampering detected"));
                return
            }
            const h = window.getComputedStyle(i)
              , p = window.getComputedStyle(o)
              , g = window.getComputedStyle(a)
              , w = window.getComputedStyle(l)
              , b = _ => _.display === "none" || _.visibility === "hidden" || parseFloat(_.opacity) === 0 || parseFloat(_.width) === 0 || parseFloat(_.height) === 0;
            if (b(h)) {
                console.error(" Integrity check: badnik1 is hidden!", {
                    display: h.display,
                    visibility: h.visibility,
                    opacity: h.opacity
                }),
                this.tamperDetected || (this.tamperDetected = !0,
                this.onTamperDetected("Enemy element hidden via Inspector - Tampering detected"));
                return
            }
            if (b(p)) {
                console.error(" Integrity check: badnik2 is hidden!", {
                    display: p.display,
                    visibility: p.visibility,
                    opacity: p.opacity
                }),
                this.tamperDetected || (this.tamperDetected = !0,
                this.onTamperDetected("Enemy element hidden via Inspector - Tampering detected"));
                return
            }
            if (b(g)) {
                console.error(" Integrity check: Player (Sonic) is hidden!", {
                    display: g.display,
                    visibility: g.visibility,
                    opacity: g.opacity
                }),
                this.tamperDetected || (this.tamperDetected = !0,
                this.onTamperDetected("Player character hidden via Inspector - Tampering detected"));
                return
            }
            if (b(w)) {
                console.error(" Integrity check: Ground is hidden!", {
                    display: w.display,
                    visibility: w.visibility,
                    opacity: w.opacity
                }),
                this.tamperDetected || (this.tamperDetected = !0,
                this.onTamperDetected("Ground element hidden via Inspector - Tampering detected"));
                return
            }
            const v = i.getBoundingClientRect()
              , S = o.getBoundingClientRect();
            if (v.top < -5e3 || v.left < -5e3 || S.top < -5e3 || S.left < -5e3) {
                this.tamperDetected || (this.tamperDetected = !0,
                this.onTamperDetected("Game elements moved off-screen - Tampering detected"));
                return
            }
            if (document.querySelector(".game")) {
                const _ = i.closest(".game")
                  , I = o.closest(".game");
                if (!_ || !I) {
                    this.tamperDetected || (this.tamperDetected = !0,
                    this.onTamperDetected("Game element structure modified - Tampering detected"));
                    return
                }
            }
        }
        , 300);
        this.observers.push( () => {
            clearInterval(s)
        }
        )
    }
    start() {
        this.detectConsoleScriptExecution(),
        this.detectScriptExecution(),
        this.detectMaliciousManipulation(),
        this.detectElementIntegrity()
    }
    stop() {
        this.observers.forEach(e => e()),
        this.observers = []
    }
}
const nTe = "/assets/play-xo8wu_lF.png"
  , rTe = "/assets/background-CK7Hn8uk.gif"
  , sTe = "/assets/ground-Busv5f7f.png"
  , iTe = ({isOpen: n, onClose: e}) => n ? m.jsxs("div", {
    className: "fixed inset-0 z-10000 flex items-center justify-center px-4 py-8",
    children: [m.jsx("div", {
        className: "absolute inset-0 bg-black/85 backdrop-blur-lg",
        onClick: e,
        "aria-hidden": "true"
    }), m.jsxs("div", {
        className: "relative z-10 w-full max-w-xl",
        children: [m.jsx("div", {
            className: "absolute inset-0 -m-1 rounded-[28px] bg-linear-to-r from-[#ff6b35] via-[#ff3d81] to-[#6a5bff] opacity-70 blur-2xl"
        }), m.jsxs("div", {
            className: "relative overflow-hidden rounded-[26px] border border-white/10 bg-linear-to-br from-[#0b101d] via-[#111b2f] to-[#080c14] shadow-[0_45px_120px_rgba(0,0,0,0.7)]",
            children: [m.jsx("div", {
                className: "pointer-events-none absolute -top-24 left-1/2 h-52 w-52 -translate-x-1/2 rounded-full bg-[#ff6b35]/25 blur-3xl"
            }), m.jsx("div", {
                className: "pointer-events-none absolute -bottom-28 -left-24 h-60 w-60 rounded-full bg-[#6a5bff]/20 blur-3xl"
            }), m.jsxs("div", {
                className: "relative flex flex-col items-center gap-10 px-10 pb-12 pt-16 text-center text-white",
                children: [m.jsx("div", {
                    className: "flex h-24 w-24 items-center justify-center rounded-full border border-[#ff6b35]/60 bg-[#ff6b35]/10 text-[#ffb692] shadow-[0_0_30px_rgba(255,107,53,0.4)]",
                    children: m.jsxs("svg", {
                        xmlns: "http://www.w3.org/2000/svg",
                        fill: "none",
                        viewBox: "0 0 24 24",
                        strokeWidth: 1.5,
                        stroke: "currentColor",
                        className: "h-12 w-12",
                        children: [m.jsx("path", {
                            strokeLinecap: "round",
                            strokeLinejoin: "round",
                            d: "M12 9v3.75m0 3.75h.007v.008H12v-.008Z"
                        }), m.jsx("path", {
                            strokeLinecap: "round",
                            strokeLinejoin: "round",
                            d: "M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"
                        })]
                    })
                }), m.jsx("p", {
                    className: "max-w-md text-lg font-semibold leading-relaxed tracking-wide text-[#f6f7ff]",
                    children: "Your account is not whitelisted. Please wait until the whitelist period is complete."
                }), m.jsxs("button", {
                    type: "button",
                    onClick: e,
                    className: "relative inline-flex w-full max-w-xs items-center cursor-pointer justify-center overflow-hidden rounded-xl bg-linear-to-r from-[#ff6b35] via-[#ff3d81] to-[#6a5bff] px-6 py-3 text-base font-semibold text-white shadow-[0_20px_45px_rgba(255,61,129,0.4)] transition hover:brightness-105",
                    children: [m.jsx("span", {
                        className: "absolute inset-0 -translate-y-full bg-white/30 opacity-0 transition-all duration-300 hover:translate-y-0 hover:opacity-100"
                    }), "Close"]
                })]
            })]
        })]
    })]
}) : null;
function oTe(n) {
    try {
        let e = window.localStorage.getItem(n);
        return e == null ? !1 : JSON.parse(e)
    } catch {
        return console.error("Error Occured while getting data"),
        !1
    }
}
let Hp = {
    Accept: "application/json",
    "Content-Type": "application/json;charset=UTF-8"
};
function yG() {
    return oTe("userInfo")?.authToken || null
}
function aTe(n) {
    const e = yG();
    return e && (Hp = {
        ...Hp,
        Authorization: "Bearer " + e
    }),
    fetch(`${n}`, {
        method: "GET",
        mode: "cors",
        cache: "no-cache",
        credentials: "same-origin",
        headers: Hp
    }).then(t => t.json()).then(async t => t).catch(t => t)
}
function bG(n, e, t) {
    const r = yG();
    return r && (Hp = {
        ...Hp,
        Authorization: "Bearer " + r,
        "x-recaptcha-token": t
    }),
    fetch(`${n}`, {
        method: "POST",
        headers: Hp,
        body: JSON.stringify(e)
    }).then(s => s.json()).then(s => s).catch(s => s)
}
const Dk = Pc.BASE_URL.play;
async function wG(n, e) {
    return await bG(`${Dk}/api/v1/game/skillbased/l1x_startSkillBasedGame`, n, e)
}
async function vG(n, e) {
    return await bG(`${Dk}/api/v1/game/skillbased/l1x_cashOutSkillBasedGame`, n, e)
}
async function lTe(n, e, t) {
    return await aTe(`${Dk}/api/v1/game/l1x_getGameHistory?page=${n}&limit=${e}&gameId=${t}`)
}
const ps = [];
for (let n = 0; n < 256; ++n)
    ps.push((n + 256).toString(16).slice(1));
function cTe(n, e=0) {
    return (ps[n[e + 0]] + ps[n[e + 1]] + ps[n[e + 2]] + ps[n[e + 3]] + "-" + ps[n[e + 4]] + ps[n[e + 5]] + "-" + ps[n[e + 6]] + ps[n[e + 7]] + "-" + ps[n[e + 8]] + ps[n[e + 9]] + "-" + ps[n[e + 10]] + ps[n[e + 11]] + ps[n[e + 12]] + ps[n[e + 13]] + ps[n[e + 14]] + ps[n[e + 15]]).toLowerCase()
}
let zA;
const uTe = new Uint8Array(16);
function dTe() {
    if (!zA) {
        if (typeof crypto > "u" || !crypto.getRandomValues)
            throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
        zA = crypto.getRandomValues.bind(crypto)
    }
    return zA(uTe)
}
const fTe = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto)
  , ij = {
    randomUUID: fTe
};
function hTe(n, e, t) {
    n = n || {};
    const r = n.random ?? n.rng?.() ?? dTe();
    if (r.length < 16)
        throw new Error("Random bytes length must be >= 16");
    return r[6] = r[6] & 15 | 64,
    r[8] = r[8] & 63 | 128,
    cTe(r)
}
function uy(n, e, t) {
    return ij.randomUUID && !n ? ij.randomUUID() : hTe(n)
}
function Xo(n, e=4) {
    const t = Number(n);
    return !isNaN(t) && parseFloat(t) === t && t % 1 !== 0 ? parseFloat(t)?.toFixed(e) : t
}
const pTe = ({isOpen: n, onClose: e, handleConfirm: t, balance: r, gameFees: s, walletInfo: i}) => {
    if (!n)
        return null;
    const o = kr();
    return m.jsx("div", {
        className: "fixed inset-0 flex lg:items-center items-start lg:py-0 py-5 justify-center z-50 backdrop-blur-lg bg-black/70 overflow-auto",
        children: m.jsx("div", {
            className: "bg-[#27364b] max-w-lg w-full rounded-3xl relative mx-4 z-50 text-white overflow-hidden",
            children: m.jsxs("div", {
                className: "bg-[#2B3A4F] p-8 relative",
                children: [m.jsx("div", {
                    className: "cursor-pointer w-12 h-12 absolute right-1 top-1 flex items-center justify-center flex-col opacity-55",
                    onClick: e,
                    children: m.jsx("svg", {
                        xmlns: "http://www.w3.org/2000/svg",
                        fill: "none",
                        viewBox: "0 0 24 24",
                        strokeWidth: 1.5,
                        stroke: "currentColor",
                        className: "size-6",
                        children: m.jsx("path", {
                            strokeLinecap: "round",
                            strokeLinejoin: "round",
                            d: "M6 18 18 6M6 6l12 12"
                        })
                    })
                }), m.jsxs("div", {
                    className: "rounded-2xl mt-5",
                    children: [m.jsxs("div", {
                        children: [" ", m.jsx("img", {
                            src: Nk,
                            className: "max-w-[180px] mx-auto"
                        })]
                    }), m.jsx("h2", {
                        className: "text-2xl font-medium text-center mb-8",
                        children: "Play Entry Confirmation"
                    })]
                }), m.jsxs("div", {
                    className: "py-4 rounded-2xl bg-[#192330]",
                    children: [m.jsxs("div", {
                        className: "flex items-center justify-between py-3 px-4 border-b border-[#2b3a4d]",
                        children: [m.jsx("span", {
                            className: "block text-sm font-light text-[#95a5bb]",
                            children: "Entry Fee:"
                        }), " ", m.jsxs("h4", {
                            className: "font-bold text-xl flex items-center gap-2",
                            children: [m.jsx("img", {
                                src: ri,
                                className: "w-5"
                            }), s, " L1XP"]
                        })]
                    }), m.jsxs("div", {
                        className: "flex items-center justify-between py-3 px-4",
                        children: [m.jsx("span", {
                            className: "block text-sm font-light text-[#95a5bb]",
                            children: "Your Balance:"
                        }), " ", m.jsxs("h4", {
                            className: "font-bold text-xl flex items-center gap-2",
                            children: [m.jsx("img", {
                                src: ri,
                                className: "w-5"
                            }), " ", Xo(r?.l1xsBalance, 2), " L1XP"]
                        })]
                    })]
                }), m.jsxs("div", {
                    className: "text-center my-8",
                    children: [m.jsx("h4", {
                        className: "text-xl font-medium",
                        children: "Ready to join"
                    }), m.jsx("p", {
                        className: "text-sm text-[#95a5bb] font-light",
                        children: "Confirm your payment to start playing!"
                    })]
                }), m.jsxs("div", {
                    className: "mt-8 flex items-center gap-3",
                    children: [r?.l1xsBalance > s ? m.jsx("button", {
                        onClick: t,
                        className: "cursor-pointer w-full gap-3 py-4 px-5 rounded-xl text-base font-semibold hover:brightness-90 hover:scale-[1.02] transition-all duration-200 brand-gradient-bg",
                        children: "Confirm & Play"
                    }) : m.jsx("button", {
                        onClick: () => o("/deposit", {
                            state: {
                                activeTab: "deposit"
                            }
                        }),
                        className: "cursor-pointer w-full gap-3 py-4 px-5 rounded-xl text-base font-semibold hover:brightness-90 hover:scale-[1.02] transition-all duration-200 brand-gradient-bg",
                        children: "Purchase L1XP"
                    }), m.jsx("button", {
                        className: "cursor-pointer w-full gap-3 py-4 px-5 rounded-xl text-base font-semibold hover:brightness-90 hover:scale-[1.02] transition-all duration-200 bg-[#46576f]",
                        onClick: e,
                        children: "Cancel"
                    })]
                })]
            })
        })
    })
}
  , mTe = () => {
    const {walletAddress: n, backendConfig: e, balance: t, emailAddress: r, connectWallet: s, refreshBalance: i} = Hs()
      , [o,a] = V.useState(!1)
      , [l,u] = V.useState(!1)
      , [d,h] = V.useState(0)
      , [p,g] = V.useState(3)
      , [w] = V.useState("Sonic")
      , [b,v] = V.useState(!1)
      , [S,N] = V.useState("")
      , [_,I] = V.useState(1)
      , k = V.useRef(null)
      , B = V.useRef(null)
      , P = V.useRef(null)
      , M = V.useRef(null)
      , R = V.useRef(null)
      , L = V.useRef(!1)
      , q = V.useRef(!0)
      , H = V.useRef(!1)
      , j = V.useRef(!1)
      , A = V.useRef(100)
      , E = V.useRef(200)
      , C = V.useRef(0)
      , O = V.useRef(0)
      , z = V.useRef(0)
      , G = V.useRef(0)
      , Y = V.useRef(0)
      , $ = V.useRef(1)
      , D = V.useRef([])
      , U = V.useRef(0)
      , W = V.useRef(0)
      , Q = V.useRef(0)
      , J = V.useRef("")
      , ne = V.useRef(0)
      , ie = V.useRef(0)
      , ae = V.useRef(null)
      , [xe,ue] = V.useState(!1)
      , [ce,me] = V.useState(!1)
      , [Ee,Oe] = V.useState(!1)
      , [mt,st] = V.useState(t)
      , ot = V.useRef(null)
      , Ct = V.useRef(null)
      , {playSound: ct, playMusic: Xe, stopMusic: Et} = r8()
      , St = B0()
      , ut = Uo()
      , {gameId: cn} = E0();
    V.useEffect( () => {
        i()
    }
    , []);
    const _t = $e => {
        let Ue = 5381;
        for (let qe = 0; qe < $e.length; qe++)
            Ue = (Ue << 5) + Ue + $e.charCodeAt(qe),
            Ue = Ue & Ue;
        return Math.abs(Ue).toString(16).padStart(8, "0").substring(0, 8)
    }
      , ee = async $e => {
        try {
            if (typeof window < "u" && window.crypto?.subtle) {
                const Ue = new TextEncoder().encode($e)
                  , qe = await window.crypto.subtle.digest("SHA-256", Ue);
                return Array.from(new Uint8Array(qe)).map(At => At.toString(16).padStart(2, "0")).join("")
            } else {
                const {createHash: Ue} = await g_(async () => {
                    const {createHash: qe} = await import("./__vite-browser-external-l0sNRNKZ.js");
                    return {
                        createHash: qe
                    }
                }
                , []);
                return Ue("sha256").update($e).digest("hex")
            }
        } catch (Ue) {
            return console.error(" Error generating hash:", Ue),
            `error_${Date.now()}`
        }
    }
    ;
    V.useEffect( () => {
        !o && k.current && (k.current.style.backgroundImage = "var(--Idle)")
    }
    , [o]);
    const K = V.useCallback(async () => {
        Oe(!0);
        const $e = uy()
          , Ue = await ut.executeV3("action")
          , qe = await wG({
            gameId: cn,
            clientSeed: $e
        }, Ue);
        if (qe?.status !== "success")
            return mf(qe?.message),
            Ze.error(qe?.message);
        if (ot.current = $e,
        Ct.current = qe?.data?.sessionId,
        console.log(" ~ Game ~ response:", qe),
        Oe(!1),
        ue(!1),
        o)
            return;
        a(!0),
        Et("menu"),
        Xe("game"),
        ct("startTrack"),
        D.current = [],
        Y.current = 0,
        G.current = 0,
        W.current = 0,
        Q.current = 0,
        ne.current = 0,
        ie.current = Date.now();
        const At = Date.now()
          , De = `${At}_0_0_0`
          , Me = _t(De)
          , Je = {
            score: 0,
            timestamp: At,
            elapsedTime: 0,
            gameState: "active",
            lives: p,
            enemiesPassed: 0,
            gameSpeed: 1,
            tampered: !1,
            validated: !1,
            tamperReason: "NA",
            checksum: Me
        };
        if (D.current.push(Je),
        J.current = Me,
        U.current = 1500,
        k.current) {
            j.current = !0,
            k.current.classList.add("run");
            const Pe = et => {
                et.animationName === "run" && k.current && (k.current.classList.remove("run"),
                k.current.style.backgroundImage = "var(--Run)",
                j.current = !1,
                k.current.removeEventListener("animationend", Pe))
            }
            ;
            k.current.addEventListener("animationend", Pe)
        }
    }
    , [o, Xe, ct, Et])
      , X = V.useCallback( () => {
        H.current || !o || k.current && (L.current || j.current || (L.current = !0,
        k.current.classList.add("jump"),
        ct("jump"),
        setTimeout( () => {
            k.current && (k.current.classList.remove("jump"),
            k.current.style.backgroundImage = "var(--Run)",
            L.current = !1)
        }
        , 500)))
    }
    , [o, ct])
      , re = V.useCallback(async () => {
        if (H.current)
            return;
        H.current = !0,
        u(!0);
        const $e = G.current;
        h($e),
        Et("game"),
        Xe("gameOver"),
        console.log(" Final Score Validation: DISABLED (only element detection active)"),
        console.log(" Final Score:", $e),
        console.log(" GAME OVER - Score Snapshots:"),
        console.table(D.current);
        const Ue = D.current.some(wt => wt.tampered === !0)
          , qe = Date.now()
          , At = Y.current
          , De = `${qe}_${$e}_${W.current}_${At}`
          , Me = await ee(De)
          , Je = {
            score: $e,
            timestamp: qe,
            elapsedTime: At,
            gameState: "gameOver",
            lives: 0,
            enemiesPassed: W.current,
            gameSpeed: Math.max(.6, 1 - Y.current / 1e5),
            tampered: Ue,
            validated: !Ue,
            tamperReason: Ue ? "Multiple tampering events detected" : "NA",
            checksum: Me
        };
        D.current.push(Je);
        const Pe = await ee(JSON.stringify(D.current))
          , et = await ee(Pe + Ct.current + ot.current)
          , Nt = await ut.executeV3("action")
          , pt = await vG({
            gameId: cn,
            sessionId: Ct.current,
            clientSeed: ot.current,
            snapshotArray: D.current,
            checksum: et
        }, Nt);
        console.log(" ~ Game ~ response:", pt),
        pt?.status !== "success" && (mf(pt?.message),
        Ze.error(pt?.message)),
        k.current && (k.current.classList.add("death"),
        k.current.animate([{
            backgroundImage: "var(--Death)",
            bottom: "14.085vh"
        }, {
            bottom: "36.285vh"
        }, {
            bottom: "9.085vh"
        }, {
            backgroundImage: "var(--Death)",
            bottom: "-5.615vh"
        }], {
            duration: 1300,
            iterations: 1
        }),
        setTimeout( () => {
            k.current && (k.current.style.opacity = 0)
        }
        , 1300))
    }
    , [Xe, Et])
      , se = V.useCallback( () => !0, [])
      , fe = V.useCallback( () => {
        if (!(H.current || !o) && k.current) {
            if (!L.current) {
                X();
                return
            }
            q.current = !1,
            ct("doubleJump"),
            k.current.animate([{
                backgroundImage: "var(--DoubleJump)",
                bottom: "39.285vh"
            }, {
                bottom: "53.285vh"
            }, {
                bottom: "66.285vh"
            }, {
                bottom: "66.285vh"
            }, {
                bottom: "53.285vh"
            }, {
                backgroundImage: "var(--DoubleJump)",
                bottom: "36.285vh"
            }, {
                bottom: "14.085vh"
            }], {
                duration: 800,
                iterations: 1
            }),
            setTimeout( () => {
                k.current && (k.current.style.backgroundImage = "var(--Run)"),
                q.current = !0
            }
            , 750)
        }
    }
    , [o, ct, X])
      , ge = V.useCallback( () => {
        !q.current || H.current || !k.current || !M.current || (q.current = !1,
        ct("hitDamage"),
        k.current.animate([{
            backgroundImage: "var(--Damage)",
            opacity: 1
        }, {
            opacity: 0
        }, {
            opacity: 1
        }, {
            backgroundImage: "var(--Damage)",
            opacity: 0
        }, {
            backgroundImage: "var(--Run)",
            opacity: 1
        }], {
            duration: 500,
            iterations: 1
        }),
        setTimeout( () => {
            const $e = p - 1;
            g($e),
            $e === 2 ? M.current.style.backgroundImage = `url(${gG})` : $e === 1 ? M.current.style.backgroundImage = `url(${mG})` : $e === 0 ? (M.current.style.backgroundImage = `url(${pG})`,
            re()) : k.current && (k.current.style.backgroundImage = "var(--Run)"),
            q.current = !0
        }
        , 500))
    }
    , [p, ct, re])
      , _e = V.useCallback($e => {
        W.current++
    }
    , []);
    V.useEffect( () => {
        const $e = new Set
          , Ue = At => {
            if (!$e.has(At.key)) {
                if ($e.add(At.key),
                !o) {
                    $t();
                    return
                }
                (At.key === " " || At.key === "ArrowUp" || At.key === "w" || At.key === "W") && (At.preventDefault(),
                L.current ? fe() : X())
            }
        }
          , qe = At => {
            $e.delete(At.key)
        }
        ;
        return window.addEventListener("keydown", Ue),
        window.addEventListener("keyup", qe),
        () => {
            window.removeEventListener("keydown", Ue),
            window.removeEventListener("keyup", qe)
        }
    }
    , [o, K, X, fe]),
    V.useEffect( () => {
        const $e = Ue => {
            const qe = Ue.detail.reason;
            N(qe);
            const At = Y.current
              , Me = (2 - Math.max(.6, 1 - Y.current / 1e5)).toFixed(2)
              , Je = Date.now()
              , Pe = G.current
              , et = W.current
              , Nt = `${Je}_${Pe}_${et}_${At}`
              , pt = _t(Nt)
              , wt = {
                score: Pe,
                timestamp: Je,
                elapsedTime: At,
                gameState: "active",
                lives: p,
                enemiesPassed: et,
                gameSpeed: parseFloat(Me),
                tampered: !0,
                validated: !1,
                tamperReason: qe,
                checksum: pt
            };
            mf("Tamper data " + Ct.current, {
                extra: wt
            }),
            D.current.push(wt)
        }
        ;
        return window.addEventListener("tamperDetected", $e),
        () => window.removeEventListener("tamperDetected", $e)
    }
    , [p]),
    V.useEffect( () => {
        if (!o)
            return;
        const $e = Ue => {
            console.error(" ANTI-TAMPER:", Ue),
            N(Ue);
            const qe = Y.current
              , De = (2 - Math.max(.6, 1 - Y.current / 1e5)).toFixed(2)
              , Me = Date.now()
              , Je = G.current
              , Pe = W.current
              , et = `${Me}_${Je}_${Pe}_${qe}`
              , Nt = _t(et)
              , pt = {
                score: Je,
                timestamp: Me,
                elapsedTime: qe,
                gameState: "active",
                lives: p,
                enemiesPassed: Pe,
                gameSpeed: parseFloat(De),
                tampered: !0,
                validated: !1,
                tamperReason: Ue,
                checksum: Nt
            };
            mf("Tamper data " + Ct.current, {
                extra: pt
            }),
            D.current.push(pt),
            console.error(" TAMPERING EVENT CAPTURED IN SNAPSHOTS:", pt),
            re()
        }
        ;
        return ae.current = new tTe($e,H),
        ae.current.start(),
        () => {
            ae.current && ae.current.stop()
        }
    }
    , [o, re, p]),
    V.useEffect( () => {
        if (!o || !B.current || !P.current)
            return;
        const $e = B.current
          , Ue = P.current
          , qe = window.innerWidth <= 800 || window.innerHeight > window.innerWidth
          , At = qe ? 200 : 400
          , De = qe ? 400 : 600
          , Me = () => Math.min(At + Math.floor(Y.current / 5e3) * 50, At * 1.8)
          , Je = () => Math.min(De + Math.floor(Y.current / 5e3) * 75, De * 1.8);
        function Pe(et) {
            z.current || (z.current = et);
            const Nt = et - z.current;
            z.current = et,
            Y.current += Nt;
            const pt = Math.max(.6, 1 - Y.current / 1e5);
            $.current = 1 / pt;
            const wt = Me()
              , Rn = Je();
            A.current >= wt && E.current >= Rn ? (A.current = wt,
            E.current = Rn) : (A.current += .5,
            E.current += .5);
            const Zt = A.current * $.current
              , Jt = E.current * $.current;
            C.current -= Zt * Nt / 1e3,
            O.current -= Jt * Nt / 1e3,
            $e.style.backgroundPositionX = C.current + "px",
            Ue.style.backgroundPositionX = O.current + "px",
            H.current || requestAnimationFrame(Pe)
        }
        requestAnimationFrame(Pe)
    }
    , [o]),
    V.useEffect( () => {
        if (!o || !R.current)
            return;
        const $e = R.current
          , Ue = setInterval( () => {
            if (H.current)
                return;
            G.current++,
            ne.current++;
            const qe = G.current >= 10 ? G.current : `0${G.current}`;
            $e.textContent = qe,
            G.current % 10 === 0 && h(G.current);
            const At = Math.min(5, Math.floor(G.current / 1e3) + 1);
            At !== _ && (I(At),
            ct("higherScoreHit")),
            G.current % 100 === 0 && G.current > 0 && ct("scoreHit"),
            G.current % 500 === 0 && G.current > 0 && ct("higherScoreHit");
            const De = Y.current;
            if (De >= U.current) {
                const Je = (2 - Math.max(.6, 1 - Y.current / 1e5)).toFixed(2)
                  , Pe = Date.now()
                  , et = Y.current
                  , Nt = G.current
                  , pt = W.current
                  , wt = `${Pe}_${Nt}_${pt}_${et}`
                  , Rn = _t(wt)
                  , Zt = {
                    score: Nt,
                    timestamp: Pe,
                    elapsedTime: et,
                    gameState: "active",
                    lives: p,
                    enemiesPassed: pt,
                    gameSpeed: parseFloat(Je),
                    tampered: !1,
                    validated: !1,
                    tamperReason: "NA",
                    checksum: Rn
                };
                D.current.push(Zt),
                U.current = De + 1500
            }
        }
        , 100);
        return () => clearInterval(Ue)
    }
    , [o, ct, p, se, _]);
    const Qe = () => {
        window.location.reload()
    }
    ;
    V.useEffect( () => (o && !l && (window.getGameData = () => ({
        currentScore: G.current,
        currentChecksum: J.current,
        scoreIncrements: ne.current,
        enemiesPassed: W.current,
        allSnapshots: D.current,
        gameTime: Y.current
    }),
    window.getCurrentChecksum = () => J.current,
    window.getAllSnapshots = () => {
        const $e = D.current;
        return console.log(" All Snapshots:", $e),
        $e.forEach( (Ue, qe) => {
            const At = (Ue.elapsedTime / 1e3).toFixed(1);
            Ue.tampered ? console.log(` [${qe + 1}] TAMPERING @ ${At}s (${Ue.gameState}): ${Ue.tamperReason}`) : console.log(` [${qe + 1}] ${At}s (${Ue.gameState}): Score ${Ue.score}, Speed ${Ue.gameSpeed}x, Tamper: ${Ue.tamperReason}`)
        }
        ),
        $e
    }
    ,
    window.verifyChecksum = async ($e, Ue=null) => {
        if (!$e)
            return console.error(" Please provide a snapshot object"),
            !1;
        if ($e.timestamp === void 0 || $e.score === void 0 || $e.enemiesPassed === void 0 || $e.elapsedTime === void 0)
            return console.error(" Snapshot missing required fields:", {
                timestamp: $e.timestamp,
                score: $e.score,
                enemiesPassed: $e.enemiesPassed,
                elapsedTime: $e.elapsedTime
            }),
            !1;
        const qe = `${$e.timestamp}_${$e.score}_${$e.enemiesPassed}_${$e.elapsedTime}`
          , At = await ee(qe)
          , De = $e.checksum === At;
        return console.log(" SHA256 Checksum Verification:"),
        console.log("  Timestamp:", $e.timestamp),
        console.log("  Score:", $e.score),
        console.log("  Enemies Passed:", $e.enemiesPassed),
        console.log("  Elapsed Time:", $e.elapsedTime),
        console.log("  Data String:", qe.substring(0, 50) + "..."),
        console.log("  Stored Checksum:", $e.checksum),
        console.log("  Calculated Checksum:", At),
        console.log("  Result:", De ? " VERIFIED" : " TAMPERED"),
        De
    }
    ,
    window.verifyAllChecksums = async ($e=null) => {
        const Ue = D.current;
        if (Ue.length === 0)
            return console.log("  No snapshots to verify"),
            !1;
        let qe = 0
          , At = 0;
        console.log(` Verifying All Checksums (SHA256)...
`);
        for (let De = 0; De < Ue.length; De++) {
            const Me = Ue[De];
            if (Me.timestamp === void 0 || Me.score === void 0 || Me.enemiesPassed === void 0 || Me.elapsedTime === void 0) {
                At++,
                console.log(` [${De + 1}] MISSING FIELDS - Score: ${Me.score}`);
                continue
            }
            const Je = `${Me.timestamp}_${Me.score}_${Me.enemiesPassed}_${Me.elapsedTime}`
              , Pe = await ee(Je);
            Me.checksum === Pe ? (qe++,
            console.log(` [${De + 1}] Valid - Score: ${Me.score}, Checksum: ${Me.checksum.substring(0, 16)}...`)) : (At++,
            console.log(` [${De + 1}] INVALID - Score: ${Me.score}`),
            console.log(`    Expected: ${Pe}`),
            console.log(`    Got:      ${Me.checksum}`),
            console.log(`    Data:     ${Je.substring(0, 60)}...`))
        }
        return console.log(`
 Summary:`),
        console.log(`  Total Snapshots: ${Ue.length}`),
        console.log(`  Valid: ${qe} `),
        console.log(`  Invalid: ${At} `),
        console.log(`  Result: ${At === 0 ? " ALL VERIFIED" : " TAMPERING DETECTED"}`),
        At === 0
    }
    ,
    console.log(" Helper functions available:"),
    console.log("   getGameData() - Get all game data"),
    console.log("   getCurrentChecksum() - Get current checksum"),
    console.log("   getAllSnapshots() - Get all snapshots (with tamper events)"),
    console.log("   await verifyChecksum(snapshot, serverSeed?) - Verify single snapshot (SHA256)"),
    console.log("   await verifyAllChecksums(serverSeed?) - Verify all snapshots (SHA256)")),
    () => {
        delete window.getGameData,
        delete window.getCurrentChecksum,
        delete window.getAllSnapshots
    }
    ), [o, l]);
    const {toggleMusicMute: Ve, toggleSoundMute: jt, isMusicMuted: dt, isSoundMuted: Qt} = r8();
    t?.isWhitelisted ?? St?.isWhitelisted;
    const Nn = dt && Qt
      , ln = () => {
        Nn ? (Ve(),
        jt()) : (dt || Ve(),
        Qt || jt())
    }
      , $t = async () => {
        St?.walletAddress || r ? ue(!0) : Ze.error("Access not found.")
    }
    ;
    return m.jsxs("div", {
        className: "area content fade-in visible",
        children: [m.jsx("div", {
            className: "sound-controls",
            children: m.jsx("button", {
                className: `sound-btn ${Nn ? "muted" : ""}`,
                onClick: ln,
                title: Nn ? "Unmute All Audio" : "Mute All Audio",
                "aria-label": Nn ? "Unmute All Audio" : "Mute All Audio",
                children: Nn ? m.jsx("svg", {
                    xmlns: "http://www.w3.org/2000/svg",
                    fill: "none",
                    viewBox: "0 0 24 24",
                    strokeWidth: 1.5,
                    stroke: "currentColor",
                    className: "size-6",
                    children: m.jsx("path", {
                        strokeLinecap: "round",
                        strokeLinejoin: "round",
                        d: "M17.25 9.75 19.5 12m0 0 2.25 2.25M19.5 12l2.25-2.25M19.5 12l-2.25 2.25m-10.5-6 4.72-4.72a.75.75 0 0 1 1.28.53v15.88a.75.75 0 0 1-1.28.53l-4.72-4.72H4.51c-.88 0-1.704-.507-1.938-1.354A9.009 9.009 0 0 1 2.25 12c0-.83.112-1.633.322-2.396C2.806 8.756 3.63 8.25 4.51 8.25H6.75Z"
                    })
                }) : m.jsx("svg", {
                    xmlns: "http://www.w3.org/2000/svg",
                    fill: "none",
                    viewBox: "0 0 24 24",
                    strokeWidth: 1.5,
                    stroke: "currentColor",
                    className: "size-6",
                    children: m.jsx("path", {
                        strokeLinecap: "round",
                        strokeLinejoin: "round",
                        d: "M19.114 5.636a9 9 0 0 1 0 12.728M16.463 8.288a5.25 5.25 0 0 1 0 7.424M6.75 8.25l4.72-4.72a.75.75 0 0 1 1.28.53v15.88a.75.75 0 0 1-1.28.53l-4.72-4.72H4.51c-.88 0-1.704-.507-1.938-1.354A9.009 9.009 0 0 1 2.25 12c0-.83.112-1.633.322-2.396C2.806 8.756 3.63 8.25 4.51 8.25H6.75Z"
                    })
                })
            })
        }), !o && m.jsxs(m.Fragment, {
            children: [m.jsx("p", {
                id: "play-txt",
                className: "play-text",
                children: window.innerWidth <= 900 ? "Tap anywhere to start!" : "Press any key or click to start!"
            }), m.jsx("div", {
                className: "start",
                children: m.jsx("img", {
                    src: nTe,
                    id: "play",
                    onClick: $t,
                    alt: "Play",
                    style: {
                        width: "150px",
                        zIndex: 99,
                        cursor: "pointer"
                    }
                })
            })]
        }), m.jsxs("div", {
            className: `game ${o ? "started" : ""}`,
            id: "background",
            ref: B,
            style: {
                backgroundImage: `url(${rTe})`
            },
            onClick: o ? X : K,
            children: [m.jsx(KDe, {
                scoreRef: R,
                lifesRef: M,
                lifes: p,
                character: w,
                difficultyLevel: _
            }), m.jsx(gDe, {
                ref: k,
                character: w
            }), m.jsx(TDe, {
                gameStarted: o,
                isGameOverRef: H,
                gameTimeRef: Y,
                speedMultiplierRef: $
            }), m.jsx(vDe, {
                gameStarted: o,
                playerRef: k,
                isGameOverRef: H,
                canLoseLifeRef: q,
                onCollision: ge,
                gameTimeRef: Y,
                speedMultiplierRef: $,
                scoreRef: G,
                onEnemyPassed: _e
            }), m.jsx("div", {
                className: "ground",
                id: "ground",
                ref: P,
                style: {
                    backgroundImage: `url(${sTe})`
                }
            }), o && m.jsx(eTe, {
                onJump: X,
                onDoubleJump: fe
            })]
        }), l && m.jsx(JDe, {
            score: d,
            onRestart: Qe
        }), m.jsx(pTe, {
            gameFees: e?.BISCUIT_GAME_FEES_IN_L1XS,
            walletInfo: St,
            balance: t,
            handleConfirm: K,
            isOpen: xe,
            onClose: () => ue(!1),
            gameLogo: Nk,
            isSubmitting: Ee
        }), m.jsx(iTe, {
            isOpen: ce,
            onClose: () => me(!1)
        })]
    })
}
  , gTe = V.createContext()
  , yTe = {
    blue: {
        name: "blue",
        cssVariables: {
            "--SiteColor": "#257BE6",
            "--Header": "url(images/header.png)",
            "--Footer": "url(images/footer-bg.gif)",
            "--CharSelect": "url(images/charselect.png)",
            "--CharColor": "#0080d0",
            "--ScrollColor": "#1C1294"
        }
    },
    dark: {
        name: "dark",
        cssVariables: {
            "--SiteColor": "#252525",
            "--Header": "url(images/header-dark.jpg)",
            "--Footer": "url(images/footer-bg-dark.gif)",
            "--CharSelect": "url(images/charselect-dark.png)",
            "--CharColor": "#001c2e",
            "--ScrollColor": "#000000"
        }
    }
}
  , bTe = ({children: n}) => {
    const [e,t] = V.useState("blue");
    V.useEffect( () => {
        const o = localStorage.getItem("theme") || "blue";
        t(o),
        r(o)
    }
    , []);
    const r = o => {
        const a = yTe[o];
        if (!a)
            return;
        Object.entries(a.cssVariables).forEach( ([u,d]) => {
            document.documentElement.style.setProperty(u, d)
        }
        );
        const l = document.querySelector('meta[name="theme-color"]');
        l && l.setAttribute("content", a.cssVariables["--SiteColor"]),
        localStorage.setItem("theme", o)
    }
      , i = {
        currentTheme: e,
        toggleTheme: () => {
            const o = e === "blue" ? "dark" : "blue";
            t(o),
            r(o)
        }
        ,
        applyTheme: r
    };
    return m.jsx(gTe.Provider, {
        value: i,
        children: n
    })
}
;
function wTe() {
    const [n,e] = V.useState(!0);
    return V.useEffect( () => {
        const t = setTimeout( () => {
            e(!1)
        }
        , 2e3);
        return () => clearTimeout(t)
    }
    , []),
    m.jsx(bTe, {
        children: m.jsx(GDe, {
            children: m.jsx("div", {
                className: "App",
                children: n ? m.jsx(lDe, {}) : m.jsx(mTe, {})
            })
        })
    })
}
function $x(n) {
    const [e,t] = V.useState(!1)
      , [r,s] = V.useState([])
      , [i,o] = V.useState(1)
      , [a,l] = V.useState(!1)
      , [u,d] = V.useState(!0)
      , [h,p] = V.useState(!1)
      , g = V.useRef(null);
    async function w(v=!1) {
        try {
            const S = v ? i + 1 : 1;
            let N;
            n === Io ? N = await zSe(S, 16, n) : n === kx ? N = await $Se(S, 16, n) : n === Pp || n === X2 ? N = await lTe(S, 16, n) : N = {
                status: "error",
                message: "Invalid game ID",
                data: [],
                meta: {
                    total: 0,
                    page: 1,
                    limit: 16,
                    totalPages: 0
                }
            };
            const _ = N?.data?.data ?? [];
            if (!(N?.status === "success"))
                throw new Error("Failed");
            if (v) {
                if (!_.length) {
                    d(!1);
                    return
                }
                s(k => [...k, ..._]),
                o(S)
            } else
                s(_),
                o(1),
                d(_.length > 0)
        } catch {
            v || s([]),
            d(!1)
        }
    }
    V.useEffect( () => {
        const v = S => {
            g.current && !g.current.contains(S.target) && t(!1)
        }
        ;
        return e && document.addEventListener("mousedown", v),
        () => document.removeEventListener("mousedown", v)
    }
    , [e]),
    V.useEffect( () => {
        e && w()
    }
    , [n, e]);
    const b = () => {
        h || (window.scrollTo(0, 0),
        t(!1)),
        p(v => !v)
    }
    ;
    return V.useEffect( () => {
        const v = S => {
            S.key === "Escape" && h && p(!1)
        }
        ;
        return h && document.addEventListener("keydown", v),
        () => document.removeEventListener("keydown", v)
    }
    , [h]),
    V.useEffect( () => (document.body.style.overflow = h ? "hidden" : "auto",
    () => document.body.style.overflow = "auto"), [h]),
    V.useEffect( () => {
        if (!e)
            return;
        const v = g.current;
        if (!v)
            return;
        const S = () => {
            if (a || !u)
                return;
            v.scrollTop + v.clientHeight >= v.scrollHeight - 20 && (l(!0),
            w(!0).finally( () => l(!1)))
        }
        ;
        return v.addEventListener("scroll", S),
        () => v.removeEventListener("scroll", S)
    }
    , [e, a, u]),
    {
        showGameHistory: e,
        setShowGameHistory: t,
        history: r,
        isFullscreen: h,
        toggleFullscreen: b,
        hasMoreRecords: u,
        gameHistoryRef: g,
        reloadHistory: () => w(!1)
    }
}
const vTe = () => {
    const n = kr()
      , {gameId: e} = E0()
      , {showGameHistory: t, setShowGameHistory: r, history: s, isFullscreen: i, toggleFullscreen: o, gameHistoryRef: a} = $x(e);
    return m.jsx("div", {
        className: i ? "" : "py-10 px-4",
        children: m.jsxs("div", {
            className: `game-area ${i ? "" : "p-4 border border-white rounded-2xl"}  transition-all duration-300 ${i ? "fixed inset-0 z-[9999] w-screen h-screen m-0 p-2 bg-black" : "relative bg-black/50"}`,
            style: i ? {
                top: 0,
                left: 0,
                right: 0,
                bottom: 0
            } : {},
            children: [!i && m.jsxs("div", {
                className: "flex items-center justify-between lg:mb-4 mb-0",
                children: [m.jsxs("div", {
                    className: "flex items-center gap-4",
                    children: [m.jsx("button", {
                        onClick: () => n(-1),
                        className: "bg-[#314258] w-10 h-10 rounded-full flex items-center justify-center hover:bg-[#3d5269] transition-colors",
                        children: m.jsx("svg", {
                            xmlns: "http://www.w3.org/2000/svg",
                            fill: "none",
                            viewBox: "0 0 24 24",
                            strokeWidth: 1.5,
                            stroke: "currentColor",
                            className: "size-6",
                            children: m.jsx("path", {
                                strokeLinecap: "round",
                                strokeLinejoin: "round",
                                d: "M10.5 19.5 3 12m0 0 7.5-7.5M3 12h18"
                            })
                        })
                    }), m.jsx("img", {
                        src: Nk,
                        className: "w-24 h-auto"
                    })]
                }), m.jsxs("div", {
                    className: "flex items-center gap-2",
                    children: [m.jsxs("button", {
                        onClick: () => r(!0),
                        className: "bg-white rounded-2xl text-black px-4 py-2 flex items-center text-base cursor-pointer gap-1.5 hover:bg-gray-100 transition-colors",
                        children: [m.jsx("svg", {
                            xmlns: "http://www.w3.org/2000/svg",
                            fill: "none",
                            viewBox: "0 0 24 24",
                            strokeWidth: 1.5,
                            stroke: "currentColor",
                            className: "size-6",
                            children: m.jsx("path", {
                                strokeLinecap: "round",
                                strokeLinejoin: "round",
                                d: "M12 6v6h4.5m4.5 0a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"
                            })
                        }), "Game History"]
                    }), m.jsx("button", {
                        onClick: o,
                        className: "w-10 h-10 rounded-full bg-black/50 flex items-center justify-center hover:bg-black/70 transition-colors",
                        title: "Enter Fullscreen",
                        children: m.jsx("svg", {
                            xmlns: "http://www.w3.org/2000/svg",
                            fill: "none",
                            viewBox: "0 0 24 24",
                            strokeWidth: 1.5,
                            stroke: "currentColor",
                            className: "size-6",
                            children: m.jsx("path", {
                                strokeLinecap: "round",
                                strokeLinejoin: "round",
                                d: "M3.75 3.75v4.5m0-4.5h4.5m-4.5 0L9 9M3.75 20.25v-4.5m0 4.5h4.5m-4.5 0L9 15M20.25 3.75h-4.5m4.5 0v4.5m0-4.5L15 9m5.25 11.25h-4.5m4.5 0v-4.5m0 4.5L15 15"
                            })
                        })
                    })]
                })]
            }), m.jsxs("div", {
                className: "play-area rounded-2xl overflow-hidden relative ",
                children: [i && m.jsx("div", {
                    className: "absolute top-4 right-4 z-50",
                    children: m.jsx("button", {
                        onClick: o,
                        className: "w-12 h-12 rounded-full bg-black/70 flex items-center justify-center hover:bg-black/90 transition-colors border-2 border-white/20",
                        title: "Exit Fullscreen (ESC)",
                        children: m.jsx("svg", {
                            xmlns: "http://www.w3.org/2000/svg",
                            fill: "none",
                            viewBox: "0 0 24 24",
                            strokeWidth: 2,
                            stroke: "currentColor",
                            className: "size-6 text-white",
                            children: m.jsx("path", {
                                strokeLinecap: "round",
                                strokeLinejoin: "round",
                                d: "M9 9V4.5M9 9H4.5M9 9 3.75 3.75M9 15v4.5M9 15H4.5M9 15l-5.25 5.25M15 9h4.5M15 9V4.5M15 9l5.25-5.25M15 15h4.5M15 15v4.5m0-4.5 5.25 5.25"
                            })
                        })
                    })
                }), m.jsx(wTe, {})]
            }), t && !i && m.jsxs("div", {
                ref: a,
                className: "gameHistory bg-black/90 p-4 border border-white rounded-2xl absolute top-0 right-0 max-w-[500px] w-full z-10 h-full overflow-y-auto",
                children: [m.jsxs("div", {
                    className: "flex items-center justify-start gap-2 mb-4",
                    children: [m.jsx("button", {
                        onClick: () => r(!1),
                        className: "rounded-2xl text-white flex items-center text-base cursor-pointer gap-1.5",
                        children: m.jsx("svg", {
                            xmlns: "http://www.w3.org/2000/svg",
                            fill: "none",
                            viewBox: "0 0 24 24",
                            strokeWidth: 1.5,
                            stroke: "currentColor",
                            className: "size-6",
                            children: m.jsx("path", {
                                strokeLinecap: "round",
                                strokeLinejoin: "round",
                                d: "M15.75 19.5 8.25 12l7.5-7.5"
                            })
                        })
                    }), m.jsx("h3", {
                        className: "text-white text-xl font-bold",
                        children: "Game History"
                    })]
                }), m.jsxs("div", {
                    className: "flex flex-col gap-2",
                    children: [m.jsxs("div", {
                        className: "grid grid-cols-3 px-4 pb-1 uppercase opacity-70 text-sm",
                        children: [m.jsx("p", {
                            children: "ID"
                        }), m.jsx("p", {
                            children: "Start Time"
                        }), m.jsx("p", {
                            children: "Score"
                        })]
                    }), s?.map( (l, u) => {
                        const d = new Date(l?.createdAt)
                          , h = d.toLocaleString("en-IN", {
                            month: "short"
                        }) + " " + d.toLocaleString("en-IN", {
                            day: "2-digit"
                        }) + ", " + d.toLocaleString("en-IN", {
                            hour: "2-digit",
                            minute: "2-digit",
                            hour12: !0
                        }).toLowerCase();
                        return m.jsxs("div", {
                            className: "grid grid-cols-3 bg-[#182637] px-4 py-3 rounded-sm mb-1",
                            children: [m.jsx("a", {
                                href: "#",
                                children: zo(l?.sessionId)
                            }), m.jsx("p", {
                                children: h
                            }), m.jsxs("p", {
                                children: [wn(l?.outcomeValue), " Points"]
                            })]
                        }, u)
                    }
                    )]
                })]
            })]
        })
    })
}
  , xTe = "data:image/svg+xml,%3csvg%20width='46'%20height='42'%20viewBox='0%200%2046%2042'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M17.5756%2035.4142C17.7365%2034.7511%2016.8286%2028.1125%2016.8286%2028.1125L12.5952%2030.4313C12.5952%2030.4313%2015.282%2037.7936%2015.6123%2037.7819C15.9426%2037.7702%2017.4146%2036.0772%2017.5756%2035.4142Z'%20fill='%23F0AF1D'/%3e%3cpath%20d='M6.94376%2025.3862C6.29255%2025.5856%204.68998%2027.1553%204.6971%2027.4857C4.70423%2027.816%2012.2089%2030.0669%2012.2089%2030.0669L14.2742%2025.703C14.2742%2025.703%207.59582%2025.1854%206.94376%2025.3862Z'%20fill='%23F0AF1D'/%3e%3cpath%20d='M32.609%2025.6504C32.1599%2026.1271%2032.1827%2026.8773%2032.658%2027.3257L32.9599%2027.6096C33.4365%2028.0589%2034.1866%2028.0373%2034.6346%2027.5608L37.5195%2024.4992C37.9686%2024.0225%2037.9472%2023.2731%2037.4705%2022.8238L37.1684%2022.5389C36.6929%2022.0894%2035.943%2022.112%2035.4937%2022.5876L32.6085%2025.6482L32.609%2025.6504Z'%20fill='%23F0AF1D'/%3e%3cpath%20d='M31.2908%2019.03C30.8415%2019.5056%2030.8632%2020.256%2031.3398%2020.7053L31.642%2020.9902C32.1186%2021.4395%2032.8674%2021.4172%2033.3167%2020.9415L36.2017%2017.8799C36.6507%2017.4031%2036.6282%2016.6541%2036.1527%2016.2045L35.8505%2015.9196C35.3739%2015.4703%2034.6251%2015.4927%2034.1758%2015.9683L31.2906%2019.0289L31.2908%2019.03Z'%20fill='%23E3BD32'/%3e%3cpath%20d='M15.8048%209.79814C15.3558%2010.2749%2014.6057%2010.2964%2014.1301%209.84686L13.828%209.56194C13.3513%209.11263%2013.3297%208.36222%2013.779%207.88659L16.6642%204.82603C17.1133%204.3493%2017.8634%204.32775%2018.3389%204.77731L18.641%205.06223C19.1177%205.51154%2019.1393%206.26195%2018.69%206.73758L15.8048%209.79814Z'%20fill='%23E3BD32'/%3e%3cpath%20d='M22.4876%2010.7276C22.0385%2011.2043%2021.2895%2011.2256%2020.8129%2010.7763L20.5118%2010.4911C20.0352%2010.0418%2020.0135%209.29141%2020.4628%208.81577L23.3478%205.75411C23.7969%205.27738%2024.5459%205.25609%2025.0225%205.70539L25.3246%205.99032C25.8013%206.43963%2025.8229%207.19003%2025.3736%207.66567L22.4884%2010.7262L22.4876%2010.7276Z'%20fill='%23E3BD32'/%3e%3cpath%20d='M37.1041%2033.7182C36.9017%2032.5492%2032.4204%2012.6843%2032.4204%2012.6843L25.274%2017.6721C25.274%2017.6721%2031.5928%2033.0438%2032.0003%2034.0349C32.4078%2035.026%2032.0711%2040.6985%2032.4491%2040.7293C32.8271%2040.7601%2037.3059%2034.885%2037.1038%2033.7171L37.1041%2033.7182Z'%20fill='%23C43A20'/%3e%3cpath%20d='M28.753%209.22621C28.753%209.22621%208.66663%205.91657%207.48999%205.78406C6.312%205.65069%200.712422%2010.4681%200.765532%2010.8436C0.818641%2011.2192%206.45957%2010.5505%207.47311%2010.8989C8.48556%2011.2476%2024.1967%2016.6558%2024.1967%2016.6558L28.7541%209.22597L28.753%209.22621Z'%20fill='%23C43A20'/%3e%3cpath%20d='M40.1153%200.697969C40.1153%200.697969%2040.1153%200.697969%2040.1161%200.696621C40.1089%200.690149%2040.1016%200.683677%2040.0944%200.677205C40.0872%200.670733%2040.0808%200.662912%2040.0736%200.65644C40.0736%200.65644%2040.0736%200.656441%2040.0716%200.658036C39.0171%20-0.207441%2035.3445%200.834652%2032.7014%203.63961C30.9138%205.53689%2027.6626%208.98612%2022.9479%2013.9873C15.8769%2021.4888%2010.2542%2029.7871%2011.3322%2030.8034C11.3901%2030.7418%2011.4518%2030.6771%2011.5134%2030.6112C11.6604%2030.8234%2011.8495%2031.0319%2011.7197%2031.1698C12.7977%2032.1861%2020.7481%2026.0833%2027.8191%2018.5818C32.533%2013.5808%2035.7842%2010.1315%2037.5725%208.23407C40.2157%205.42911%2041.0411%201.70105%2040.1155%200.69907L40.1153%200.697969Z'%20fill='%23E24126'/%3e%3cpath%20d='M38.6253%204.81385C38.6253%204.81385%2038.2273%204.02997%2037.6305%203.46769C37.0348%202.90516%2036.2432%202.56705%2036.2432%202.56705C36.0733%202.40743%2035.8068%202.41522%2035.6459%202.58436C35.4864%202.75434%2035.4942%203.02092%2035.6642%203.18054C35.6642%203.18054%2036.5964%203.65593%2037.0567%204.08924C37.516%204.5228%2038.0451%205.42758%2038.0451%205.42758C38.2151%205.5872%2038.4816%205.57941%2038.6425%205.41028C38.802%205.24029%2038.7941%204.97371%2038.6253%204.81385Z'%20fill='%23F0AF1D'/%3e%3cpath%20d='M11.1452%2032.2002L10.5703%2031.6584L17.1398%2024.6882C17.2892%2024.5297%2017.5395%2024.5221%2017.6979%2024.6716C17.8563%2024.8211%2017.864%2025.0715%2017.7146%2025.2299L11.1452%2032.2002Z'%20fill='%23F0AF1D'/%3e%3c/svg%3e"
  , ETe = "data:image/svg+xml,%3csvg%20width='46'%20height='42'%20viewBox='0%200%2046%2042'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M17.5756%2035.4142C17.7365%2034.7511%2016.8286%2028.1125%2016.8286%2028.1125L12.5952%2030.4313C12.5952%2030.4313%2015.282%2037.7936%2015.6123%2037.7819C15.9426%2037.7702%2017.4146%2036.0772%2017.5756%2035.4142Z'%20fill='%23F0AF1D'/%3e%3cpath%20d='M6.94376%2025.3862C6.29255%2025.5856%204.68998%2027.1553%204.6971%2027.4857C4.70423%2027.816%2012.2089%2030.0669%2012.2089%2030.0669L14.2742%2025.703C14.2742%2025.703%207.59582%2025.1854%206.94376%2025.3862Z'%20fill='%23F0AF1D'/%3e%3cpath%20d='M32.609%2025.6504C32.1599%2026.1271%2032.1827%2026.8773%2032.658%2027.3257L32.9599%2027.6096C33.4365%2028.0589%2034.1866%2028.0373%2034.6346%2027.5608L37.5195%2024.4992C37.9686%2024.0225%2037.9472%2023.2731%2037.4705%2022.8238L37.1684%2022.5389C36.6929%2022.0894%2035.943%2022.112%2035.4937%2022.5876L32.6085%2025.6482L32.609%2025.6504Z'%20fill='%23F0AF1D'/%3e%3cpath%20d='M31.2908%2019.03C30.8415%2019.5056%2030.8632%2020.256%2031.3398%2020.7053L31.642%2020.9902C32.1186%2021.4395%2032.8674%2021.4172%2033.3167%2020.9415L36.2017%2017.8799C36.6507%2017.4031%2036.6282%2016.6541%2036.1527%2016.2045L35.8505%2015.9196C35.3739%2015.4703%2034.6251%2015.4927%2034.1758%2015.9683L31.2906%2019.0289L31.2908%2019.03Z'%20fill='%23E3BD32'/%3e%3cpath%20d='M15.8048%209.79814C15.3558%2010.2749%2014.6057%2010.2964%2014.1301%209.84686L13.828%209.56194C13.3513%209.11263%2013.3297%208.36222%2013.779%207.88659L16.6642%204.82603C17.1133%204.3493%2017.8634%204.32775%2018.3389%204.77731L18.641%205.06223C19.1177%205.51154%2019.1393%206.26195%2018.69%206.73758L15.8048%209.79814Z'%20fill='%23E3BD32'/%3e%3cpath%20d='M22.4876%2010.7276C22.0385%2011.2043%2021.2895%2011.2256%2020.8129%2010.7763L20.5118%2010.4911C20.0352%2010.0418%2020.0135%209.29141%2020.4628%208.81577L23.3478%205.75411C23.7969%205.27738%2024.5459%205.25609%2025.0225%205.70539L25.3246%205.99032C25.8013%206.43963%2025.8229%207.19003%2025.3736%207.66567L22.4884%2010.7262L22.4876%2010.7276Z'%20fill='%23E3BD32'/%3e%3cpath%20d='M37.1041%2033.7182C36.9017%2032.5492%2032.4204%2012.6843%2032.4204%2012.6843L25.274%2017.6721C25.274%2017.6721%2031.5928%2033.0438%2032.0003%2034.0349C32.4078%2035.026%2032.0711%2040.6985%2032.4491%2040.7293C32.8271%2040.7601%2037.3059%2034.885%2037.1038%2033.7171L37.1041%2033.7182Z'%20fill='%23C43A20'/%3e%3cpath%20d='M28.753%209.22621C28.753%209.22621%208.66663%205.91657%207.48999%205.78406C6.312%205.65069%200.712422%2010.4681%200.765532%2010.8436C0.818641%2011.2192%206.45957%2010.5505%207.47311%2010.8989C8.48556%2011.2476%2024.1967%2016.6558%2024.1967%2016.6558L28.7541%209.22597L28.753%209.22621Z'%20fill='%23C43A20'/%3e%3cpath%20d='M40.1153%200.697969C40.1153%200.697969%2040.1153%200.697969%2040.1161%200.696621C40.1089%200.690149%2040.1016%200.683677%2040.0944%200.677205C40.0872%200.670733%2040.0808%200.662912%2040.0736%200.65644C40.0736%200.65644%2040.0736%200.656441%2040.0716%200.658036C39.0171%20-0.207441%2035.3445%200.834652%2032.7014%203.63961C30.9138%205.53689%2027.6626%208.98612%2022.9479%2013.9873C15.8769%2021.4888%2010.2542%2029.7871%2011.3322%2030.8034C11.3901%2030.7418%2011.4518%2030.6771%2011.5134%2030.6112C11.6604%2030.8234%2011.8495%2031.0319%2011.7197%2031.1698C12.7977%2032.1861%2020.7481%2026.0833%2027.8191%2018.5818C32.533%2013.5808%2035.7842%2010.1315%2037.5725%208.23407C40.2157%205.42911%2041.0411%201.70105%2040.1155%200.69907L40.1153%200.697969Z'%20fill='%23E24126'/%3e%3cpath%20d='M38.6253%204.81385C38.6253%204.81385%2038.2273%204.02997%2037.6305%203.46769C37.0348%202.90516%2036.2432%202.56705%2036.2432%202.56705C36.0733%202.40743%2035.8068%202.41522%2035.6459%202.58436C35.4864%202.75434%2035.4942%203.02092%2035.6642%203.18054C35.6642%203.18054%2036.5964%203.65593%2037.0567%204.08924C37.516%204.5228%2038.0451%205.42758%2038.0451%205.42758C38.2151%205.5872%2038.4816%205.57941%2038.6425%205.41028C38.802%205.24029%2038.7941%204.97371%2038.6253%204.81385Z'%20fill='%23F0AF1D'/%3e%3cpath%20d='M11.1452%2032.2002L10.5703%2031.6584L17.1398%2024.6882C17.2892%2024.5297%2017.5395%2024.5221%2017.6979%2024.6716C17.8563%2024.8211%2017.864%2025.0715%2017.7146%2025.2299L11.1452%2032.2002Z'%20fill='%23F0AF1D'/%3e%3c/svg%3e"
  , xG = "data:image/svg+xml,%3csvg%20width='24'%20height='25'%20viewBox='0%200%2024%2025'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3crect%20width='24'%20height='25'%20fill='url(%23pattern0_157_6552)'/%3e%3cdefs%3e%3cpattern%20id='pattern0_157_6552'%20patternContentUnits='objectBoundingBox'%20width='1'%20height='1'%3e%3cuse%20xlink:href='%23image0_157_6552'%20transform='matrix(0.0325521%200%200%200.03125%20-0.00455729%200)'/%3e%3c/pattern%3e%3cimage%20id='image0_157_6552'%20width='31'%20height='32'%20preserveAspectRatio='none'%20xlink:href='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB8AAAAgCAYAAADqgqNBAAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAH6ADAAQAAAABAAAAIAAAAABT9vqhAAAI30lEQVRIDY1WXaxUVxX+9j5/c2bmzp37C8Nve8VSmpZSSiCEatSoBKzpQ7VJjfYV+2B88UGTatBEnxo1MRrxzZiQGGPiQwuNmJCmJcYEaiOSe1uoAu2F+9d75+fOnP+z/daZGShCxZ175sw9s/b61vrWt9Y+Cv/HMgYKVx/wMFb9VO6ab2g7e8poM53cDLD2Rqc38cnJJWzI3wlvRCc7y/npxtM3AqVg7uda/S+DAjTa/RAsPGt0/rzS2U4gt2GMQs6dWQ6T8s5/VZobpCZLOng3Cyd+H+tnXqs9dOgtpT4rFvdcHwtOYAvZvq/BCn9AlAeJYPHi3+DK6C/j95RXEcjte54gT4LGcl57+Zw/vfd7gHdZKUWDO9c9wY15bIwJvgQdf5sIBJXFvQLMBG+BCbgEIc/+624YULLuGVP/yfve1OHvwqr8iQEEhavBx13gxhwcB4ITQPw0vZZugRLYMMu8mSCcjxGtMD0COhUNv+HCGbEpDLobBje4R8EU1NT3192JQ78gTT9WamN3GMAd4MYcqOV5eELr+DmC6iGwiTIE51tozYVYnQ0QM2NjsezkJM2pLHqZmilh04ERlOoMQjMMXgVDDKK7NorSjuOBNTLzHeg9vyYDUigJtb+YmEL06Dfh5S+Tw3LxlNxlawlW/7KK5ltdJGQ3dRXskkJl1Ea5bsFjxparkdNdFhlogtm08R8b6TvnHsNgg+YjKDWeWdO16edR+8qfpRvuBG/ufB11PEVg/pQjDzMs/XYB61dCpKRX+Nq63cPkTh9qwkfzagh/RMHb6oHZEJ2MxBT9zQj2phKUPciemSUdB2btINyNOy9hYupzauOLS6SWkTFgtPY9i6qzv2gjAW4n+PDkIoKrETICS8bbd/mY3FeFfoDgm0fg1oBlshLOMSypsaOhfAv29hJj5/9CLp2LVi0vRhxcQT7/7xlcf+9LgluAI913ELXkZ7ASTzJGkqF7roXeHMVZVghotZXZTuwm8LQH+C7gGnhjNhJm2r0WwLTZzgIo9RMWuIwAD5amPlR5EWFz2c/Wlr/K35QWW6jO14HeZhancJAuUdH/WIc/rhHS0bYdJdR2lqHGnCI7uASPE2aj4U3ZSDsZsnWCD3ue8ReUM7Bizg1icOsRwnCVJVg71Dv3rYZkTo/5YSpGFTVLckRvd+CwfiGd1CZtjArwOM1IPTS32LzYAZJg7WEfYZdl6hCce/o0S0YMQOaKAA8YEKGmaKLXbVad1vJRG+2Zx1ExW4dRm3W2FbN2iJWS3g3767AapNojbwJclkaI+lkSovpwBdYUNcDWMhZrzl/zIIVhElaZe4bUF9nTxumh12or1XQ+b8PGEdaYipJdLPd8BB3kiEetooUsRgu5GAwsesgoLmYtcx0C5muURxkUKTcRZ30nQW92HepGCG9XhapnsJwJEgShORv4e9BVuVGPsGD5QbrtHxT0ly3EEMCIho1JxnStB7RY3w0OVJG95MYl41RWTyJm5GxLQ7v2xS667JBKw0JwpYex8RIZYHCDlXEsBiFbN8trBDfbiCNBFZkXqnUUNLOyJzitpkuIGZC5FsLZSPpLQr/YcgNxQXoFOPswRpPACcXnNGyOKY3alAstOpFFc4GIKKQoSpGlRgm4XzwdgOecUjljkSkllCpPwZ3xkUsAnGSKgRWAouzB4tmO7qUuVC9DznI5VQv1Lcx4gl3B3i8CHdj2WixpUlStZyMiDyKkApywVGhK1VoEKeYzN0nsmqJTHKXg8OGeftZSy8FWySAe44CpOqhu86BrFIlP+6L3Bdkgo05aKzlnA6eJpS5rRGaJde8LSMYj9yTMfgjcp5f/SwYCSiVDelouoZwdCiqdLEKxImVqQ4/KEKK9tORg8BgCL3JoBdQrk+O/5g2dB9nf2Z8MS4JTcLaXkTI52ddng3ehWLJsMWQeNNH1AO3ZHuLFmMOGbIkxmSJ2P2j5Qs0UJxG/ip+MjC5cj4sDiGiJnaWvatMyr9E5wWlBEG/MRWULhcKkCr7luUyTXsq6h2i9vY7liwEWeKhcOd9FxNYUEM1Rq+XYK9gQRO6RduQjabOEQotZZTlG+Nul2c7qZW31Fs+aMF8uwEmRouHInipStpDh5JKActIdX+rg5uttrH6QIOG8t3mcNjZZaPPFImFGesTiexyRpDSyBnQPh0x7Beh22S08yxnAK8d+g1Tji+zUKD/dp56bmalT5ezZ6CJZYLfTWcYjcvFSgC63ZXVdvDBs+YSPOrtgcne5OJh776ecDTI+mZlN3kVHRdb8yu835qgJTirL0iuupU4xPKPJqLGi/I80Xi/qztrLSC7vqnJEMmuq25lwMP1kFRbn+9ikgw08Ml3e5fhUFJbH16jaHk4z6kU1/DuA5WhdeMcg6vjwXMt4nnVmZf/ieSGHhWEIZ8ZGTdk9qcrqSPGseDoInAIDB4ao3TRTCGlKBo2oWbQgtiJGis5Iy/KVhq/R4rVgPFgFbs5WOFjISoI5RMEXHj8+/wENBuByPzU9g3G8yZNrA/f1vfJTmCusBEvaTQQltVX8LiqXS4QlgAzsoyuLM6y/V+dLhCs/r/HgfGHzi/98deiWOwvfBkeX/oWefQwdM08n/bAlS7mkFGxraatiIHkcHjLp5MUtIDMEuQUs+LI94HExPwFPVzBStsPRiv3zIAnPDIEHuHLrL3P2M3ZmVg5rd/l3yjN1Kom2XP3PvtH9PgmMwOIhM07NcCpS5HxH+aH21S/Vly/wlLq97nLLvQpvbtsLHf2Kzf4E68qRdZfZbQ/DbwIqby5dCi6a5FOev8qsUAg/wkJ2Qh27QIruXPf0WgTw1y2bGPpRpv0CeT/AbTZp5xhjpYTy4i2Fd6lzwjJEPLcTXrnPB5qjD68w8J+it+Vv6rk/yPy8a90T/KNW5sSTDp5wP41u7zjC9l4q0IMd8xxjEDFpTSqsMbOVmWiZiDP2Ivv8JbQbZz8OdOj/vuBDw8unjng7LP0oX0P283jakaf5FNN0WaRIO1giL1cIfAGqdlEdPc2Ze//1Hw8akh9Qm9p6AAAAAElFTkSuQmCC'/%3e%3c/defs%3e%3c/svg%3e"
  , oj = "/assets/planeSound-DFjQ_Sk8.mp3"
  , STe = "/assets/explosion-jFkcOUYD.mp3";
function ATe(n, e) {
    try {
        return typeof e == "object" && (e = JSON.stringify(e)),
        window.localStorage.setItem(n, e),
        !0
    } catch {
        return console.error("Error Occured while storing data"),
        !1
    }
}
function EG(n) {
    try {
        let e = window.localStorage.getItem(n);
        return e == null ? !1 : JSON.parse(e)
    } catch {
        return console.error("Error Occured while getting data"),
        !1
    }
}
let bf = {
    Accept: "application/json",
    "Content-Type": "application/json;charset=UTF-8"
};
function SG() {
    return EG("userInfo")?.authToken || null
}
function Tk(n) {
    const e = SG();
    return e && (bf = {
        ...bf,
        Authorization: "Bearer " + e
    }),
    fetch(`${n}`, {
        method: "GET",
        mode: "cors",
        cache: "no-cache",
        credentials: "same-origin",
        headers: bf
    }).then(t => t.json()).then(async t => t).catch(t => t)
}
function AG(n, e, t) {
    const r = SG();
    return r && (bf = {
        ...bf,
        Authorization: "Bearer " + r
    },
    t && (bf["x-recaptcha-token"] = t)),
    fetch(`${n}`, {
        method: "POST",
        headers: bf,
        body: JSON.stringify(e)
    }).then(s => s.json()).then(s => s).catch(s => s)
}
const sb = Pc.BASE_URL.play;
async function CTe(n, e) {
    return await AG(`${sb}/api/v1/game/l1x_start`, n, e)
}
async function _Te(n, e) {
    return await AG(`${sb}/api/v1/game/l1x_cashOut`, n, e)
}
async function kTe(n, e, t) {
    return await Tk(`${sb}/api/v1/game/l1x_verify?gameId=${t}&page=${n}&limit=${e}`)
}
async function NTe(n, e, t, r) {
    return await Tk(`${sb}/api/v1/game/l1x_session_bets?page=${n}&limit=${e}&gameId=${t}&sessionId=${r}`)
}
async function DTe(n) {
    return await Tk(`${sb}/api/v1/game/l1x_active_session?gameId=${n}`)
}
const TTe = ({isOpen: n, onClose: e, data: t}) => {
    if (!n)
        return null;
    const [r,s] = V.useState("result")
      , [i,o] = V.useState(!1)
      , [a,l] = V.useState(!1)
      , [u,d] = V.useState(!1)
      , [h,p] = V.useState([])
      , [g,w] = V.useState([])
      , b = new Date(t?.timestamp).toLocaleDateString("en-US", {
        month: "2-digit",
        day: "2-digit",
        year: "numeric"
    })
      , v = new Date(t?.timestamp).toLocaleTimeString("en-US", {
        hour: "2-digit",
        minute: "2-digit"
    })
      , S = t?.expectedOutcome
      , N = t?.serverSeed
      , _ = t?.clientSeed
      , I = t?.sessionId;
    V.useEffect( () => {
        k()
    }
    , []);
    const k = async () => {
        try {
            const M = await NTe(1, 10, Io, I);
            M?.status === "success" ? (p(M?.data?.data),
            w(M?.data?.meta)) : p([])
        } catch (M) {
            console.log(" ~ getLeaderBoard ~ error:", M)
        }
    }
      , B = M => ({
        T: "bg-green-500",
        B: "bg-orange-500",
        X: "bg-gray-500",
        N: "bg-green-500",
        L: "bg-blue-500"
    })[M] || "bg-gray-500"
      , P = (M, R) => {
        navigator.clipboard.writeText(M),
        R === "hash" ? (o(!0),
        setTimeout( () => o(!1), 2e3)) : R === "seed" ? (l(!0),
        setTimeout( () => l(!1), 2e3)) : R === "gameId" && (d(!0),
        setTimeout( () => d(!1), 2e3))
    }
    ;
    return m.jsx("div", {
        className: "fixed inset-0 z-[101] flex items-center justify-center bg-black/30 bg-opacity-60 backdrop-blur-sm",
        children: m.jsxs("div", {
            className: "relative w-full max-w-xl mx-4 bg-[#1C2837] rounded-2xl shadow-2xl overflow-hidden",
            children: [m.jsxs("div", {
                className: "p-6 border-b border-[#2F3E53]",
                children: [m.jsxs("div", {
                    className: "flex items-center justify-between mb-0",
                    children: [m.jsxs("div", {
                        className: "flex items-center gap-3",
                        children: [m.jsxs("h3", {
                            className: "text-lg font-semibold text-white",
                            children: ["Crash Game: ", zo(I, 8)]
                        }), m.jsx("button", {
                            onClick: () => P(I, "gameId"),
                            className: "p-1.5 hover:bg-[#2F3E53] rounded transition-colors",
                            title: "Copy Game ID",
                            children: u ? m.jsx("svg", {
                                xmlns: "http://www.w3.org/2000/svg",
                                fill: "none",
                                viewBox: "0 0 24 24",
                                strokeWidth: 2,
                                stroke: "currentColor",
                                className: "w-4 h-4 text-green-400",
                                children: m.jsx("path", {
                                    strokeLinecap: "round",
                                    strokeLinejoin: "round",
                                    d: "M4.5 12.75l6 6 9-13.5"
                                })
                            }) : m.jsx("svg", {
                                xmlns: "http://www.w3.org/2000/svg",
                                fill: "none",
                                viewBox: "0 0 24 24",
                                strokeWidth: 1.5,
                                stroke: "currentColor",
                                className: "w-4 h-4 text-gray-400",
                                children: m.jsx("path", {
                                    strokeLinecap: "round",
                                    strokeLinejoin: "round",
                                    d: "M15.666 3.888A2.25 2.25 0 0013.5 2.25h-3c-1.03 0-1.9.693-2.166 1.638m7.332 0c.055.194.084.4.084.612v0a.75.75 0 01-.75.75H9a.75.75 0 01-.75-.75v0c0-.212.03-.418.084-.612m7.332 0c.646.049 1.288.11 1.927.184 1.1.128 1.907 1.077 1.907 2.185V19.5a2.25 2.25 0 01-2.25 2.25H6.75A2.25 2.25 0 014.5 19.5V6.257c0-1.108.806-2.057 1.907-2.185a48.208 48.208 0 011.927-.184"
                                })
                            })
                        })]
                    }), m.jsx("button", {
                        onClick: e,
                        className: "p-2 hover:bg-[#2F3E53] rounded-lg transition-colors",
                        children: m.jsx("svg", {
                            xmlns: "http://www.w3.org/2000/svg",
                            fill: "none",
                            viewBox: "0 0 24 24",
                            strokeWidth: 1.5,
                            stroke: "currentColor",
                            className: "w-6 h-6 text-gray-400",
                            children: m.jsx("path", {
                                strokeLinecap: "round",
                                strokeLinejoin: "round",
                                d: "M6 18L18 6M6 6l12 12"
                            })
                        })
                    })]
                }), m.jsxs("p", {
                    className: "text-sm text-gray-400",
                    children: ["on ", b, " at ", v]
                })]
            }), m.jsx("div", {
                className: "flex justify-center p-6 pb-0",
                children: m.jsxs("div", {
                    className: "relative inline-flex bg-[#2F3E53] rounded-full p-1 gap-1",
                    children: [m.jsx("button", {
                        onClick: () => s("result"),
                        className: `px-6 py-2.5 rounded-full font-medium text-sm transition-all duration-200 cursor-pointer ${r === "result" ? "bg-white text-[#1C2837] shadow-sm" : "text-gray-400 hover:text-white"}`,
                        children: "Result"
                    }), m.jsx("button", {
                        onClick: () => s("leaderboard"),
                        className: `px-6 py-2.5 rounded-full font-medium text-sm transition-all duration-200 cursor-pointer ${r === "leaderboard" ? "bg-white text-[#1C2837] shadow-sm" : "text-gray-400 hover:text-white"}`,
                        children: "Leaderboard"
                    })]
                })
            }), m.jsx("div", {
                className: "p-6",
                children: r === "result" ? m.jsxs("div", {
                    className: "space-y-6",
                    children: [m.jsx("div", {
                        className: "text-center py-4",
                        children: m.jsxs("div", {
                            className: "text-7xl font-bold bg-gradient-to-r from-[#FF7124] to-[#FF9000] bg-clip-text text-transparent mb-2",
                            children: [wn(S, 2), "x"]
                        })
                    }), m.jsxs("div", {
                        className: "space-y-4",
                        children: [m.jsx("h4", {
                            className: "text-lg font-semibold text-white mb-4 text-center",
                            children: "Provable Fairness"
                        }), m.jsxs("div", {
                            children: [m.jsx("label", {
                                className: "block text-sm font-medium text-gray-400 mb-2",
                                children: "Hash"
                            }), m.jsxs("div", {
                                className: "relative",
                                children: [m.jsx("input", {
                                    type: "text",
                                    value: _,
                                    readOnly: !0,
                                    className: "w-full bg-[#2F3E53] border border-[#3a4a5f] rounded-xl px-4 py-3 pr-12 text-sm text-gray-300 focus:outline-none focus:border-[#EE5B35]"
                                }), m.jsx("button", {
                                    onClick: () => P(_, "hash"),
                                    className: "absolute right-3 top-1/2 -translate-y-1/2 p-2 hover:bg-[#3a4a5f] rounded-lg transition-colors",
                                    title: "Copy Hash",
                                    children: i ? m.jsx("svg", {
                                        xmlns: "http://www.w3.org/2000/svg",
                                        fill: "none",
                                        viewBox: "0 0 24 24",
                                        strokeWidth: 2,
                                        stroke: "currentColor",
                                        className: "w-4 h-4 text-green-400",
                                        children: m.jsx("path", {
                                            strokeLinecap: "round",
                                            strokeLinejoin: "round",
                                            d: "M4.5 12.75l6 6 9-13.5"
                                        })
                                    }) : m.jsx("svg", {
                                        xmlns: "http://www.w3.org/2000/svg",
                                        fill: "none",
                                        viewBox: "0 0 24 24",
                                        strokeWidth: 1.5,
                                        stroke: "currentColor",
                                        className: "w-4 h-4 text-gray-400",
                                        children: m.jsx("path", {
                                            strokeLinecap: "round",
                                            strokeLinejoin: "round",
                                            d: "M15.666 3.888A2.25 2.25 0 0013.5 2.25h-3c-1.03 0-1.9.693-2.166 1.638m7.332 0c.055.194.084.4.084.612v0a.75.75 0 01-.75.75H9a.75.75 0 01-.75-.75v0c0-.212.03-.418.084-.612m7.332 0c.646.049 1.288.11 1.927.184 1.1.128 1.907 1.077 1.907 2.185V19.5a2.25 2.25 0 01-2.25 2.25H6.75A2.25 2.25 0 014.5 19.5V6.257c0-1.108.806-2.057 1.907-2.185a48.208 48.208 0 011.927-.184"
                                        })
                                    })
                                })]
                            })]
                        }), m.jsxs("div", {
                            children: [m.jsx("label", {
                                className: "block text-sm font-medium text-gray-400 mb-2",
                                children: m.jsxs("span", {
                                    className: "flex items-center gap-2",
                                    children: ["Seed", m.jsx("button", {
                                        className: "p-1 hover:bg-[#2F3E53] rounded transition-colors",
                                        title: "Learn more about Seed",
                                        children: m.jsx("svg", {
                                            xmlns: "http://www.w3.org/2000/svg",
                                            fill: "none",
                                            viewBox: "0 0 24 24",
                                            strokeWidth: 1.5,
                                            stroke: "currentColor",
                                            className: "w-4 h-4 text-gray-400",
                                            children: m.jsx("path", {
                                                strokeLinecap: "round",
                                                strokeLinejoin: "round",
                                                d: "M9.879 7.519c1.171-1.025 3.071-1.025 4.242 0 1.172 1.025 1.172 2.687 0 3.712-.203.179-.43.326-.67.442-.745.361-1.45.999-1.45 1.827v.75M21 12a9 9 0 11-18 0 9 9 0 0118 0zm-9 5.25h.008v.008H12v-.008z"
                                            })
                                        })
                                    })]
                                })
                            }), m.jsxs("div", {
                                className: "relative",
                                children: [m.jsx("input", {
                                    type: "text",
                                    value: N,
                                    readOnly: !0,
                                    className: "w-full bg-[#2F3E53] border border-[#3a4a5f] rounded-xl px-4 py-3 pr-12 text-sm text-gray-300 focus:outline-none focus:border-[#EE5B35]"
                                }), m.jsx("button", {
                                    onClick: () => P(N, "seed"),
                                    className: "absolute right-3 top-1/2 -translate-y-1/2 p-2 hover:bg-[#3a4a5f] rounded-lg transition-colors",
                                    title: "Copy Seed",
                                    children: a ? m.jsx("svg", {
                                        xmlns: "http://www.w3.org/2000/svg",
                                        fill: "none",
                                        viewBox: "0 0 24 24",
                                        strokeWidth: 2,
                                        stroke: "currentColor",
                                        className: "w-4 h-4 text-green-400",
                                        children: m.jsx("path", {
                                            strokeLinecap: "round",
                                            strokeLinejoin: "round",
                                            d: "M4.5 12.75l6 6 9-13.5"
                                        })
                                    }) : m.jsx("svg", {
                                        xmlns: "http://www.w3.org/2000/svg",
                                        fill: "none",
                                        viewBox: "0 0 24 24",
                                        strokeWidth: 1.5,
                                        stroke: "currentColor",
                                        className: "w-4 h-4 text-gray-400",
                                        children: m.jsx("path", {
                                            strokeLinecap: "round",
                                            strokeLinejoin: "round",
                                            d: "M15.666 3.888A2.25 2.25 0 0013.5 2.25h-3c-1.03 0-1.9.693-2.166 1.638m7.332 0c.055.194.084.4.084.612v0a.75.75 0 01-.75.75H9a.75.75 0 01-.75-.75v0c0-.212.03-.418.084-.612m7.332 0c.646.049 1.288.11 1.927.184 1.1.128 1.907 1.077 1.907 2.185V19.5a2.25 2.25 0 01-2.25 2.25H6.75A2.25 2.25 0 014.5 19.5V6.257c0-1.108.806-2.057 1.907-2.185a48.208 48.208 0 011.927-.184"
                                        })
                                    })
                                })]
                            })]
                        }), m.jsx("div", {
                            className: "flex gap-4 pt-2 justify-center",
                            children: m.jsx("button", {
                                onClick: () => {
                                    window.open("/verify-games", "_blank")
                                }
                                ,
                                className: "text-sm bg-[#2F3E53]/50 text-white px-4 py-2 rounded-full transition-colors font-medium cursor-pointer",
                                children: "Verify Game"
                            })
                        })]
                    })]
                }) : m.jsxs("div", {
                    className: "space-y-0",
                    children: [m.jsx("style", {
                        children: `
                .leaderboard-scroll::-webkit-scrollbar {
                  width: 6px;
                }
                .leaderboard-scroll::-webkit-scrollbar-track {
                  background: transparent;
                }
                .leaderboard-scroll::-webkit-scrollbar-thumb {
                  background-color: #2F3E53;
                  border-radius: 3px;
                }
                .leaderboard-scroll::-webkit-scrollbar-thumb:hover {
                  background-color: #3a4a5f;
                }
              `
                    }), m.jsx("div", {
                        className: "max-h-[500px] overflow-y-auto pr-2 leaderboard-scroll",
                        style: {
                            scrollbarWidth: "thin",
                            scrollbarColor: "#2F3E53 transparent"
                        },
                        children: h?.map( (M, R) => m.jsxs("div", {
                            className: "grid grid-cols-3 items-center justify-between py-3 px-2 border-b border-[#2F3E53] last:border-b-0 hover:bg-[#2F3E53] transition-colors rounded-lg",
                            children: [m.jsx("div", {
                                className: "flex items-center gap-2 flex-1 min-w-0",
                                children: M.isHidden ? m.jsxs(m.Fragment, {
                                    children: [m.jsxs("svg", {
                                        xmlns: "http://www.w3.org/2000/svg",
                                        fill: "none",
                                        viewBox: "0 0 24 24",
                                        strokeWidth: 1.5,
                                        stroke: "currentColor",
                                        className: "w-4 h-4 text-gray-400 shrink-0",
                                        children: [m.jsx("path", {
                                            strokeLinecap: "round",
                                            strokeLinejoin: "round",
                                            d: "M9.568 3H5.25A2.25 2.25 0 003 5.25v4.318c0 .597.237 1.17.659 1.591l9.581 9.581c.699.699 1.78.872 2.607.33a18.095 18.095 0 005.223-5.223c.542-.827.369-1.908-.33-2.607L11.16 3.66A2.25 2.25 0 009.568 3z"
                                        }), m.jsx("path", {
                                            strokeLinecap: "round",
                                            strokeLinejoin: "round",
                                            d: "M6 6h.008v.008H6V6z"
                                        })]
                                    }), m.jsx("span", {
                                        className: "text-white text-sm truncate",
                                        children: M.player
                                    })]
                                }) : m.jsx("span", {
                                    className: "text-white text-sm truncate",
                                    children: M?.username || " "
                                })
                            }), m.jsx("div", {
                                className: "shrink-0 px-4 text-center",
                                children: m.jsx("span", {
                                    className: "text-white text-sm font-medium",
                                    children: (M?.won ? wn(M?.playerCashoutPoint, 2) : wn(M?.outcomeValue, 2)) + "x"
                                })
                            }), m.jsxs("div", {
                                className: "flex items-center gap-2 shrink-0 justify-end",
                                children: [m.jsx("div", {
                                    className: `w-6 h-6 rounded-full ${B(M.currency)} flex items-center justify-center`,
                                    children: m.jsx("img", {
                                        src: xG,
                                        className: ""
                                    })
                                }), m.jsx("span", {
                                    className: "text-green-400 text-sm font-medium whitespace-nowrap",
                                    children: wn(M?.winAmount, 2)
                                })]
                            })]
                        }, R))
                    })]
                })
            })]
        })
    })
}
  , ITe = n => n <= 0 ? 0 : Math.pow(2, 4 * (n - 1));
function MTe(n=120, e=1) {
    const t = [60, 560]
      , r = [350, 540]
      , s = [800, 250]
      , i = [940, 90]
      , o = [];
    for (let a = 0; a <= n * e; ++a) {
        const l = a / n
          , u = 1 - l
          , d = u * u * u * t[0] + 3 * u * u * l * r[0] + 3 * u * l * l * s[0] + l * l * l * i[0]
          , h = u * u * u * t[1] + 3 * u * u * l * r[1] + 3 * u * l * l * s[1] + l * l * l * i[1];
        o.push([d, h])
    }
    return o
}
function aj({x: n, y: e, angle: t=24, size: r=80}) {
    const s = r / 130;
    return m.jsxs("g", {
        transform: `translate(${n},${e}) rotate(${t}) scale(${s}) translate(-67,-65)`,
        children: [m.jsxs("g", {
            clipPath: "url(#clip0_563_6951)",
            children: [m.jsx("path", {
                d: "M35.9114 101.533C36.8968 99.5398 38.7499 77.7787 38.7499 77.7787L23.6309 82.1302C23.6309 82.1302 26.9179 107.463 27.9768 107.662C29.0358 107.86 34.926 103.527 35.9114 101.533Z",
                fill: "#F0AF1D"
            }), m.jsx("path", {
                d: "M9.2619 62.0501C7.04847 62.2193 0.830988 66.0668 0.617734 67.1225C0.404479 68.1782 22.6639 80.6956 22.6639 80.6956L32.3486 68.2922C32.3486 68.2922 11.479 61.8772 9.2619 62.0501Z",
                fill: "#F0AF1D"
            }), m.jsx("path", {
                d: "M90.6963 81.2179C88.9277 82.4133 88.4644 84.8153 89.6557 86.5809L90.4131 87.6991C91.6081 89.4684 94.0091 89.9355 95.7739 88.7401L107.135 81.0634C108.904 79.8679 109.371 77.4696 108.176 75.7003L107.418 74.5784C106.227 72.8091 103.826 72.3457 102.058 73.5375L90.6963 81.2105V81.2179Z",
                fill: "#F0AF1D"
            }), m.jsx("path", {
                d: "M91.2291 59.2214C89.4606 60.4132 88.9936 62.8151 90.1886 64.5844L90.946 65.7063C92.141 67.4756 94.5382 67.9391 96.3068 66.7473L107.668 59.0706C109.437 57.8751 109.9 55.4768 108.709 53.7075L107.951 52.5856C106.756 50.8164 104.359 50.3529 102.59 51.5447L91.2291 59.2177V59.2214Z",
                fill: "#E3BD32"
            }), m.jsx("path", {
                d: "M48.5744 18.8037C46.8058 19.9992 44.4049 19.532 43.2136 17.7627L42.4562 16.6408C41.2612 14.8715 41.7282 12.4696 43.4967 11.2778L54.858 3.60475C56.6266 2.40929 59.0275 2.87644 60.2188 4.64572L60.9762 5.76762C62.1712 7.53691 61.7042 9.93887 59.9357 11.1307L48.5744 18.8037Z",
                fill: "#E3BD32"
            }), m.jsx("path", {
                d: "M69.1644 26.5319C67.3959 27.7273 64.9986 27.2602 63.8037 25.4909L63.0499 24.369C61.8549 22.5997 62.3219 20.1977 64.0904 19.006L75.4518 11.3292C77.2203 10.1338 79.6176 10.6009 80.8126 12.3702L81.57 13.4921C82.7649 15.2614 82.298 17.6634 80.5294 18.8551L69.1681 26.5282L69.1644 26.5319Z",
                fill: "#E3BD32"
            }), m.jsx("path", {
                d: "M99.2296 110.086C99.4208 106.223 99.3546 39.8475 99.3546 39.8475L73.0654 50.6067C73.0654 50.6067 82.1839 104.005 82.7722 107.448C83.3605 110.891 78.2387 128.691 79.4189 129.059C80.5992 129.426 99.0384 113.941 99.2296 110.082V110.086Z",
                fill: "#C43A20"
            }), m.jsx("path", {
                d: "M90.1621 26.2306C90.1621 26.2306 28.6454 1.36127 24.998 0.0995942C21.347 -1.16576 0.098697 10.1562 -0.000576721 11.3884C-0.0998505 12.6207 18.3173 14.5224 21.2918 16.3542C24.2627 18.186 70.3661 46.605 70.3661 46.605L90.1657 26.2306H90.1621Z",
                fill: "#C43A20"
            }), m.jsx("path", {
                d: "M132.389 7.22348C132.389 7.22348 132.389 7.22348 132.393 7.2198C132.375 7.19405 132.356 7.1683 132.338 7.14255C132.319 7.11681 132.305 7.08738 132.286 7.06163C132.286 7.06163 132.286 7.06163 132.279 7.06531C129.543 3.55984 117.12 4.25137 106.71 11.2844C99.6706 16.0417 86.868 24.6895 68.3026 37.2278C40.4581 56.0352 16.6508 78.4106 19.3533 82.4126C19.5812 82.2581 19.8239 82.0963 20.0666 81.9307C20.3828 82.7105 20.835 83.5087 20.3239 83.8545C23.0264 87.8566 52.6688 74.1253 80.5132 55.3179C99.0762 42.7796 111.879 34.1318 118.921 29.3745C129.33 22.3415 134.617 11.0747 132.389 7.22716V7.22348Z",
                fill: "#E24126"
            }), m.jsx("path", {
                d: "M124.71 19.2488C124.71 19.2488 124.004 16.4716 122.508 14.2572C121.015 12.0429 118.739 10.4023 118.739 10.4023C118.313 9.77334 117.46 9.60781 116.827 10.0308C116.198 10.4575 116.033 11.3109 116.46 11.9399C116.46 11.9399 119.085 14.1175 120.239 15.8242C121.39 17.531 122.427 20.7863 122.427 20.7863C122.853 21.4153 123.707 21.5808 124.339 21.1578C124.968 20.7311 125.133 19.8778 124.71 19.2488Z",
                fill: "#F0AF1D"
            }), m.jsx("path", {
                d: "M17.7587 86.7207L16.3174 84.5873L42.1874 67.1115C42.7757 66.7142 43.5772 66.8687 43.9743 67.4572C44.3714 68.0458 44.217 68.8477 43.6287 69.2449L17.7587 86.7207Z",
                fill: "#F0AF1D"
            })]
        }), m.jsx("defs", {
            children: m.jsx("clipPath", {
                id: "clip0_563_6951",
                children: m.jsx("rect", {
                    width: "133.078",
                    height: "129.066",
                    fill: "white"
                })
            })
        })]
    })
}
const BTe = 50
  , RTe = ({progressValue: n, running: e, crashed: t, hasCashedOut: r, cashoutMultiplier: s, winAmount: i, betAmount: o, isBufferTime: a, isMuted: l=!1, waitingProgress: u, isGameActive: d}) => {
    const [h,p] = V.useState(n || 0)
      , g = V.useRef(n || 0)
      , w = V.useRef(null)
      , b = V.useRef(null)
      , v = V.useRef(!1)
      , S = V.useRef(null)
      , N = V.useRef(!1)
      , [_,I] = V.useState(!1)
      , [k,B] = V.useState(20)
      , [P,M] = V.useState(!1);
    V.useEffect( () => {
        g.current = typeof n == "number" && isFinite(n) ? n : 0
    }
    , [n]),
    V.useEffect( () => {
        if (t) {
            M(!1);
            const ue = setTimeout( () => {
                M(!0),
                p(1),
                g.current = 1
            }
            , 2e3);
            return () => {
                clearTimeout(ue)
            }
        } else
            a || !e && !t && !r ? (M(!0),
            p(1),
            g.current = 1) : e && !t && M(!1)
    }
    , [t, a, e, r]),
    V.useEffect( () => {
        let ue;
        const ce = me => {
            S.current == null && (S.current = me);
            const Ee = (me - S.current) / 1e3;
            S.current = me;
            const mt = 30 * Ee;
            p(st => {
                const ot = g.current
                  , Ct = ot - st;
                if (!isFinite(Ct))
                    return st;
                if (Math.abs(Ct) <= mt)
                    return ot;
                const ct = Math.sign(Ct) * mt;
                return st + ct
            }
            ),
            ue = requestAnimationFrame(ce)
        }
        ;
        return ue = requestAnimationFrame(ce),
        () => cancelAnimationFrame(ue)
    }
    , []),
    V.useEffect( () => {
        t && typeof n == "number" && isFinite(n) && p(n)
    }
    , [t, n]);
    const R = h / 10.5;
    let L = typeof R == "number" && isFinite(R) ? R : 0;
    L = Math.max(0, Math.min(L, 1));
    const [q,H] = V.useState(performance.now())
      , [j,A] = V.useState(0)
      , E = V.useRef(t);
    V.useEffect( () => {
        let ue = !0;
        const ce = () => {
            ue && (H(performance.now()),
            requestAnimationFrame(ce))
        }
        ;
        return ce(),
        () => {
            ue = !1
        }
    }
    , []),
    V.useEffect( () => {
        t || A(0),
        E.current = t
    }
    , [t]),
    V.useEffect( () => {
        if (!e)
            return;
        A(0);
        let ue, ce = performance.now();
        const me = Ee => {
            const Oe = (Ee - ce) / 1e3;
            ce = Ee,
            E.current || A(mt => mt + Oe),
            ue = requestAnimationFrame(me)
        }
        ;
        return ue = requestAnimationFrame(me),
        () => cancelAnimationFrame(ue)
    }
    , [e]),
    V.useEffect( () => {
        const ue = w.current;
        if (!ue) {
            console.warn("Engine sound ref is null in running effect");
            return
        }
        if (t) {
            ue.pause(),
            ue.currentTime = 0;
            return
        }
        e && !t ? (ue.loop = !0,
        ue.volume = .35,
        ue.readyState < 2 && ue.load(),
        ( () => {
            if (ue.readyState >= 2) {
                const me = ue.play();
                me && typeof me.catch == "function" && me.then( () => {
                    N.current = !0
                }
                ).catch(Ee => {
                    console.warn("Audio play failed:", Ee),
                    setTimeout( () => {
                        e && !t && ue && ue.play().catch(Oe => {
                            console.warn("Audio play retry failed:", Oe)
                        }
                        )
                    }
                    , 200)
                }
                )
            } else {
                const me = () => {
                    ue.play().then( () => {
                        N.current = !0
                    }
                    ).catch(Ee => {
                        console.warn("Audio play after load failed:", Ee)
                    }
                    ),
                    ue.removeEventListener("canplay", me)
                }
                ;
                ue.addEventListener("canplay", me)
            }
        }
        )()) : (ue.pause(),
        ue.currentTime = 0)
    }
    , [e, t]),
    V.useEffect( () => {
        const ue = b.current
          , ce = w.current;
        if (ue) {
            if (t && !v.current) {
                ce && (ce.pause(),
                ce.currentTime = 0),
                v.current = !0,
                ue.currentTime = 0,
                ue.volume = .5;
                const me = ue.play();
                me && typeof me.catch == "function" && me.then( () => {}
                ).catch(Ee => {
                    console.warn("Flew away sound play failed:", Ee)
                }
                )
            }
            t || (v.current = !1,
            ue && !ue.paused && (ue.pause(),
            ue.currentTime = 0))
        }
    }
    , [t]),
    V.useEffect( () => {
        const ue = w.current
          , ce = b.current;
        ue && (ue.muted = l),
        ce && (ce.muted = l)
    }
    , [l]);
    const O = {
        position: "relative",
        width: "100vw",
        maxWidth: "100%",
        aspectRatio: 1e3 / 640,
        minHeight: 0,
        background: "#161D28",
        borderRadius: "18px",
        overflow: "hidden",
        border: "1.5px solid #25344d",
        boxShadow: "0 8px 44px #111b31bb",
        display: "flex",
        alignItems: "center",
        justifyContent: "center"
    }
      , z = q / 1e3
      , Y = Math.max(0, Math.min(1, j * .15))
      , $ = MTe(160, Y)
      , D = e && !t ? Math.sin(z * 3) * 6 : 0
      , U = $.map( ([ue,ce]) => [ue, ce + D])
      , W = U[U.length - 1]
      , Q = U.map( ([ue,ce], me) => `${me === 0 ? "M" : "L"}${ue.toFixed(2)},${ce.toFixed(2)}`).join(" ")
      , J = `${Q} L${W[0]},560 L60,560 Z`
      , ne = 3 * Math.sin(z * 2.4) + 2 * Math.sin(z * 5.1 + .7);
    let ie = -14;
    if (U.length > 2) {
        const [ue,ce] = W
          , [me,Ee] = U[U.length - 2];
        let Oe = Math.atan2(ce - Ee, ue - me) * 180 / Math.PI;
        Oe < -12 && (Oe = -12),
        ie = Oe + ne
    } else
        ie += ne;
    const ae = W[0]
      , xe = W[1];
    return (1 + (BTe - 1) * ITe(L)).toFixed(2),
    V.useEffect( () => {
        const ue = w.current;
        if (!ue) {
            console.warn("Engine sound ref is null");
            return
        }
        ue.volume = .35,
        ue.loop = !0;
        const ce = async () => {
            if (!N.current && ue)
                try {
                    await ue.play(),
                    ue.pause(),
                    ue.currentTime = 0,
                    N.current = !0
                } catch (Oe) {
                    console.warn("Failed to enable audio:", Oe)
                }
        }
          , me = () => {}
          , Ee = Oe => {
            console.error("Audio error:", Oe),
            console.error("Audio src:", ue.src)
        }
        ;
        return ue.addEventListener("canplay", me),
        ue.addEventListener("error", Ee),
        document.addEventListener("click", ce, {
            once: !0,
            passive: !0
        }),
        document.addEventListener("touchstart", ce, {
            once: !0,
            passive: !0
        }),
        document.addEventListener("keydown", ce, {
            once: !0,
            passive: !0
        }),
        () => {
            ue.removeEventListener("canplay", me),
            ue.removeEventListener("error", Ee),
            document.removeEventListener("click", ce),
            document.removeEventListener("touchstart", ce),
            document.removeEventListener("keydown", ce)
        }
    }
    , []),
    m.jsxs("div", {
        style: O,
        children: [m.jsx("audio", {
            ref: w,
            src: oj,
            preload: "auto",
            crossOrigin: "anonymous",
            onLoadedData: () => {}
            ,
            onError: ue => {
                console.error("Audio element error:", ue),
                console.error("Trying to load:", oj)
            }
        }), m.jsx("audio", {
            ref: b,
            src: STe,
            preload: "auto"
        }), !P && m.jsxs("svg", {
            style: {
                position: "absolute",
                width: "100vw",
                height: "100%",
                left: 0,
                top: 0,
                maxWidth: "100%",
                minWidth: 0,
                zIndex: 3
            },
            width: "1000",
            height: "640",
            viewBox: "0 0 1000 640",
            children: [m.jsx("path", {
                d: Q,
                stroke: "#fff",
                strokeWidth: "3.5",
                fill: "none",
                style: {
                    filter: "drop-shadow(0 1px 15px #fff6)"
                }
            }), m.jsx("defs", {
                children: m.jsxs("linearGradient", {
                    id: "avi-fill",
                    x1: "0",
                    y1: "0",
                    x2: "0",
                    y2: "1",
                    children: [m.jsx("stop", {
                        offset: "0%",
                        stopColor: "#FF9000",
                        stopOpacity: .97
                    }), m.jsx("stop", {
                        offset: "70%",
                        stopColor: "#FF9000",
                        stopOpacity: .3
                    }), m.jsx("stop", {
                        offset: "100%",
                        stopColor: "#FF9000",
                        stopOpacity: 0
                    })]
                })
            }), m.jsx("path", {
                d: J,
                fill: "url(#avi-fill)",
                opacity: ".87"
            }), t ? m.jsx(aj, {
                x: ae,
                y: xe,
                angle: ie
            }) : m.jsx(aj, {
                x: ae,
                y: xe,
                angle: ie
            })]
        }, "game-svg"), r && s && !P && m.jsxs("div", {
            style: {
                position: "absolute",
                top: "20px",
                left: "50%",
                transform: "translateX(-50%)",
                zIndex: 10,
                background: "rgba(65, 177, 4, 0.30)",
                borderRadius: "60px",
                padding: "8px 30px",
                display: "flex",
                flexDirection: "column",
                alignItems: "center",
                gap: "4px",
                minWidth: "250px",
                border: "1px solid #297500"
            },
            children: [m.jsx("span", {
                style: {
                    fontSize: "14px",
                    fontWeight: 500,
                    color: "#fff",
                    textAlign: "center"
                },
                children: "You have cashed out"
            }), m.jsxs("div", {
                className: "flex items-center gap-2 justify-between w-full text-2xl ",
                children: [m.jsxs("span", {
                    className: "font-semibold text-[#41B104]",
                    children: [wn(s, 2), "x "]
                }), m.jsxs("span", {
                    style: {
                        fontSize: "18px",
                        fontWeight: 700,
                        color: "#fff",
                        textAlign: "center",
                        background: "#41B104",
                        padding: "6px 12px",
                        borderRadius: "30px"
                    },
                    children: ["Won: ", i ? wn(i, 2) + " L1XP" : wn(Number(o) * Number(s), 2) + " L1XP"]
                })]
            })]
        }), P && m.jsxs("div", {
            style: {
                position: "absolute",
                top: "50%",
                left: "50%",
                transform: "translate(-50%, -50%)",
                zIndex: 90,
                backgroundColor: "#2F3E53",
                borderRadius: "16px",
                padding: "24px 32px",
                display: "flex",
                flexDirection: "column",
                alignItems: "center",
                gap: "16px",
                minWidth: "280px",
                boxShadow: "0 8px 24px rgba(0, 0, 0, 0.4)"
            },
            children: [m.jsx("span", {
                style: {
                    fontSize: "14px",
                    fontWeight: 600,
                    color: "#fff",
                    textTransform: "uppercase",
                    letterSpacing: "0.5px"
                },
                children: d ? "Game Starts in" : "Game Unavailable"
            }), d ? m.jsx("div", {
                style: {
                    width: "100%",
                    height: "8px",
                    backgroundColor: "#1C2837",
                    borderRadius: "4px",
                    overflow: "hidden",
                    position: "relative"
                },
                children: m.jsx("div", {
                    style: {
                        width: `${(k - u) / k * 100}%`,
                        height: "100%",
                        backgroundColor: "#FF7124",
                        borderRadius: "4px",
                        transition: "width 0.1s linear"
                    }
                })
            }) : "", d ? m.jsxs("span", {
                style: {
                    fontSize: "18px",
                    fontWeight: 700,
                    color: "#fff"
                },
                children: [u > 0 ? u : 0, "s"]
            }) : ""]
        }, "waiting-badge"), !P && m.jsxs("div", {
            style: {
                position: "absolute",
                left: "50%",
                top: "30%",
                transform: "translate(-50%,-56%)",
                zIndex: 9,
                width: "100%",
                display: "flex",
                flexDirection: "column",
                alignItems: "center",
                justifyContent: "center"
            },
            children: [m.jsxs("span", {
                style: {
                    fontSize: "6vw",
                    minFontSize: "2rem",
                    fontWeight: 800,
                    color: t ? "#FF3340" : L < 1 ? "#FF7124" : "#FF3340",
                    filter: "brightness(1.09)",
                    transition: "color .24s",
                    height: "90px",
                    textAlign: "right"
                },
                children: [wn(h, 2), "x"]
            }), t && m.jsx("span", {
                style: {
                    fontWeight: 600,
                    letterSpacing: "0.16em",
                    fontSize: "1.9vw",
                    color: "#fff",
                    opacity: .84,
                    marginTop: "0.18em",
                    textShadow: "0 2px 24px #713ed777, 0 0 3px #0008",
                    textTransform: "uppercase",
                    fontFamily: "inherit"
                },
                children: "Crashed"
            })]
        }, "multiplier-display")]
    })
}
  , OTe = () => {
    const [e,t] = V.useState(!1)
      , {balance: r, refreshBalance: s, backendConfig: i} = Hs()
      , [o,a] = V.useState(!1)
      , [l,u] = V.useState(!1)
      , [d,h] = V.useState(0)
      , [p,g] = V.useState([])
      , w = V.useRef(null)
      , b = V.useRef(null)
      , [v,S] = V.useState(!1)
      , [N,_] = V.useState(!1)
      , [I,k] = V.useState(!1)
      , [B,P] = V.useState(!1)
      , [M,R] = V.useState(!1)
      , [L,q] = V.useState(null)
      , [H,j] = V.useState("")
      , A = V.useRef(v)
      , [E,C] = V.useState("0.10")
      , [O,z] = V.useState(3)
      , G = V.useRef(!1)
      , Y = V.useRef(null)
      , $ = V.useRef(null)
      , D = V.useRef(null)
      , U = V.useRef(null)
      , W = V.useRef(null)
      , Q = V.useRef(3)
      , J = V.useRef(!1)
      , ne = V.useRef("0.10")
      , [ie,ae] = V.useState(!1)
      , [xe,ue] = V.useState(null)
      , [ce,me] = V.useState(null)
      , [Ee,Oe] = V.useState(null)
      , mt = V.useRef([])
      , st = Uo()
      , [ot,Ct] = V.useState( () => localStorage.getItem("crashPlaneMuted") === "true")
      , [ct,Xe] = V.useState(!0)
      , [Et] = V.useState(window.localStorage.getItem("userId"))
      , [St,ut] = V.useState(0)
      , cn = () => {
        const De = !ot;
        Ct(De),
        localStorage.setItem("crashPlaneMuted", De.toString())
    }
      , _t = Pc.BASE_URL.play;
    V.useEffect( () => {
        if (mt.current) {
            try {
                mt.current.close()
            } catch (Je) {
                console.warn("Error closing existing subscription:", Je)
            }
            mt.current = null
        }
        if ($.current) {
            try {
                $.current.disconnect()
            } catch (Je) {
                console.warn("Error disconnecting existing transmit:", Je)
            }
            $.current = null
        }
        const De = new lX({
            baseUrl: _t,
            debug: !0
        });
        return $.current = De,
        (async () => {
            try {
                const Je = De.subscription(`game:${Io}`);
                Je.onMessage(Pe => {
                    if (!(!Pe || !Pe.event)) {
                        if (Pe.event.startsWith("game:next:countdown")) {
                            const {remaining: et} = Pe.data || {};
                            ut(et),
                            P(!0)
                        }
                        if (Pe.event.startsWith("game:round:update")) {
                            const {currentMultiplier: et, sessionId: Nt} = Pe.data || {};
                            if (!et)
                                return;
                            const pt = Number(et.replace("x", "")) || 1;
                            P(!1),
                            q(Nt),
                            D.current = pt,
                            A.current = !0,
                            S(!0),
                            _(!1),
                            pt === 1 && (J.current = !1,
                            ae(!1),
                            ue(null),
                            me(null)),
                            G.current || (G.current = !0,
                            u(!0),
                            w.current = requestAnimationFrame(ee));
                            const wt = Number(Q.current);
                            !J.current && Nt === W.current && wt > 1 && pt >= wt && (ue(pt),
                            me(pt * ne.current),
                            ae(!0),
                            J.current = !0,
                            W.current = null,
                            setTimeout( () => {
                                s()
                            }
                            , 2e3));
                            return
                        }
                        if (Pe.event.startsWith("game:session:summary")) {
                            const {sessionId: et, status: Nt, users: pt, totalBetAmount: wt, totalUsers: Rn} = Pe.data || {};
                            q(et),
                            S(Nt === "active"),
                            pt?.some(Jt => Jt.userId === Et) && !J.current && (W.current = et,
                            U.current = !0,
                            A.current = !0,
                            S(!0),
                            _(!1))
                        }
                        if (Pe.event.startsWith("game:round:end")) {
                            const {finalMultiplier: et, sessionId: Nt, clientSeed: pt, serverSeed: wt} = Pe.data || {}
                              , Rn = Number(et.replace("x", "")) || 1;
                            P(!0),
                            D.current = Rn,
                            A.current = !1,
                            _(!0),
                            cancelAnimationFrame(w.current),
                            w.current = null,
                            G.current = !1,
                            u(!1),
                            se(),
                            fe(1);
                            const Zt = new Date().toISOString();
                            g(Jt => {
                                if (Jt.some(Ht => Ht?.sessionId === Nt))
                                    return Jt;
                                const Dt = [{
                                    sessionId: Nt,
                                    clientSeed: pt,
                                    serverSeed: wt,
                                    expectedOutcome: Rn,
                                    timestamp: Zt
                                }, ...Jt];
                                return Dt?.length <= 10 ? Dt : Dt?.slice(0, 10)
                            }
                            ),
                            Nt === W.current && (W.current = null);
                            return
                        }
                    }
                }
                ),
                await Je.create(),
                mt.current = Je
            } catch (Je) {
                console.error(" Failed to setup subscription:", Je)
            }
        }
        )(),
        () => {
            if (mt.current) {
                try {
                    mt.current.close()
                } catch (Je) {
                    console.warn("Error closing subscription:", Je)
                }
                mt.current = null
            }
            $.current && ($.current = null),
            Y.current && (clearTimeout(Y.current),
            Y.current = null)
        }
    }
    , []),
    V.useEffect( () => (B ? (R(!1),
    Y.current && clearTimeout(Y.current),
    Y.current = setTimeout( () => {
        R(!0),
        Y.current = null
    }
    , 9e3)) : (R(!1),
    Y.current && (clearTimeout(Y.current),
    Y.current = null)),
    () => {
        Y.current && (clearTimeout(Y.current),
        Y.current = null)
    }
    ), [B]);
    const ee = () => {
        if (!G.current)
            return;
        const De = D.current || 1;
        h(De),
        w.current = requestAnimationFrame(ee)
    }
      , K = () => new Promise(De => {
        const Me = setInterval( () => {
            st && (clearInterval(Me),
            De(!0))
        }
        , 100)
    }
    )
      , X = async () => {
        st || await K();
        try {
            return await st.executeV3("action")
        } catch (De) {
            return console.log("reCAPTCHA failed:", De),
            null
        }
    }
      , re = async (De, Me) => {
        if (!De)
            return;
        const Je = await X();
        try {
            const Pe = await _Te({
                gameId: Io,
                sessionId: De,
                cashoutMultiplier: Me
            }, Je);
            Pe?.status === "success" && (ue(Me),
            me(Pe?.data?.payout),
            ae(!0),
            J.current = !0,
            W.current = null,
            s())
        } catch (Pe) {
            console.log(Pe)
        }
    }
      , se = () => {
        cancelAnimationFrame(w.current),
        w.current = null,
        u(!1),
        G.current = !1,
        b.current = null
    }
      , fe = De => {
        se(),
        u(!0),
        G.current = !0,
        h(De),
        b.current = null,
        w.current = requestAnimationFrame(ee)
    }
      , ge = async () => {
        try {
            if (!E || isNaN(Number(E)) || Number(E) <= 0)
                return j("Enter a valid bet amount to continue");
            j(""),
            k(!0);
            const De = await st.executeV3("action");
            let Me = {
                betAmount: E,
                gameId: Io
            };
            ct && O && (Me.autoCashoutMultiplier = O);
            const Je = await CTe(Me, De);
            if (Je.status !== "success") {
                Ze.error(Je.message || "Error while placing bet");
                return
            }
            W.current = Je.data.sessionId,
            U.current = !0,
            A.current = !0,
            S(!0),
            _(!1),
            s(),
            ATe("crashBetSession", {
                sessionId: Je.data.sessionId,
                betAmount: E,
                gameId: Io,
                autoCashoutMultiplier: O,
                userId: Et
            })
        } catch (De) {
            console.log(De)
        } finally {
            k(!1)
        }
    }
    ;
    V.useEffect( () => {
        _e(),
        Ve()
    }
    , []);
    const _e = async () => {
        try {
            const De = await kTe(1, 10, Io);
            De?.status === "success" ? g(De?.data?.sessions?.data) : g([])
        } catch (De) {
            console.log(De)
        }
    }
      , Qe = (De, Me) => {
        const Je = EG("crashBetSession");
        if (Je?.userId === Et) {
            const Pe = Je?.sessionId === De
              , et = Je?.sessionId === Me
              , Nt = Je?.betAmount
              , pt = Je?.autoCashoutMultiplier;
            return {
                isActiveSession: Pe,
                isNextSession: et,
                betAmount: Nt,
                autoCashoutMultiplier: pt
            }
        }
        return {
            status: !1
        }
    }
      , Ve = async () => {
        try {
            const De = await DTe(Io);
            if (console.log(" ~ checkUserSession ~ res:", De),
            De?.status === "success") {
                const Me = window.localStorage.getItem("userId") || ""
                  , Je = De?.data?.users
                  , Pe = Je?.some(Rn => Rn.userId === Me)
                  , et = Je?.find(Rn => Rn.userId === Me)
                  , Nt = De?.data?.sessionId
                  , pt = De?.data?.nextSessionId
                  , wt = Qe(Nt, pt);
                console.log(" ~ checkUserSession ~ betSession:", wt),
                (Pe || wt?.isNextSession) && (W.current = wt?.isActiveSession ? Nt : pt,
                U.current = !0,
                A.current = !0,
                et?.result === "win" && (ae(!0),
                J.current = !0,
                me(Xo(et?.crashPoint * et?.betAmount, 2))),
                S(!0),
                _(!1),
                C(wt?.betAmount),
                ne.current = wt?.betAmount,
                wt?.autoCashoutMultiplier && (z(wt?.autoCashoutMultiplier),
                Q.current = wt?.autoCashoutMultiplier,
                Xe(!0)))
            }
        } catch (De) {
            console.log(De)
        }
    }
      , jt = De => {
        let Me = De.target.value;
        if (Me === "" || Me === null) {
            C(""),
            ne.current = "";
            return
        }
        if (!/^\d*\.?\d*$/.test(Me))
            return;
        if (Me.startsWith(".") && (Me = "0" + Me),
        Me.endsWith(".")) {
            C(Me),
            ne.current = Me;
            return
        }
        let Je = Number(Me);
        Je < 0 && (Je = 0),
        C(Me),
        ne.current = Me,
        Je > 0 && j("")
    }
      , dt = De => {
        let Me = De.target.value;
        if (Me === "") {
            z(""),
            Q.current = "";
            return
        }
        if (!/^\d*\.?\d*$/.test(Me))
            return;
        if (Me.startsWith(".") && (Me = "0" + Me),
        Me.endsWith(".")) {
            z(Me),
            Q.current = Me;
            return
        }
        const Je = Number(Me);
        z(Me),
        Q.current = Je
    }
      , Qt = () => H || (M ? "Bets Locked" : I ? "Submitting..." : G.current && L === W.current && !J.current && !B ? "Cash Out" : G.current && W.current && L !== W.current || G.current && W.current && (L !== W.current || J.current) || B && W.current && (L === W.current || J.current) || B && W.current ? "Bet Placed (Next Round)" : G.current && (L !== W.current || J.current) ? "Bet Next Round" : G.current && W.current && L === W.current ? "Bet Next Round " : "Place Bet")
      , Nn = () => At ? "bg-[#516076] text-white" : G.current && L === W.current && !ie ? "bg-[#FFC12C] text-black" : G.current && W.current && L !== W.current ? "bg-[#FF0C43] text-white" : "cssgradient"
      , ln = () => {
        if (W?.current)
            return !1;
        const De = !ct;
        Xe(De),
        De ? (Q.current = 3,
        z(3)) : (Q.current = null,
        z(""))
    }
      , $t = De => {
        if (W.current)
            return !1;
        const Me = Xo((r?.l1xsBalance || 0) * (De / 100), 4);
        C(Me),
        ne.current = Me
    }
      , $e = ct ? Number(O) < 1.2 : !1
      , Ue = Number(E) < .1
      , qe = Number(E) > r?.l1xsBalance && L !== W.current
      , At = V.useMemo( () => I || M || G.current && W.current && L !== W.current || B && W.current && (L === W.current || J.current) || $e || Ue || qe || !Number(i?.CRASH_ENABLED) || B && W.current, [I, M, G, W, L, $e, B, Ue, qe, i?.CRASH_ENABLED]);
    return m.jsxs("div", {
        className: "md:bg-[#263446] md:rounded-3xl md:p-4",
        children: [m.jsxs("div", {
            className: "grid grid-cols-12 md:gap-6",
            children: [m.jsx("div", {
                className: "col-span-12 lg:col-span-8 2xl:col-span-9",
                children: m.jsxs("div", {
                    className: "md:bg-[#1C2837] md:rounded-2xl md:p-4",
                    children: [m.jsxs("div", {
                        className: "relative historyArea mb-3",
                        children: [m.jsx("ul", {
                            className: `bg-[#2F3E53] rounded-xl p-3 flex items-center gap-2 relative ${o ? "flex-wrap pr-20" : "overflow-hidden"}`,
                            children: p?.map( (De, Me) => {
                                const Je = parseFloat(De?.expectedOutcome) || 0
                                  , Pe = Je < 1.99 ? "#118CD0" : Je < 9.99 ? "#864AD0" : "#AC1EA2";
                                return m.jsxs("li", {
                                    onClick: () => {
                                        Oe(De),
                                        t(!0)
                                    }
                                    ,
                                    className: "py-1 px-3 rounded-md font-medium text-sm cursor-pointer",
                                    style: {
                                        backgroundColor: Pe
                                    },
                                    children: [Xo(De?.expectedOutcome, 2), "x"]
                                }, Me)
                            }
                            )
                        }), m.jsx("div", {
                            className: "absolute right-0 top-0 single-gradient w-16 flex items-center justify-center p-2 rounded-tr-xl rounded-br-xl md:hidden",
                            children: m.jsx("button", {
                                className: "flex flex-col items-end",
                                onClick: () => a(De => !De),
                                children: m.jsxs("a", {
                                    href: "#",
                                    className: "bg-[#1C2837] w-10 h-10 rounded-[30px] flex items-center justify-center",
                                    children: [" ", m.jsx("svg", {
                                        xmlns: "http://www.w3.org/2000/svg",
                                        fill: "none",
                                        viewBox: "0 0 24 24",
                                        strokeWidth: 1.5,
                                        stroke: "currentColor",
                                        className: "w-7",
                                        children: m.jsx("path", {
                                            strokeLinecap: "round",
                                            strokeLinejoin: "round",
                                            d: "M12 6v6h4.5m4.5 0a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"
                                        })
                                    })]
                                })
                            })
                        })]
                    }), m.jsx("div", {
                        className: "crashArea",
                        children: m.jsx(RTe, {
                            progressValue: parseFloat(d?.toFixed(2)),
                            running: l,
                            crashed: N,
                            hasCashedOut: ie,
                            cashoutMultiplier: xe,
                            winAmount: ce,
                            betAmount: E,
                            isBufferTime: B,
                            isMuted: ot,
                            waitingProgress: St,
                            isGameActive: !(i?.CRASH_ENABLED === "0" || i?.CRASH_ENABLED === 0)
                        })
                    })]
                })
            }), m.jsx("div", {
                className: "col-span-12 lg:col-span-4 2xl:col-span-3",
                children: m.jsxs("div", {
                    className: "bg-[#1C2837] p-4 md:rounded-2xl md:mx-0",
                    children: [m.jsxs("div", {
                        className: "flex items-start justify-start gap-8 mb-6",
                        children: [m.jsxs("h3", {
                            className: "lemon-font items-center flex gap-2 text-xl md:text-3xl font-bold justify-center",
                            children: ["Crash ", m.jsx("img", {
                                src: ETe,
                                className: "h-8 md:h-11"
                            }), " Cash"]
                        }), m.jsx("div", {
                            className: "relative top-0",
                            children: m.jsx("button", {
                                className: `sound-btn ${ot ? "muted" : ""}`,
                                onClick: cn,
                                title: ot ? "Unmute All Audio" : "Mute All Audio",
                                "aria-label": ot ? "Unmute All Audio" : "Mute All Audio",
                                children: ot ? m.jsx("svg", {
                                    xmlns: "http://www.w3.org/2000/svg",
                                    fill: "none",
                                    viewBox: "0 0 24 24",
                                    strokeWidth: 1.5,
                                    stroke: "currentColor",
                                    className: "size-6",
                                    children: m.jsx("path", {
                                        strokeLinecap: "round",
                                        strokeLinejoin: "round",
                                        d: "M17.25 9.75 19.5 12m0 0 2.25 2.25M19.5 12l2.25-2.25M19.5 12l-2.25 2.25m-10.5-6 4.72-4.72a.75.75 0 0 1 1.28.53v15.88a.75.75 0 0 1-1.28.53l-4.72-4.72H4.51c-.88 0-1.704-.507-1.938-1.354A9.009 9.009 0 0 1 2.25 12c0-.83.112-1.633.322-2.396C2.806 8.756 3.63 8.25 4.51 8.25H6.75Z"
                                    })
                                }) : m.jsx("svg", {
                                    xmlns: "http://www.w3.org/2000/svg",
                                    fill: "none",
                                    viewBox: "0 0 24 24",
                                    strokeWidth: 1.5,
                                    stroke: "currentColor",
                                    className: "size-6",
                                    children: m.jsx("path", {
                                        strokeLinecap: "round",
                                        strokeLinejoin: "round",
                                        d: "M19.114 5.636a9 9 0 0 1 0 12.728M16.463 8.288a5.25 5.25 0 0 1 0 7.424M6.75 8.25l4.72-4.72a.75.75 0 0 1 1.28.53v15.88a.75.75 0 0 1-1.28.53l-4.72-4.72H4.51c-.88 0-1.704-.507-1.938-1.354A9.009 9.009 0 0 1 2.25 12c0-.83.112-1.633.322-2.396C2.806 8.756 3.63 8.25 4.51 8.25H6.75Z"
                                    })
                                })
                            })
                        })]
                    }), m.jsxs("div", {
                        className: "",
                        children: [m.jsxs("div", {
                            className: "flex items-center justify-between mb-1",
                            children: [m.jsx("label", {
                                className: "",
                                children: "Bet Amount"
                            }), m.jsxs("label", {
                                className: "",
                                children: ["Balance: ", m.jsxs("span", {
                                    className: "font-semibold",
                                    children: [Xo(r?.l1xsBalance, 2), " L1XP"]
                                })]
                            })]
                        }), m.jsxs("div", {
                            className: "relative",
                            children: [m.jsx("img", {
                                src: xG,
                                className: "absolute left-3 top-1/2 -translate-y-1/2"
                            }), m.jsx("input", {
                                value: E === "" || E === null ? "" : E,
                                onChange: jt,
                                disabled: W?.current,
                                placeholder: "0.00",
                                className: "border-1 border-transparent focus:border-[#EE5B35] bg-[#2F3E53] text-2xl font-semibold text-white rounded-xl pl-11 pr-25 py-3 w-full outline-none"
                            }), m.jsxs("div", {
                                className: "flex items-center gap-2 absolute right-1.5 top-1/2 -translate-y-1/2",
                                children: [m.jsx("button", {
                                    onClick: () => C(De => {
                                        let Me = 1;
                                        De < 1 && (Me = .1);
                                        const Je = (De || 0) - Me
                                          , Pe = Je <= 0 ? "" : parseFloat(Je).toFixed(4);
                                        return ne.current = Pe,
                                        Pe
                                    }
                                    ),
                                    disabled: W?.current,
                                    className: "bg-[#1C2837] w-9 h-9 rounded-md flex items-center justify-center flex-col cursor-pointer hover:bg-[#516076] hover:scale-105 active:scale-95 transition-all duration-150 ease-out",
                                    children: m.jsx("svg", {
                                        xmlns: "http://www.w3.org/2000/svg",
                                        fill: "none",
                                        viewBox: "0 0 24 24",
                                        strokeWidth: 1.5,
                                        stroke: "currentColor",
                                        className: "size-6",
                                        children: m.jsx("path", {
                                            strokeLinecap: "round",
                                            strokeLinejoin: "round",
                                            d: "M5 12h14"
                                        })
                                    })
                                }), m.jsx("button", {
                                    onClick: () => {
                                        j(""),
                                        C(De => {
                                            const Me = Number(De) || 0
                                              , Je = Number(r?.l1xsBalance) || 0;
                                            let Pe = Me < 1 ? .1 : 1;
                                            const et = Number((Me + Pe).toFixed(4));
                                            if (et > Je)
                                                return De;
                                            const Nt = et <= 0 ? "" : et.toFixed(4);
                                            return ne.current = Nt,
                                            Nt
                                        }
                                        )
                                    }
                                    ,
                                    disabled: W?.current,
                                    className: "bg-[#1C2837] w-9 h-9 rounded-md flex items-center justify-center flex-col cursor-pointer hover:bg-[#516076] hover:scale-105 active:scale-95 transition-all duration-150 ease-out",
                                    children: m.jsx("svg", {
                                        xmlns: "http://www.w3.org/2000/svg",
                                        fill: "none",
                                        viewBox: "0 0 24 24",
                                        strokeWidth: 1.5,
                                        stroke: "currentColor",
                                        className: "size-6",
                                        children: m.jsx("path", {
                                            strokeLinecap: "round",
                                            strokeLinejoin: "round",
                                            d: "M12 4.5v15m7.5-7.5h-15"
                                        })
                                    })
                                })]
                            })]
                        }), m.jsx("div", {
                            className: "text-[#e20202]",
                            children: Ue ? "Bet amount must be greater than or equal to 0.10." : ""
                        }), m.jsxs("ul", {
                            className: "flex items-center gap-2 justify-between mt-3 ",
                            children: [m.jsx("li", {
                                onClick: () => $t(10),
                                className: "bg-[#2F3E53] hover:bg-white hover:text-black py-1 px-2 xl:px-3 rounded-md w-full font-semibold text-center cursor-pointer",
                                children: "10%"
                            }), m.jsx("li", {
                                onClick: () => $t(25),
                                className: "bg-[#2F3E53] hover:bg-white hover:text-black py-1 px-2 xl:px-3 rounded-md w-full font-semibold text-center cursor-pointer",
                                children: "25%"
                            }), m.jsx("li", {
                                onClick: () => $t(50),
                                className: "bg-[#2F3E53] hover:bg-white hover:text-black py-1 px-2 xl:px-3 rounded-md w-full font-semibold text-center cursor-pointer",
                                children: "50%"
                            }), m.jsx("li", {
                                onClick: () => $t(75),
                                className: "bg-[#2F3E53] hover:bg-white hover:text-black py-1 px-2 xl:px-3 rounded-md w-full font-semibold text-center cursor-pointer",
                                children: "75%"
                            }), m.jsx("li", {
                                onClick: () => $t(100),
                                className: "bg-[#2F3E53] hover:bg-white hover:text-black py-1 px-2 xl:px-3 rounded-md w-full font-semibold text-center cursor-pointer",
                                children: "MAX"
                            })]
                        })]
                    }), m.jsxs("div", {
                        className: "mb-5",
                        children: [m.jsxs("div", {
                            className: "flex items-center justify-between mb-2 mt-8",
                            children: [m.jsx("label", {
                                className: "",
                                children: "Auto cashout at"
                            }), m.jsxs("label", {
                                className: "relative inline-block h-7 w-[48px] cursor-pointer rounded-full bg-[#2F3E53] transition [-webkit-tap-highlight-color:_transparent] has-[:checked]:bg-[#1976D2]",
                                children: [m.jsx("input", {
                                    checked: ct,
                                    onChange: ln,
                                    type: "checkbox",
                                    id: "AcceptConditions",
                                    className: "peer sr-only"
                                }), m.jsx("span", {
                                    className: "absolute inset-y-0 start-0 m-1 size-5 rounded-full bg-[#516076] ring-[5px] ring-inset ring-[#516076] transition-all peer-checked:start-5 bg-[#2F3E53] peer-checked:w-5 peer-checked:bg-white peer-checked:ring-transparent"
                                })]
                            })]
                        }), m.jsxs("div", {
                            className: `relative transition-opacity duration-200 ${ct ? "" : "opacity-50 pointer-events-none"}`,
                            children: [m.jsx("input", {
                                type: "text",
                                value: O,
                                placeholder: "Enter multiplier E.g. 1.5",
                                onChange: dt,
                                disabled: !ct || W?.current,
                                className: `border-1 border-transparent focus:border-[#EE5B35] bg-[#2F3E53]
             text-xl font-semibold text-white rounded-xl pl-4 pr-25 py-2 w-full outline-none disabled:opacity-50 disabled:cursor-not-allowed`
                            }), m.jsxs("div", {
                                className: "flex items-center gap-2 absolute right-1.5 top-[5px] ",
                                children: [m.jsx("button", {
                                    onClick: () => z(De => De <= 1 ? (Q.current = Xo(De, 1),
                                    Xo(De, 1)) : (Q.current = Xo(De - .1, 1),
                                    Xo(De - .1, 1))),
                                    disabled: !ct || W?.current,
                                    className: "bg-[#1C2837] w-9 h-9 rounded-md flex items-center justify-center flex-col cursor-pointer hover:bg-[#516076] hover:scale-105 active:scale-95 transition-all duration-150 ease-out disabled:opacity-50 disabled:cursor-not-allowed disabled:hover:bg-[#1C2837] disabled:hover:scale-100",
                                    children: m.jsx("svg", {
                                        xmlns: "http://www.w3.org/2000/svg",
                                        fill: "none",
                                        viewBox: "0 0 24 24",
                                        strokeWidth: 1.5,
                                        stroke: "currentColor",
                                        className: "size-6",
                                        children: m.jsx("path", {
                                            strokeLinecap: "round",
                                            strokeLinejoin: "round",
                                            d: "M5 12h14"
                                        })
                                    })
                                }), m.jsx("button", {
                                    onClick: () => z(De => (Q.current = Xo(Number(De) + .1, 1),
                                    Xo(Number(De) + .1, 1))),
                                    disabled: !ct || W?.current,
                                    className: "bg-[#1C2837] w-9 h-9 rounded-md flex items-center justify-center flex-col cursor-pointer hover:bg-[#516076] hover:scale-105 active:scale-95 transition-all duration-150 ease-out disabled:opacity-50 disabled:cursor-not-allowed disabled:hover:bg-[#1C2837] disabled:hover:scale-100",
                                    children: m.jsx("svg", {
                                        xmlns: "http://www.w3.org/2000/svg",
                                        fill: "none",
                                        viewBox: "0 0 24 24",
                                        strokeWidth: 1.5,
                                        stroke: "currentColor",
                                        className: "size-6",
                                        children: m.jsx("path", {
                                            strokeLinecap: "round",
                                            strokeLinejoin: "round",
                                            d: "M12 4.5v15m7.5-7.5h-15"
                                        })
                                    })
                                })]
                            })]
                        }), m.jsx("div", {
                            className: `text-[#e20202] transition-opacity duration-200 ${ct ? "" : "opacity-50"}`,
                            children: $e ? "Auto cashout must be greater then or equal to 1.2" : ""
                        })]
                    }), m.jsx("button", {
                        className: `py-3 px-4 rounded-4xl w-full text-center text-base font-medium cursor-pointer hover:scale-105 hover:brightness-110 transition-all duration-300 ease-in-out ${Nn()}`,
                        onClick: () => {
                            G.current && L === W.current && !J.current ? re(W.current, D.current) : ge()
                        }
                        ,
                        disabled: At,
                        children: Qt()
                    })]
                })
            })]
        }), m.jsx(TTe, {
            isOpen: e,
            onClose: () => t(!1),
            data: Ee
        })]
    })
}
;
function PTe() {
    return m.jsx(m.Fragment, {
        children: m.jsx(cL, {
            children: m.jsx(Vn, {
                path: "/",
                element: m.jsx(OTe, {})
            })
        })
    })
}
const jTe = () => {
    const {showGameHistory: n, setShowGameHistory: e, history: t, isFullscreen: r, toggleFullscreen: s, gameHistoryRef: i} = $x(Io);
    return m.jsx("div", {
        className: r ? "" : "py-4 md:py-10 md:px-4",
        children: m.jsxs("div", {
            className: `game-area ${r ? "" : "md:p-4 md:border md:border-white md:rounded-2xl"}  transition-all duration-300 ${r ? "fixed inset-0 z-[9999] w-screen h-screen m-0 p-2 bg-black" : "relative bg-black/50"}`,
            style: r ? {
                top: 0,
                left: 0,
                right: 0,
                bottom: 0
            } : {},
            children: [!r && m.jsxs("div", {
                className: "flex items-center justify-between md:mb-4 p-3 md:p-0",
                children: [m.jsxs("div", {
                    className: "flex items-center gap-4",
                    children: [m.jsx("button", {
                        onClick: () => navigate(-1),
                        className: "bg-[#314258] w-8 h-8 md:w-10 md:h-10 rounded-full flex items-center justify-center hover:bg-[#3d5269] transition-colors",
                        children: m.jsx("svg", {
                            xmlns: "http://www.w3.org/2000/svg",
                            fill: "none",
                            viewBox: "0 0 24 24",
                            strokeWidth: 1.5,
                            stroke: "currentColor",
                            className: "size-5 md:size-6",
                            children: m.jsx("path", {
                                strokeLinecap: "round",
                                strokeLinejoin: "round",
                                d: "M10.5 19.5 3 12m0 0 7.5-7.5M3 12h18"
                            })
                        })
                    }), m.jsxs("h3", {
                        className: "lemon-font items-center flex gap-2 text-xl md:text-3xl font-bold",
                        children: ["Crash ", m.jsx("img", {
                            src: xTe,
                            className: "h-8 md:h-11"
                        }), " Cash"]
                    })]
                }), m.jsxs("div", {
                    className: "flex items-center gap-2",
                    children: [m.jsxs("button", {
                        onClick: () => e(!0),
                        className: "bg-white rounded-2xl text-black px-3 md:px-4 py-1.5 md:py-2 flex items-center text-sm md:text-base cursor-pointer gap-1.5 hover:bg-gray-100 transition-colors",
                        children: [m.jsx("svg", {
                            xmlns: "http://www.w3.org/2000/svg",
                            fill: "none",
                            viewBox: "0 0 24 24",
                            strokeWidth: 1.5,
                            stroke: "currentColor",
                            className: "size-4 md:size-6",
                            children: m.jsx("path", {
                                strokeLinecap: "round",
                                strokeLinejoin: "round",
                                d: "M12 6v6h4.5m4.5 0a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"
                            })
                        }), "My Game History"]
                    }), m.jsx("button", {
                        onClick: s,
                        className: "w-10 h-10 rounded-full bg-black/50 hidden md:flex items-center justify-center hover:bg-black/70 transition-colors",
                        title: "Enter Fullscreen",
                        children: m.jsx("svg", {
                            xmlns: "http://www.w3.org/2000/svg",
                            fill: "none",
                            viewBox: "0 0 24 24",
                            strokeWidth: 1.5,
                            stroke: "currentColor",
                            className: "size-6",
                            children: m.jsx("path", {
                                strokeLinecap: "round",
                                strokeLinejoin: "round",
                                d: "M3.75 3.75v4.5m0-4.5h4.5m-4.5 0L9 9M3.75 20.25v-4.5m0 4.5h4.5m-4.5 0L9 15M20.25 3.75h-4.5m4.5 0v4.5m0-4.5L15 9m5.25 11.25h-4.5m4.5 0v-4.5m0 4.5L15 15"
                            })
                        })
                    })]
                })]
            }), m.jsxs("div", {
                className: "play-area rounded-2xl overflow-hidden relative ",
                children: [r && m.jsx("div", {
                    className: "absolute top-4 right-4 z-50",
                    children: m.jsx("button", {
                        onClick: s,
                        className: "w-12 h-12 rounded-full bg-black/70 flex items-center justify-center hover:bg-black/90 transition-colors border-2 border-white/20",
                        title: "Exit Fullscreen (ESC)",
                        children: m.jsx("svg", {
                            xmlns: "http://www.w3.org/2000/svg",
                            fill: "none",
                            viewBox: "0 0 24 24",
                            strokeWidth: 2,
                            stroke: "currentColor",
                            className: "size-6 text-white",
                            children: m.jsx("path", {
                                strokeLinecap: "round",
                                strokeLinejoin: "round",
                                d: "M9 9V4.5M9 9H4.5M9 9 3.75 3.75M9 15v4.5M9 15H4.5M9 15l-5.25 5.25M15 9h4.5M15 9V4.5M15 9l5.25-5.25M15 15h4.5M15 15v4.5m0-4.5 5.25 5.25"
                            })
                        })
                    })
                }), m.jsx(PTe, {})]
            }), n && !r && m.jsxs("div", {
                ref: i,
                className: "gameHistory bg-black/90 p-4 border border-white rounded-2xl absolute top-0 right-0 max-w-[500px] w-full z-10 h-full overflow-y-auto",
                children: [m.jsxs("div", {
                    className: "flex items-center justify-start gap-2 mb-4",
                    children: [m.jsx("button", {
                        onClick: () => e(!1),
                        className: "rounded-2xl text-white flex items-center text-base cursor-pointer gap-1.5",
                        children: m.jsx("svg", {
                            xmlns: "http://www.w3.org/2000/svg",
                            fill: "none",
                            viewBox: "0 0 24 24",
                            strokeWidth: 1.5,
                            stroke: "currentColor",
                            className: "size-6",
                            children: m.jsx("path", {
                                strokeLinecap: "round",
                                strokeLinejoin: "round",
                                d: "M15.75 19.5 8.25 12l7.5-7.5"
                            })
                        })
                    }), m.jsx("h3", {
                        className: "text-white text-xl font-bold",
                        children: "Game History"
                    })]
                }), m.jsxs("div", {
                    className: "flex flex-col gap-2",
                    children: [m.jsx("div", {
                        className: "grid grid-cols-3 px-4 pb-1 uppercase opacity-70 text-sm"
                    }), t?.map( (o, a) => {
                        const l = o.outcomeValue ? Af(o.outcomeValue) : "0.00"
                          , u = o.winAmount ? Af(o.winAmount) : "0.00"
                          , d = o.betAmount ? Af(o.betAmount) : "0.00"
                          , h = new Date(o?.createdAt)
                          , p = h.toLocaleString("en-IN", {
                            month: "short"
                        }) + " " + h.toLocaleString("en-IN", {
                            day: "2-digit"
                        }) + ", " + h.toLocaleString("en-IN", {
                            hour: "2-digit",
                            minute: "2-digit",
                            hour12: !0
                        }).toLowerCase();
                        return m.jsxs("div", {
                            className: "p-3 rounded-lg text-white text-sm space-y-1 bg-[#1e2840]",
                            children: [m.jsxs("div", {
                                className: "flex justify-between items-center",
                                children: [m.jsxs("span", {
                                    children: ["Crashed: ", l, "x ", l === "1.00" && ""]
                                }), m.jsxs("span", {
                                    className: o.won ? "text-green-400 font-semibold" : "text-red-400 font-semibold",
                                    children: ["Cashed: ", u]
                                }), m.jsx("span", {
                                    className: o.won ? "text-green-400 font-semibold" : "text-red-400 font-semibold",
                                    children: d
                                })]
                            }), m.jsxs("div", {
                                className: "flex justify-between",
                                children: [m.jsxs("span", {
                                    className: "text-xs text-gray-400 font-mono",
                                    children: ["Date : ", p || "N/A"]
                                }), m.jsxs("span", {
                                    className: "text-xs text-gray-400 font-mono",
                                    children: ["gameID: ", zo(o.sessionId)]
                                })]
                            })]
                        }, a)
                    }
                    )]
                })]
            })]
        })
    })
}
  , LTe = "/assets/email-verified-successfully-BbZxRG2t.png"
  , FTe = ({isOpen: n, emailAddress: e}) => {
    if (!n)
        return null;
    const t = kr();
    return m.jsxs("div", {
        className: "",
        children: [m.jsx("div", {
            className: "bg-[#27364b] max-w-lg w-full rounded-3xl absolute top-12 left-0 right-0 mx-auto z-50 text-white overflow-hidden",
            children: m.jsxs("div", {
                className: "bg-[#2B3A4F] py-18 px-8 relative",
                children: [m.jsx("div", {
                    className: "cursor-pointer w-12 h-12 absolute right-1 top-1 flex items-center justify-center flex-col opacity-55",
                    onClick: () => {
                        t("/login")
                    }
                    ,
                    children: m.jsx("svg", {
                        xmlns: "http://www.w3.org/2000/svg",
                        fill: "none",
                        viewBox: "0 0 24 24",
                        strokeWidth: 1.5,
                        stroke: "currentColor",
                        className: "size-6",
                        children: m.jsx("path", {
                            strokeLinecap: "round",
                            strokeLinejoin: "round",
                            d: "M6 18 18 6M6 6l12 12"
                        })
                    })
                }), m.jsxs("div", {
                    className: "verified-email-successfully",
                    children: [m.jsxs("div", {
                        className: "text-center",
                        children: [m.jsx("div", {
                            className: "mb-4 text-center",
                            children: m.jsx("img", {
                                src: LTe,
                                className: "mx-auto"
                            })
                        }), m.jsx("h3", {
                            className: "text-3xl font-medium text-center mb-4",
                            children: "Email verified successfully"
                        }), m.jsxs("p", {
                            className: "text-sm font-light",
                            children: ["Use your email ", m.jsx(Us, {
                                to: "#",
                                className: "inline-block text-[#FF6717]",
                                children: e
                            }), " to login and start playing"]
                        })]
                    }), m.jsx("div", {
                        className: "mt-8 text-center",
                        children: m.jsx("button", {
                            onClick: () => {
                                t("/login")
                            }
                            ,
                            className: "cursor-pointer inline-flex items-center justify-between gap-3 btn-clr py-4 px-18 rounded-xl text-base font-semibold hover:brightness-90 hover:scale-[1.02] transition-all duration-200",
                            children: "Login Now"
                        })
                    })]
                })]
            })
        }), m.jsx("div", {
            className: "fixed bg-black/70 w-full h-full top-0 left-0 z-40 backdrop-blur-lg"
        })]
    })
}
  , UTe = () => {
    const [n,e] = V.useState(!1)
      , {search: t} = Ti()
      , r = new URLSearchParams(t)
      , s = kr()
      , i = r.get("email")
      , o = r.get("verificationCode")
      , a = async () => {
        try {
            (await T5e({
                email: i,
                verificationCode: o
            }))?.status === "success" && e(!0)
        } catch {}
    }
    ;
    return V.useEffect( () => {
        i && o && a()
    }
    , [i, o]),
    m.jsx("div", {
        className: "",
        children: n ? m.jsx(FTe, {
            isOpen: !0
        }) : m.jsxs(m.Fragment, {
            children: [m.jsx("div", {
                className: "bg-[#27364b] max-w-lg w-full rounded-3xl absolute top-12 left-0 right-0 mx-auto z-50 text-white overflow-hidden",
                children: m.jsxs("div", {
                    className: "bg-[#2B3A4F] py-18 px-8 relative",
                    children: [m.jsx("div", {
                        className: "cursor-pointer w-12 h-12 absolute right-1 top-1 flex items-center justify-center flex-col opacity-55",
                        onClick: () => {
                            s("/login")
                        }
                        ,
                        children: m.jsx("svg", {
                            xmlns: "http://www.w3.org/2000/svg",
                            fill: "none",
                            viewBox: "0 0 24 24",
                            strokeWidth: 1.5,
                            stroke: "currentColor",
                            className: "size-6",
                            children: m.jsx("path", {
                                strokeLinecap: "round",
                                strokeLinejoin: "round",
                                d: "M6 18 18 6M6 6l12 12"
                            })
                        })
                    }), m.jsxs("div", {
                        className: "verify-email-address",
                        children: [m.jsxs("div", {
                            className: "text-center",
                            children: [m.jsx("div", {
                                className: "mb-4 text-center",
                                children: m.jsx("img", {
                                    src: rq,
                                    className: "mx-auto"
                                })
                            }), m.jsx("h3", {
                                className: "text-3xl font-medium text-center mb-4",
                                children: "Verify your email address is In progess"
                            })]
                        }), m.jsx("div", {
                            className: "mt-8 text-center"
                        })]
                    })]
                })
            }), m.jsx("div", {
                className: "fixed bg-black/70 w-full h-full top-0 left-0 z-40 backdrop-blur-lg"
            })]
        })
    })
}
  , zTe = () => {
    const [n,e] = V.useState("processing")
      , t = 6e4
      , r = l => {
        e(l)
    }
      , {merchantOrderId: s} = E0()
      , i = V.useRef(null)
      , o = () => {
        i.current && (clearInterval(i.current),
        i.current = null)
    }
    ;
    V.useEffect( () => {
        if (o(),
        !!s)
            return a(s),
            i.current = setInterval( () => {
                a(s)
            }
            , t),
            o
    }
    , [s]);
    const a = async l => {
        try {
            const u = await WV(l);
            if (new Promise(d => setTimeout(d, 2e3)),
            u?.status === "success" && u?.data) {
                const d = u?.data?.status;
                d === "FINISHED" ? (r("success"),
                o()) : d === "PAY_FAIL" ? (r("failed"),
                o()) : r("processing")
            } else
                Ze.error(u?.message || "Failed to fetch payment status")
        } catch {
            Ze.error("An error occurred while fetching payment status")
        }
    }
    ;
    return m.jsxs(m.Fragment, {
        children: [n === "processing" && m.jsx("div", {
            className: "modalForPay fixed inset-0 z-50 flex items-center justify-center bg-black/70 backdrop-blur-sm ",
            children: m.jsx("div", {
                className: "payment-modal-container bg-[#1A2332]  w-full max-w-full relative overflow-hidden",
                children: m.jsx("div", {
                    className: "payment-modal-stage min-h-[100vh] flex flex-col gap-6 ",
                    children: m.jsxs("div", {
                        "data-stage": "processing",
                        className: "flex-1 flex flex-col justify-center items-center text-white text-center gap-4",
                        children: [m.jsx("div", {
                            className: "w-16 h-16 border-4 border-[#FFC12C] border-t-transparent rounded-full animate-spin"
                        }), m.jsxs("div", {
                            children: [m.jsx("h3", {
                                className: "text-xl font-semibold",
                                children: "Processing"
                            }), m.jsx("p", {
                                className: "text-sm text-[#99B0CF] mt-2 max-w-md",
                                children: "We're verifying your payment and confirming the on-chain transaction."
                            })]
                        })]
                    })
                })
            })
        }), n === "success" && m.jsx("div", {
            className: "modalForPay fixed inset-0 z-50 flex items-center justify-center bg-black/70 backdrop-blur-sm",
            children: m.jsx("div", {
                className: "payment-modal-container bg-[#1A2332] w-full max-w-full relative overflow-hidden",
                children: m.jsx("div", {
                    className: "payment-modal-stage min-h-[100vh] flex flex-col gap-6 ",
                    children: m.jsxs("div", {
                        "data-stage": "success",
                        className: "flex-1 flex flex-col justify-center items-center text-white text-center gap-4",
                        children: [m.jsxs("div", {
                            className: "relative w-16 h-16",
                            children: [m.jsx("div", {
                                className: "absolute inset-0 rounded-full bg-emerald-400/20 animate-ping"
                            }), m.jsx("div", {
                                className: "relative w-full h-full rounded-full bg-emerald-500/20 border border-emerald-300 flex items-center justify-center",
                                children: m.jsx("span", {
                                    className: "text-2xl text-emerald-300",
                                    children: ""
                                })
                            })]
                        }), m.jsxs("div", {
                            children: [m.jsx("h3", {
                                className: "text-2xl font-semibold",
                                children: "Payment Successful"
                            }), m.jsx("p", {
                                className: "text-sm text-white/70 mt-2 max-w-xs mx-auto",
                                children: "We've confirmed your payment. You can continue once you're ready."
                            })]
                        })]
                    })
                })
            })
        }), n === "failed" && m.jsx("div", {
            className: "modalForPay fixed inset-0 z-50 flex items-center justify-center bg-black/70 backdrop-blur-sm",
            children: m.jsx("div", {
                className: "payment-modal-container bg-[#1A2332] w-full max-w-full relative overflow-hidden",
                children: m.jsx("div", {
                    className: "payment-modal-stage min-h-[100vh] flex flex-col gap-6 ",
                    children: m.jsxs("div", {
                        "data-stage": "failed",
                        className: "flex-1 flex flex-col justify-center items-center text-white text-center gap-4",
                        children: [m.jsxs("div", {
                            className: "relative w-16 h-16",
                            children: [m.jsx("div", {
                                className: "absolute inset-0 rounded-full bg-red-400/20 animate-ping"
                            }), m.jsx("div", {
                                className: "relative w-full h-full rounded-full bg-red-500/20 border border-red-300 flex items-center justify-center",
                                children: m.jsx("span", {
                                    className: "text-2xl text-red-300",
                                    children: ""
                                })
                            })]
                        }), m.jsxs("div", {
                            children: [m.jsx("h3", {
                                className: "text-2xl font-semibold",
                                children: "Payment Failed"
                            }), m.jsx("p", {
                                className: "text-sm text-white/70 mt-2 max-w-xs mx-auto",
                                children: "Something went wrong. Try again or close the modal."
                            })]
                        })]
                    })
                })
            })
        })]
    })
}
  , $Te = () => {
    const [n,e] = V.useState(!1)
      , [t,r] = V.useState({
        newpassword: "",
        confirmpassword: ""
    })
      , s = kr()
      , i = Ti()
      , o = new URLSearchParams(i.search).get("code")
      , a = d => {
        r({
            ...t,
            [d.target.name]: d.target.value
        })
    }
      , l = d => d && d.trim() !== ""
      , u = async () => {
        if (!l(t.newpassword)) {
            Ze.error("Enter new password");
            return
        }
        if (t.newpassword !== t.confirmpassword) {
            Ze.error("Passwords do not match");
            return
        }
        if (!o) {
            Ze.error("Invalid or missing reset code");
            return
        }
        try {
            const d = await B5e({
                password: t.newpassword,
                code: o
            });
            if (d?.status === "success") {
                Ze.success("Password updated successfully. Please login."),
                s("/login");
                return
            }
            Ze.error(d?.message || "Failed to update password")
        } catch {
            Ze.error("Failed to update password.")
        }
    }
    ;
    return m.jsxs("div", {
        children: [m.jsx("div", {
            className: "bg-[#27364b] max-w-md w-full rounded-3xl absolute top-12 left-0 right-0 mx-auto z-50 text-white overflow-hidden",
            children: m.jsxs("div", {
                className: "bg-brandGray p-8 relative",
                children: [m.jsx("h2", {
                    className: "text-2xl font-light mb-8",
                    children: "Reset Your Password"
                }), m.jsx("div", {
                    className: "cursor-pointer w-12 h-12 absolute right-1 top-1 flex items-center justify-center flex-col opacity-55",
                    onClick: () => s("/login"),
                    children: m.jsx("svg", {
                        xmlns: "http://www.w3.org/2000/svg",
                        fill: "none",
                        viewBox: "0 0 24 24",
                        strokeWidth: 1.5,
                        stroke: "currentColor",
                        className: "size-6",
                        children: m.jsx("path", {
                            strokeLinecap: "round",
                            strokeLinejoin: "round",
                            d: "M6 18 18 6M6 6l12 12"
                        })
                    })
                }), m.jsxs("div", {
                    className: "relative mb-8",
                    children: [m.jsx("input", {
                        type: "password",
                        name: "newpassword",
                        placeholder: " ",
                        value: t.newpassword,
                        onChange: a,
                        className: `peer w-full px-4 py-3 bg-transparent border ${l(t.newpassword) ? "border-orange-400" : "border-[#3F4E63]"} rounded-lg text-white focus:outline-none focus:border-orange-400`
                    }), m.jsx("label", {
                        className: "absolute left-4 -top-3 text-sm bg-brandGray px-2 text-[#8FA1B8] peer-focus:text-orange-500",
                        children: "New Password"
                    })]
                }), m.jsxs("div", {
                    className: "relative mb-8",
                    children: [m.jsx("input", {
                        type: "password",
                        name: "confirmpassword",
                        placeholder: " ",
                        value: t.confirmpassword,
                        onChange: a,
                        className: `peer w-full px-4 py-3 bg-transparent border ${l(t.confirmpassword) ? "border-orange-400" : "border-[#3F4E63]"} rounded-lg text-white focus:outline-none focus:border-orange-400`
                    }), m.jsx("label", {
                        className: "absolute left-4 -top-3 text-sm bg-brandGray px-2 text-[#8FA1B8] peer-focus:text-orange-500",
                        children: "Confirm Password"
                    })]
                }), m.jsx("div", {
                    className: "mt-8",
                    children: m.jsx("button", {
                        onClick: u,
                        className: "cursor-pointer w-full btn-clr py-4 px-5 rounded-xl text-base font-semibold hover:brightness-90 hover:scale-[1.02] transition-all",
                        children: "Reset Password"
                    })
                })]
            })
        }), m.jsx("div", {
            className: "fixed bg-black/70 w-full h-full top-0 left-0 z-40 backdrop-blur-lg"
        }), n && m.jsx(sk, {})]
    })
}
  , HTe = () => {
    const [n,e] = V.useState("")
      , [t,r] = V.useState("")
      , [s,i] = V.useState("")
      , [o,a] = V.useState("")
      , [l,u] = V.useState("")
      , [d,h] = V.useState(null)
      , [p,g] = V.useState(null)
      , [w,b] = V.useState(!1)
      , [v,S] = V.useState(!1)
      , [N,_] = V.useState(!1)
      , [I,k] = V.useState(!1)
      , [B,P] = V.useState(!0)
      , M = Uo()
      , R = async () => {
        b(!0);
        try {
            if (!n || n.trim().length === 0) {
                Ze.error("Please select game");
                return
            }
            if (!t || t.trim().length === 0) {
                Ze.error("Hash is required");
                return
            }
            if (!s || s.trim().length === 0) {
                Ze.error("Seed is required");
                return
            }
            if (s.trim().length < 63) {
                Ze.error("Invalid seed");
                return
            }
            if (n === "Plinko") {
                if (!o || o.trim().length === 0) {
                    Ze.error("Nonce is required");
                    return
                }
                if (Number(o) < 0) {
                    Ze.error("Invalid nonce");
                    return
                }
            }
            const L = await M.executeV3("action");
            let q = null;
            if (n === "Crash" && (q = await qSe({
                gameId: Io,
                clientSeed: t,
                serverSeed: s
            }, L)),
            n === "Plinko" && (q = await VSe({
                gameId: kx,
                clientSeed: t,
                serverSeed: s,
                nonce: Number(o),
                rows: 12,
                risk: "Medium"
            }, L)),
            q.status !== "success" && Ze.error(q.message || "Verification failed"),
            h(q?.data?.outcome || q?.data?.finalMultiplier),
            n === "Plinko") {
                const H = q?.data?.pathSequence?.join(", ");
                u(H)
            }
        } catch (L) {
            console.error(L),
            Ze.error("API verification error")
        } finally {
            b(!1)
        }
    }
    ;
    return m.jsxs("div", {
        className: "min-h-screen bg-gradient-to-br from-[#0F172A] via-[#1C2837] to-[#0F172A] py-8 pt-0 px-4",
        children: [m.jsx(pk, {}), m.jsxs("div", {
            className: "max-w-6xl mx-auto pt-10",
            children: [m.jsxs("div", {
                className: "text-center mb-8",
                children: [m.jsx("h1", {
                    className: "text-3xl font-bold bg-gradient-to-r from-[#FF7124] via-[#FF9000] to-[#FF7124] bg-clip-text text-transparent mb-3 ",
                    children: "Provably Fair Verification"
                }), m.jsx("p", {
                    className: "text-gray-400 text-base",
                    children: "Verify the fairness of your game results using cryptographic proofs"
                })]
            }), m.jsxs("div", {
                className: "bg-[#1C2837]/80 backdrop-blur-xl rounded-3xl shadow-2xl border border-[#2F3E53]/50 overflow-hidden",
                children: [m.jsxs("div", {
                    className: "p-8 border-b border-[#2F3E53] bg-gradient-to-r from-[#1C2837] to-[#2F3E53]/30",
                    children: [m.jsxs("h2", {
                        className: "text-2xl font-semibold text-white mb-6 flex items-center gap-2",
                        children: [m.jsx("svg", {
                            xmlns: "http://www.w3.org/2000/svg",
                            fill: "none",
                            viewBox: "0 0 24 24",
                            strokeWidth: 2,
                            stroke: "currentColor",
                            className: "w-6 h-6 text-[#FF7124]",
                            children: m.jsx("path", {
                                strokeLinecap: "round",
                                strokeLinejoin: "round",
                                d: "M9 12h3.75M9 15h3.75M9 18h3.75m3 .75H18a2.25 2.25 0 002.25-2.25V6.108c0-1.135-.845-2.098-1.976-2.192a48.424 48.424 0 00-1.123-.08m-5.801 0c-.065.21-.1.433-.1.664 0 .414.336.75.75.75h4.5a.75.75 0 00.75-.75 2.25 2.25 0 00-.1-.664m-5.8 0A2.251 2.251 0 0113.5 2.25h1.5m-5.8 0c-.376.023-.75.05-1.124.08C9.095 4.01 8.25 4.973 8.25 6.108V8.25m0 0H4.875c-.621 0-1.125.504-1.125 1.125v11.25c0 .621.504 1.125 1.125 1.125h4.125m0 0h3.75m-3.75 0h3.75m-3.75 0H9m-4.125 0H6.75m-1.875 0h1.875m0 0h3.75m-3.75 0h3.75m-3.75 0H9"
                            })
                        }), "Game Parameters"]
                    }), m.jsxs("div", {
                        className: "space-y-6",
                        children: [m.jsxs("div", {
                            children: [m.jsx("label", {
                                className: "block text-sm font-medium text-gray-400 mb-2",
                                children: "Game"
                            }), m.jsxs("div", {
                                className: "relative",
                                children: [m.jsxs("select", {
                                    value: n,
                                    onChange: L => e(L.target.value),
                                    className: "w-full bg-[#2F3E53] border border-[#3a4a5f] rounded-xl px-4 py-3 text-white focus:outline-none focus:border-[#FF7124] focus:ring-2 focus:ring-[#FF7124]/20 transition-all appearance-none cursor-pointer",
                                    children: [m.jsx("option", {
                                        value: "",
                                        children: "Select Game"
                                    }), m.jsx("option", {
                                        value: "Crash",
                                        children: "Crash"
                                    }), m.jsx("option", {
                                        value: "Plinko",
                                        children: "Plinko"
                                    })]
                                }), m.jsx("svg", {
                                    xmlns: "http://www.w3.org/2000/svg",
                                    fill: "none",
                                    viewBox: "0 0 24 24",
                                    strokeWidth: 2,
                                    stroke: "currentColor",
                                    className: "w-5 h-5 text-gray-400 absolute right-3 top-1/2 -translate-y-1/2 pointer-events-none",
                                    children: m.jsx("path", {
                                        strokeLinecap: "round",
                                        strokeLinejoin: "round",
                                        d: "M19.5 8.25l-7.5 7.5-7.5-7.5"
                                    })
                                })]
                            })]
                        }), m.jsxs("div", {
                            children: [m.jsx("label", {
                                className: "block text-sm font-medium text-gray-400 mb-2",
                                children: n === "Plinko" ? " Client Seed" : "Hash"
                            }), m.jsx("div", {
                                className: "relative",
                                children: m.jsx("input", {
                                    type: "text",
                                    value: t,
                                    onChange: L => r(L.target.value),
                                    placeholder: "Enter client seed...",
                                    className: "w-full bg-[#2F3E53] border border-[#3a4a5f] rounded-xl px-4 py-3 pr-12 text-sm text-gray-300 focus:outline-none focus:border-[#FF7124] focus:ring-2 focus:ring-[#FF7124]/20 transition-all font-mono"
                                })
                            })]
                        }), m.jsxs("div", {
                            children: [m.jsx("label", {
                                className: "flex items-center gap-2 text-sm font-medium text-gray-400 mb-2",
                                children: m.jsx("span", {
                                    children: "Server Seed"
                                })
                            }), m.jsx("div", {
                                className: "relative",
                                children: m.jsx("input", {
                                    type: "text",
                                    value: s,
                                    onChange: L => i(L.target.value),
                                    placeholder: "Enter server seed",
                                    className: "w-full bg-[#2F3E53] border border-[#3a4a5f] rounded-xl px-4 py-3 pr-12 text-sm text-gray-300 focus:outline-none focus:border-[#FF7124] focus:ring-2 focus:ring-[#FF7124]/20 transition-all font-mono"
                                })
                            })]
                        }), n === "Plinko" ? m.jsxs(m.Fragment, {
                            children: [m.jsxs("div", {
                                children: [m.jsx("label", {
                                    className: "flex items-center gap-2 text-sm font-medium text-gray-400 mb-2",
                                    children: m.jsx("span", {
                                        children: "Nonce"
                                    })
                                }), m.jsx("div", {
                                    className: "relative",
                                    children: m.jsx("input", {
                                        type: "text",
                                        value: o,
                                        onChange: L => a(L.target.value),
                                        placeholder: "Enter nonce",
                                        className: "w-full bg-[#2F3E53] border border-[#3a4a5f] rounded-xl px-4 py-3 pr-12 text-sm text-gray-300 focus:outline-none focus:border-[#FF7124] focus:ring-2 focus:ring-[#FF7124]/20 transition-all font-mono"
                                    })
                                })]
                            }), m.jsxs("div", {
                                children: [m.jsx("label", {
                                    className: "flex items-center gap-2 text-sm font-medium text-gray-400 mb-2",
                                    children: m.jsx("span", {
                                        children: "Risk"
                                    })
                                }), m.jsx("div", {
                                    className: "relative",
                                    children: m.jsx("input", {
                                        type: "text",
                                        value: "Medium",
                                        disabled: !0,
                                        placeholder: "Enter risk level",
                                        className: "w-full bg-[#2F3E53] border border-[#3a4a5f] rounded-xl px-4 py-3 pr-12 text-sm text-gray-300 focus:outline-none focus:border-[#FF7124] focus:ring-2 focus:ring-[#FF7124]/20 transition-all font-mono"
                                    })
                                })]
                            }), m.jsxs("div", {
                                children: [m.jsx("label", {
                                    className: "flex items-center gap-2 text-sm font-medium text-gray-400 mb-2",
                                    children: m.jsx("span", {
                                        children: "Rows"
                                    })
                                }), m.jsx("div", {
                                    className: "relative",
                                    children: m.jsx("input", {
                                        disabled: !0,
                                        type: "text",
                                        value: 12,
                                        placeholder: "Enter rows number",
                                        className: "w-full bg-[#2F3E53] border border-[#3a4a5f] rounded-xl px-4 py-3 pr-12 text-sm text-gray-300 focus:outline-none focus:border-[#FF7124] focus:ring-2 focus:ring-[#FF7124]/20 transition-all font-mono"
                                    })
                                })]
                            })]
                        }) : ""]
                    })]
                }), d ? m.jsxs("div", {
                    className: "p-8 text-center bg-gradient-to-b from-[#1C2837] to-[#2F3E53]/20",
                    children: [m.jsxs("div", {
                        className: "inline-block p-8 rounded-2xl bg-gradient-to-br from-[#FF7124]/20 to-[#FF9000]/20 border border-[#FF7124]/30 backdrop-blur-sm",
                        children: [m.jsxs("div", {
                            className: "text-8xl font-bold bg-gradient-to-r from-[#FF7124] to-[#FF9000] bg-clip-text text-transparent mb-2 animate-pulse",
                            children: [d.toFixed(2), "x"]
                        }), m.jsx("p", {
                            className: "text-gray-400 text-sm mt-2",
                            children: "Final Result"
                        })]
                    }), n === "Plinko" ? m.jsxs("p", {
                        className: "text-gray-400 text-sm mt-4",
                        children: ["Path : ", l]
                    }) : ""]
                }) : m.jsx("div", {
                    className: "p-8 text-center bg-gradient-to-b from-[#1C2837] to-[#2F3E53]/20",
                    children: m.jsx("button", {
                        onClick: R,
                        className: "mt-6 bg-[#FF7124] px-6 py-3 rounded-xl text-white font-semibold hover:opacity-90 cursor-pointer",
                        children: w ? "Verifying..." : "Verify"
                    })
                })]
            })]
        })]
    })
}
  , CG = "/assets/logo-Bq7oLjZC.svg"
  , gw = {
    MANUAL: "MANUAL",
    AUTO: "AUTO"
}
  , Mn = {
    LOW: "LOW",
    MEDIUM: "MEDIUM",
    HIGH: "HIGH"
};
function lj(n, e, t) {
    return Array.from({
        length: t
    }, (r, s) => ({
        r: Math.round(n.r + (e.r - n.r) / (t - 1) * s),
        g: Math.round(n.g + (e.g - n.g) / (t - 1) * s),
        b: Math.round(n.b + (e.b - n.b) / (t - 1) * s)
    }))
}
function VTe(n) {
    const e = n + 1
      , t = e % 2 === 0
      , r = Math.ceil(e / 2)
      , s = lj({
        r: 255,
        g: 0,
        b: 63
    }, {
        r: 255,
        g: 192,
        b: 0
    }, r).map( ({r: o, g: a, b: l}) => `rgb(${o}, ${a}, ${l})`)
      , i = lj({
        r: 166,
        g: 0,
        b: 4
    }, {
        r: 171,
        g: 121,
        b: 0
    }, r).map( ({r: o, g: a, b: l}) => `rgb(${o}, ${a}, ${l})`);
    return {
        background: [...s, ...s.toReversed().slice(t ? 0 : 1)],
        shadow: [...i, ...i.toReversed().slice(t ? 0 : 1)]
    }
}
function qTe(n) {
    const t = [];
    for (let r = 0; r <= n; r++) {
        const i = $A(n) / ($A(r) * $A(n - r)) * Math.pow(.5, r) * Math.pow(1 - .5, n - r);
        t.push(i)
    }
    return t
}
function $A(n) {
    let e = 1;
    for (let t = 2; t <= n; t++)
        e *= t;
    return e
}
function GTe(n, e) {
    return n + Math.random() * (e - n)
}
const cj = {
    SETTINGS: {
        ANIMATION: "plinko_settings_animation"
    }
}
  , _G = [8, 9, 10, 11, 12, 13, 14, 15, 16]
  , WTe = 250
  , kG = _G.reduce( (n, e) => (n[e] = VTe(e),
n), {});
_G.reduce( (n, e) => (n[e] = qTe(e),
n), {});
const Hx = {
    8: {
        [Mn.LOW]: [5.6, 2.1, 1.1, 1, .5, 1, 1.1, 2.1, 5.6],
        [Mn.MEDIUM]: [13, 3, 1.3, .7, .4, .7, 1.3, 3, 13],
        [Mn.HIGH]: [29, 4, 1.5, .3, .2, .3, 1.5, 4, 29]
    },
    9: {
        [Mn.LOW]: [5.6, 2, 1.6, 1, .7, .7, 1, 1.6, 2, 5.6],
        [Mn.MEDIUM]: [18, 4, 1.7, .9, .5, .5, .9, 1.7, 4, 18],
        [Mn.HIGH]: [43, 7, 2, .6, .2, .2, .6, 2, 7, 43]
    },
    10: {
        [Mn.LOW]: [8.9, 3, 1.4, 1.1, 1, .5, 1, 1.1, 1.4, 3, 8.9],
        [Mn.MEDIUM]: [22, 5, 2, 1.4, .6, .4, .6, 1.4, 2, 5, 22],
        [Mn.HIGH]: [76, 10, 3, .9, .3, .2, .3, .9, 3, 10, 76]
    },
    11: {
        [Mn.LOW]: [8.4, 3, 1.9, 1.3, 1, .7, .7, 1, 1.3, 1.9, 3, 8.4],
        [Mn.MEDIUM]: [24, 6, 3, 1.8, .7, .5, .5, .7, 1.8, 3, 6, 24],
        [Mn.HIGH]: [120, 14, 5.2, 1.4, .4, .2, .2, .4, 1.4, 5.2, 14, 120]
    },
    12: {
        [Mn.LOW]: [10, 3, 1.6, 1.4, 1.1, 1, .5, 1, 1.1, 1.4, 1.6, 3, 10],
        [Mn.MEDIUM]: [33, 11, 4, 2, 1.1, .6, .3, .6, 1.1, 2, 4, 11, 33],
        [Mn.HIGH]: [170, 24, 8.1, 2, .7, .2, .2, .2, .7, 2, 8.1, 24, 170]
    },
    13: {
        [Mn.LOW]: [8.1, 4, 3, 1.9, 1.2, .9, .7, .7, .9, 1.2, 1.9, 3, 4, 8.1],
        [Mn.MEDIUM]: [43, 13, 6, 3, 1.3, .7, .4, .4, .7, 1.3, 3, 6, 13, 43],
        [Mn.HIGH]: [260, 37, 11, 4, 1, .2, .2, .2, .2, 1, 4, 11, 37, 260]
    },
    14: {
        [Mn.LOW]: [7.1, 4, 1.9, 1.4, 1.3, 1.1, 1, .5, 1, 1.1, 1.3, 1.4, 1.9, 4, 7.1],
        [Mn.MEDIUM]: [58, 15, 7, 4, 1.9, 1, .5, .2, .5, 1, 1.9, 4, 7, 15, 58],
        [Mn.HIGH]: [420, 56, 18, 5, 1.9, .3, .2, .2, .2, .3, 1.9, 5, 18, 56, 420]
    },
    15: {
        [Mn.LOW]: [15, 8, 3, 2, 1.5, 1.1, 1, .7, .7, 1, 1.1, 1.5, 2, 3, 8, 15],
        [Mn.MEDIUM]: [88, 18, 11, 5, 3, 1.3, .5, .3, .3, .5, 1.3, 3, 5, 11, 18, 88],
        [Mn.HIGH]: [620, 83, 27, 8, 3, .5, .2, .2, .2, .2, .5, 3, 8, 27, 83, 620]
    },
    16: {
        [Mn.LOW]: [16, 9, 2, 1.4, 1.4, 1.2, 1.1, 1, .5, 1, 1.1, 1.2, 1.4, 1.4, 2, 9, 16],
        [Mn.MEDIUM]: [110, 41, 10, 5, 3, 1.5, 1, .5, .3, .5, 1, 1.5, 3, 5, 10, 41, 110],
        [Mn.HIGH]: [1e3, 130, 26, 9, 4, 2, .2, .2, .2, .2, .2, 2, 4, 9, 26, 130, 1e3]
    }
};
var r2 = {
    exports: {}
};
var YTe = r2.exports, uj;
function KTe() {
    return uj || (uj = 1,
    (function(n, e) {
        (function(r, s) {
            n.exports = s()
        }
        )(YTe, function() {
            return (function(t) {
                var r = {};
                function s(i) {
                    if (r[i])
                        return r[i].exports;
                    var o = r[i] = {
                        i,
                        l: !1,
                        exports: {}
                    };
                    return t[i].call(o.exports, o, o.exports, s),
                    o.l = !0,
                    o.exports
                }
                return s.m = t,
                s.c = r,
                s.d = function(i, o, a) {
                    s.o(i, o) || Object.defineProperty(i, o, {
                        enumerable: !0,
                        get: a
                    })
                }
                ,
                s.r = function(i) {
                    typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(i, Symbol.toStringTag, {
                        value: "Module"
                    }),
                    Object.defineProperty(i, "__esModule", {
                        value: !0
                    })
                }
                ,
                s.t = function(i, o) {
                    if (o & 1 && (i = s(i)),
                    o & 8 || o & 4 && typeof i == "object" && i && i.__esModule)
                        return i;
                    var a = Object.create(null);
                    if (s.r(a),
                    Object.defineProperty(a, "default", {
                        enumerable: !0,
                        value: i
                    }),
                    o & 2 && typeof i != "string")
                        for (var l in i)
                            s.d(a, l, (function(u) {
                                return i[u]
                            }
                            ).bind(null, l));
                    return a
                }
                ,
                s.n = function(i) {
                    var o = i && i.__esModule ? function() {
                        return i.default
                    }
                    : function() {
                        return i
                    }
                    ;
                    return s.d(o, "a", o),
                    o
                }
                ,
                s.o = function(i, o) {
                    return Object.prototype.hasOwnProperty.call(i, o)
                }
                ,
                s.p = "",
                s(s.s = 20)
            }
            )([(function(t, r) {
                var s = {};
                t.exports = s,
                (function() {
                    s._baseDelta = 1e3 / 60,
                    s._nextId = 0,
                    s._seed = 0,
                    s._nowStartTime = +new Date,
                    s._warnedOnce = {},
                    s._decomp = null,
                    s.extend = function(o, a) {
                        var l, u;
                        typeof a == "boolean" ? (l = 2,
                        u = a) : (l = 1,
                        u = !0);
                        for (var d = l; d < arguments.length; d++) {
                            var h = arguments[d];
                            if (h)
                                for (var p in h)
                                    u && h[p] && h[p].constructor === Object && (!o[p] || o[p].constructor === Object) ? (o[p] = o[p] || {},
                                    s.extend(o[p], u, h[p])) : o[p] = h[p]
                        }
                        return o
                    }
                    ,
                    s.clone = function(o, a) {
                        return s.extend({}, a, o)
                    }
                    ,
                    s.keys = function(o) {
                        if (Object.keys)
                            return Object.keys(o);
                        var a = [];
                        for (var l in o)
                            a.push(l);
                        return a
                    }
                    ,
                    s.values = function(o) {
                        var a = [];
                        if (Object.keys) {
                            for (var l = Object.keys(o), u = 0; u < l.length; u++)
                                a.push(o[l[u]]);
                            return a
                        }
                        for (var d in o)
                            a.push(o[d]);
                        return a
                    }
                    ,
                    s.get = function(o, a, l, u) {
                        a = a.split(".").slice(l, u);
                        for (var d = 0; d < a.length; d += 1)
                            o = o[a[d]];
                        return o
                    }
                    ,
                    s.set = function(o, a, l, u, d) {
                        var h = a.split(".").slice(u, d);
                        return s.get(o, a, 0, -1)[h[h.length - 1]] = l,
                        l
                    }
                    ,
                    s.shuffle = function(o) {
                        for (var a = o.length - 1; a > 0; a--) {
                            var l = Math.floor(s.random() * (a + 1))
                              , u = o[a];
                            o[a] = o[l],
                            o[l] = u
                        }
                        return o
                    }
                    ,
                    s.choose = function(o) {
                        return o[Math.floor(s.random() * o.length)]
                    }
                    ,
                    s.isElement = function(o) {
                        return typeof HTMLElement < "u" ? o instanceof HTMLElement : !!(o && o.nodeType && o.nodeName)
                    }
                    ,
                    s.isArray = function(o) {
                        return Object.prototype.toString.call(o) === "[object Array]"
                    }
                    ,
                    s.isFunction = function(o) {
                        return typeof o == "function"
                    }
                    ,
                    s.isPlainObject = function(o) {
                        return typeof o == "object" && o.constructor === Object
                    }
                    ,
                    s.isString = function(o) {
                        return toString.call(o) === "[object String]"
                    }
                    ,
                    s.clamp = function(o, a, l) {
                        return o < a ? a : o > l ? l : o
                    }
                    ,
                    s.sign = function(o) {
                        return o < 0 ? -1 : 1
                    }
                    ,
                    s.now = function() {
                        if (typeof window < "u" && window.performance) {
                            if (window.performance.now)
                                return window.performance.now();
                            if (window.performance.webkitNow)
                                return window.performance.webkitNow()
                        }
                        return Date.now ? Date.now() : new Date - s._nowStartTime
                    }
                    ,
                    s.random = function(o, a) {
                        return o = typeof o < "u" ? o : 0,
                        a = typeof a < "u" ? a : 1,
                        o + i() * (a - o)
                    }
                    ;
                    var i = function() {
                        return s._seed = (s._seed * 9301 + 49297) % 233280,
                        s._seed / 233280
                    };
                    s.colorToNumber = function(o) {
                        return o = o.replace("#", ""),
                        o.length == 3 && (o = o.charAt(0) + o.charAt(0) + o.charAt(1) + o.charAt(1) + o.charAt(2) + o.charAt(2)),
                        parseInt(o, 16)
                    }
                    ,
                    s.logLevel = 1,
                    s.log = function() {
                        console && s.logLevel > 0 && s.logLevel <= 3 && console.log.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments)))
                    }
                    ,
                    s.info = function() {
                        console && s.logLevel > 0 && s.logLevel <= 2 && console.info.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments)))
                    }
                    ,
                    s.warn = function() {
                        console && s.logLevel > 0 && s.logLevel <= 3 && console.warn.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments)))
                    }
                    ,
                    s.warnOnce = function() {
                        var o = Array.prototype.slice.call(arguments).join(" ");
                        s._warnedOnce[o] || (s.warn(o),
                        s._warnedOnce[o] = !0)
                    }
                    ,
                    s.deprecated = function(o, a, l) {
                        o[a] = s.chain(function() {
                            s.warnOnce(" deprecated ", l)
                        }, o[a])
                    }
                    ,
                    s.nextId = function() {
                        return s._nextId++
                    }
                    ,
                    s.indexOf = function(o, a) {
                        if (o.indexOf)
                            return o.indexOf(a);
                        for (var l = 0; l < o.length; l++)
                            if (o[l] === a)
                                return l;
                        return -1
                    }
                    ,
                    s.map = function(o, a) {
                        if (o.map)
                            return o.map(a);
                        for (var l = [], u = 0; u < o.length; u += 1)
                            l.push(a(o[u]));
                        return l
                    }
                    ,
                    s.topologicalSort = function(o) {
                        var a = []
                          , l = []
                          , u = [];
                        for (var d in o)
                            !l[d] && !u[d] && s._topologicalSort(d, l, u, o, a);
                        return a
                    }
                    ,
                    s._topologicalSort = function(o, a, l, u, d) {
                        var h = u[o] || [];
                        l[o] = !0;
                        for (var p = 0; p < h.length; p += 1) {
                            var g = h[p];
                            l[g] || a[g] || s._topologicalSort(g, a, l, u, d)
                        }
                        l[o] = !1,
                        a[o] = !0,
                        d.push(o)
                    }
                    ,
                    s.chain = function() {
                        for (var o = [], a = 0; a < arguments.length; a += 1) {
                            var l = arguments[a];
                            l._chained ? o.push.apply(o, l._chained) : o.push(l)
                        }
                        var u = function() {
                            for (var d, h = new Array(arguments.length), p = 0, g = arguments.length; p < g; p++)
                                h[p] = arguments[p];
                            for (p = 0; p < o.length; p += 1) {
                                var w = o[p].apply(d, h);
                                typeof w < "u" && (d = w)
                            }
                            return d
                        };
                        return u._chained = o,
                        u
                    }
                    ,
                    s.chainPathBefore = function(o, a, l) {
                        return s.set(o, a, s.chain(l, s.get(o, a)))
                    }
                    ,
                    s.chainPathAfter = function(o, a, l) {
                        return s.set(o, a, s.chain(s.get(o, a), l))
                    }
                    ,
                    s.setDecomp = function(o) {
                        s._decomp = o
                    }
                    ,
                    s.getDecomp = function() {
                        var o = s._decomp;
                        try {
                            !o && typeof window < "u" && (o = window.decomp),
                            !o && typeof To < "u" && (o = To.decomp)
                        } catch {
                            o = null
                        }
                        return o
                    }
                }
                )()
            }
            ), (function(t, r) {
                var s = {};
                t.exports = s,
                (function() {
                    s.create = function(i) {
                        var o = {
                            min: {
                                x: 0,
                                y: 0
                            },
                            max: {
                                x: 0,
                                y: 0
                            }
                        };
                        return i && s.update(o, i),
                        o
                    }
                    ,
                    s.update = function(i, o, a) {
                        i.min.x = 1 / 0,
                        i.max.x = -1 / 0,
                        i.min.y = 1 / 0,
                        i.max.y = -1 / 0;
                        for (var l = 0; l < o.length; l++) {
                            var u = o[l];
                            u.x > i.max.x && (i.max.x = u.x),
                            u.x < i.min.x && (i.min.x = u.x),
                            u.y > i.max.y && (i.max.y = u.y),
                            u.y < i.min.y && (i.min.y = u.y)
                        }
                        a && (a.x > 0 ? i.max.x += a.x : i.min.x += a.x,
                        a.y > 0 ? i.max.y += a.y : i.min.y += a.y)
                    }
                    ,
                    s.contains = function(i, o) {
                        return o.x >= i.min.x && o.x <= i.max.x && o.y >= i.min.y && o.y <= i.max.y
                    }
                    ,
                    s.overlaps = function(i, o) {
                        return i.min.x <= o.max.x && i.max.x >= o.min.x && i.max.y >= o.min.y && i.min.y <= o.max.y
                    }
                    ,
                    s.translate = function(i, o) {
                        i.min.x += o.x,
                        i.max.x += o.x,
                        i.min.y += o.y,
                        i.max.y += o.y
                    }
                    ,
                    s.shift = function(i, o) {
                        var a = i.max.x - i.min.x
                          , l = i.max.y - i.min.y;
                        i.min.x = o.x,
                        i.max.x = o.x + a,
                        i.min.y = o.y,
                        i.max.y = o.y + l
                    }
                }
                )()
            }
            ), (function(t, r) {
                var s = {};
                t.exports = s,
                (function() {
                    s.create = function(i, o) {
                        return {
                            x: i || 0,
                            y: o || 0
                        }
                    }
                    ,
                    s.clone = function(i) {
                        return {
                            x: i.x,
                            y: i.y
                        }
                    }
                    ,
                    s.magnitude = function(i) {
                        return Math.sqrt(i.x * i.x + i.y * i.y)
                    }
                    ,
                    s.magnitudeSquared = function(i) {
                        return i.x * i.x + i.y * i.y
                    }
                    ,
                    s.rotate = function(i, o, a) {
                        var l = Math.cos(o)
                          , u = Math.sin(o);
                        a || (a = {});
                        var d = i.x * l - i.y * u;
                        return a.y = i.x * u + i.y * l,
                        a.x = d,
                        a
                    }
                    ,
                    s.rotateAbout = function(i, o, a, l) {
                        var u = Math.cos(o)
                          , d = Math.sin(o);
                        l || (l = {});
                        var h = a.x + ((i.x - a.x) * u - (i.y - a.y) * d);
                        return l.y = a.y + ((i.x - a.x) * d + (i.y - a.y) * u),
                        l.x = h,
                        l
                    }
                    ,
                    s.normalise = function(i) {
                        var o = s.magnitude(i);
                        return o === 0 ? {
                            x: 0,
                            y: 0
                        } : {
                            x: i.x / o,
                            y: i.y / o
                        }
                    }
                    ,
                    s.dot = function(i, o) {
                        return i.x * o.x + i.y * o.y
                    }
                    ,
                    s.cross = function(i, o) {
                        return i.x * o.y - i.y * o.x
                    }
                    ,
                    s.cross3 = function(i, o, a) {
                        return (o.x - i.x) * (a.y - i.y) - (o.y - i.y) * (a.x - i.x)
                    }
                    ,
                    s.add = function(i, o, a) {
                        return a || (a = {}),
                        a.x = i.x + o.x,
                        a.y = i.y + o.y,
                        a
                    }
                    ,
                    s.sub = function(i, o, a) {
                        return a || (a = {}),
                        a.x = i.x - o.x,
                        a.y = i.y - o.y,
                        a
                    }
                    ,
                    s.mult = function(i, o) {
                        return {
                            x: i.x * o,
                            y: i.y * o
                        }
                    }
                    ,
                    s.div = function(i, o) {
                        return {
                            x: i.x / o,
                            y: i.y / o
                        }
                    }
                    ,
                    s.perp = function(i, o) {
                        return o = o === !0 ? -1 : 1,
                        {
                            x: o * -i.y,
                            y: o * i.x
                        }
                    }
                    ,
                    s.neg = function(i) {
                        return {
                            x: -i.x,
                            y: -i.y
                        }
                    }
                    ,
                    s.angle = function(i, o) {
                        return Math.atan2(o.y - i.y, o.x - i.x)
                    }
                    ,
                    s._temp = [s.create(), s.create(), s.create(), s.create(), s.create(), s.create()]
                }
                )()
            }
            ), (function(t, r, s) {
                var i = {};
                t.exports = i;
                var o = s(2)
                  , a = s(0);
                (function() {
                    i.create = function(l, u) {
                        for (var d = [], h = 0; h < l.length; h++) {
                            var p = l[h]
                              , g = {
                                x: p.x,
                                y: p.y,
                                index: h,
                                body: u,
                                isInternal: !1
                            };
                            d.push(g)
                        }
                        return d
                    }
                    ,
                    i.fromPath = function(l, u) {
                        var d = /L?\s*([-\d.e]+)[\s,]*([-\d.e]+)*/ig
                          , h = [];
                        return l.replace(d, function(p, g, w) {
                            h.push({
                                x: parseFloat(g),
                                y: parseFloat(w)
                            })
                        }),
                        i.create(h, u)
                    }
                    ,
                    i.centre = function(l) {
                        for (var u = i.area(l, !0), d = {
                            x: 0,
                            y: 0
                        }, h, p, g, w = 0; w < l.length; w++)
                            g = (w + 1) % l.length,
                            h = o.cross(l[w], l[g]),
                            p = o.mult(o.add(l[w], l[g]), h),
                            d = o.add(d, p);
                        return o.div(d, 6 * u)
                    }
                    ,
                    i.mean = function(l) {
                        for (var u = {
                            x: 0,
                            y: 0
                        }, d = 0; d < l.length; d++)
                            u.x += l[d].x,
                            u.y += l[d].y;
                        return o.div(u, l.length)
                    }
                    ,
                    i.area = function(l, u) {
                        for (var d = 0, h = l.length - 1, p = 0; p < l.length; p++)
                            d += (l[h].x - l[p].x) * (l[h].y + l[p].y),
                            h = p;
                        return u ? d / 2 : Math.abs(d) / 2
                    }
                    ,
                    i.inertia = function(l, u) {
                        for (var d = 0, h = 0, p = l, g, w, b = 0; b < p.length; b++)
                            w = (b + 1) % p.length,
                            g = Math.abs(o.cross(p[w], p[b])),
                            d += g * (o.dot(p[w], p[w]) + o.dot(p[w], p[b]) + o.dot(p[b], p[b])),
                            h += g;
                        return u / 6 * (d / h)
                    }
                    ,
                    i.translate = function(l, u, d) {
                        d = typeof d < "u" ? d : 1;
                        var h = l.length, p = u.x * d, g = u.y * d, w;
                        for (w = 0; w < h; w++)
                            l[w].x += p,
                            l[w].y += g;
                        return l
                    }
                    ,
                    i.rotate = function(l, u, d) {
                        if (u !== 0) {
                            var h = Math.cos(u), p = Math.sin(u), g = d.x, w = d.y, b = l.length, v, S, N, _;
                            for (_ = 0; _ < b; _++)
                                v = l[_],
                                S = v.x - g,
                                N = v.y - w,
                                v.x = g + (S * h - N * p),
                                v.y = w + (S * p + N * h);
                            return l
                        }
                    }
                    ,
                    i.contains = function(l, u) {
                        for (var d = u.x, h = u.y, p = l.length, g = l[p - 1], w, b = 0; b < p; b++) {
                            if (w = l[b],
                            (d - g.x) * (w.y - g.y) + (h - g.y) * (g.x - w.x) > 0)
                                return !1;
                            g = w
                        }
                        return !0
                    }
                    ,
                    i.scale = function(l, u, d, h) {
                        if (u === 1 && d === 1)
                            return l;
                        h = h || i.centre(l);
                        for (var p, g, w = 0; w < l.length; w++)
                            p = l[w],
                            g = o.sub(p, h),
                            l[w].x = h.x + g.x * u,
                            l[w].y = h.y + g.y * d;
                        return l
                    }
                    ,
                    i.chamfer = function(l, u, d, h, p) {
                        typeof u == "number" ? u = [u] : u = u || [8],
                        d = typeof d < "u" ? d : -1,
                        h = h || 2,
                        p = p || 14;
                        for (var g = [], w = 0; w < l.length; w++) {
                            var b = l[w - 1 >= 0 ? w - 1 : l.length - 1]
                              , v = l[w]
                              , S = l[(w + 1) % l.length]
                              , N = u[w < u.length ? w : u.length - 1];
                            if (N === 0) {
                                g.push(v);
                                continue
                            }
                            var _ = o.normalise({
                                x: v.y - b.y,
                                y: b.x - v.x
                            })
                              , I = o.normalise({
                                x: S.y - v.y,
                                y: v.x - S.x
                            })
                              , k = Math.sqrt(2 * Math.pow(N, 2))
                              , B = o.mult(a.clone(_), N)
                              , P = o.normalise(o.mult(o.add(_, I), .5))
                              , M = o.sub(v, o.mult(P, k))
                              , R = d;
                            d === -1 && (R = Math.pow(N, .32) * 1.75),
                            R = a.clamp(R, h, p),
                            R % 2 === 1 && (R += 1);
                            for (var L = Math.acos(o.dot(_, I)), q = L / R, H = 0; H < R; H++)
                                g.push(o.add(o.rotate(B, q * H), M))
                        }
                        return g
                    }
                    ,
                    i.clockwiseSort = function(l) {
                        var u = i.mean(l);
                        return l.sort(function(d, h) {
                            return o.angle(u, d) - o.angle(u, h)
                        }),
                        l
                    }
                    ,
                    i.isConvex = function(l) {
                        var u = 0, d = l.length, h, p, g, w;
                        if (d < 3)
                            return null;
                        for (h = 0; h < d; h++)
                            if (p = (h + 1) % d,
                            g = (h + 2) % d,
                            w = (l[p].x - l[h].x) * (l[g].y - l[p].y),
                            w -= (l[p].y - l[h].y) * (l[g].x - l[p].x),
                            w < 0 ? u |= 1 : w > 0 && (u |= 2),
                            u === 3)
                                return !1;
                        return u !== 0 ? !0 : null
                    }
                    ,
                    i.hull = function(l) {
                        var u = [], d = [], h, p;
                        for (l = l.slice(0),
                        l.sort(function(g, w) {
                            var b = g.x - w.x;
                            return b !== 0 ? b : g.y - w.y
                        }),
                        p = 0; p < l.length; p += 1) {
                            for (h = l[p]; d.length >= 2 && o.cross3(d[d.length - 2], d[d.length - 1], h) <= 0; )
                                d.pop();
                            d.push(h)
                        }
                        for (p = l.length - 1; p >= 0; p -= 1) {
                            for (h = l[p]; u.length >= 2 && o.cross3(u[u.length - 2], u[u.length - 1], h) <= 0; )
                                u.pop();
                            u.push(h)
                        }
                        return u.pop(),
                        d.pop(),
                        u.concat(d)
                    }
                }
                )()
            }
            ), (function(t, r, s) {
                var i = {};
                t.exports = i;
                var o = s(3)
                  , a = s(2)
                  , l = s(7)
                  , u = s(0)
                  , d = s(1)
                  , h = s(11);
                (function() {
                    i._timeCorrection = !0,
                    i._inertiaScale = 4,
                    i._nextCollidingGroupId = 1,
                    i._nextNonCollidingGroupId = -1,
                    i._nextCategory = 1,
                    i._baseDelta = 1e3 / 60,
                    i.create = function(g) {
                        var w = {
                            id: u.nextId(),
                            type: "body",
                            label: "Body",
                            parts: [],
                            plugin: {},
                            angle: 0,
                            vertices: o.fromPath("L 0 0 L 40 0 L 40 40 L 0 40"),
                            position: {
                                x: 0,
                                y: 0
                            },
                            force: {
                                x: 0,
                                y: 0
                            },
                            torque: 0,
                            positionImpulse: {
                                x: 0,
                                y: 0
                            },
                            constraintImpulse: {
                                x: 0,
                                y: 0,
                                angle: 0
                            },
                            totalContacts: 0,
                            speed: 0,
                            angularSpeed: 0,
                            velocity: {
                                x: 0,
                                y: 0
                            },
                            angularVelocity: 0,
                            isSensor: !1,
                            isStatic: !1,
                            isSleeping: !1,
                            motion: 0,
                            sleepThreshold: 60,
                            density: .001,
                            restitution: 0,
                            friction: .1,
                            frictionStatic: .5,
                            frictionAir: .01,
                            collisionFilter: {
                                category: 1,
                                mask: 4294967295,
                                group: 0
                            },
                            slop: .05,
                            timeScale: 1,
                            render: {
                                visible: !0,
                                opacity: 1,
                                strokeStyle: null,
                                fillStyle: null,
                                lineWidth: null,
                                sprite: {
                                    xScale: 1,
                                    yScale: 1,
                                    xOffset: 0,
                                    yOffset: 0
                                }
                            },
                            events: null,
                            bounds: null,
                            chamfer: null,
                            circleRadius: 0,
                            positionPrev: null,
                            anglePrev: 0,
                            parent: null,
                            axes: null,
                            area: 0,
                            mass: 0,
                            inertia: 0,
                            deltaTime: 16.666666666666668,
                            _original: null
                        }
                          , b = u.extend(w, g);
                        return p(b, g),
                        b
                    }
                    ,
                    i.nextGroup = function(g) {
                        return g ? i._nextNonCollidingGroupId-- : i._nextCollidingGroupId++
                    }
                    ,
                    i.nextCategory = function() {
                        return i._nextCategory = i._nextCategory << 1,
                        i._nextCategory
                    }
                    ;
                    var p = function(g, w) {
                        w = w || {},
                        i.set(g, {
                            bounds: g.bounds || d.create(g.vertices),
                            positionPrev: g.positionPrev || a.clone(g.position),
                            anglePrev: g.anglePrev || g.angle,
                            vertices: g.vertices,
                            parts: g.parts || [g],
                            isStatic: g.isStatic,
                            isSleeping: g.isSleeping,
                            parent: g.parent || g
                        }),
                        o.rotate(g.vertices, g.angle, g.position),
                        h.rotate(g.axes, g.angle),
                        d.update(g.bounds, g.vertices, g.velocity),
                        i.set(g, {
                            axes: w.axes || g.axes,
                            area: w.area || g.area,
                            mass: w.mass || g.mass,
                            inertia: w.inertia || g.inertia
                        });
                        var b = g.isStatic ? "#14151f" : u.choose(["#f19648", "#f5d259", "#f55a3c", "#063e7b", "#ececd1"])
                          , v = g.isStatic ? "#555" : "#ccc"
                          , S = g.isStatic && g.render.fillStyle === null ? 1 : 0;
                        g.render.fillStyle = g.render.fillStyle || b,
                        g.render.strokeStyle = g.render.strokeStyle || v,
                        g.render.lineWidth = g.render.lineWidth || S,
                        g.render.sprite.xOffset += -(g.bounds.min.x - g.position.x) / (g.bounds.max.x - g.bounds.min.x),
                        g.render.sprite.yOffset += -(g.bounds.min.y - g.position.y) / (g.bounds.max.y - g.bounds.min.y)
                    };
                    i.set = function(g, w, b) {
                        var v;
                        typeof w == "string" && (v = w,
                        w = {},
                        w[v] = b);
                        for (v in w)
                            if (Object.prototype.hasOwnProperty.call(w, v))
                                switch (b = w[v],
                                v) {
                                case "isStatic":
                                    i.setStatic(g, b);
                                    break;
                                case "isSleeping":
                                    l.set(g, b);
                                    break;
                                case "mass":
                                    i.setMass(g, b);
                                    break;
                                case "density":
                                    i.setDensity(g, b);
                                    break;
                                case "inertia":
                                    i.setInertia(g, b);
                                    break;
                                case "vertices":
                                    i.setVertices(g, b);
                                    break;
                                case "position":
                                    i.setPosition(g, b);
                                    break;
                                case "angle":
                                    i.setAngle(g, b);
                                    break;
                                case "velocity":
                                    i.setVelocity(g, b);
                                    break;
                                case "angularVelocity":
                                    i.setAngularVelocity(g, b);
                                    break;
                                case "speed":
                                    i.setSpeed(g, b);
                                    break;
                                case "angularSpeed":
                                    i.setAngularSpeed(g, b);
                                    break;
                                case "parts":
                                    i.setParts(g, b);
                                    break;
                                case "centre":
                                    i.setCentre(g, b);
                                    break;
                                default:
                                    g[v] = b
                                }
                    }
                    ,
                    i.setStatic = function(g, w) {
                        for (var b = 0; b < g.parts.length; b++) {
                            var v = g.parts[b];
                            w ? (v.isStatic || (v._original = {
                                restitution: v.restitution,
                                friction: v.friction,
                                mass: v.mass,
                                inertia: v.inertia,
                                density: v.density,
                                inverseMass: v.inverseMass,
                                inverseInertia: v.inverseInertia
                            }),
                            v.restitution = 0,
                            v.friction = 1,
                            v.mass = v.inertia = v.density = 1 / 0,
                            v.inverseMass = v.inverseInertia = 0,
                            v.positionPrev.x = v.position.x,
                            v.positionPrev.y = v.position.y,
                            v.anglePrev = v.angle,
                            v.angularVelocity = 0,
                            v.speed = 0,
                            v.angularSpeed = 0,
                            v.motion = 0) : v._original && (v.restitution = v._original.restitution,
                            v.friction = v._original.friction,
                            v.mass = v._original.mass,
                            v.inertia = v._original.inertia,
                            v.density = v._original.density,
                            v.inverseMass = v._original.inverseMass,
                            v.inverseInertia = v._original.inverseInertia,
                            v._original = null),
                            v.isStatic = w
                        }
                    }
                    ,
                    i.setMass = function(g, w) {
                        var b = g.inertia / (g.mass / 6);
                        g.inertia = b * (w / 6),
                        g.inverseInertia = 1 / g.inertia,
                        g.mass = w,
                        g.inverseMass = 1 / g.mass,
                        g.density = g.mass / g.area
                    }
                    ,
                    i.setDensity = function(g, w) {
                        i.setMass(g, w * g.area),
                        g.density = w
                    }
                    ,
                    i.setInertia = function(g, w) {
                        g.inertia = w,
                        g.inverseInertia = 1 / g.inertia
                    }
                    ,
                    i.setVertices = function(g, w) {
                        w[0].body === g ? g.vertices = w : g.vertices = o.create(w, g),
                        g.axes = h.fromVertices(g.vertices),
                        g.area = o.area(g.vertices),
                        i.setMass(g, g.density * g.area);
                        var b = o.centre(g.vertices);
                        o.translate(g.vertices, b, -1),
                        i.setInertia(g, i._inertiaScale * o.inertia(g.vertices, g.mass)),
                        o.translate(g.vertices, g.position),
                        d.update(g.bounds, g.vertices, g.velocity)
                    }
                    ,
                    i.setParts = function(g, w, b) {
                        var v;
                        for (w = w.slice(0),
                        g.parts.length = 0,
                        g.parts.push(g),
                        g.parent = g,
                        v = 0; v < w.length; v++) {
                            var S = w[v];
                            S !== g && (S.parent = g,
                            g.parts.push(S))
                        }
                        if (g.parts.length !== 1) {
                            if (b = typeof b < "u" ? b : !0,
                            b) {
                                var N = [];
                                for (v = 0; v < w.length; v++)
                                    N = N.concat(w[v].vertices);
                                o.clockwiseSort(N);
                                var _ = o.hull(N)
                                  , I = o.centre(_);
                                i.setVertices(g, _),
                                o.translate(g.vertices, I)
                            }
                            var k = i._totalProperties(g);
                            g.area = k.area,
                            g.parent = g,
                            g.position.x = k.centre.x,
                            g.position.y = k.centre.y,
                            g.positionPrev.x = k.centre.x,
                            g.positionPrev.y = k.centre.y,
                            i.setMass(g, k.mass),
                            i.setInertia(g, k.inertia),
                            i.setPosition(g, k.centre)
                        }
                    }
                    ,
                    i.setCentre = function(g, w, b) {
                        b ? (g.positionPrev.x += w.x,
                        g.positionPrev.y += w.y,
                        g.position.x += w.x,
                        g.position.y += w.y) : (g.positionPrev.x = w.x - (g.position.x - g.positionPrev.x),
                        g.positionPrev.y = w.y - (g.position.y - g.positionPrev.y),
                        g.position.x = w.x,
                        g.position.y = w.y)
                    }
                    ,
                    i.setPosition = function(g, w, b) {
                        var v = a.sub(w, g.position);
                        b ? (g.positionPrev.x = g.position.x,
                        g.positionPrev.y = g.position.y,
                        g.velocity.x = v.x,
                        g.velocity.y = v.y,
                        g.speed = a.magnitude(v)) : (g.positionPrev.x += v.x,
                        g.positionPrev.y += v.y);
                        for (var S = 0; S < g.parts.length; S++) {
                            var N = g.parts[S];
                            N.position.x += v.x,
                            N.position.y += v.y,
                            o.translate(N.vertices, v),
                            d.update(N.bounds, N.vertices, g.velocity)
                        }
                    }
                    ,
                    i.setAngle = function(g, w, b) {
                        var v = w - g.angle;
                        b ? (g.anglePrev = g.angle,
                        g.angularVelocity = v,
                        g.angularSpeed = Math.abs(v)) : g.anglePrev += v;
                        for (var S = 0; S < g.parts.length; S++) {
                            var N = g.parts[S];
                            N.angle += v,
                            o.rotate(N.vertices, v, g.position),
                            h.rotate(N.axes, v),
                            d.update(N.bounds, N.vertices, g.velocity),
                            S > 0 && a.rotateAbout(N.position, v, g.position, N.position)
                        }
                    }
                    ,
                    i.setVelocity = function(g, w) {
                        var b = g.deltaTime / i._baseDelta;
                        g.positionPrev.x = g.position.x - w.x * b,
                        g.positionPrev.y = g.position.y - w.y * b,
                        g.velocity.x = (g.position.x - g.positionPrev.x) / b,
                        g.velocity.y = (g.position.y - g.positionPrev.y) / b,
                        g.speed = a.magnitude(g.velocity)
                    }
                    ,
                    i.getVelocity = function(g) {
                        var w = i._baseDelta / g.deltaTime;
                        return {
                            x: (g.position.x - g.positionPrev.x) * w,
                            y: (g.position.y - g.positionPrev.y) * w
                        }
                    }
                    ,
                    i.getSpeed = function(g) {
                        return a.magnitude(i.getVelocity(g))
                    }
                    ,
                    i.setSpeed = function(g, w) {
                        i.setVelocity(g, a.mult(a.normalise(i.getVelocity(g)), w))
                    }
                    ,
                    i.setAngularVelocity = function(g, w) {
                        var b = g.deltaTime / i._baseDelta;
                        g.anglePrev = g.angle - w * b,
                        g.angularVelocity = (g.angle - g.anglePrev) / b,
                        g.angularSpeed = Math.abs(g.angularVelocity)
                    }
                    ,
                    i.getAngularVelocity = function(g) {
                        return (g.angle - g.anglePrev) * i._baseDelta / g.deltaTime
                    }
                    ,
                    i.getAngularSpeed = function(g) {
                        return Math.abs(i.getAngularVelocity(g))
                    }
                    ,
                    i.setAngularSpeed = function(g, w) {
                        i.setAngularVelocity(g, u.sign(i.getAngularVelocity(g)) * w)
                    }
                    ,
                    i.translate = function(g, w, b) {
                        i.setPosition(g, a.add(g.position, w), b)
                    }
                    ,
                    i.rotate = function(g, w, b, v) {
                        if (!b)
                            i.setAngle(g, g.angle + w, v);
                        else {
                            var S = Math.cos(w)
                              , N = Math.sin(w)
                              , _ = g.position.x - b.x
                              , I = g.position.y - b.y;
                            i.setPosition(g, {
                                x: b.x + (_ * S - I * N),
                                y: b.y + (_ * N + I * S)
                            }, v),
                            i.setAngle(g, g.angle + w, v)
                        }
                    }
                    ,
                    i.scale = function(g, w, b, v) {
                        var S = 0
                          , N = 0;
                        v = v || g.position;
                        for (var _ = 0; _ < g.parts.length; _++) {
                            var I = g.parts[_];
                            o.scale(I.vertices, w, b, v),
                            I.axes = h.fromVertices(I.vertices),
                            I.area = o.area(I.vertices),
                            i.setMass(I, g.density * I.area),
                            o.translate(I.vertices, {
                                x: -I.position.x,
                                y: -I.position.y
                            }),
                            i.setInertia(I, i._inertiaScale * o.inertia(I.vertices, I.mass)),
                            o.translate(I.vertices, {
                                x: I.position.x,
                                y: I.position.y
                            }),
                            _ > 0 && (S += I.area,
                            N += I.inertia),
                            I.position.x = v.x + (I.position.x - v.x) * w,
                            I.position.y = v.y + (I.position.y - v.y) * b,
                            d.update(I.bounds, I.vertices, g.velocity)
                        }
                        g.parts.length > 1 && (g.area = S,
                        g.isStatic || (i.setMass(g, g.density * S),
                        i.setInertia(g, N))),
                        g.circleRadius && (w === b ? g.circleRadius *= w : g.circleRadius = null)
                    }
                    ,
                    i.update = function(g, w) {
                        w = (typeof w < "u" ? w : 1e3 / 60) * g.timeScale;
                        var b = w * w
                          , v = i._timeCorrection ? w / (g.deltaTime || w) : 1
                          , S = 1 - g.frictionAir * (w / u._baseDelta)
                          , N = (g.position.x - g.positionPrev.x) * v
                          , _ = (g.position.y - g.positionPrev.y) * v;
                        g.velocity.x = N * S + g.force.x / g.mass * b,
                        g.velocity.y = _ * S + g.force.y / g.mass * b,
                        g.positionPrev.x = g.position.x,
                        g.positionPrev.y = g.position.y,
                        g.position.x += g.velocity.x,
                        g.position.y += g.velocity.y,
                        g.deltaTime = w,
                        g.angularVelocity = (g.angle - g.anglePrev) * S * v + g.torque / g.inertia * b,
                        g.anglePrev = g.angle,
                        g.angle += g.angularVelocity;
                        for (var I = 0; I < g.parts.length; I++) {
                            var k = g.parts[I];
                            o.translate(k.vertices, g.velocity),
                            I > 0 && (k.position.x += g.velocity.x,
                            k.position.y += g.velocity.y),
                            g.angularVelocity !== 0 && (o.rotate(k.vertices, g.angularVelocity, g.position),
                            h.rotate(k.axes, g.angularVelocity),
                            I > 0 && a.rotateAbout(k.position, g.angularVelocity, g.position, k.position)),
                            d.update(k.bounds, k.vertices, g.velocity)
                        }
                    }
                    ,
                    i.updateVelocities = function(g) {
                        var w = i._baseDelta / g.deltaTime
                          , b = g.velocity;
                        b.x = (g.position.x - g.positionPrev.x) * w,
                        b.y = (g.position.y - g.positionPrev.y) * w,
                        g.speed = Math.sqrt(b.x * b.x + b.y * b.y),
                        g.angularVelocity = (g.angle - g.anglePrev) * w,
                        g.angularSpeed = Math.abs(g.angularVelocity)
                    }
                    ,
                    i.applyForce = function(g, w, b) {
                        var v = {
                            x: w.x - g.position.x,
                            y: w.y - g.position.y
                        };
                        g.force.x += b.x,
                        g.force.y += b.y,
                        g.torque += v.x * b.y - v.y * b.x
                    }
                    ,
                    i._totalProperties = function(g) {
                        for (var w = {
                            mass: 0,
                            area: 0,
                            inertia: 0,
                            centre: {
                                x: 0,
                                y: 0
                            }
                        }, b = g.parts.length === 1 ? 0 : 1; b < g.parts.length; b++) {
                            var v = g.parts[b]
                              , S = v.mass !== 1 / 0 ? v.mass : 1;
                            w.mass += S,
                            w.area += v.area,
                            w.inertia += v.inertia,
                            w.centre = a.add(w.centre, a.mult(v.position, S))
                        }
                        return w.centre = a.div(w.centre, w.mass),
                        w
                    }
                }
                )()
            }
            ), (function(t, r, s) {
                var i = {};
                t.exports = i;
                var o = s(0);
                (function() {
                    i.on = function(a, l, u) {
                        for (var d = l.split(" "), h, p = 0; p < d.length; p++)
                            h = d[p],
                            a.events = a.events || {},
                            a.events[h] = a.events[h] || [],
                            a.events[h].push(u);
                        return u
                    }
                    ,
                    i.off = function(a, l, u) {
                        if (!l) {
                            a.events = {};
                            return
                        }
                        typeof l == "function" && (u = l,
                        l = o.keys(a.events).join(" "));
                        for (var d = l.split(" "), h = 0; h < d.length; h++) {
                            var p = a.events[d[h]]
                              , g = [];
                            if (u && p)
                                for (var w = 0; w < p.length; w++)
                                    p[w] !== u && g.push(p[w]);
                            a.events[d[h]] = g
                        }
                    }
                    ,
                    i.trigger = function(a, l, u) {
                        var d, h, p, g, w = a.events;
                        if (w && o.keys(w).length > 0) {
                            u || (u = {}),
                            d = l.split(" ");
                            for (var b = 0; b < d.length; b++)
                                if (h = d[b],
                                p = w[h],
                                p) {
                                    g = o.clone(u, !1),
                                    g.name = h,
                                    g.source = a;
                                    for (var v = 0; v < p.length; v++)
                                        p[v].apply(a, [g])
                                }
                        }
                    }
                }
                )()
            }
            ), (function(t, r, s) {
                var i = {};
                t.exports = i;
                var o = s(5)
                  , a = s(0)
                  , l = s(1)
                  , u = s(4);
                (function() {
                    i.create = function(d) {
                        return a.extend({
                            id: a.nextId(),
                            type: "composite",
                            parent: null,
                            isModified: !1,
                            bodies: [],
                            constraints: [],
                            composites: [],
                            label: "Composite",
                            plugin: {},
                            cache: {
                                allBodies: null,
                                allConstraints: null,
                                allComposites: null
                            }
                        }, d)
                    }
                    ,
                    i.setModified = function(d, h, p, g) {
                        if (d.isModified = h,
                        h && d.cache && (d.cache.allBodies = null,
                        d.cache.allConstraints = null,
                        d.cache.allComposites = null),
                        p && d.parent && i.setModified(d.parent, h, p, g),
                        g)
                            for (var w = 0; w < d.composites.length; w++) {
                                var b = d.composites[w];
                                i.setModified(b, h, p, g)
                            }
                    }
                    ,
                    i.add = function(d, h) {
                        var p = [].concat(h);
                        o.trigger(d, "beforeAdd", {
                            object: h
                        });
                        for (var g = 0; g < p.length; g++) {
                            var w = p[g];
                            switch (w.type) {
                            case "body":
                                if (w.parent !== w) {
                                    a.warn("Composite.add: skipped adding a compound body part (you must add its parent instead)");
                                    break
                                }
                                i.addBody(d, w);
                                break;
                            case "constraint":
                                i.addConstraint(d, w);
                                break;
                            case "composite":
                                i.addComposite(d, w);
                                break;
                            case "mouseConstraint":
                                i.addConstraint(d, w.constraint);
                                break
                            }
                        }
                        return o.trigger(d, "afterAdd", {
                            object: h
                        }),
                        d
                    }
                    ,
                    i.remove = function(d, h, p) {
                        var g = [].concat(h);
                        o.trigger(d, "beforeRemove", {
                            object: h
                        });
                        for (var w = 0; w < g.length; w++) {
                            var b = g[w];
                            switch (b.type) {
                            case "body":
                                i.removeBody(d, b, p);
                                break;
                            case "constraint":
                                i.removeConstraint(d, b, p);
                                break;
                            case "composite":
                                i.removeComposite(d, b, p);
                                break;
                            case "mouseConstraint":
                                i.removeConstraint(d, b.constraint);
                                break
                            }
                        }
                        return o.trigger(d, "afterRemove", {
                            object: h
                        }),
                        d
                    }
                    ,
                    i.addComposite = function(d, h) {
                        return d.composites.push(h),
                        h.parent = d,
                        i.setModified(d, !0, !0, !1),
                        d
                    }
                    ,
                    i.removeComposite = function(d, h, p) {
                        var g = a.indexOf(d.composites, h);
                        if (g !== -1) {
                            var w = i.allBodies(h);
                            i.removeCompositeAt(d, g);
                            for (var b = 0; b < w.length; b++)
                                w[b].sleepCounter = 0
                        }
                        if (p)
                            for (var b = 0; b < d.composites.length; b++)
                                i.removeComposite(d.composites[b], h, !0);
                        return d
                    }
                    ,
                    i.removeCompositeAt = function(d, h) {
                        return d.composites.splice(h, 1),
                        i.setModified(d, !0, !0, !1),
                        d
                    }
                    ,
                    i.addBody = function(d, h) {
                        return d.bodies.push(h),
                        i.setModified(d, !0, !0, !1),
                        d
                    }
                    ,
                    i.removeBody = function(d, h, p) {
                        var g = a.indexOf(d.bodies, h);
                        if (g !== -1 && (i.removeBodyAt(d, g),
                        h.sleepCounter = 0),
                        p)
                            for (var w = 0; w < d.composites.length; w++)
                                i.removeBody(d.composites[w], h, !0);
                        return d
                    }
                    ,
                    i.removeBodyAt = function(d, h) {
                        return d.bodies.splice(h, 1),
                        i.setModified(d, !0, !0, !1),
                        d
                    }
                    ,
                    i.addConstraint = function(d, h) {
                        return d.constraints.push(h),
                        i.setModified(d, !0, !0, !1),
                        d
                    }
                    ,
                    i.removeConstraint = function(d, h, p) {
                        var g = a.indexOf(d.constraints, h);
                        if (g !== -1 && i.removeConstraintAt(d, g),
                        p)
                            for (var w = 0; w < d.composites.length; w++)
                                i.removeConstraint(d.composites[w], h, !0);
                        return d
                    }
                    ,
                    i.removeConstraintAt = function(d, h) {
                        return d.constraints.splice(h, 1),
                        i.setModified(d, !0, !0, !1),
                        d
                    }
                    ,
                    i.clear = function(d, h, p) {
                        if (p)
                            for (var g = 0; g < d.composites.length; g++)
                                i.clear(d.composites[g], h, !0);
                        return h ? d.bodies = d.bodies.filter(function(w) {
                            return w.isStatic
                        }) : d.bodies.length = 0,
                        d.constraints.length = 0,
                        d.composites.length = 0,
                        i.setModified(d, !0, !0, !1),
                        d
                    }
                    ,
                    i.allBodies = function(d) {
                        if (d.cache && d.cache.allBodies)
                            return d.cache.allBodies;
                        for (var h = [].concat(d.bodies), p = 0; p < d.composites.length; p++)
                            h = h.concat(i.allBodies(d.composites[p]));
                        return d.cache && (d.cache.allBodies = h),
                        h
                    }
                    ,
                    i.allConstraints = function(d) {
                        if (d.cache && d.cache.allConstraints)
                            return d.cache.allConstraints;
                        for (var h = [].concat(d.constraints), p = 0; p < d.composites.length; p++)
                            h = h.concat(i.allConstraints(d.composites[p]));
                        return d.cache && (d.cache.allConstraints = h),
                        h
                    }
                    ,
                    i.allComposites = function(d) {
                        if (d.cache && d.cache.allComposites)
                            return d.cache.allComposites;
                        for (var h = [].concat(d.composites), p = 0; p < d.composites.length; p++)
                            h = h.concat(i.allComposites(d.composites[p]));
                        return d.cache && (d.cache.allComposites = h),
                        h
                    }
                    ,
                    i.get = function(d, h, p) {
                        var g, w;
                        switch (p) {
                        case "body":
                            g = i.allBodies(d);
                            break;
                        case "constraint":
                            g = i.allConstraints(d);
                            break;
                        case "composite":
                            g = i.allComposites(d).concat(d);
                            break
                        }
                        return g ? (w = g.filter(function(b) {
                            return b.id.toString() === h.toString()
                        }),
                        w.length === 0 ? null : w[0]) : null
                    }
                    ,
                    i.move = function(d, h, p) {
                        return i.remove(d, h),
                        i.add(p, h),
                        d
                    }
                    ,
                    i.rebase = function(d) {
                        for (var h = i.allBodies(d).concat(i.allConstraints(d)).concat(i.allComposites(d)), p = 0; p < h.length; p++)
                            h[p].id = a.nextId();
                        return d
                    }
                    ,
                    i.translate = function(d, h, p) {
                        for (var g = p ? i.allBodies(d) : d.bodies, w = 0; w < g.length; w++)
                            u.translate(g[w], h);
                        return d
                    }
                    ,
                    i.rotate = function(d, h, p, g) {
                        for (var w = Math.cos(h), b = Math.sin(h), v = g ? i.allBodies(d) : d.bodies, S = 0; S < v.length; S++) {
                            var N = v[S]
                              , _ = N.position.x - p.x
                              , I = N.position.y - p.y;
                            u.setPosition(N, {
                                x: p.x + (_ * w - I * b),
                                y: p.y + (_ * b + I * w)
                            }),
                            u.rotate(N, h)
                        }
                        return d
                    }
                    ,
                    i.scale = function(d, h, p, g, w) {
                        for (var b = w ? i.allBodies(d) : d.bodies, v = 0; v < b.length; v++) {
                            var S = b[v]
                              , N = S.position.x - g.x
                              , _ = S.position.y - g.y;
                            u.setPosition(S, {
                                x: g.x + N * h,
                                y: g.y + _ * p
                            }),
                            u.scale(S, h, p)
                        }
                        return d
                    }
                    ,
                    i.bounds = function(d) {
                        for (var h = i.allBodies(d), p = [], g = 0; g < h.length; g += 1) {
                            var w = h[g];
                            p.push(w.bounds.min, w.bounds.max)
                        }
                        return l.create(p)
                    }
                }
                )()
            }
            ), (function(t, r, s) {
                var i = {};
                t.exports = i;
                var o = s(4)
                  , a = s(5)
                  , l = s(0);
                (function() {
                    i._motionWakeThreshold = .18,
                    i._motionSleepThreshold = .08,
                    i._minBias = .9,
                    i.update = function(u, d) {
                        for (var h = d / l._baseDelta, p = i._motionSleepThreshold, g = 0; g < u.length; g++) {
                            var w = u[g]
                              , b = o.getSpeed(w)
                              , v = o.getAngularSpeed(w)
                              , S = b * b + v * v;
                            if (w.force.x !== 0 || w.force.y !== 0) {
                                i.set(w, !1);
                                continue
                            }
                            var N = Math.min(w.motion, S)
                              , _ = Math.max(w.motion, S);
                            w.motion = i._minBias * N + (1 - i._minBias) * _,
                            w.sleepThreshold > 0 && w.motion < p ? (w.sleepCounter += 1,
                            w.sleepCounter >= w.sleepThreshold / h && i.set(w, !0)) : w.sleepCounter > 0 && (w.sleepCounter -= 1)
                        }
                    }
                    ,
                    i.afterCollisions = function(u) {
                        for (var d = i._motionSleepThreshold, h = 0; h < u.length; h++) {
                            var p = u[h];
                            if (p.isActive) {
                                var g = p.collision
                                  , w = g.bodyA.parent
                                  , b = g.bodyB.parent;
                                if (!(w.isSleeping && b.isSleeping || w.isStatic || b.isStatic) && (w.isSleeping || b.isSleeping)) {
                                    var v = w.isSleeping && !w.isStatic ? w : b
                                      , S = v === w ? b : w;
                                    !v.isStatic && S.motion > d && i.set(v, !1)
                                }
                            }
                        }
                    }
                    ,
                    i.set = function(u, d) {
                        var h = u.isSleeping;
                        d ? (u.isSleeping = !0,
                        u.sleepCounter = u.sleepThreshold,
                        u.positionImpulse.x = 0,
                        u.positionImpulse.y = 0,
                        u.positionPrev.x = u.position.x,
                        u.positionPrev.y = u.position.y,
                        u.anglePrev = u.angle,
                        u.speed = 0,
                        u.angularSpeed = 0,
                        u.motion = 0,
                        h || a.trigger(u, "sleepStart")) : (u.isSleeping = !1,
                        u.sleepCounter = 0,
                        h && a.trigger(u, "sleepEnd"))
                    }
                }
                )()
            }
            ), (function(t, r, s) {
                var i = {};
                t.exports = i;
                var o = s(3)
                  , a = s(9);
                (function() {
                    var l = []
                      , u = {
                        overlap: 0,
                        axis: null
                    }
                      , d = {
                        overlap: 0,
                        axis: null
                    };
                    i.create = function(h, p) {
                        return {
                            pair: null,
                            collided: !1,
                            bodyA: h,
                            bodyB: p,
                            parentA: h.parent,
                            parentB: p.parent,
                            depth: 0,
                            normal: {
                                x: 0,
                                y: 0
                            },
                            tangent: {
                                x: 0,
                                y: 0
                            },
                            penetration: {
                                x: 0,
                                y: 0
                            },
                            supports: [null, null],
                            supportCount: 0
                        }
                    }
                    ,
                    i.collides = function(h, p, g) {
                        if (i._overlapAxes(u, h.vertices, p.vertices, h.axes),
                        u.overlap <= 0 || (i._overlapAxes(d, p.vertices, h.vertices, p.axes),
                        d.overlap <= 0))
                            return null;
                        var w = g && g.table[a.id(h, p)], b;
                        w ? b = w.collision : (b = i.create(h, p),
                        b.collided = !0,
                        b.bodyA = h.id < p.id ? h : p,
                        b.bodyB = h.id < p.id ? p : h,
                        b.parentA = b.bodyA.parent,
                        b.parentB = b.bodyB.parent),
                        h = b.bodyA,
                        p = b.bodyB;
                        var v;
                        u.overlap < d.overlap ? v = u : v = d;
                        var S = b.normal
                          , N = b.tangent
                          , _ = b.penetration
                          , I = b.supports
                          , k = v.overlap
                          , B = v.axis
                          , P = B.x
                          , M = B.y
                          , R = p.position.x - h.position.x
                          , L = p.position.y - h.position.y;
                        P * R + M * L >= 0 && (P = -P,
                        M = -M),
                        S.x = P,
                        S.y = M,
                        N.x = -M,
                        N.y = P,
                        _.x = P * k,
                        _.y = M * k,
                        b.depth = k;
                        var q = i._findSupports(h, p, S, 1)
                          , H = 0;
                        if (o.contains(h.vertices, q[0]) && (I[H++] = q[0]),
                        o.contains(h.vertices, q[1]) && (I[H++] = q[1]),
                        H < 2) {
                            var j = i._findSupports(p, h, S, -1);
                            o.contains(p.vertices, j[0]) && (I[H++] = j[0]),
                            H < 2 && o.contains(p.vertices, j[1]) && (I[H++] = j[1])
                        }
                        return H === 0 && (I[H++] = q[0]),
                        b.supportCount = H,
                        b
                    }
                    ,
                    i._overlapAxes = function(h, p, g, w) {
                        var b = p.length, v = g.length, S = p[0].x, N = p[0].y, _ = g[0].x, I = g[0].y, k = w.length, B = Number.MAX_VALUE, P = 0, M, R, L, q, H, j;
                        for (H = 0; H < k; H++) {
                            var A = w[H]
                              , E = A.x
                              , C = A.y
                              , O = S * E + N * C
                              , z = _ * E + I * C
                              , G = O
                              , Y = z;
                            for (j = 1; j < b; j += 1)
                                q = p[j].x * E + p[j].y * C,
                                q > G ? G = q : q < O && (O = q);
                            for (j = 1; j < v; j += 1)
                                q = g[j].x * E + g[j].y * C,
                                q > Y ? Y = q : q < z && (z = q);
                            if (R = G - z,
                            L = Y - O,
                            M = R < L ? R : L,
                            M < B && (B = M,
                            P = H,
                            M <= 0))
                                break
                        }
                        h.axis = w[P],
                        h.overlap = B
                    }
                    ,
                    i._findSupports = function(h, p, g, w) {
                        var b = p.vertices, v = b.length, S = h.position.x, N = h.position.y, _ = g.x * w, I = g.y * w, k = b[0], B = k, P = _ * (S - B.x) + I * (N - B.y), M, R, L;
                        for (L = 1; L < v; L += 1)
                            B = b[L],
                            R = _ * (S - B.x) + I * (N - B.y),
                            R < P && (P = R,
                            k = B);
                        return M = b[(v + k.index - 1) % v],
                        P = _ * (S - M.x) + I * (N - M.y),
                        B = b[(k.index + 1) % v],
                        _ * (S - B.x) + I * (N - B.y) < P ? (l[0] = k,
                        l[1] = B,
                        l) : (l[0] = k,
                        l[1] = M,
                        l)
                    }
                }
                )()
            }
            ), (function(t, r, s) {
                var i = {};
                t.exports = i;
                var o = s(16);
                (function() {
                    i.create = function(a, l) {
                        var u = a.bodyA
                          , d = a.bodyB
                          , h = {
                            id: i.id(u, d),
                            bodyA: u,
                            bodyB: d,
                            collision: a,
                            contacts: [o.create(), o.create()],
                            contactCount: 0,
                            separation: 0,
                            isActive: !0,
                            isSensor: u.isSensor || d.isSensor,
                            timeCreated: l,
                            timeUpdated: l,
                            inverseMass: 0,
                            friction: 0,
                            frictionStatic: 0,
                            restitution: 0,
                            slop: 0
                        };
                        return i.update(h, a, l),
                        h
                    }
                    ,
                    i.update = function(a, l, u) {
                        var d = l.supports
                          , h = l.supportCount
                          , p = a.contacts
                          , g = l.parentA
                          , w = l.parentB;
                        a.isActive = !0,
                        a.timeUpdated = u,
                        a.collision = l,
                        a.separation = l.depth,
                        a.inverseMass = g.inverseMass + w.inverseMass,
                        a.friction = g.friction < w.friction ? g.friction : w.friction,
                        a.frictionStatic = g.frictionStatic > w.frictionStatic ? g.frictionStatic : w.frictionStatic,
                        a.restitution = g.restitution > w.restitution ? g.restitution : w.restitution,
                        a.slop = g.slop > w.slop ? g.slop : w.slop,
                        a.contactCount = h,
                        l.pair = a;
                        var b = d[0]
                          , v = p[0]
                          , S = d[1]
                          , N = p[1];
                        (N.vertex === b || v.vertex === S) && (p[1] = v,
                        p[0] = v = N,
                        N = p[1]),
                        v.vertex = b,
                        N.vertex = S
                    }
                    ,
                    i.setActive = function(a, l, u) {
                        l ? (a.isActive = !0,
                        a.timeUpdated = u) : (a.isActive = !1,
                        a.contactCount = 0)
                    }
                    ,
                    i.id = function(a, l) {
                        return a.id < l.id ? a.id.toString(36) + ":" + l.id.toString(36) : l.id.toString(36) + ":" + a.id.toString(36)
                    }
                }
                )()
            }
            ), (function(t, r, s) {
                var i = {};
                t.exports = i;
                var o = s(3)
                  , a = s(2)
                  , l = s(7)
                  , u = s(1)
                  , d = s(11)
                  , h = s(0);
                (function() {
                    i._warming = .4,
                    i._torqueDampen = 1,
                    i._minLength = 1e-6,
                    i.create = function(p) {
                        var g = p;
                        g.bodyA && !g.pointA && (g.pointA = {
                            x: 0,
                            y: 0
                        }),
                        g.bodyB && !g.pointB && (g.pointB = {
                            x: 0,
                            y: 0
                        });
                        var w = g.bodyA ? a.add(g.bodyA.position, g.pointA) : g.pointA
                          , b = g.bodyB ? a.add(g.bodyB.position, g.pointB) : g.pointB
                          , v = a.magnitude(a.sub(w, b));
                        g.length = typeof g.length < "u" ? g.length : v,
                        g.id = g.id || h.nextId(),
                        g.label = g.label || "Constraint",
                        g.type = "constraint",
                        g.stiffness = g.stiffness || (g.length > 0 ? 1 : .7),
                        g.damping = g.damping || 0,
                        g.angularStiffness = g.angularStiffness || 0,
                        g.angleA = g.bodyA ? g.bodyA.angle : g.angleA,
                        g.angleB = g.bodyB ? g.bodyB.angle : g.angleB,
                        g.plugin = {};
                        var S = {
                            visible: !0,
                            lineWidth: 2,
                            strokeStyle: "#ffffff",
                            type: "line",
                            anchors: !0
                        };
                        return g.length === 0 && g.stiffness > .1 ? (S.type = "pin",
                        S.anchors = !1) : g.stiffness < .9 && (S.type = "spring"),
                        g.render = h.extend(S, g.render),
                        g
                    }
                    ,
                    i.preSolveAll = function(p) {
                        for (var g = 0; g < p.length; g += 1) {
                            var w = p[g]
                              , b = w.constraintImpulse;
                            w.isStatic || b.x === 0 && b.y === 0 && b.angle === 0 || (w.position.x += b.x,
                            w.position.y += b.y,
                            w.angle += b.angle)
                        }
                    }
                    ,
                    i.solveAll = function(p, g) {
                        for (var w = h.clamp(g / h._baseDelta, 0, 1), b = 0; b < p.length; b += 1) {
                            var v = p[b]
                              , S = !v.bodyA || v.bodyA && v.bodyA.isStatic
                              , N = !v.bodyB || v.bodyB && v.bodyB.isStatic;
                            (S || N) && i.solve(p[b], w)
                        }
                        for (b = 0; b < p.length; b += 1)
                            v = p[b],
                            S = !v.bodyA || v.bodyA && v.bodyA.isStatic,
                            N = !v.bodyB || v.bodyB && v.bodyB.isStatic,
                            !S && !N && i.solve(p[b], w)
                    }
                    ,
                    i.solve = function(p, g) {
                        var w = p.bodyA
                          , b = p.bodyB
                          , v = p.pointA
                          , S = p.pointB;
                        if (!(!w && !b)) {
                            w && !w.isStatic && (a.rotate(v, w.angle - p.angleA, v),
                            p.angleA = w.angle),
                            b && !b.isStatic && (a.rotate(S, b.angle - p.angleB, S),
                            p.angleB = b.angle);
                            var N = v
                              , _ = S;
                            if (w && (N = a.add(w.position, v)),
                            b && (_ = a.add(b.position, S)),
                            !(!N || !_)) {
                                var I = a.sub(N, _)
                                  , k = a.magnitude(I);
                                k < i._minLength && (k = i._minLength);
                                var B = (k - p.length) / k, P = p.stiffness >= 1 || p.length === 0, M = P ? p.stiffness * g : p.stiffness * g * g, R = p.damping * g, L = a.mult(I, B * M), q = (w ? w.inverseMass : 0) + (b ? b.inverseMass : 0), H = (w ? w.inverseInertia : 0) + (b ? b.inverseInertia : 0), j = q + H, A, E, C, O, z;
                                if (R > 0) {
                                    var G = a.create();
                                    C = a.div(I, k),
                                    z = a.sub(b && a.sub(b.position, b.positionPrev) || G, w && a.sub(w.position, w.positionPrev) || G),
                                    O = a.dot(C, z)
                                }
                                w && !w.isStatic && (E = w.inverseMass / q,
                                w.constraintImpulse.x -= L.x * E,
                                w.constraintImpulse.y -= L.y * E,
                                w.position.x -= L.x * E,
                                w.position.y -= L.y * E,
                                R > 0 && (w.positionPrev.x -= R * C.x * O * E,
                                w.positionPrev.y -= R * C.y * O * E),
                                A = a.cross(v, L) / j * i._torqueDampen * w.inverseInertia * (1 - p.angularStiffness),
                                w.constraintImpulse.angle -= A,
                                w.angle -= A),
                                b && !b.isStatic && (E = b.inverseMass / q,
                                b.constraintImpulse.x += L.x * E,
                                b.constraintImpulse.y += L.y * E,
                                b.position.x += L.x * E,
                                b.position.y += L.y * E,
                                R > 0 && (b.positionPrev.x += R * C.x * O * E,
                                b.positionPrev.y += R * C.y * O * E),
                                A = a.cross(S, L) / j * i._torqueDampen * b.inverseInertia * (1 - p.angularStiffness),
                                b.constraintImpulse.angle += A,
                                b.angle += A)
                            }
                        }
                    }
                    ,
                    i.postSolveAll = function(p) {
                        for (var g = 0; g < p.length; g++) {
                            var w = p[g]
                              , b = w.constraintImpulse;
                            if (!(w.isStatic || b.x === 0 && b.y === 0 && b.angle === 0)) {
                                l.set(w, !1);
                                for (var v = 0; v < w.parts.length; v++) {
                                    var S = w.parts[v];
                                    o.translate(S.vertices, b),
                                    v > 0 && (S.position.x += b.x,
                                    S.position.y += b.y),
                                    b.angle !== 0 && (o.rotate(S.vertices, b.angle, w.position),
                                    d.rotate(S.axes, b.angle),
                                    v > 0 && a.rotateAbout(S.position, b.angle, w.position, S.position)),
                                    u.update(S.bounds, S.vertices, w.velocity)
                                }
                                b.angle *= i._warming,
                                b.x *= i._warming,
                                b.y *= i._warming
                            }
                        }
                    }
                    ,
                    i.pointAWorld = function(p) {
                        return {
                            x: (p.bodyA ? p.bodyA.position.x : 0) + (p.pointA ? p.pointA.x : 0),
                            y: (p.bodyA ? p.bodyA.position.y : 0) + (p.pointA ? p.pointA.y : 0)
                        }
                    }
                    ,
                    i.pointBWorld = function(p) {
                        return {
                            x: (p.bodyB ? p.bodyB.position.x : 0) + (p.pointB ? p.pointB.x : 0),
                            y: (p.bodyB ? p.bodyB.position.y : 0) + (p.pointB ? p.pointB.y : 0)
                        }
                    }
                    ,
                    i.currentLength = function(p) {
                        var g = (p.bodyA ? p.bodyA.position.x : 0) + (p.pointA ? p.pointA.x : 0)
                          , w = (p.bodyA ? p.bodyA.position.y : 0) + (p.pointA ? p.pointA.y : 0)
                          , b = (p.bodyB ? p.bodyB.position.x : 0) + (p.pointB ? p.pointB.x : 0)
                          , v = (p.bodyB ? p.bodyB.position.y : 0) + (p.pointB ? p.pointB.y : 0)
                          , S = g - b
                          , N = w - v;
                        return Math.sqrt(S * S + N * N)
                    }
                }
                )()
            }
            ), (function(t, r, s) {
                var i = {};
                t.exports = i;
                var o = s(2)
                  , a = s(0);
                (function() {
                    i.fromVertices = function(l) {
                        for (var u = {}, d = 0; d < l.length; d++) {
                            var h = (d + 1) % l.length
                              , p = o.normalise({
                                x: l[h].y - l[d].y,
                                y: l[d].x - l[h].x
                            })
                              , g = p.y === 0 ? 1 / 0 : p.x / p.y;
                            g = g.toFixed(3).toString(),
                            u[g] = p
                        }
                        return a.values(u)
                    }
                    ,
                    i.rotate = function(l, u) {
                        if (u !== 0)
                            for (var d = Math.cos(u), h = Math.sin(u), p = 0; p < l.length; p++) {
                                var g = l[p], w;
                                w = g.x * d - g.y * h,
                                g.y = g.x * h + g.y * d,
                                g.x = w
                            }
                    }
                }
                )()
            }
            ), (function(t, r, s) {
                var i = {};
                t.exports = i;
                var o = s(3)
                  , a = s(0)
                  , l = s(4)
                  , u = s(1)
                  , d = s(2);
                (function() {
                    i.rectangle = function(h, p, g, w, b) {
                        b = b || {};
                        var v = {
                            label: "Rectangle Body",
                            position: {
                                x: h,
                                y: p
                            },
                            vertices: o.fromPath("L 0 0 L " + g + " 0 L " + g + " " + w + " L 0 " + w)
                        };
                        if (b.chamfer) {
                            var S = b.chamfer;
                            v.vertices = o.chamfer(v.vertices, S.radius, S.quality, S.qualityMin, S.qualityMax),
                            delete b.chamfer
                        }
                        return l.create(a.extend({}, v, b))
                    }
                    ,
                    i.trapezoid = function(h, p, g, w, b, v) {
                        v = v || {},
                        b >= 1 && a.warn("Bodies.trapezoid: slope parameter must be < 1."),
                        b *= .5;
                        var S = (1 - b * 2) * g, N = g * b, _ = N + S, I = _ + N, k;
                        b < .5 ? k = "L 0 0 L " + N + " " + -w + " L " + _ + " " + -w + " L " + I + " 0" : k = "L 0 0 L " + _ + " " + -w + " L " + I + " 0";
                        var B = {
                            label: "Trapezoid Body",
                            position: {
                                x: h,
                                y: p
                            },
                            vertices: o.fromPath(k)
                        };
                        if (v.chamfer) {
                            var P = v.chamfer;
                            B.vertices = o.chamfer(B.vertices, P.radius, P.quality, P.qualityMin, P.qualityMax),
                            delete v.chamfer
                        }
                        return l.create(a.extend({}, B, v))
                    }
                    ,
                    i.circle = function(h, p, g, w, b) {
                        w = w || {};
                        var v = {
                            label: "Circle Body",
                            circleRadius: g
                        };
                        b = b || 25;
                        var S = Math.ceil(Math.max(10, Math.min(b, g)));
                        return S % 2 === 1 && (S += 1),
                        i.polygon(h, p, S, g, a.extend({}, v, w))
                    }
                    ,
                    i.polygon = function(h, p, g, w, b) {
                        if (b = b || {},
                        g < 3)
                            return i.circle(h, p, w, b);
                        for (var v = 2 * Math.PI / g, S = "", N = v * .5, _ = 0; _ < g; _ += 1) {
                            var I = N + _ * v
                              , k = Math.cos(I) * w
                              , B = Math.sin(I) * w;
                            S += "L " + k.toFixed(3) + " " + B.toFixed(3) + " "
                        }
                        var P = {
                            label: "Polygon Body",
                            position: {
                                x: h,
                                y: p
                            },
                            vertices: o.fromPath(S)
                        };
                        if (b.chamfer) {
                            var M = b.chamfer;
                            P.vertices = o.chamfer(P.vertices, M.radius, M.quality, M.qualityMin, M.qualityMax),
                            delete b.chamfer
                        }
                        return l.create(a.extend({}, P, b))
                    }
                    ,
                    i.fromVertices = function(h, p, g, w, b, v, S, N) {
                        var _ = a.getDecomp(), I, k, B, P, M, R, L, q, H, j, A;
                        for (I = !!(_ && _.quickDecomp),
                        w = w || {},
                        B = [],
                        b = typeof b < "u" ? b : !1,
                        v = typeof v < "u" ? v : .01,
                        S = typeof S < "u" ? S : 10,
                        N = typeof N < "u" ? N : .01,
                        a.isArray(g[0]) || (g = [g]),
                        j = 0; j < g.length; j += 1)
                            if (R = g[j],
                            P = o.isConvex(R),
                            M = !P,
                            M && !I && a.warnOnce("Bodies.fromVertices: Install the 'poly-decomp' library and use Common.setDecomp or provide 'decomp' as a global to decompose concave vertices."),
                            P || !I)
                                P ? R = o.clockwiseSort(R) : R = o.hull(R),
                                B.push({
                                    position: {
                                        x: h,
                                        y: p
                                    },
                                    vertices: R
                                });
                            else {
                                var E = R.map(function(J) {
                                    return [J.x, J.y]
                                });
                                _.makeCCW(E),
                                v !== !1 && _.removeCollinearPoints(E, v),
                                N !== !1 && _.removeDuplicatePoints && _.removeDuplicatePoints(E, N);
                                var C = _.quickDecomp(E);
                                for (L = 0; L < C.length; L++) {
                                    var O = C[L]
                                      , z = O.map(function(J) {
                                        return {
                                            x: J[0],
                                            y: J[1]
                                        }
                                    });
                                    S > 0 && o.area(z) < S || B.push({
                                        position: o.centre(z),
                                        vertices: z
                                    })
                                }
                            }
                        for (L = 0; L < B.length; L++)
                            B[L] = l.create(a.extend(B[L], w));
                        if (b) {
                            var G = 5;
                            for (L = 0; L < B.length; L++) {
                                var Y = B[L];
                                for (q = L + 1; q < B.length; q++) {
                                    var $ = B[q];
                                    if (u.overlaps(Y.bounds, $.bounds)) {
                                        var D = Y.vertices
                                          , U = $.vertices;
                                        for (H = 0; H < Y.vertices.length; H++)
                                            for (A = 0; A < $.vertices.length; A++) {
                                                var W = d.magnitudeSquared(d.sub(D[(H + 1) % D.length], U[A]))
                                                  , Q = d.magnitudeSquared(d.sub(D[H], U[(A + 1) % U.length]));
                                                W < G && Q < G && (D[H].isInternal = !0,
                                                U[A].isInternal = !0)
                                            }
                                    }
                                }
                            }
                        }
                        return B.length > 1 ? (k = l.create(a.extend({
                            parts: B.slice(0)
                        }, w)),
                        l.setPosition(k, {
                            x: h,
                            y: p
                        }),
                        k) : B[0]
                    }
                }
                )()
            }
            ), (function(t, r, s) {
                var i = {};
                t.exports = i;
                var o = s(0)
                  , a = s(8);
                (function() {
                    i.create = function(l) {
                        var u = {
                            bodies: [],
                            collisions: [],
                            pairs: null
                        };
                        return o.extend(u, l)
                    }
                    ,
                    i.setBodies = function(l, u) {
                        l.bodies = u.slice(0)
                    }
                    ,
                    i.clear = function(l) {
                        l.bodies = [],
                        l.collisions = []
                    }
                    ,
                    i.collisions = function(l) {
                        var u = l.pairs, d = l.bodies, h = d.length, p = i.canCollide, g = a.collides, w = l.collisions, b = 0, v, S;
                        for (d.sort(i._compareBoundsX),
                        v = 0; v < h; v++) {
                            var N = d[v]
                              , _ = N.bounds
                              , I = N.bounds.max.x
                              , k = N.bounds.max.y
                              , B = N.bounds.min.y
                              , P = N.isStatic || N.isSleeping
                              , M = N.parts.length
                              , R = M === 1;
                            for (S = v + 1; S < h; S++) {
                                var L = d[S]
                                  , q = L.bounds;
                                if (q.min.x > I)
                                    break;
                                if (!(k < q.min.y || B > q.max.y) && !(P && (L.isStatic || L.isSleeping)) && p(N.collisionFilter, L.collisionFilter)) {
                                    var H = L.parts.length;
                                    if (R && H === 1) {
                                        var j = g(N, L, u);
                                        j && (w[b++] = j)
                                    } else
                                        for (var A = M > 1 ? 1 : 0, E = H > 1 ? 1 : 0, C = A; C < M; C++)
                                            for (var O = N.parts[C], _ = O.bounds, z = E; z < H; z++) {
                                                var G = L.parts[z]
                                                  , q = G.bounds;
                                                if (!(_.min.x > q.max.x || _.max.x < q.min.x || _.max.y < q.min.y || _.min.y > q.max.y)) {
                                                    var j = g(O, G, u);
                                                    j && (w[b++] = j)
                                                }
                                            }
                                }
                            }
                        }
                        return w.length !== b && (w.length = b),
                        w
                    }
                    ,
                    i.canCollide = function(l, u) {
                        return l.group === u.group && l.group !== 0 ? l.group > 0 : (l.mask & u.category) !== 0 && (u.mask & l.category) !== 0
                    }
                    ,
                    i._compareBoundsX = function(l, u) {
                        return l.bounds.min.x - u.bounds.min.x
                    }
                }
                )()
            }
            ), (function(t, r, s) {
                var i = {};
                t.exports = i;
                var o = s(0);
                (function() {
                    i.create = function(a) {
                        var l = {};
                        return a || o.log("Mouse.create: element was undefined, defaulting to document.body", "warn"),
                        l.element = a || document.body,
                        l.absolute = {
                            x: 0,
                            y: 0
                        },
                        l.position = {
                            x: 0,
                            y: 0
                        },
                        l.mousedownPosition = {
                            x: 0,
                            y: 0
                        },
                        l.mouseupPosition = {
                            x: 0,
                            y: 0
                        },
                        l.offset = {
                            x: 0,
                            y: 0
                        },
                        l.scale = {
                            x: 1,
                            y: 1
                        },
                        l.wheelDelta = 0,
                        l.button = -1,
                        l.pixelRatio = parseInt(l.element.getAttribute("data-pixel-ratio"), 10) || 1,
                        l.sourceEvents = {
                            mousemove: null,
                            mousedown: null,
                            mouseup: null,
                            mousewheel: null
                        },
                        l.mousemove = function(u) {
                            var d = i._getRelativeMousePosition(u, l.element, l.pixelRatio)
                              , h = u.changedTouches;
                            h && (l.button = 0,
                            u.preventDefault()),
                            l.absolute.x = d.x,
                            l.absolute.y = d.y,
                            l.position.x = l.absolute.x * l.scale.x + l.offset.x,
                            l.position.y = l.absolute.y * l.scale.y + l.offset.y,
                            l.sourceEvents.mousemove = u
                        }
                        ,
                        l.mousedown = function(u) {
                            var d = i._getRelativeMousePosition(u, l.element, l.pixelRatio)
                              , h = u.changedTouches;
                            h ? (l.button = 0,
                            u.preventDefault()) : l.button = u.button,
                            l.absolute.x = d.x,
                            l.absolute.y = d.y,
                            l.position.x = l.absolute.x * l.scale.x + l.offset.x,
                            l.position.y = l.absolute.y * l.scale.y + l.offset.y,
                            l.mousedownPosition.x = l.position.x,
                            l.mousedownPosition.y = l.position.y,
                            l.sourceEvents.mousedown = u
                        }
                        ,
                        l.mouseup = function(u) {
                            var d = i._getRelativeMousePosition(u, l.element, l.pixelRatio)
                              , h = u.changedTouches;
                            h && u.preventDefault(),
                            l.button = -1,
                            l.absolute.x = d.x,
                            l.absolute.y = d.y,
                            l.position.x = l.absolute.x * l.scale.x + l.offset.x,
                            l.position.y = l.absolute.y * l.scale.y + l.offset.y,
                            l.mouseupPosition.x = l.position.x,
                            l.mouseupPosition.y = l.position.y,
                            l.sourceEvents.mouseup = u
                        }
                        ,
                        l.mousewheel = function(u) {
                            l.wheelDelta = Math.max(-1, Math.min(1, u.wheelDelta || -u.detail)),
                            u.preventDefault(),
                            l.sourceEvents.mousewheel = u
                        }
                        ,
                        i.setElement(l, l.element),
                        l
                    }
                    ,
                    i.setElement = function(a, l) {
                        a.element = l,
                        l.addEventListener("mousemove", a.mousemove, {
                            passive: !0
                        }),
                        l.addEventListener("mousedown", a.mousedown, {
                            passive: !0
                        }),
                        l.addEventListener("mouseup", a.mouseup, {
                            passive: !0
                        }),
                        l.addEventListener("wheel", a.mousewheel, {
                            passive: !1
                        }),
                        l.addEventListener("touchmove", a.mousemove, {
                            passive: !1
                        }),
                        l.addEventListener("touchstart", a.mousedown, {
                            passive: !1
                        }),
                        l.addEventListener("touchend", a.mouseup, {
                            passive: !1
                        })
                    }
                    ,
                    i.clearSourceEvents = function(a) {
                        a.sourceEvents.mousemove = null,
                        a.sourceEvents.mousedown = null,
                        a.sourceEvents.mouseup = null,
                        a.sourceEvents.mousewheel = null,
                        a.wheelDelta = 0
                    }
                    ,
                    i.setOffset = function(a, l) {
                        a.offset.x = l.x,
                        a.offset.y = l.y,
                        a.position.x = a.absolute.x * a.scale.x + a.offset.x,
                        a.position.y = a.absolute.y * a.scale.y + a.offset.y
                    }
                    ,
                    i.setScale = function(a, l) {
                        a.scale.x = l.x,
                        a.scale.y = l.y,
                        a.position.x = a.absolute.x * a.scale.x + a.offset.x,
                        a.position.y = a.absolute.y * a.scale.y + a.offset.y
                    }
                    ,
                    i._getRelativeMousePosition = function(a, l, u) {
                        var d = l.getBoundingClientRect(), h = document.documentElement || document.body.parentNode || document.body, p = window.pageXOffset !== void 0 ? window.pageXOffset : h.scrollLeft, g = window.pageYOffset !== void 0 ? window.pageYOffset : h.scrollTop, w = a.changedTouches, b, v;
                        return w ? (b = w[0].pageX - d.left - p,
                        v = w[0].pageY - d.top - g) : (b = a.pageX - d.left - p,
                        v = a.pageY - d.top - g),
                        {
                            x: b / (l.clientWidth / (l.width || l.clientWidth) * u),
                            y: v / (l.clientHeight / (l.height || l.clientHeight) * u)
                        }
                    }
                }
                )()
            }
            ), (function(t, r, s) {
                var i = {};
                t.exports = i;
                var o = s(0);
                (function() {
                    i._registry = {},
                    i.register = function(a) {
                        if (i.isPlugin(a) || o.warn("Plugin.register:", i.toString(a), "does not implement all required fields."),
                        a.name in i._registry) {
                            var l = i._registry[a.name]
                              , u = i.versionParse(a.version).number
                              , d = i.versionParse(l.version).number;
                            u > d ? (o.warn("Plugin.register:", i.toString(l), "was upgraded to", i.toString(a)),
                            i._registry[a.name] = a) : u < d ? o.warn("Plugin.register:", i.toString(l), "can not be downgraded to", i.toString(a)) : a !== l && o.warn("Plugin.register:", i.toString(a), "is already registered to different plugin object")
                        } else
                            i._registry[a.name] = a;
                        return a
                    }
                    ,
                    i.resolve = function(a) {
                        return i._registry[i.dependencyParse(a).name]
                    }
                    ,
                    i.toString = function(a) {
                        return typeof a == "string" ? a : (a.name || "anonymous") + "@" + (a.version || a.range || "0.0.0")
                    }
                    ,
                    i.isPlugin = function(a) {
                        return a && a.name && a.version && a.install
                    }
                    ,
                    i.isUsed = function(a, l) {
                        return a.used.indexOf(l) > -1
                    }
                    ,
                    i.isFor = function(a, l) {
                        var u = a.for && i.dependencyParse(a.for);
                        return !a.for || l.name === u.name && i.versionSatisfies(l.version, u.range)
                    }
                    ,
                    i.use = function(a, l) {
                        if (a.uses = (a.uses || []).concat(l || []),
                        a.uses.length === 0) {
                            o.warn("Plugin.use:", i.toString(a), "does not specify any dependencies to install.");
                            return
                        }
                        for (var u = i.dependencies(a), d = o.topologicalSort(u), h = [], p = 0; p < d.length; p += 1)
                            if (d[p] !== a.name) {
                                var g = i.resolve(d[p]);
                                if (!g) {
                                    h.push(" " + d[p]);
                                    continue
                                }
                                i.isUsed(a, g.name) || (i.isFor(g, a) || (o.warn("Plugin.use:", i.toString(g), "is for", g.for, "but installed on", i.toString(a) + "."),
                                g._warned = !0),
                                g.install ? g.install(a) : (o.warn("Plugin.use:", i.toString(g), "does not specify an install function."),
                                g._warned = !0),
                                g._warned ? (h.push(" " + i.toString(g)),
                                delete g._warned) : h.push(" " + i.toString(g)),
                                a.used.push(g.name))
                            }
                        h.length > 0 && o.info(h.join("  "))
                    }
                    ,
                    i.dependencies = function(a, l) {
                        var u = i.dependencyParse(a)
                          , d = u.name;
                        if (l = l || {},
                        !(d in l)) {
                            a = i.resolve(a) || a,
                            l[d] = o.map(a.uses || [], function(p) {
                                i.isPlugin(p) && i.register(p);
                                var g = i.dependencyParse(p)
                                  , w = i.resolve(p);
                                return w && !i.versionSatisfies(w.version, g.range) ? (o.warn("Plugin.dependencies:", i.toString(w), "does not satisfy", i.toString(g), "used by", i.toString(u) + "."),
                                w._warned = !0,
                                a._warned = !0) : w || (o.warn("Plugin.dependencies:", i.toString(p), "used by", i.toString(u), "could not be resolved."),
                                a._warned = !0),
                                g.name
                            });
                            for (var h = 0; h < l[d].length; h += 1)
                                i.dependencies(l[d][h], l);
                            return l
                        }
                    }
                    ,
                    i.dependencyParse = function(a) {
                        if (o.isString(a)) {
                            var l = /^[\w-]+(@(\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-+]+)?))?$/;
                            return l.test(a) || o.warn("Plugin.dependencyParse:", a, "is not a valid dependency string."),
                            {
                                name: a.split("@")[0],
                                range: a.split("@")[1] || "*"
                            }
                        }
                        return {
                            name: a.name,
                            range: a.range || a.version
                        }
                    }
                    ,
                    i.versionParse = function(a) {
                        var l = /^(\*)|(\^|~|>=|>)?\s*((\d+)\.(\d+)\.(\d+))(-[0-9A-Za-z-+]+)?$/;
                        l.test(a) || o.warn("Plugin.versionParse:", a, "is not a valid version or range.");
                        var u = l.exec(a)
                          , d = Number(u[4])
                          , h = Number(u[5])
                          , p = Number(u[6]);
                        return {
                            isRange: !!(u[1] || u[2]),
                            version: u[3],
                            range: a,
                            operator: u[1] || u[2] || "",
                            major: d,
                            minor: h,
                            patch: p,
                            parts: [d, h, p],
                            prerelease: u[7],
                            number: d * 1e8 + h * 1e4 + p
                        }
                    }
                    ,
                    i.versionSatisfies = function(a, l) {
                        l = l || "*";
                        var u = i.versionParse(l)
                          , d = i.versionParse(a);
                        if (u.isRange) {
                            if (u.operator === "*" || a === "*")
                                return !0;
                            if (u.operator === ">")
                                return d.number > u.number;
                            if (u.operator === ">=")
                                return d.number >= u.number;
                            if (u.operator === "~")
                                return d.major === u.major && d.minor === u.minor && d.patch >= u.patch;
                            if (u.operator === "^")
                                return u.major > 0 ? d.major === u.major && d.number >= u.number : u.minor > 0 ? d.minor === u.minor && d.patch >= u.patch : d.patch === u.patch
                        }
                        return a === l || a === "*"
                    }
                }
                )()
            }
            ), (function(t, r) {
                var s = {};
                t.exports = s,
                (function() {
                    s.create = function(i) {
                        return {
                            vertex: i,
                            normalImpulse: 0,
                            tangentImpulse: 0
                        }
                    }
                }
                )()
            }
            ), (function(t, r, s) {
                var i = {};
                t.exports = i;
                var o = s(7)
                  , a = s(18)
                  , l = s(13)
                  , u = s(19)
                  , d = s(5)
                  , h = s(6)
                  , p = s(10)
                  , g = s(0)
                  , w = s(4);
                (function() {
                    i._deltaMax = 1e3 / 60,
                    i.create = function(b) {
                        b = b || {};
                        var v = {
                            positionIterations: 6,
                            velocityIterations: 4,
                            constraintIterations: 2,
                            enableSleeping: !1,
                            events: [],
                            plugin: {},
                            gravity: {
                                x: 0,
                                y: 1,
                                scale: .001
                            },
                            timing: {
                                timestamp: 0,
                                timeScale: 1,
                                lastDelta: 0,
                                lastElapsed: 0,
                                lastUpdatesPerFrame: 0
                            }
                        }
                          , S = g.extend(v, b);
                        return S.world = b.world || h.create({
                            label: "World"
                        }),
                        S.pairs = b.pairs || u.create(),
                        S.detector = b.detector || l.create(),
                        S.detector.pairs = S.pairs,
                        S.grid = {
                            buckets: []
                        },
                        S.world.gravity = S.gravity,
                        S.broadphase = S.grid,
                        S.metrics = {},
                        S
                    }
                    ,
                    i.update = function(b, v) {
                        var S = g.now(), N = b.world, _ = b.detector, I = b.pairs, k = b.timing, B = k.timestamp, P;
                        v > i._deltaMax && g.warnOnce("Matter.Engine.update: delta argument is recommended to be less than or equal to", i._deltaMax.toFixed(3), "ms."),
                        v = typeof v < "u" ? v : g._baseDelta,
                        v *= k.timeScale,
                        k.timestamp += v,
                        k.lastDelta = v;
                        var M = {
                            timestamp: k.timestamp,
                            delta: v
                        };
                        d.trigger(b, "beforeUpdate", M);
                        var R = h.allBodies(N)
                          , L = h.allConstraints(N);
                        for (N.isModified && (l.setBodies(_, R),
                        h.setModified(N, !1, !1, !0)),
                        b.enableSleeping && o.update(R, v),
                        i._bodiesApplyGravity(R, b.gravity),
                        v > 0 && i._bodiesUpdate(R, v),
                        d.trigger(b, "beforeSolve", M),
                        p.preSolveAll(R),
                        P = 0; P < b.constraintIterations; P++)
                            p.solveAll(L, v);
                        p.postSolveAll(R);
                        var q = l.collisions(_);
                        u.update(I, q, B),
                        b.enableSleeping && o.afterCollisions(I.list),
                        I.collisionStart.length > 0 && d.trigger(b, "collisionStart", {
                            pairs: I.collisionStart,
                            timestamp: k.timestamp,
                            delta: v
                        });
                        var H = g.clamp(20 / b.positionIterations, 0, 1);
                        for (a.preSolvePosition(I.list),
                        P = 0; P < b.positionIterations; P++)
                            a.solvePosition(I.list, v, H);
                        for (a.postSolvePosition(R),
                        p.preSolveAll(R),
                        P = 0; P < b.constraintIterations; P++)
                            p.solveAll(L, v);
                        for (p.postSolveAll(R),
                        a.preSolveVelocity(I.list),
                        P = 0; P < b.velocityIterations; P++)
                            a.solveVelocity(I.list, v);
                        return i._bodiesUpdateVelocities(R),
                        I.collisionActive.length > 0 && d.trigger(b, "collisionActive", {
                            pairs: I.collisionActive,
                            timestamp: k.timestamp,
                            delta: v
                        }),
                        I.collisionEnd.length > 0 && d.trigger(b, "collisionEnd", {
                            pairs: I.collisionEnd,
                            timestamp: k.timestamp,
                            delta: v
                        }),
                        i._bodiesClearForces(R),
                        d.trigger(b, "afterUpdate", M),
                        b.timing.lastElapsed = g.now() - S,
                        b
                    }
                    ,
                    i.merge = function(b, v) {
                        if (g.extend(b, v),
                        v.world) {
                            b.world = v.world,
                            i.clear(b);
                            for (var S = h.allBodies(b.world), N = 0; N < S.length; N++) {
                                var _ = S[N];
                                o.set(_, !1),
                                _.id = g.nextId()
                            }
                        }
                    }
                    ,
                    i.clear = function(b) {
                        u.clear(b.pairs),
                        l.clear(b.detector)
                    }
                    ,
                    i._bodiesClearForces = function(b) {
                        for (var v = b.length, S = 0; S < v; S++) {
                            var N = b[S];
                            N.force.x = 0,
                            N.force.y = 0,
                            N.torque = 0
                        }
                    }
                    ,
                    i._bodiesApplyGravity = function(b, v) {
                        var S = typeof v.scale < "u" ? v.scale : .001
                          , N = b.length;
                        if (!(v.x === 0 && v.y === 0 || S === 0))
                            for (var _ = 0; _ < N; _++) {
                                var I = b[_];
                                I.isStatic || I.isSleeping || (I.force.y += I.mass * v.y * S,
                                I.force.x += I.mass * v.x * S)
                            }
                    }
                    ,
                    i._bodiesUpdate = function(b, v) {
                        for (var S = b.length, N = 0; N < S; N++) {
                            var _ = b[N];
                            _.isStatic || _.isSleeping || w.update(_, v)
                        }
                    }
                    ,
                    i._bodiesUpdateVelocities = function(b) {
                        for (var v = b.length, S = 0; S < v; S++)
                            w.updateVelocities(b[S])
                    }
                }
                )()
            }
            ), (function(t, r, s) {
                var i = {};
                t.exports = i;
                var o = s(3)
                  , a = s(0)
                  , l = s(1);
                (function() {
                    i._restingThresh = 2,
                    i._restingThreshTangent = Math.sqrt(6),
                    i._positionDampen = .9,
                    i._positionWarming = .8,
                    i._frictionNormalMultiplier = 5,
                    i._frictionMaxStatic = Number.MAX_VALUE,
                    i.preSolvePosition = function(u) {
                        var d, h, p, g = u.length;
                        for (d = 0; d < g; d++)
                            h = u[d],
                            h.isActive && (p = h.contactCount,
                            h.collision.parentA.totalContacts += p,
                            h.collision.parentB.totalContacts += p)
                    }
                    ,
                    i.solvePosition = function(u, d, h) {
                        var p, g, w, b, v, S, N, _, I = i._positionDampen * (h || 1), k = a.clamp(d / a._baseDelta, 0, 1), B = u.length;
                        for (p = 0; p < B; p++)
                            g = u[p],
                            !(!g.isActive || g.isSensor) && (w = g.collision,
                            b = w.parentA,
                            v = w.parentB,
                            S = w.normal,
                            g.separation = w.depth + S.x * (v.positionImpulse.x - b.positionImpulse.x) + S.y * (v.positionImpulse.y - b.positionImpulse.y));
                        for (p = 0; p < B; p++)
                            g = u[p],
                            !(!g.isActive || g.isSensor) && (w = g.collision,
                            b = w.parentA,
                            v = w.parentB,
                            S = w.normal,
                            _ = g.separation - g.slop * k,
                            (b.isStatic || v.isStatic) && (_ *= 2),
                            b.isStatic || b.isSleeping || (N = I / b.totalContacts,
                            b.positionImpulse.x += S.x * _ * N,
                            b.positionImpulse.y += S.y * _ * N),
                            v.isStatic || v.isSleeping || (N = I / v.totalContacts,
                            v.positionImpulse.x -= S.x * _ * N,
                            v.positionImpulse.y -= S.y * _ * N))
                    }
                    ,
                    i.postSolvePosition = function(u) {
                        for (var d = i._positionWarming, h = u.length, p = o.translate, g = l.update, w = 0; w < h; w++) {
                            var b = u[w]
                              , v = b.positionImpulse
                              , S = v.x
                              , N = v.y
                              , _ = b.velocity;
                            if (b.totalContacts = 0,
                            S !== 0 || N !== 0) {
                                for (var I = 0; I < b.parts.length; I++) {
                                    var k = b.parts[I];
                                    p(k.vertices, v),
                                    g(k.bounds, k.vertices, _),
                                    k.position.x += S,
                                    k.position.y += N
                                }
                                b.positionPrev.x += S,
                                b.positionPrev.y += N,
                                S * _.x + N * _.y < 0 ? (v.x = 0,
                                v.y = 0) : (v.x *= d,
                                v.y *= d)
                            }
                        }
                    }
                    ,
                    i.preSolveVelocity = function(u) {
                        var d = u.length, h, p;
                        for (h = 0; h < d; h++) {
                            var g = u[h];
                            if (!(!g.isActive || g.isSensor)) {
                                var w = g.contacts
                                  , b = g.contactCount
                                  , v = g.collision
                                  , S = v.parentA
                                  , N = v.parentB
                                  , _ = v.normal
                                  , I = v.tangent;
                                for (p = 0; p < b; p++) {
                                    var k = w[p]
                                      , B = k.vertex
                                      , P = k.normalImpulse
                                      , M = k.tangentImpulse;
                                    if (P !== 0 || M !== 0) {
                                        var R = _.x * P + I.x * M
                                          , L = _.y * P + I.y * M;
                                        S.isStatic || S.isSleeping || (S.positionPrev.x += R * S.inverseMass,
                                        S.positionPrev.y += L * S.inverseMass,
                                        S.anglePrev += S.inverseInertia * ((B.x - S.position.x) * L - (B.y - S.position.y) * R)),
                                        N.isStatic || N.isSleeping || (N.positionPrev.x -= R * N.inverseMass,
                                        N.positionPrev.y -= L * N.inverseMass,
                                        N.anglePrev -= N.inverseInertia * ((B.x - N.position.x) * L - (B.y - N.position.y) * R))
                                    }
                                }
                            }
                        }
                    }
                    ,
                    i.solveVelocity = function(u, d) {
                        var h = d / a._baseDelta, p = h * h, g = p * h, w = -i._restingThresh * h, b = i._restingThreshTangent, v = i._frictionNormalMultiplier * h, S = i._frictionMaxStatic, N = u.length, _, I, k, B;
                        for (k = 0; k < N; k++) {
                            var P = u[k];
                            if (!(!P.isActive || P.isSensor)) {
                                var M = P.collision
                                  , R = M.parentA
                                  , L = M.parentB
                                  , q = M.normal.x
                                  , H = M.normal.y
                                  , j = M.tangent.x
                                  , A = M.tangent.y
                                  , E = P.inverseMass
                                  , C = P.friction * P.frictionStatic * v
                                  , O = P.contacts
                                  , z = P.contactCount
                                  , G = 1 / z
                                  , Y = R.position.x - R.positionPrev.x
                                  , $ = R.position.y - R.positionPrev.y
                                  , D = R.angle - R.anglePrev
                                  , U = L.position.x - L.positionPrev.x
                                  , W = L.position.y - L.positionPrev.y
                                  , Q = L.angle - L.anglePrev;
                                for (B = 0; B < z; B++) {
                                    var J = O[B]
                                      , ne = J.vertex
                                      , ie = ne.x - R.position.x
                                      , ae = ne.y - R.position.y
                                      , xe = ne.x - L.position.x
                                      , ue = ne.y - L.position.y
                                      , ce = Y - ae * D
                                      , me = $ + ie * D
                                      , Ee = U - ue * Q
                                      , Oe = W + xe * Q
                                      , mt = ce - Ee
                                      , st = me - Oe
                                      , ot = q * mt + H * st
                                      , Ct = j * mt + A * st
                                      , ct = P.separation + ot
                                      , Xe = Math.min(ct, 1);
                                    Xe = ct < 0 ? 0 : Xe;
                                    var Et = Xe * C;
                                    Ct < -Et || Ct > Et ? (I = Ct > 0 ? Ct : -Ct,
                                    _ = P.friction * (Ct > 0 ? 1 : -1) * g,
                                    _ < -I ? _ = -I : _ > I && (_ = I)) : (_ = Ct,
                                    I = S);
                                    var St = ie * H - ae * q
                                      , ut = xe * H - ue * q
                                      , cn = G / (E + R.inverseInertia * St * St + L.inverseInertia * ut * ut)
                                      , _t = (1 + P.restitution) * ot * cn;
                                    if (_ *= cn,
                                    ot < w)
                                        J.normalImpulse = 0;
                                    else {
                                        var ee = J.normalImpulse;
                                        J.normalImpulse += _t,
                                        J.normalImpulse > 0 && (J.normalImpulse = 0),
                                        _t = J.normalImpulse - ee
                                    }
                                    if (Ct < -b || Ct > b)
                                        J.tangentImpulse = 0;
                                    else {
                                        var K = J.tangentImpulse;
                                        J.tangentImpulse += _,
                                        J.tangentImpulse < -I && (J.tangentImpulse = -I),
                                        J.tangentImpulse > I && (J.tangentImpulse = I),
                                        _ = J.tangentImpulse - K
                                    }
                                    var X = q * _t + j * _
                                      , re = H * _t + A * _;
                                    R.isStatic || R.isSleeping || (R.positionPrev.x += X * R.inverseMass,
                                    R.positionPrev.y += re * R.inverseMass,
                                    R.anglePrev += (ie * re - ae * X) * R.inverseInertia),
                                    L.isStatic || L.isSleeping || (L.positionPrev.x -= X * L.inverseMass,
                                    L.positionPrev.y -= re * L.inverseMass,
                                    L.anglePrev -= (xe * re - ue * X) * L.inverseInertia)
                                }
                            }
                        }
                    }
                }
                )()
            }
            ), (function(t, r, s) {
                var i = {};
                t.exports = i;
                var o = s(9)
                  , a = s(0);
                (function() {
                    i.create = function(l) {
                        return a.extend({
                            table: {},
                            list: [],
                            collisionStart: [],
                            collisionActive: [],
                            collisionEnd: []
                        }, l)
                    }
                    ,
                    i.update = function(l, u, d) {
                        var h = o.update, p = o.create, g = o.setActive, w = l.table, b = l.list, v = b.length, S = v, N = l.collisionStart, _ = l.collisionEnd, I = l.collisionActive, k = u.length, B = 0, P = 0, M = 0, R, L, q;
                        for (q = 0; q < k; q++)
                            R = u[q],
                            L = R.pair,
                            L ? (L.isActive && (I[M++] = L),
                            h(L, R, d)) : (L = p(R, d),
                            w[L.id] = L,
                            N[B++] = L,
                            b[S++] = L);
                        for (S = 0,
                        v = b.length,
                        q = 0; q < v; q++)
                            L = b[q],
                            L.timeUpdated >= d ? b[S++] = L : (g(L, !1, d),
                            L.collision.bodyA.sleepCounter > 0 && L.collision.bodyB.sleepCounter > 0 ? b[S++] = L : (_[P++] = L,
                            delete w[L.id]));
                        b.length !== S && (b.length = S),
                        N.length !== B && (N.length = B),
                        _.length !== P && (_.length = P),
                        I.length !== M && (I.length = M)
                    }
                    ,
                    i.clear = function(l) {
                        return l.table = {},
                        l.list.length = 0,
                        l.collisionStart.length = 0,
                        l.collisionActive.length = 0,
                        l.collisionEnd.length = 0,
                        l
                    }
                }
                )()
            }
            ), (function(t, r, s) {
                var i = t.exports = s(21);
                i.Axes = s(11),
                i.Bodies = s(12),
                i.Body = s(4),
                i.Bounds = s(1),
                i.Collision = s(8),
                i.Common = s(0),
                i.Composite = s(6),
                i.Composites = s(22),
                i.Constraint = s(10),
                i.Contact = s(16),
                i.Detector = s(13),
                i.Engine = s(17),
                i.Events = s(5),
                i.Grid = s(23),
                i.Mouse = s(14),
                i.MouseConstraint = s(24),
                i.Pair = s(9),
                i.Pairs = s(19),
                i.Plugin = s(15),
                i.Query = s(25),
                i.Render = s(26),
                i.Resolver = s(18),
                i.Runner = s(27),
                i.SAT = s(28),
                i.Sleeping = s(7),
                i.Svg = s(29),
                i.Vector = s(2),
                i.Vertices = s(3),
                i.World = s(30),
                i.Engine.run = i.Runner.run,
                i.Common.deprecated(i.Engine, "run", "Engine.run  use Matter.Runner.run(engine) instead")
            }
            ), (function(t, r, s) {
                var i = {};
                t.exports = i;
                var o = s(15)
                  , a = s(0);
                (function() {
                    i.name = "matter-js",
                    i.version = "0.20.0",
                    i.uses = [],
                    i.used = [],
                    i.use = function() {
                        o.use(i, Array.prototype.slice.call(arguments))
                    }
                    ,
                    i.before = function(l, u) {
                        return l = l.replace(/^Matter./, ""),
                        a.chainPathBefore(i, l, u)
                    }
                    ,
                    i.after = function(l, u) {
                        return l = l.replace(/^Matter./, ""),
                        a.chainPathAfter(i, l, u)
                    }
                }
                )()
            }
            ), (function(t, r, s) {
                var i = {};
                t.exports = i;
                var o = s(6)
                  , a = s(10)
                  , l = s(0)
                  , u = s(4)
                  , d = s(12)
                  , h = l.deprecated;
                (function() {
                    i.stack = function(p, g, w, b, v, S, N) {
                        for (var _ = o.create({
                            label: "Stack"
                        }), I = p, k = g, B, P = 0, M = 0; M < b; M++) {
                            for (var R = 0, L = 0; L < w; L++) {
                                var q = N(I, k, L, M, B, P);
                                if (q) {
                                    var H = q.bounds.max.y - q.bounds.min.y
                                      , j = q.bounds.max.x - q.bounds.min.x;
                                    H > R && (R = H),
                                    u.translate(q, {
                                        x: j * .5,
                                        y: H * .5
                                    }),
                                    I = q.bounds.max.x + v,
                                    o.addBody(_, q),
                                    B = q,
                                    P += 1
                                } else
                                    I += v
                            }
                            k += R + S,
                            I = p
                        }
                        return _
                    }
                    ,
                    i.chain = function(p, g, w, b, v, S) {
                        for (var N = p.bodies, _ = 1; _ < N.length; _++) {
                            var I = N[_ - 1]
                              , k = N[_]
                              , B = I.bounds.max.y - I.bounds.min.y
                              , P = I.bounds.max.x - I.bounds.min.x
                              , M = k.bounds.max.y - k.bounds.min.y
                              , R = k.bounds.max.x - k.bounds.min.x
                              , L = {
                                bodyA: I,
                                pointA: {
                                    x: P * g,
                                    y: B * w
                                },
                                bodyB: k,
                                pointB: {
                                    x: R * b,
                                    y: M * v
                                }
                            }
                              , q = l.extend(L, S);
                            o.addConstraint(p, a.create(q))
                        }
                        return p.label += " Chain",
                        p
                    }
                    ,
                    i.mesh = function(p, g, w, b, v) {
                        var S = p.bodies, N, _, I, k, B;
                        for (N = 0; N < w; N++) {
                            for (_ = 1; _ < g; _++)
                                I = S[_ - 1 + N * g],
                                k = S[_ + N * g],
                                o.addConstraint(p, a.create(l.extend({
                                    bodyA: I,
                                    bodyB: k
                                }, v)));
                            if (N > 0)
                                for (_ = 0; _ < g; _++)
                                    I = S[_ + (N - 1) * g],
                                    k = S[_ + N * g],
                                    o.addConstraint(p, a.create(l.extend({
                                        bodyA: I,
                                        bodyB: k
                                    }, v))),
                                    b && _ > 0 && (B = S[_ - 1 + (N - 1) * g],
                                    o.addConstraint(p, a.create(l.extend({
                                        bodyA: B,
                                        bodyB: k
                                    }, v)))),
                                    b && _ < g - 1 && (B = S[_ + 1 + (N - 1) * g],
                                    o.addConstraint(p, a.create(l.extend({
                                        bodyA: B,
                                        bodyB: k
                                    }, v))))
                        }
                        return p.label += " Mesh",
                        p
                    }
                    ,
                    i.pyramid = function(p, g, w, b, v, S, N) {
                        return i.stack(p, g, w, b, v, S, function(_, I, k, B, P, M) {
                            var R = Math.min(b, Math.ceil(w / 2))
                              , L = P ? P.bounds.max.x - P.bounds.min.x : 0;
                            if (!(B > R)) {
                                B = R - B;
                                var q = B
                                  , H = w - 1 - B;
                                if (!(k < q || k > H)) {
                                    M === 1 && u.translate(P, {
                                        x: (k + (w % 2 === 1 ? 1 : -1)) * L,
                                        y: 0
                                    });
                                    var j = P ? k * L : 0;
                                    return N(p + j + k * v, I, k, B, P, M)
                                }
                            }
                        })
                    }
                    ,
                    i.newtonsCradle = function(p, g, w, b, v) {
                        for (var S = o.create({
                            label: "Newtons Cradle"
                        }), N = 0; N < w; N++) {
                            var _ = 1.9
                              , I = d.circle(p + N * (b * _), g + v, b, {
                                inertia: 1 / 0,
                                restitution: 1,
                                friction: 0,
                                frictionAir: 1e-4,
                                slop: 1
                            })
                              , k = a.create({
                                pointA: {
                                    x: p + N * (b * _),
                                    y: g
                                },
                                bodyB: I
                            });
                            o.addBody(S, I),
                            o.addConstraint(S, k)
                        }
                        return S
                    }
                    ,
                    h(i, "newtonsCradle", "Composites.newtonsCradle  moved to newtonsCradle example"),
                    i.car = function(p, g, w, b, v) {
                        var S = u.nextGroup(!0)
                          , N = 20
                          , _ = -w * .5 + N
                          , I = w * .5 - N
                          , k = 0
                          , B = o.create({
                            label: "Car"
                        })
                          , P = d.rectangle(p, g, w, b, {
                            collisionFilter: {
                                group: S
                            },
                            chamfer: {
                                radius: b * .5
                            },
                            density: 2e-4
                        })
                          , M = d.circle(p + _, g + k, v, {
                            collisionFilter: {
                                group: S
                            },
                            friction: .8
                        })
                          , R = d.circle(p + I, g + k, v, {
                            collisionFilter: {
                                group: S
                            },
                            friction: .8
                        })
                          , L = a.create({
                            bodyB: P,
                            pointB: {
                                x: _,
                                y: k
                            },
                            bodyA: M,
                            stiffness: 1,
                            length: 0
                        })
                          , q = a.create({
                            bodyB: P,
                            pointB: {
                                x: I,
                                y: k
                            },
                            bodyA: R,
                            stiffness: 1,
                            length: 0
                        });
                        return o.addBody(B, P),
                        o.addBody(B, M),
                        o.addBody(B, R),
                        o.addConstraint(B, L),
                        o.addConstraint(B, q),
                        B
                    }
                    ,
                    h(i, "car", "Composites.car  moved to car example"),
                    i.softBody = function(p, g, w, b, v, S, N, _, I, k) {
                        I = l.extend({
                            inertia: 1 / 0
                        }, I),
                        k = l.extend({
                            stiffness: .2,
                            render: {
                                type: "line",
                                anchors: !1
                            }
                        }, k);
                        var B = i.stack(p, g, w, b, v, S, function(P, M) {
                            return d.circle(P, M, _, I)
                        });
                        return i.mesh(B, w, b, N, k),
                        B.label = "Soft Body",
                        B
                    }
                    ,
                    h(i, "softBody", "Composites.softBody  moved to softBody and cloth examples")
                }
                )()
            }
            ), (function(t, r, s) {
                var i = {};
                t.exports = i;
                var o = s(9)
                  , a = s(0)
                  , l = a.deprecated;
                (function() {
                    i.create = function(u) {
                        var d = {
                            buckets: {},
                            pairs: {},
                            pairsList: [],
                            bucketWidth: 48,
                            bucketHeight: 48
                        };
                        return a.extend(d, u)
                    }
                    ,
                    i.update = function(u, d, h, p) {
                        var g, w, b, v = h.world, S = u.buckets, N, _, I = !1;
                        for (g = 0; g < d.length; g++) {
                            var k = d[g];
                            if (!(k.isSleeping && !p) && !(v.bounds && (k.bounds.max.x < v.bounds.min.x || k.bounds.min.x > v.bounds.max.x || k.bounds.max.y < v.bounds.min.y || k.bounds.min.y > v.bounds.max.y))) {
                                var B = i._getRegion(u, k);
                                if (!k.region || B.id !== k.region.id || p) {
                                    (!k.region || p) && (k.region = B);
                                    var P = i._regionUnion(B, k.region);
                                    for (w = P.startCol; w <= P.endCol; w++)
                                        for (b = P.startRow; b <= P.endRow; b++) {
                                            _ = i._getBucketId(w, b),
                                            N = S[_];
                                            var M = w >= B.startCol && w <= B.endCol && b >= B.startRow && b <= B.endRow
                                              , R = w >= k.region.startCol && w <= k.region.endCol && b >= k.region.startRow && b <= k.region.endRow;
                                            !M && R && R && N && i._bucketRemoveBody(u, N, k),
                                            (k.region === B || M && !R || p) && (N || (N = i._createBucket(S, _)),
                                            i._bucketAddBody(u, N, k))
                                        }
                                    k.region = B,
                                    I = !0
                                }
                            }
                        }
                        I && (u.pairsList = i._createActivePairsList(u))
                    }
                    ,
                    l(i, "update", "Grid.update  replaced by Matter.Detector"),
                    i.clear = function(u) {
                        u.buckets = {},
                        u.pairs = {},
                        u.pairsList = []
                    }
                    ,
                    l(i, "clear", "Grid.clear  replaced by Matter.Detector"),
                    i._regionUnion = function(u, d) {
                        var h = Math.min(u.startCol, d.startCol)
                          , p = Math.max(u.endCol, d.endCol)
                          , g = Math.min(u.startRow, d.startRow)
                          , w = Math.max(u.endRow, d.endRow);
                        return i._createRegion(h, p, g, w)
                    }
                    ,
                    i._getRegion = function(u, d) {
                        var h = d.bounds
                          , p = Math.floor(h.min.x / u.bucketWidth)
                          , g = Math.floor(h.max.x / u.bucketWidth)
                          , w = Math.floor(h.min.y / u.bucketHeight)
                          , b = Math.floor(h.max.y / u.bucketHeight);
                        return i._createRegion(p, g, w, b)
                    }
                    ,
                    i._createRegion = function(u, d, h, p) {
                        return {
                            id: u + "," + d + "," + h + "," + p,
                            startCol: u,
                            endCol: d,
                            startRow: h,
                            endRow: p
                        }
                    }
                    ,
                    i._getBucketId = function(u, d) {
                        return "C" + u + "R" + d
                    }
                    ,
                    i._createBucket = function(u, d) {
                        var h = u[d] = [];
                        return h
                    }
                    ,
                    i._bucketAddBody = function(u, d, h) {
                        var p = u.pairs, g = o.id, w = d.length, b;
                        for (b = 0; b < w; b++) {
                            var v = d[b];
                            if (!(h.id === v.id || h.isStatic && v.isStatic)) {
                                var S = g(h, v)
                                  , N = p[S];
                                N ? N[2] += 1 : p[S] = [h, v, 1]
                            }
                        }
                        d.push(h)
                    }
                    ,
                    i._bucketRemoveBody = function(u, d, h) {
                        var p = u.pairs, g = o.id, w;
                        d.splice(a.indexOf(d, h), 1);
                        var b = d.length;
                        for (w = 0; w < b; w++) {
                            var v = p[g(h, d[w])];
                            v && (v[2] -= 1)
                        }
                    }
                    ,
                    i._createActivePairsList = function(u) {
                        var d, h = u.pairs, p = a.keys(h), g = p.length, w = [], b;
                        for (b = 0; b < g; b++)
                            d = h[p[b]],
                            d[2] > 0 ? w.push(d) : delete h[p[b]];
                        return w
                    }
                }
                )()
            }
            ), (function(t, r, s) {
                var i = {};
                t.exports = i;
                var o = s(3)
                  , a = s(7)
                  , l = s(14)
                  , u = s(5)
                  , d = s(13)
                  , h = s(10)
                  , p = s(6)
                  , g = s(0)
                  , w = s(1);
                (function() {
                    i.create = function(b, v) {
                        var S = (b ? b.mouse : null) || (v ? v.mouse : null);
                        S || (b && b.render && b.render.canvas ? S = l.create(b.render.canvas) : v && v.element ? S = l.create(v.element) : (S = l.create(),
                        g.warn("MouseConstraint.create: options.mouse was undefined, options.element was undefined, may not function as expected")));
                        var N = h.create({
                            label: "Mouse Constraint",
                            pointA: S.position,
                            pointB: {
                                x: 0,
                                y: 0
                            },
                            length: .01,
                            stiffness: .1,
                            angularStiffness: 1,
                            render: {
                                strokeStyle: "#90EE90",
                                lineWidth: 3
                            }
                        })
                          , _ = {
                            type: "mouseConstraint",
                            mouse: S,
                            element: null,
                            body: null,
                            constraint: N,
                            collisionFilter: {
                                category: 1,
                                mask: 4294967295,
                                group: 0
                            }
                        }
                          , I = g.extend(_, v);
                        return u.on(b, "beforeUpdate", function() {
                            var k = p.allBodies(b.world);
                            i.update(I, k),
                            i._triggerEvents(I)
                        }),
                        I
                    }
                    ,
                    i.update = function(b, v) {
                        var S = b.mouse
                          , N = b.constraint
                          , _ = b.body;
                        if (S.button === 0) {
                            if (N.bodyB)
                                a.set(N.bodyB, !1),
                                N.pointA = S.position;
                            else
                                for (var I = 0; I < v.length; I++)
                                    if (_ = v[I],
                                    w.contains(_.bounds, S.position) && d.canCollide(_.collisionFilter, b.collisionFilter))
                                        for (var k = _.parts.length > 1 ? 1 : 0; k < _.parts.length; k++) {
                                            var B = _.parts[k];
                                            if (o.contains(B.vertices, S.position)) {
                                                N.pointA = S.position,
                                                N.bodyB = b.body = _,
                                                N.pointB = {
                                                    x: S.position.x - _.position.x,
                                                    y: S.position.y - _.position.y
                                                },
                                                N.angleB = _.angle,
                                                a.set(_, !1),
                                                u.trigger(b, "startdrag", {
                                                    mouse: S,
                                                    body: _
                                                });
                                                break
                                            }
                                        }
                        } else
                            N.bodyB = b.body = null,
                            N.pointB = null,
                            _ && u.trigger(b, "enddrag", {
                                mouse: S,
                                body: _
                            })
                    }
                    ,
                    i._triggerEvents = function(b) {
                        var v = b.mouse
                          , S = v.sourceEvents;
                        S.mousemove && u.trigger(b, "mousemove", {
                            mouse: v
                        }),
                        S.mousedown && u.trigger(b, "mousedown", {
                            mouse: v
                        }),
                        S.mouseup && u.trigger(b, "mouseup", {
                            mouse: v
                        }),
                        l.clearSourceEvents(v)
                    }
                }
                )()
            }
            ), (function(t, r, s) {
                var i = {};
                t.exports = i;
                var o = s(2)
                  , a = s(8)
                  , l = s(1)
                  , u = s(12)
                  , d = s(3);
                (function() {
                    i.collides = function(h, p) {
                        for (var g = [], w = p.length, b = h.bounds, v = a.collides, S = l.overlaps, N = 0; N < w; N++) {
                            var _ = p[N]
                              , I = _.parts.length
                              , k = I === 1 ? 0 : 1;
                            if (S(_.bounds, b))
                                for (var B = k; B < I; B++) {
                                    var P = _.parts[B];
                                    if (S(P.bounds, b)) {
                                        var M = v(P, h);
                                        if (M) {
                                            g.push(M);
                                            break
                                        }
                                    }
                                }
                        }
                        return g
                    }
                    ,
                    i.ray = function(h, p, g, w) {
                        w = w || 1e-100;
                        for (var b = o.angle(p, g), v = o.magnitude(o.sub(p, g)), S = (g.x + p.x) * .5, N = (g.y + p.y) * .5, _ = u.rectangle(S, N, v, w, {
                            angle: b
                        }), I = i.collides(_, h), k = 0; k < I.length; k += 1) {
                            var B = I[k];
                            B.body = B.bodyB = B.bodyA
                        }
                        return I
                    }
                    ,
                    i.region = function(h, p, g) {
                        for (var w = [], b = 0; b < h.length; b++) {
                            var v = h[b]
                              , S = l.overlaps(v.bounds, p);
                            (S && !g || !S && g) && w.push(v)
                        }
                        return w
                    }
                    ,
                    i.point = function(h, p) {
                        for (var g = [], w = 0; w < h.length; w++) {
                            var b = h[w];
                            if (l.contains(b.bounds, p))
                                for (var v = b.parts.length === 1 ? 0 : 1; v < b.parts.length; v++) {
                                    var S = b.parts[v];
                                    if (l.contains(S.bounds, p) && d.contains(S.vertices, p)) {
                                        g.push(b);
                                        break
                                    }
                                }
                        }
                        return g
                    }
                }
                )()
            }
            ), (function(t, r, s) {
                var i = {};
                t.exports = i;
                var o = s(4)
                  , a = s(0)
                  , l = s(6)
                  , u = s(1)
                  , d = s(5)
                  , h = s(2)
                  , p = s(14);
                (function() {
                    var g, w;
                    typeof window < "u" && (g = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || function(k) {
                        window.setTimeout(function() {
                            k(a.now())
                        }, 1e3 / 60)
                    }
                    ,
                    w = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame),
                    i._goodFps = 30,
                    i._goodDelta = 1e3 / 60,
                    i.create = function(k) {
                        var B = {
                            engine: null,
                            element: null,
                            canvas: null,
                            mouse: null,
                            frameRequestId: null,
                            timing: {
                                historySize: 60,
                                delta: 0,
                                deltaHistory: [],
                                lastTime: 0,
                                lastTimestamp: 0,
                                lastElapsed: 0,
                                timestampElapsed: 0,
                                timestampElapsedHistory: [],
                                engineDeltaHistory: [],
                                engineElapsedHistory: [],
                                engineUpdatesHistory: [],
                                elapsedHistory: []
                            },
                            options: {
                                width: 800,
                                height: 600,
                                pixelRatio: 1,
                                background: "#14151f",
                                wireframeBackground: "#14151f",
                                wireframeStrokeStyle: "#bbb",
                                hasBounds: !!k.bounds,
                                enabled: !0,
                                wireframes: !0,
                                showSleeping: !0,
                                showDebug: !1,
                                showStats: !1,
                                showPerformance: !1,
                                showBounds: !1,
                                showVelocity: !1,
                                showCollisions: !1,
                                showSeparations: !1,
                                showAxes: !1,
                                showPositions: !1,
                                showAngleIndicator: !1,
                                showIds: !1,
                                showVertexNumbers: !1,
                                showConvexHulls: !1,
                                showInternalEdges: !1,
                                showMousePosition: !1
                            }
                        }
                          , P = a.extend(B, k);
                        return P.canvas && (P.canvas.width = P.options.width || P.canvas.width,
                        P.canvas.height = P.options.height || P.canvas.height),
                        P.mouse = k.mouse,
                        P.engine = k.engine,
                        P.canvas = P.canvas || S(P.options.width, P.options.height),
                        P.context = P.canvas.getContext("2d"),
                        P.textures = {},
                        P.bounds = P.bounds || {
                            min: {
                                x: 0,
                                y: 0
                            },
                            max: {
                                x: P.canvas.width,
                                y: P.canvas.height
                            }
                        },
                        P.controller = i,
                        P.options.showBroadphase = !1,
                        P.options.pixelRatio !== 1 && i.setPixelRatio(P, P.options.pixelRatio),
                        a.isElement(P.element) && P.element.appendChild(P.canvas),
                        P
                    }
                    ,
                    i.run = function(k) {
                        (function B(P) {
                            k.frameRequestId = g(B),
                            b(k, P),
                            i.world(k, P),
                            k.context.setTransform(k.options.pixelRatio, 0, 0, k.options.pixelRatio, 0, 0),
                            (k.options.showStats || k.options.showDebug) && i.stats(k, k.context, P),
                            (k.options.showPerformance || k.options.showDebug) && i.performance(k, k.context, P),
                            k.context.setTransform(1, 0, 0, 1, 0, 0)
                        }
                        )()
                    }
                    ,
                    i.stop = function(k) {
                        w(k.frameRequestId)
                    }
                    ,
                    i.setPixelRatio = function(k, B) {
                        var P = k.options
                          , M = k.canvas;
                        B === "auto" && (B = N(M)),
                        P.pixelRatio = B,
                        M.setAttribute("data-pixel-ratio", B),
                        M.width = P.width * B,
                        M.height = P.height * B,
                        M.style.width = P.width + "px",
                        M.style.height = P.height + "px"
                    }
                    ,
                    i.setSize = function(k, B, P) {
                        k.options.width = B,
                        k.options.height = P,
                        k.bounds.max.x = k.bounds.min.x + B,
                        k.bounds.max.y = k.bounds.min.y + P,
                        k.options.pixelRatio !== 1 ? i.setPixelRatio(k, k.options.pixelRatio) : (k.canvas.width = B,
                        k.canvas.height = P)
                    }
                    ,
                    i.lookAt = function(k, B, P, M) {
                        M = typeof M < "u" ? M : !0,
                        B = a.isArray(B) ? B : [B],
                        P = P || {
                            x: 0,
                            y: 0
                        };
                        for (var R = {
                            min: {
                                x: 1 / 0,
                                y: 1 / 0
                            },
                            max: {
                                x: -1 / 0,
                                y: -1 / 0
                            }
                        }, L = 0; L < B.length; L += 1) {
                            var q = B[L]
                              , H = q.bounds ? q.bounds.min : q.min || q.position || q
                              , j = q.bounds ? q.bounds.max : q.max || q.position || q;
                            H && j && (H.x < R.min.x && (R.min.x = H.x),
                            j.x > R.max.x && (R.max.x = j.x),
                            H.y < R.min.y && (R.min.y = H.y),
                            j.y > R.max.y && (R.max.y = j.y))
                        }
                        var A = R.max.x - R.min.x + 2 * P.x
                          , E = R.max.y - R.min.y + 2 * P.y
                          , C = k.canvas.height
                          , O = k.canvas.width
                          , z = O / C
                          , G = A / E
                          , Y = 1
                          , $ = 1;
                        G > z ? $ = G / z : Y = z / G,
                        k.options.hasBounds = !0,
                        k.bounds.min.x = R.min.x,
                        k.bounds.max.x = R.min.x + A * Y,
                        k.bounds.min.y = R.min.y,
                        k.bounds.max.y = R.min.y + E * $,
                        M && (k.bounds.min.x += A * .5 - A * Y * .5,
                        k.bounds.max.x += A * .5 - A * Y * .5,
                        k.bounds.min.y += E * .5 - E * $ * .5,
                        k.bounds.max.y += E * .5 - E * $ * .5),
                        k.bounds.min.x -= P.x,
                        k.bounds.max.x -= P.x,
                        k.bounds.min.y -= P.y,
                        k.bounds.max.y -= P.y,
                        k.mouse && (p.setScale(k.mouse, {
                            x: (k.bounds.max.x - k.bounds.min.x) / k.canvas.width,
                            y: (k.bounds.max.y - k.bounds.min.y) / k.canvas.height
                        }),
                        p.setOffset(k.mouse, k.bounds.min))
                    }
                    ,
                    i.startViewTransform = function(k) {
                        var B = k.bounds.max.x - k.bounds.min.x
                          , P = k.bounds.max.y - k.bounds.min.y
                          , M = B / k.options.width
                          , R = P / k.options.height;
                        k.context.setTransform(k.options.pixelRatio / M, 0, 0, k.options.pixelRatio / R, 0, 0),
                        k.context.translate(-k.bounds.min.x, -k.bounds.min.y)
                    }
                    ,
                    i.endViewTransform = function(k) {
                        k.context.setTransform(k.options.pixelRatio, 0, 0, k.options.pixelRatio, 0, 0)
                    }
                    ,
                    i.world = function(k, B) {
                        var P = a.now(), M = k.engine, R = M.world, L = k.canvas, q = k.context, H = k.options, j = k.timing, A = l.allBodies(R), E = l.allConstraints(R), C = H.wireframes ? H.wireframeBackground : H.background, O = [], z = [], G, Y = {
                            timestamp: M.timing.timestamp
                        };
                        if (d.trigger(k, "beforeRender", Y),
                        k.currentBackground !== C && I(k, C),
                        q.globalCompositeOperation = "source-in",
                        q.fillStyle = "transparent",
                        q.fillRect(0, 0, L.width, L.height),
                        q.globalCompositeOperation = "source-over",
                        H.hasBounds) {
                            for (G = 0; G < A.length; G++) {
                                var $ = A[G];
                                u.overlaps($.bounds, k.bounds) && O.push($)
                            }
                            for (G = 0; G < E.length; G++) {
                                var D = E[G]
                                  , U = D.bodyA
                                  , W = D.bodyB
                                  , Q = D.pointA
                                  , J = D.pointB;
                                U && (Q = h.add(U.position, D.pointA)),
                                W && (J = h.add(W.position, D.pointB)),
                                !(!Q || !J) && (u.contains(k.bounds, Q) || u.contains(k.bounds, J)) && z.push(D)
                            }
                            i.startViewTransform(k),
                            k.mouse && (p.setScale(k.mouse, {
                                x: (k.bounds.max.x - k.bounds.min.x) / k.options.width,
                                y: (k.bounds.max.y - k.bounds.min.y) / k.options.height
                            }),
                            p.setOffset(k.mouse, k.bounds.min))
                        } else
                            z = E,
                            O = A,
                            k.options.pixelRatio !== 1 && k.context.setTransform(k.options.pixelRatio, 0, 0, k.options.pixelRatio, 0, 0);
                        !H.wireframes || M.enableSleeping && H.showSleeping ? i.bodies(k, O, q) : (H.showConvexHulls && i.bodyConvexHulls(k, O, q),
                        i.bodyWireframes(k, O, q)),
                        H.showBounds && i.bodyBounds(k, O, q),
                        (H.showAxes || H.showAngleIndicator) && i.bodyAxes(k, O, q),
                        H.showPositions && i.bodyPositions(k, O, q),
                        H.showVelocity && i.bodyVelocity(k, O, q),
                        H.showIds && i.bodyIds(k, O, q),
                        H.showSeparations && i.separations(k, M.pairs.list, q),
                        H.showCollisions && i.collisions(k, M.pairs.list, q),
                        H.showVertexNumbers && i.vertexNumbers(k, O, q),
                        H.showMousePosition && i.mousePosition(k, k.mouse, q),
                        i.constraints(z, q),
                        H.hasBounds && i.endViewTransform(k),
                        d.trigger(k, "afterRender", Y),
                        j.lastElapsed = a.now() - P
                    }
                    ,
                    i.stats = function(k, B, P) {
                        for (var M = k.engine, R = M.world, L = l.allBodies(R), q = 0, H = 55, j = 44, A = 0, E = 0, C = 0; C < L.length; C += 1)
                            q += L[C].parts.length;
                        var O = {
                            Part: q,
                            Body: L.length,
                            Cons: l.allConstraints(R).length,
                            Comp: l.allComposites(R).length,
                            Pair: M.pairs.list.length
                        };
                        B.fillStyle = "#0e0f19",
                        B.fillRect(A, E, H * 5.5, j),
                        B.font = "12px Arial",
                        B.textBaseline = "top",
                        B.textAlign = "right";
                        for (var z in O) {
                            var G = O[z];
                            B.fillStyle = "#aaa",
                            B.fillText(z, A + H, E + 8),
                            B.fillStyle = "#eee",
                            B.fillText(G, A + H, E + 26),
                            A += H
                        }
                    }
                    ,
                    i.performance = function(k, B) {
                        var P = k.engine
                          , M = k.timing
                          , R = M.deltaHistory
                          , L = M.elapsedHistory
                          , q = M.timestampElapsedHistory
                          , H = M.engineDeltaHistory
                          , j = M.engineUpdatesHistory
                          , A = M.engineElapsedHistory
                          , E = P.timing.lastUpdatesPerFrame
                          , C = P.timing.lastDelta
                          , O = v(R)
                          , z = v(L)
                          , G = v(H)
                          , Y = v(j)
                          , $ = v(A)
                          , D = v(q)
                          , U = D / O || 0
                          , W = Math.round(O / C)
                          , Q = 1e3 / O || 0
                          , J = 4
                          , ne = 12
                          , ie = 60
                          , ae = 34
                          , xe = 10
                          , ue = 69;
                        B.fillStyle = "#0e0f19",
                        B.fillRect(0, 50, ne * 5 + ie * 6 + 22, ae),
                        i.status(B, xe, ue, ie, J, R.length, Math.round(Q) + " fps", Q / i._goodFps, function(ce) {
                            return R[ce] / O - 1
                        }),
                        i.status(B, xe + ne + ie, ue, ie, J, H.length, C.toFixed(2) + " dt", i._goodDelta / C, function(ce) {
                            return H[ce] / G - 1
                        }),
                        i.status(B, xe + (ne + ie) * 2, ue, ie, J, j.length, E + " upf", Math.pow(a.clamp(Y / W || 1, 0, 1), 4), function(ce) {
                            return j[ce] / Y - 1
                        }),
                        i.status(B, xe + (ne + ie) * 3, ue, ie, J, A.length, $.toFixed(2) + " ut", 1 - E * $ / i._goodFps, function(ce) {
                            return A[ce] / $ - 1
                        }),
                        i.status(B, xe + (ne + ie) * 4, ue, ie, J, L.length, z.toFixed(2) + " rt", 1 - z / i._goodFps, function(ce) {
                            return L[ce] / z - 1
                        }),
                        i.status(B, xe + (ne + ie) * 5, ue, ie, J, q.length, U.toFixed(2) + " x", U * U * U, function(ce) {
                            return (q[ce] / R[ce] / U || 0) - 1
                        })
                    }
                    ,
                    i.status = function(k, B, P, M, R, L, q, H, j) {
                        k.strokeStyle = "#888",
                        k.fillStyle = "#444",
                        k.lineWidth = 1,
                        k.fillRect(B, P + 7, M, 1),
                        k.beginPath(),
                        k.moveTo(B, P + 7 - R * a.clamp(.4 * j(0), -2, 2));
                        for (var A = 0; A < M; A += 1)
                            k.lineTo(B + A, P + 7 - (A < L ? R * a.clamp(.4 * j(A), -2, 2) : 0));
                        k.stroke(),
                        k.fillStyle = "hsl(" + a.clamp(25 + 95 * H, 0, 120) + ",100%,60%)",
                        k.fillRect(B, P - 7, 4, 4),
                        k.font = "12px Arial",
                        k.textBaseline = "middle",
                        k.textAlign = "right",
                        k.fillStyle = "#eee",
                        k.fillText(q, B + M, P - 5)
                    }
                    ,
                    i.constraints = function(k, B) {
                        for (var P = B, M = 0; M < k.length; M++) {
                            var R = k[M];
                            if (!(!R.render.visible || !R.pointA || !R.pointB)) {
                                var L = R.bodyA, q = R.bodyB, H, j;
                                if (L ? H = h.add(L.position, R.pointA) : H = R.pointA,
                                R.render.type === "pin")
                                    P.beginPath(),
                                    P.arc(H.x, H.y, 3, 0, 2 * Math.PI),
                                    P.closePath();
                                else {
                                    if (q ? j = h.add(q.position, R.pointB) : j = R.pointB,
                                    P.beginPath(),
                                    P.moveTo(H.x, H.y),
                                    R.render.type === "spring")
                                        for (var A = h.sub(j, H), E = h.perp(h.normalise(A)), C = Math.ceil(a.clamp(R.length / 5, 12, 20)), O, z = 1; z < C; z += 1)
                                            O = z % 2 === 0 ? 1 : -1,
                                            P.lineTo(H.x + A.x * (z / C) + E.x * O * 4, H.y + A.y * (z / C) + E.y * O * 4);
                                    P.lineTo(j.x, j.y)
                                }
                                R.render.lineWidth && (P.lineWidth = R.render.lineWidth,
                                P.strokeStyle = R.render.strokeStyle,
                                P.stroke()),
                                R.render.anchors && (P.fillStyle = R.render.strokeStyle,
                                P.beginPath(),
                                P.arc(H.x, H.y, 3, 0, 2 * Math.PI),
                                P.arc(j.x, j.y, 3, 0, 2 * Math.PI),
                                P.closePath(),
                                P.fill())
                            }
                        }
                    }
                    ,
                    i.bodies = function(k, B, P) {
                        var M = P;
                        k.engine;
                        var R = k.options, L = R.showInternalEdges || !R.wireframes, q, H, j, A;
                        for (j = 0; j < B.length; j++)
                            if (q = B[j],
                            !!q.render.visible) {
                                for (A = q.parts.length > 1 ? 1 : 0; A < q.parts.length; A++)
                                    if (H = q.parts[A],
                                    !!H.render.visible) {
                                        if (R.showSleeping && q.isSleeping ? M.globalAlpha = .5 * H.render.opacity : H.render.opacity !== 1 && (M.globalAlpha = H.render.opacity),
                                        H.render.sprite && H.render.sprite.texture && !R.wireframes) {
                                            var E = H.render.sprite
                                              , C = _(k, E.texture);
                                            M.translate(H.position.x, H.position.y),
                                            M.rotate(H.angle),
                                            M.drawImage(C, C.width * -E.xOffset * E.xScale, C.height * -E.yOffset * E.yScale, C.width * E.xScale, C.height * E.yScale),
                                            M.rotate(-H.angle),
                                            M.translate(-H.position.x, -H.position.y)
                                        } else {
                                            if (H.circleRadius)
                                                M.beginPath(),
                                                M.arc(H.position.x, H.position.y, H.circleRadius, 0, 2 * Math.PI);
                                            else {
                                                M.beginPath(),
                                                M.moveTo(H.vertices[0].x, H.vertices[0].y);
                                                for (var O = 1; O < H.vertices.length; O++)
                                                    !H.vertices[O - 1].isInternal || L ? M.lineTo(H.vertices[O].x, H.vertices[O].y) : M.moveTo(H.vertices[O].x, H.vertices[O].y),
                                                    H.vertices[O].isInternal && !L && M.moveTo(H.vertices[(O + 1) % H.vertices.length].x, H.vertices[(O + 1) % H.vertices.length].y);
                                                M.lineTo(H.vertices[0].x, H.vertices[0].y),
                                                M.closePath()
                                            }
                                            R.wireframes ? (M.lineWidth = 1,
                                            M.strokeStyle = k.options.wireframeStrokeStyle,
                                            M.stroke()) : (M.fillStyle = H.render.fillStyle,
                                            H.render.lineWidth && (M.lineWidth = H.render.lineWidth,
                                            M.strokeStyle = H.render.strokeStyle,
                                            M.stroke()),
                                            M.fill())
                                        }
                                        M.globalAlpha = 1
                                    }
                            }
                    }
                    ,
                    i.bodyWireframes = function(k, B, P) {
                        var M = P, R = k.options.showInternalEdges, L, q, H, j, A;
                        for (M.beginPath(),
                        H = 0; H < B.length; H++)
                            if (L = B[H],
                            !!L.render.visible)
                                for (A = L.parts.length > 1 ? 1 : 0; A < L.parts.length; A++) {
                                    for (q = L.parts[A],
                                    M.moveTo(q.vertices[0].x, q.vertices[0].y),
                                    j = 1; j < q.vertices.length; j++)
                                        !q.vertices[j - 1].isInternal || R ? M.lineTo(q.vertices[j].x, q.vertices[j].y) : M.moveTo(q.vertices[j].x, q.vertices[j].y),
                                        q.vertices[j].isInternal && !R && M.moveTo(q.vertices[(j + 1) % q.vertices.length].x, q.vertices[(j + 1) % q.vertices.length].y);
                                    M.lineTo(q.vertices[0].x, q.vertices[0].y)
                                }
                        M.lineWidth = 1,
                        M.strokeStyle = k.options.wireframeStrokeStyle,
                        M.stroke()
                    }
                    ,
                    i.bodyConvexHulls = function(k, B, P) {
                        var M = P, R, L, q;
                        for (M.beginPath(),
                        L = 0; L < B.length; L++)
                            if (R = B[L],
                            !(!R.render.visible || R.parts.length === 1)) {
                                for (M.moveTo(R.vertices[0].x, R.vertices[0].y),
                                q = 1; q < R.vertices.length; q++)
                                    M.lineTo(R.vertices[q].x, R.vertices[q].y);
                                M.lineTo(R.vertices[0].x, R.vertices[0].y)
                            }
                        M.lineWidth = 1,
                        M.strokeStyle = "rgba(255,255,255,0.2)",
                        M.stroke()
                    }
                    ,
                    i.vertexNumbers = function(k, B, P) {
                        var M = P, R, L, q;
                        for (R = 0; R < B.length; R++) {
                            var H = B[R].parts;
                            for (q = H.length > 1 ? 1 : 0; q < H.length; q++) {
                                var j = H[q];
                                for (L = 0; L < j.vertices.length; L++)
                                    M.fillStyle = "rgba(255,255,255,0.2)",
                                    M.fillText(R + "_" + L, j.position.x + (j.vertices[L].x - j.position.x) * .8, j.position.y + (j.vertices[L].y - j.position.y) * .8)
                            }
                        }
                    }
                    ,
                    i.mousePosition = function(k, B, P) {
                        var M = P;
                        M.fillStyle = "rgba(255,255,255,0.8)",
                        M.fillText(B.position.x + "  " + B.position.y, B.position.x + 5, B.position.y - 5)
                    }
                    ,
                    i.bodyBounds = function(k, B, P) {
                        var M = P;
                        k.engine;
                        var R = k.options;
                        M.beginPath();
                        for (var L = 0; L < B.length; L++) {
                            var q = B[L];
                            if (q.render.visible)
                                for (var H = B[L].parts, j = H.length > 1 ? 1 : 0; j < H.length; j++) {
                                    var A = H[j];
                                    M.rect(A.bounds.min.x, A.bounds.min.y, A.bounds.max.x - A.bounds.min.x, A.bounds.max.y - A.bounds.min.y)
                                }
                        }
                        R.wireframes ? M.strokeStyle = "rgba(255,255,255,0.08)" : M.strokeStyle = "rgba(0,0,0,0.1)",
                        M.lineWidth = 1,
                        M.stroke()
                    }
                    ,
                    i.bodyAxes = function(k, B, P) {
                        var M = P;
                        k.engine;
                        var R = k.options, L, q, H, j;
                        for (M.beginPath(),
                        q = 0; q < B.length; q++) {
                            var A = B[q]
                              , E = A.parts;
                            if (A.render.visible)
                                if (R.showAxes)
                                    for (H = E.length > 1 ? 1 : 0; H < E.length; H++)
                                        for (L = E[H],
                                        j = 0; j < L.axes.length; j++) {
                                            var C = L.axes[j];
                                            M.moveTo(L.position.x, L.position.y),
                                            M.lineTo(L.position.x + C.x * 20, L.position.y + C.y * 20)
                                        }
                                else
                                    for (H = E.length > 1 ? 1 : 0; H < E.length; H++)
                                        for (L = E[H],
                                        j = 0; j < L.axes.length; j++)
                                            M.moveTo(L.position.x, L.position.y),
                                            M.lineTo((L.vertices[0].x + L.vertices[L.vertices.length - 1].x) / 2, (L.vertices[0].y + L.vertices[L.vertices.length - 1].y) / 2)
                        }
                        R.wireframes ? (M.strokeStyle = "indianred",
                        M.lineWidth = 1) : (M.strokeStyle = "rgba(255, 255, 255, 0.4)",
                        M.globalCompositeOperation = "overlay",
                        M.lineWidth = 2),
                        M.stroke(),
                        M.globalCompositeOperation = "source-over"
                    }
                    ,
                    i.bodyPositions = function(k, B, P) {
                        var M = P;
                        k.engine;
                        var R = k.options, L, q, H, j;
                        for (M.beginPath(),
                        H = 0; H < B.length; H++)
                            if (L = B[H],
                            !!L.render.visible)
                                for (j = 0; j < L.parts.length; j++)
                                    q = L.parts[j],
                                    M.arc(q.position.x, q.position.y, 3, 0, 2 * Math.PI, !1),
                                    M.closePath();
                        for (R.wireframes ? M.fillStyle = "indianred" : M.fillStyle = "rgba(0,0,0,0.5)",
                        M.fill(),
                        M.beginPath(),
                        H = 0; H < B.length; H++)
                            L = B[H],
                            L.render.visible && (M.arc(L.positionPrev.x, L.positionPrev.y, 2, 0, 2 * Math.PI, !1),
                            M.closePath());
                        M.fillStyle = "rgba(255,165,0,0.8)",
                        M.fill()
                    }
                    ,
                    i.bodyVelocity = function(k, B, P) {
                        var M = P;
                        M.beginPath();
                        for (var R = 0; R < B.length; R++) {
                            var L = B[R];
                            if (L.render.visible) {
                                var q = o.getVelocity(L);
                                M.moveTo(L.position.x, L.position.y),
                                M.lineTo(L.position.x + q.x, L.position.y + q.y)
                            }
                        }
                        M.lineWidth = 3,
                        M.strokeStyle = "cornflowerblue",
                        M.stroke()
                    }
                    ,
                    i.bodyIds = function(k, B, P) {
                        var M = P, R, L;
                        for (R = 0; R < B.length; R++)
                            if (B[R].render.visible) {
                                var q = B[R].parts;
                                for (L = q.length > 1 ? 1 : 0; L < q.length; L++) {
                                    var H = q[L];
                                    M.font = "12px Arial",
                                    M.fillStyle = "rgba(255,255,255,0.5)",
                                    M.fillText(H.id, H.position.x + 10, H.position.y - 10)
                                }
                            }
                    }
                    ,
                    i.collisions = function(k, B, P) {
                        var M = P, R = k.options, L, q, H, j;
                        for (M.beginPath(),
                        H = 0; H < B.length; H++)
                            if (L = B[H],
                            !!L.isActive)
                                for (q = L.collision,
                                j = 0; j < L.contactCount; j++) {
                                    var A = L.contacts[j]
                                      , E = A.vertex;
                                    M.rect(E.x - 1.5, E.y - 1.5, 3.5, 3.5)
                                }
                        for (R.wireframes ? M.fillStyle = "rgba(255,255,255,0.7)" : M.fillStyle = "orange",
                        M.fill(),
                        M.beginPath(),
                        H = 0; H < B.length; H++)
                            if (L = B[H],
                            !!L.isActive && (q = L.collision,
                            L.contactCount > 0)) {
                                var C = L.contacts[0].vertex.x
                                  , O = L.contacts[0].vertex.y;
                                L.contactCount === 2 && (C = (L.contacts[0].vertex.x + L.contacts[1].vertex.x) / 2,
                                O = (L.contacts[0].vertex.y + L.contacts[1].vertex.y) / 2),
                                q.bodyB === q.supports[0].body || q.bodyA.isStatic === !0 ? M.moveTo(C - q.normal.x * 8, O - q.normal.y * 8) : M.moveTo(C + q.normal.x * 8, O + q.normal.y * 8),
                                M.lineTo(C, O)
                            }
                        R.wireframes ? M.strokeStyle = "rgba(255,165,0,0.7)" : M.strokeStyle = "orange",
                        M.lineWidth = 1,
                        M.stroke()
                    }
                    ,
                    i.separations = function(k, B, P) {
                        var M = P, R = k.options, L, q, H, j, A;
                        for (M.beginPath(),
                        A = 0; A < B.length; A++)
                            if (L = B[A],
                            !!L.isActive) {
                                q = L.collision,
                                H = q.bodyA,
                                j = q.bodyB;
                                var E = 1;
                                !j.isStatic && !H.isStatic && (E = .5),
                                j.isStatic && (E = 0),
                                M.moveTo(j.position.x, j.position.y),
                                M.lineTo(j.position.x - q.penetration.x * E, j.position.y - q.penetration.y * E),
                                E = 1,
                                !j.isStatic && !H.isStatic && (E = .5),
                                H.isStatic && (E = 0),
                                M.moveTo(H.position.x, H.position.y),
                                M.lineTo(H.position.x + q.penetration.x * E, H.position.y + q.penetration.y * E)
                            }
                        R.wireframes ? M.strokeStyle = "rgba(255,165,0,0.5)" : M.strokeStyle = "orange",
                        M.stroke()
                    }
                    ,
                    i.inspector = function(k, B) {
                        k.engine;
                        var P = k.selected, M = k.render, R = M.options, L;
                        if (R.hasBounds) {
                            var q = M.bounds.max.x - M.bounds.min.x
                              , H = M.bounds.max.y - M.bounds.min.y
                              , j = q / M.options.width
                              , A = H / M.options.height;
                            B.scale(1 / j, 1 / A),
                            B.translate(-M.bounds.min.x, -M.bounds.min.y)
                        }
                        for (var E = 0; E < P.length; E++) {
                            var C = P[E].data;
                            switch (B.translate(.5, .5),
                            B.lineWidth = 1,
                            B.strokeStyle = "rgba(255,165,0,0.9)",
                            B.setLineDash([1, 2]),
                            C.type) {
                            case "body":
                                L = C.bounds,
                                B.beginPath(),
                                B.rect(Math.floor(L.min.x - 3), Math.floor(L.min.y - 3), Math.floor(L.max.x - L.min.x + 6), Math.floor(L.max.y - L.min.y + 6)),
                                B.closePath(),
                                B.stroke();
                                break;
                            case "constraint":
                                var O = C.pointA;
                                C.bodyA && (O = C.pointB),
                                B.beginPath(),
                                B.arc(O.x, O.y, 10, 0, 2 * Math.PI),
                                B.closePath(),
                                B.stroke();
                                break
                            }
                            B.setLineDash([]),
                            B.translate(-.5, -.5)
                        }
                        k.selectStart !== null && (B.translate(.5, .5),
                        B.lineWidth = 1,
                        B.strokeStyle = "rgba(255,165,0,0.6)",
                        B.fillStyle = "rgba(255,165,0,0.1)",
                        L = k.selectBounds,
                        B.beginPath(),
                        B.rect(Math.floor(L.min.x), Math.floor(L.min.y), Math.floor(L.max.x - L.min.x), Math.floor(L.max.y - L.min.y)),
                        B.closePath(),
                        B.stroke(),
                        B.fill(),
                        B.translate(-.5, -.5)),
                        R.hasBounds && B.setTransform(1, 0, 0, 1, 0, 0)
                    }
                    ;
                    var b = function(k, B) {
                        var P = k.engine
                          , M = k.timing
                          , R = M.historySize
                          , L = P.timing.timestamp;
                        M.delta = B - M.lastTime || i._goodDelta,
                        M.lastTime = B,
                        M.timestampElapsed = L - M.lastTimestamp || 0,
                        M.lastTimestamp = L,
                        M.deltaHistory.unshift(M.delta),
                        M.deltaHistory.length = Math.min(M.deltaHistory.length, R),
                        M.engineDeltaHistory.unshift(P.timing.lastDelta),
                        M.engineDeltaHistory.length = Math.min(M.engineDeltaHistory.length, R),
                        M.timestampElapsedHistory.unshift(M.timestampElapsed),
                        M.timestampElapsedHistory.length = Math.min(M.timestampElapsedHistory.length, R),
                        M.engineUpdatesHistory.unshift(P.timing.lastUpdatesPerFrame),
                        M.engineUpdatesHistory.length = Math.min(M.engineUpdatesHistory.length, R),
                        M.engineElapsedHistory.unshift(P.timing.lastElapsed),
                        M.engineElapsedHistory.length = Math.min(M.engineElapsedHistory.length, R),
                        M.elapsedHistory.unshift(M.lastElapsed),
                        M.elapsedHistory.length = Math.min(M.elapsedHistory.length, R)
                    }
                      , v = function(k) {
                        for (var B = 0, P = 0; P < k.length; P += 1)
                            B += k[P];
                        return B / k.length || 0
                    }
                      , S = function(k, B) {
                        var P = document.createElement("canvas");
                        return P.width = k,
                        P.height = B,
                        P.oncontextmenu = function() {
                            return !1
                        }
                        ,
                        P.onselectstart = function() {
                            return !1
                        }
                        ,
                        P
                    }
                      , N = function(k) {
                        var B = k.getContext("2d")
                          , P = window.devicePixelRatio || 1
                          , M = B.webkitBackingStorePixelRatio || B.mozBackingStorePixelRatio || B.msBackingStorePixelRatio || B.oBackingStorePixelRatio || B.backingStorePixelRatio || 1;
                        return P / M
                    }
                      , _ = function(k, B) {
                        var P = k.textures[B];
                        return P || (P = k.textures[B] = new Image,
                        P.src = B,
                        P)
                    }
                      , I = function(k, B) {
                        var P = B;
                        /(jpg|gif|png)$/.test(B) && (P = "url(" + B + ")"),
                        k.canvas.style.background = P,
                        k.canvas.style.backgroundSize = "contain",
                        k.currentBackground = B
                    }
                }
                )()
            }
            ), (function(t, r, s) {
                var i = {};
                t.exports = i;
                var o = s(5)
                  , a = s(17)
                  , l = s(0);
                (function() {
                    i._maxFrameDelta = 1e3 / 15,
                    i._frameDeltaFallback = 1e3 / 60,
                    i._timeBufferMargin = 1.5,
                    i._elapsedNextEstimate = 1,
                    i._smoothingLowerBound = .1,
                    i._smoothingUpperBound = .9,
                    i.create = function(d) {
                        var h = {
                            delta: 16.666666666666668,
                            frameDelta: null,
                            frameDeltaSmoothing: !0,
                            frameDeltaSnapping: !0,
                            frameDeltaHistory: [],
                            frameDeltaHistorySize: 100,
                            frameRequestId: null,
                            timeBuffer: 0,
                            timeLastTick: null,
                            maxUpdates: null,
                            maxFrameTime: 33.333333333333336,
                            lastUpdatesDeferred: 0,
                            enabled: !0
                        }
                          , p = l.extend(h, d);
                        return p.fps = 0,
                        p
                    }
                    ,
                    i.run = function(d, h) {
                        return d.timeBuffer = i._frameDeltaFallback,
                        (function p(g) {
                            d.frameRequestId = i._onNextFrame(d, p),
                            g && d.enabled && i.tick(d, h, g)
                        }
                        )(),
                        d
                    }
                    ,
                    i.tick = function(d, h, p) {
                        var g = l.now()
                          , w = d.delta
                          , b = 0
                          , v = p - d.timeLastTick;
                        if ((!v || !d.timeLastTick || v > Math.max(i._maxFrameDelta, d.maxFrameTime)) && (v = d.frameDelta || i._frameDeltaFallback),
                        d.frameDeltaSmoothing) {
                            d.frameDeltaHistory.push(v),
                            d.frameDeltaHistory = d.frameDeltaHistory.slice(-d.frameDeltaHistorySize);
                            var S = d.frameDeltaHistory.slice(0).sort()
                              , N = d.frameDeltaHistory.slice(S.length * i._smoothingLowerBound, S.length * i._smoothingUpperBound)
                              , _ = u(N);
                            v = _ || v
                        }
                        d.frameDeltaSnapping && (v = 1e3 / Math.round(1e3 / v)),
                        d.frameDelta = v,
                        d.timeLastTick = p,
                        d.timeBuffer += d.frameDelta,
                        d.timeBuffer = l.clamp(d.timeBuffer, 0, d.frameDelta + w * i._timeBufferMargin),
                        d.lastUpdatesDeferred = 0;
                        var I = d.maxUpdates || Math.ceil(d.maxFrameTime / w)
                          , k = {
                            timestamp: h.timing.timestamp
                        };
                        o.trigger(d, "beforeTick", k),
                        o.trigger(d, "tick", k);
                        for (var B = l.now(); w > 0 && d.timeBuffer >= w * i._timeBufferMargin; ) {
                            o.trigger(d, "beforeUpdate", k),
                            a.update(h, w),
                            o.trigger(d, "afterUpdate", k),
                            d.timeBuffer -= w,
                            b += 1;
                            var P = l.now() - g
                              , M = l.now() - B
                              , R = P + i._elapsedNextEstimate * M / b;
                            if (b >= I || R > d.maxFrameTime) {
                                d.lastUpdatesDeferred = Math.round(Math.max(0, d.timeBuffer / w - i._timeBufferMargin));
                                break
                            }
                        }
                        h.timing.lastUpdatesPerFrame = b,
                        o.trigger(d, "afterTick", k),
                        d.frameDeltaHistory.length >= 100 && (d.lastUpdatesDeferred && Math.round(d.frameDelta / w) > I ? l.warnOnce("Matter.Runner: runner reached runner.maxUpdates, see docs.") : d.lastUpdatesDeferred && l.warnOnce("Matter.Runner: runner reached runner.maxFrameTime, see docs."),
                        typeof d.isFixed < "u" && l.warnOnce("Matter.Runner: runner.isFixed is now redundant, see docs."),
                        (d.deltaMin || d.deltaMax) && l.warnOnce("Matter.Runner: runner.deltaMin and runner.deltaMax were removed, see docs."),
                        d.fps !== 0 && l.warnOnce("Matter.Runner: runner.fps was replaced by runner.delta, see docs."))
                    }
                    ,
                    i.stop = function(d) {
                        i._cancelNextFrame(d)
                    }
                    ,
                    i._onNextFrame = function(d, h) {
                        if (typeof window < "u" && window.requestAnimationFrame)
                            d.frameRequestId = window.requestAnimationFrame(h);
                        else
                            throw new Error("Matter.Runner: missing required global window.requestAnimationFrame.");
                        return d.frameRequestId
                    }
                    ,
                    i._cancelNextFrame = function(d) {
                        if (typeof window < "u" && window.cancelAnimationFrame)
                            window.cancelAnimationFrame(d.frameRequestId);
                        else
                            throw new Error("Matter.Runner: missing required global window.cancelAnimationFrame.")
                    }
                    ;
                    var u = function(d) {
                        for (var h = 0, p = d.length, g = 0; g < p; g += 1)
                            h += d[g];
                        return h / p || 0
                    }
                }
                )()
            }
            ), (function(t, r, s) {
                var i = {};
                t.exports = i;
                var o = s(8)
                  , a = s(0)
                  , l = a.deprecated;
                (function() {
                    i.collides = function(u, d) {
                        return o.collides(u, d)
                    }
                    ,
                    l(i, "collides", "SAT.collides  replaced by Collision.collides")
                }
                )()
            }
            ), (function(t, r, s) {
                var i = {};
                t.exports = i,
                s(1);
                var o = s(0);
                (function() {
                    i.pathToVertices = function(a, l) {
                        typeof window < "u" && !("SVGPathSeg"in window) && o.warn("Svg.pathToVertices: SVGPathSeg not defined, a polyfill is required.");
                        var u, d, h, p, g, w, b, v, S, N, _ = [], I, k, B = 0, P = 0, M = 0;
                        l = l || 15;
                        var R = function(q, H, j) {
                            var A = j % 2 === 1 && j > 1;
                            if (!S || q != S.x || H != S.y) {
                                S && A ? (I = S.x,
                                k = S.y) : (I = 0,
                                k = 0);
                                var E = {
                                    x: I + q,
                                    y: k + H
                                };
                                (A || !S) && (S = E),
                                _.push(E),
                                P = I + q,
                                M = k + H
                            }
                        }
                          , L = function(q) {
                            var H = q.pathSegTypeAsLetter.toUpperCase();
                            if (H !== "Z") {
                                switch (H) {
                                case "M":
                                case "L":
                                case "T":
                                case "C":
                                case "S":
                                case "Q":
                                    P = q.x,
                                    M = q.y;
                                    break;
                                case "H":
                                    P = q.x;
                                    break;
                                case "V":
                                    M = q.y;
                                    break
                                }
                                R(P, M, q.pathSegType)
                            }
                        };
                        for (i._svgPathToAbsolute(a),
                        h = a.getTotalLength(),
                        w = [],
                        u = 0; u < a.pathSegList.numberOfItems; u += 1)
                            w.push(a.pathSegList.getItem(u));
                        for (b = w.concat(); B < h; ) {
                            if (N = a.getPathSegAtLength(B),
                            g = w[N],
                            g != v) {
                                for (; b.length && b[0] != g; )
                                    L(b.shift());
                                v = g
                            }
                            switch (g.pathSegTypeAsLetter.toUpperCase()) {
                            case "C":
                            case "T":
                            case "S":
                            case "Q":
                            case "A":
                                p = a.getPointAtLength(B),
                                R(p.x, p.y, 0);
                                break
                            }
                            B += l
                        }
                        for (u = 0,
                        d = b.length; u < d; ++u)
                            L(b[u]);
                        return _
                    }
                    ,
                    i._svgPathToAbsolute = function(a) {
                        for (var l, u, d, h, p, g, w = a.pathSegList, b = 0, v = 0, S = w.numberOfItems, N = 0; N < S; ++N) {
                            var _ = w.getItem(N)
                              , I = _.pathSegTypeAsLetter;
                            if (/[MLHVCSQTA]/.test(I))
                                "x"in _ && (b = _.x),
                                "y"in _ && (v = _.y);
                            else
                                switch ("x1"in _ && (d = b + _.x1),
                                "x2"in _ && (p = b + _.x2),
                                "y1"in _ && (h = v + _.y1),
                                "y2"in _ && (g = v + _.y2),
                                "x"in _ && (b += _.x),
                                "y"in _ && (v += _.y),
                                I) {
                                case "m":
                                    w.replaceItem(a.createSVGPathSegMovetoAbs(b, v), N);
                                    break;
                                case "l":
                                    w.replaceItem(a.createSVGPathSegLinetoAbs(b, v), N);
                                    break;
                                case "h":
                                    w.replaceItem(a.createSVGPathSegLinetoHorizontalAbs(b), N);
                                    break;
                                case "v":
                                    w.replaceItem(a.createSVGPathSegLinetoVerticalAbs(v), N);
                                    break;
                                case "c":
                                    w.replaceItem(a.createSVGPathSegCurvetoCubicAbs(b, v, d, h, p, g), N);
                                    break;
                                case "s":
                                    w.replaceItem(a.createSVGPathSegCurvetoCubicSmoothAbs(b, v, p, g), N);
                                    break;
                                case "q":
                                    w.replaceItem(a.createSVGPathSegCurvetoQuadraticAbs(b, v, d, h), N);
                                    break;
                                case "t":
                                    w.replaceItem(a.createSVGPathSegCurvetoQuadraticSmoothAbs(b, v), N);
                                    break;
                                case "a":
                                    w.replaceItem(a.createSVGPathSegArcAbs(b, v, _.r1, _.r2, _.angle, _.largeArcFlag, _.sweepFlag), N);
                                    break;
                                case "z":
                                case "Z":
                                    b = l,
                                    v = u;
                                    break
                                }
                            (I == "M" || I == "m") && (l = b,
                            u = v)
                        }
                    }
                }
                )()
            }
            ), (function(t, r, s) {
                var i = {};
                t.exports = i;
                var o = s(6);
                s(0),
                (function() {
                    i.create = o.create,
                    i.add = o.add,
                    i.remove = o.remove,
                    i.clear = o.clear,
                    i.addComposite = o.addComposite,
                    i.addBody = o.addBody,
                    i.addConstraint = o.addConstraint
                }
                )()
            }
            )])
        })
    }
    )(r2)),
    r2.exports
}
var XTe = KTe();
const Lt = Fo(XTe);
class qn {
    static WIDTH = 760;
    static HEIGHT = 570;
    static PADDING_X = 52;
    static PADDING_TOP = 36;
    static PADDING_BOTTOM = 28;
    static PIN_CATEGORY = 1;
    static BALL_CATEGORY = 2;
    static ballFrictions = {
        friction: .4,
        frictionAirByRowCount: {
            8: .083,
            9: .085,
            10: .08,
            11: .076,
            12: .088,
            13: .09,
            14: .084,
            15: .088,
            16: .078
        }
    };
    constructor(e, t) {
        this.canvas = e,
        this.onBallEnterBin = t.onBallEnterBin,
        this.onBalanceDeduct = t.onBalanceDeduct,
        this.betAmount = t.getBetAmount(),
        this.rowCount = t.getRowCount(),
        this.riskLevel = t.getRiskLevel(),
        this.engine = Lt.Engine.create({
            timing: {
                timeScale: .53
            },
            positionIterations: 8,
            velocityIterations: 6
        }),
        this.render = Lt.Render.create({
            engine: this.engine,
            canvas: this.canvas,
            options: {
                width: qn.WIDTH,
                height: qn.HEIGHT,
                background: "#0f1728",
                wireframes: !1
            }
        }),
        this.runner = Lt.Runner.create(),
        this.pins = [],
        this.walls = [],
        this.pinsLastRowXCoords = [],
        this.pinGlowTimeouts = new Map,
        this.glowAnimationFrameId = null,
        this.backendPath = null,
        this.targetBinIndex = null,
        this.targetBinCenterX = null,
        this.ballGuidance = new Map,
        this.pinRowYCoords = [],
        this.placePinsAndWalls(),
        this.updateTargetBinCenter(),
        this.handleBeforeUpdate = this.applyGuidanceForces.bind(this),
        Lt.Events.on(this.engine, "beforeUpdate", this.handleBeforeUpdate),
        this.sensor = Lt.Bodies.rectangle(this.canvas.width / 2, this.canvas.height, this.canvas.width, 10, {
            isSensor: !0,
            isStatic: !0,
            render: {
                visible: !1
            }
        }),
        Lt.Composite.add(this.engine.world, [this.sensor]),
        Lt.Events.on(this.engine, "collisionStart", ({pairs: r}) => {
            r.forEach( ({bodyA: s, bodyB: i}) => {
                s === this.sensor ? this.handleBallEnterBin(i) : i === this.sensor ? this.handleBallEnterBin(s) : (this.handlePinCollision(s, i),
                this.applyDeterministicBounce(s, i))
            }
            )
        }
        ),
        this.setupGlowRendering()
    }
    updateBetAmount(e) {
        this.betAmount = e
    }
    updateRowCount(e) {
        e !== this.rowCount && (this.removeAllBalls(),
        this.rowCount = e,
        this.placePinsAndWalls())
    }
    updateRiskLevel(e) {
        this.riskLevel = e
    }
    start() {
        Lt.Render.run(this.render),
        Lt.Runner.run(this.runner, this.engine)
    }
    stop() {
        Lt.Render.stop(this.render),
        Lt.Runner.stop(this.runner),
        this.glowAnimationFrameId !== null && (cancelAnimationFrame(this.glowAnimationFrameId),
        this.glowAnimationFrameId = null),
        this.handleBeforeUpdate && (Lt.Events.off(this.engine, "beforeUpdate", this.handleBeforeUpdate),
        this.handleBeforeUpdate = null),
        this.ballGuidance.clear()
    }
    dropBall() {
        const e = this.pinDistanceX * .8
          , t = this.pinRadius * 2
          , {friction: r, frictionAirByRowCount: s} = qn.ballFrictions
          , {dropX: i, guidanceTargetX: o, guidanceProfile: a, bounceDirections: l} = this.getDropParameters(e)
          , d = (this.pinRowYCoords.length > 0 ? this.pinRowYCoords[0] : qn.PADDING_TOP) - t - 5
          , h = Lt.Bodies.circle(i, d, t, {
            restitution: .68,
            friction: r,
            frictionAir: s[this.rowCount],
            collisionFilter: {
                category: qn.BALL_CATEGORY,
                mask: qn.PIN_CATEGORY
            },
            render: {
                fillStyle: "#ff3f4a"
            }
        });
        return Lt.Composite.add(this.engine.world, h),
        Lt.Body.setVelocity(h, {
            x: 0,
            y: .27
        }),
        o !== null && this.ballGuidance.set(h.id, {
            targetX: o,
            profile: a,
            bounceDirections: l,
            waypointIndex: 0,
            createdAt: performance.now(),
            lastVelSetAt: 0,
            processedRows: new Set
        }),
        this.onBalanceDeduct && this.onBalanceDeduct(this.betAmount),
        h.id
    }
    get binsWidthPercentage() {
        return (this.pinsLastRowXCoords[this.pinsLastRowXCoords.length - 1] - this.pinsLastRowXCoords[0]) / qn.WIDTH
    }
    get pinDistanceX() {
        const e = 3 + this.rowCount - 1;
        return (this.canvas.width - qn.PADDING_X * 2) / (e - 1)
    }
    get pinRadius() {
        return (24 - this.rowCount) / 2
    }
    handleBallEnterBin(e) {
        const t = this.pinsLastRowXCoords.findLastIndex(r => r < e.position.x);
        t !== -1 && t < this.pinsLastRowXCoords.length - 1 && this.onBallEnterBin && this.onBallEnterBin(e, t),
        this.ballGuidance.delete(e.id),
        Lt.Composite.remove(this.engine.world, e)
    }
    setBackendPath(e) {
        if (!Array.isArray(e) || e.length === 0) {
            this.backendPath = null,
            this.targetBinCenterX = null;
            return
        }
        const t = e.filter(r => {
            const s = (r || "").toUpperCase();
            return s === "R" || s === "L"
        }
        );
        if (t.length === 0) {
            this.backendPath = null,
            this.targetBinCenterX = null;
            return
        }
        this.backendPath = t,
        this.updateTargetBinCenter()
    }
    setTargetBinIndex(e) {
        if (!this.backendPath) {
            if (!Number.isInteger(e)) {
                this.targetBinIndex = null,
                this.targetBinCenterX = null;
                return
            }
            this.targetBinIndex = Math.max(0, e),
            this.updateTargetBinCenter()
        }
    }
    updateTargetBinCenterForBin(e) {
        const t = this.computeBinCenterX(e);
        this.targetBinCenterX = t
    }
    convertPathToBounceDirections(e) {
        return e.map(t => {
            const r = (t || "").toUpperCase();
            return r === "R" ? 1 : r === "L" ? -1 : 0
        }
        ).filter(t => t !== 0)
    }
    getDropParameters(e) {
        const t = () => ({
            dropX: this.clampXPosition(GTe(this.canvas.width / 2 - e, this.canvas.width / 2 + e)),
            guidanceTargetX: null,
            guidanceProfile: null,
            bounceDirections: null
        });
        if (!this.backendPath || !Array.isArray(this.backendPath) || this.backendPath.length === 0)
            return t();
        const r = this.convertPathToBounceDirections(this.backendPath);
        if (r.length === 0 || r.length !== this.rowCount)
            return console.warn(`Path length (${r.length}) doesn't match row count (${this.rowCount}). Using random drop.`),
            t();
        const i = r.filter(u => u === 1).length;
        Hx[this.rowCount]?.[this.riskLevel]?.[i];
        const a = this.computeBinCenterX(i);
        if (a === null)
            return t();
        this.targetBinCenterX = a;
        const l = this.calculateStartPosition(r);
        return {
            dropX: l,
            guidanceTargetX: a,
            guidanceProfile: this.createDeterministicProfile(r, l),
            bounceDirections: r
        }
    }
    calculateBounceDirections(e) {
        const t = this.rowCount
          , r = t + 1
          , s = Math.max(0, Math.min(e, r - 1))
          , i = s
          , o = t - s
          , a = []
          , l = [];
        for (let u = 0; u < o; u++)
            l.push(-1);
        for (let u = 0; u < i; u++)
            l.push(1);
        for (; l.length; )
            l.length && a.push(l.shift()),
            l.length && a.push(l.pop());
        for (; a.length < t; )
            a.push(Math.random() > .5 ? 1 : -1);
        return a.slice(0, t)
    }
    shuffleArray(e) {
        for (let t = e.length - 1; t > 0; t--) {
            const r = Math.floor(Math.random() * (t + 1));
            [e[t],e[r]] = [e[r], e[t]]
        }
        return e
    }
    calculateStartPosition(e) {
        const t = []
          , r = this.pinRowYCoords[0];
        for (const a of this.pins)
            Math.abs(a.position.y - r) < 2 && t.push(a.position.x);
        if (t.length === 0)
            return this.canvas.width / 2;
        t.sort( (a, l) => a - l);
        const s = t[0]
          , i = t[t.length - 1]
          , o = (s + i) / 2;
        return this.clampXPosition(o)
    }
    getPinRowBounds(e) {
        let t = 0
          , r = 1 / 0;
        for (let a = 0; a < this.pinRowYCoords.length; a++) {
            const l = Math.abs(this.pinRowYCoords[a] - e);
            l < r && (r = l,
            t = a)
        }
        const s = []
          , i = this.pinRowYCoords[t];
        for (const a of this.pins)
            Math.abs(a.position.y - i) < 5 && s.push(a.position.x);
        if (s.length === 0)
            return {
                left: qn.PADDING_X + this.pinRadius,
                right: this.canvas.width - qn.PADDING_X - this.pinRadius
            };
        s.sort( (a, l) => a - l);
        const o = this.pinRadius * 1.5;
        return {
            left: s[0] - o,
            right: s[s.length - 1] + o
        }
    }
    createDeterministicProfile(e, t) {
        if (!this.pinRowYCoords.length || !e)
            return null;
        const r = [];
        let s = t;
        const i = this.pinDistanceX / 2
          , o = this.pinRadius * 2
          , l = this.pinRowYCoords[0] - o - 5;
        r.push({
            y: l,
            x: s,
            targetX: s
        });
        for (let d = 0; d < e.length && d < this.pinRowYCoords.length; d++) {
            const h = this.pinRowYCoords[d]
              , p = e[d];
            s = s + p * i;
            const g = this.getPinRowBounds(h);
            s = Math.max(g.left, Math.min(g.right, s));
            const w = h + this.pinRadius * 3;
            r.push({
                y: w,
                x: s,
                targetX: s,
                rowIndex: d,
                bounce: p
            })
        }
        const u = this.targetBinCenterX;
        return r.push({
            y: this.canvas.height - qn.PADDING_BOTTOM - 10,
            x: u,
            targetX: u,
            final: !0
        }),
        r
    }
    applyGuidanceForces() {
        if (this.ballGuidance.size === 0)
            return;
        const e = performance.now()
          , t = Lt.Composite.allBodies(this.engine.world);
        for (const r of t) {
            if (!r.collisionFilter || r.collisionFilter.category !== qn.BALL_CATEGORY)
                continue;
            const s = this.ballGuidance.get(r.id);
            if (!s)
                continue;
            const i = r.velocity.x ?? 0
              , o = r.velocity.y ?? 0
              , a = r.position.x
              , l = r.position.y
              , u = s.profile
              , d = this.canvas.height - qn.PADDING_BOTTOM
              , h = Math.min(1, l / d)
              , p = h < .2;
            let g = s.targetX
              , w = s.waypointIndex || 0;
            if (u && u.length > 0) {
                for (; w < u.length - 1 && l >= u[w].y - 6; )
                    w++;
                s.waypointIndex = w;
                const B = u[w];
                g = B?.targetX ?? B?.x ?? s.targetX
            }
            if (typeof g != "number")
                continue;
            if (u && u.length > 0) {
                const B = u[u.length - 1];
                if (B && Math.abs(B.x - a) < 1.5 && l > B.y - 20) {
                    this.ballGuidance.delete(r.id);
                    continue
                }
            }
            const b = this.getPinRowBounds(l)
              , S = Math.max(b.left, Math.min(b.right, g)) - a
              , N = Math.abs(S);
            if (N > 8) {
                const B = 1 + h * .3
                  , P = N > 40 ? 18e-5 : N > 20 ? 12e-5 : 8e-5;
                let M = S * P * B;
                const R = .0018;
                M > R && (M = R),
                M < -R && (M = -R),
                Lt.Body.applyForce(r, r.position, {
                    x: M,
                    y: 0
                })
            }
            if (u && u.length > 0) {
                const B = u[w];
                if (B && typeof B.rowIndex == "number") {
                    const P = B.rowIndex
                      , M = this.pinRowYCoords[P];
                    if (l >= M - this.pinRadius * 1.4 && l <= M + this.pinRadius * 3.6 && !s.processedRows.has(P)) {
                        s.processedRows.add(P);
                        const L = 1 + P / Math.max(1, this.pinRowYCoords.length) * .2
                          , q = (B.bounce || 0) * .0012 * L
                          , H = .001 * L;
                        Lt.Body.applyForce(r, r.position, {
                            x: q,
                            y: H
                        });
                        const j = s.lastVelSetAt || 0;
                        if (e - j > 50) {
                            const A = B.bounce || 0;
                            Lt.Body.setVelocity(r, {
                                x: r.velocity.x * .96 + A * .04,
                                y: Math.max(.3, r.velocity.y * .99)
                            }),
                            s.lastVelSetAt = e
                        }
                    }
                }
            }
            const _ = Math.hypot(i, o);
            o < .3 && _ < .4 && Lt.Body.applyForce(r, r.position, {
                x: 0,
                y: p ? .0015 : .001
            });
            const I = p ? .3 : .27
              , k = s.lastVelSetAt || 0;
            if (o < I && e - k > 80 && (Lt.Body.setVelocity(r, {
                x: r.velocity.x,
                y: I
            }),
            s.lastVelSetAt = e),
            _ < .35 && o < .3) {
                const B = s.lastVelSetAt || 0;
                e - B > 80 && (Lt.Body.setVelocity(r, {
                    x: r.velocity.x * .95 + S * .03,
                    y: Math.max(.27, o + .03)
                }),
                s.lastVelSetAt = e)
            }
        }
    }
    clampXPosition(e) {
        const t = qn.PADDING_X + this.pinRadius
          , r = this.canvas.width - qn.PADDING_X - this.pinRadius;
        return Math.max(t, Math.min(r, e))
    }
    applyDeterministicBounce(e, t) {
        const {PIN_CATEGORY: r, BALL_CATEGORY: s} = qn;
        let i = null
          , o = null;
        if (e.collisionFilter.category === r && t.collisionFilter.category === s)
            o = e,
            i = t;
        else if (t.collisionFilter.category === r && e.collisionFilter.category === s)
            o = t,
            i = e;
        else
            return;
        const a = this.ballGuidance.get(i.id);
        if (!a || !a.bounceDirections)
            return;
        const l = o.position.y;
        let u = -1;
        for (let S = 0; S < this.pinRowYCoords.length; S++)
            if (Math.abs(this.pinRowYCoords[S] - l) < 5) {
                u = S;
                break
            }
        if (u < 0 || u >= a.bounceDirections.length || (a.processedRows || (a.processedRows = new Set),
        a.processedRows.has(u)))
            return;
        a.processedRows.add(u);
        const d = a.bounceDirections[u]
          , h = i.velocity.x
          , p = d * .7
          , g = h * .92 + p * .08
          , w = i.velocity.y;
        Lt.Body.setVelocity(i, {
            x: g,
            y: Math.max(.27, w * .99)
        }),
        Lt.Body.applyForce(i, i.position, {
            x: d * 6e-4,
            y: 5e-4
        });
        const v = Math.hypot(i.velocity.x, i.velocity.y);
        w < .3 && v < .4 && (Lt.Body.setVelocity(i, {
            x: g,
            y: Math.max(.3, w + .03)
        }),
        Lt.Body.applyForce(i, i.position, {
            x: d * 8e-4,
            y: .001
        }))
    }
    handlePinCollision(e, t) {
        const {PIN_CATEGORY: r, BALL_CATEGORY: s} = qn;
        let i = null;
        e.collisionFilter.category === r && t.collisionFilter.category === s ? i = e : t.collisionFilter.category === r && e.collisionFilter.category === s && (i = t),
        i && this.pins.includes(i) && this.applyPinGlow(i)
    }
    applyPinGlow(e) {
        this.pinGlowTimeouts.has(e.id) && clearTimeout(this.pinGlowTimeouts.get(e.id)),
        e.isGlowing = !0,
        e._glowStart = performance.now(),
        e.render && (e.render.fillStyle = "#ffffff",
        e.render.strokeStyle = void 0,
        e.render.lineWidth = 0,
        e.render._glowApplied = !0);
        const t = setTimeout( () => {
            e.isGlowing = !1,
            delete e._glowStart,
            e.render && (e.render.fillStyle = "#fffaf0",
            e.render._glowApplied = !1),
            this.pinGlowTimeouts.delete(e.id)
        }
        , 400);
        this.pinGlowTimeouts.set(e.id, t)
    }
    setupGlowRendering() {
        const e = this;
        if (this._afterRenderHandler) {
            try {
                Lt.Events.off(this.render, "afterRender", this._afterRenderHandler)
            } catch {}
            this._afterRenderHandler = null
        }
        const t = function() {
            if (!e.render || !e.render.canvas)
                return;
            const r = e.render.canvas.getContext("2d");
            if (!r)
                return;
            r.save();
            const s = performance.now();
            for (const o of e.pins) {
                if (!o.isGlowing || !o._glowStart)
                    continue;
                const a = o.position.x
                  , l = o.position.y
                  , u = o.circleRadius || e.pinRadius
                  , d = Math.max(0, s - o._glowStart)
                  , h = 400
                  , p = Math.min(1, d / h)
                  , g = u * (1.6 + .9 * (1 - p));
                r.beginPath();
                const w = r.createRadialGradient(a, l, u * .8, a, l, g);
                w.addColorStop(0, `rgba(24,32,38, ${.92 - .92 * p})`),
                w.addColorStop(1, "rgba(24,32,38, 1)"),
                r.fillStyle = w,
                r.arc(a, l, g, 0, Math.PI * 2),
                r.fill();
                for (let b = 0; b < 2; b++) {
                    const v = b * 90
                      , S = h - b * 80
                      , N = Math.max(0, d - v);
                    if (N <= 0)
                        continue;
                    const _ = Math.min(1, N / S)
                      , I = u + u * (3.6 + b * 1.8) * _
                      , k = (1 - _) * (.95 - b * .25);
                    k <= .02 || (r.save(),
                    r.shadowBlur = 12 + 18 * (1 - _),
                    r.shadowColor = `rgba(60,90,110, ${Math.max(.12, k * .6).toFixed(3)})`,
                    r.beginPath(),
                    r.lineWidth = Math.max(1.2, 3.2 * (1 - _) + b * .6),
                    r.strokeStyle = `rgba(65,90,105, ${k.toFixed(3)})`,
                    r.arc(a, l, I, 0, Math.PI * 2),
                    r.stroke(),
                    r.restore())
                }
            }
            const i = Lt.Composite.allBodies(e.engine.world);
            for (const o of i) {
                if (!o.position || !(o.collisionFilter && o.collisionFilter.category === qn.BALL_CATEGORY))
                    continue;
                const a = o.position.x
                  , l = o.position.y
                  , u = o.circleRadius || e.pinRadius * 2
                  , d = o.velocity || {
                    x: 0,
                    y: 0
                }
                  , h = d.x * 2.2
                  , p = d.y * .6
                  , g = u * (1.6 + Math.min(1.2, Math.hypot(d.x, d.y) * .5))
                  , w = r.createRadialGradient(a - h * 2.5, l - p * 2.5, u * .12, a - h * 2.5, l - p * 2.5, g);
                w.addColorStop(0, "rgba(255,90,90,0.32)"),
                w.addColorStop(.5, "rgba(255,50,50,0.12)"),
                w.addColorStop(1, "rgba(0,0,0,0)"),
                r.fillStyle = w,
                r.beginPath(),
                r.arc(a - h * 2.5, l - p * 2.5, g, 0, Math.PI * 2),
                r.fill();
                const b = r.createRadialGradient(a - u * .22, l - u * .4, u * .12, a, l, u);
                b.addColorStop(0, "rgba(255,255,245,0.96)"),
                b.addColorStop(.12, "rgba(255,110,110,0.99)"),
                b.addColorStop(.6, "rgba(220,40,40,0.99)"),
                b.addColorStop(1, "rgba(150,16,20,0.99)"),
                r.fillStyle = b,
                r.beginPath(),
                r.arc(a, l, u, 0, Math.PI * 2),
                r.fill();
                const v = a - u * .22
                  , S = l - u * .64
                  , N = u * .34
                  , _ = r.createRadialGradient(v, S, 1, v, S, N);
                _.addColorStop(0, "rgba(255,255,255,0.98)"),
                _.addColorStop(1, "rgba(255,255,255,0)"),
                r.fillStyle = _,
                r.beginPath(),
                r.arc(v, S, N, 0, Math.PI * 2),
                r.fill();
                for (const I of e.pins) {
                    const k = I.position.x - a
                      , B = I.position.y - l
                      , P = Math.hypot(k, B)
                      , M = u + (I.circleRadius || e.pinRadius) + 8;
                    if (P < M) {
                        const R = I._glowStart || s - 40
                          , L = Math.max(0, s - R)
                          , q = Math.min(1, L / 400)
                          , H = I.position.x
                          , j = I.position.y
                          , A = (I.circleRadius || e.pinRadius) * (.95 + 2.6 * q)
                          , E = Math.max(0, (1 - q) * .98);
                        E > .02 && (r.save(),
                        r.shadowBlur = 14 * (1 - q),
                        r.shadowColor = `rgba(80,110,130, ${Math.min(.6, E).toFixed(3)})`,
                        r.beginPath(),
                        r.lineWidth = Math.max(1.6, 3.2 * (1 - q)),
                        r.strokeStyle = `rgba(60,90,105, ${E.toFixed(3)})`,
                        r.arc(H, j, A, 0, Math.PI * 2),
                        r.stroke(),
                        r.restore());
                        const C = (I.circleRadius || e.pinRadius) * (1.2 - .9 * q)
                          , O = Math.max(0, .78 * (1 - q));
                        if (O > .02) {
                            const z = r.createRadialGradient(H, j, 1, H, j, C);
                            z.addColorStop(0, `rgba(20,30,36, ${O.toFixed(3)})`),
                            z.addColorStop(1, "rgba(20,30,36,0)"),
                            r.fillStyle = z,
                            r.beginPath(),
                            r.arc(H, j, C, 0, Math.PI * 2),
                            r.fill()
                        }
                        break
                    }
                }
            }
            r.restore()
        };
        this._afterRenderHandler = t,
        Lt.Events.on(this.render, "afterRender", t)
    }
    placePinsAndWalls() {
        const {PADDING_X: e, PADDING_TOP: t, PADDING_BOTTOM: r} = qn;
        this.pins.length > 0 && (this.cleanupGlowTimeouts(),
        Lt.Composite.remove(this.engine.world, this.pins),
        this.pins = []),
        this.pinsLastRowXCoords.length > 0 && (this.pinsLastRowXCoords = []),
        this.walls.length > 0 && (Lt.Composite.remove(this.engine.world, this.walls),
        this.walls = []),
        this.pinRowYCoords = [];
        for (let u = 0; u < this.rowCount; ++u) {
            const d = t + (this.canvas.height - t - r) / (this.rowCount - 1) * u;
            this.pinRowYCoords.push(d);
            const h = e + (this.rowCount - 1 - u) * this.pinDistanceX / 2;
            for (let p = 0; p < 3 + u; ++p) {
                const g = h + (this.canvas.width - h * 2) / (3 + u - 1) * p
                  , w = Lt.Bodies.circle(g, d, this.pinRadius, {
                    isStatic: !0,
                    render: {
                        fillStyle: "#fffaf0"
                    },
                    collisionFilter: {
                        category: qn.PIN_CATEGORY,
                        mask: qn.BALL_CATEGORY
                    }
                });
                this.pins.push(w),
                u === this.rowCount - 1 && this.pinsLastRowXCoords.push(g)
            }
        }
        Lt.Composite.add(this.engine.world, this.pins);
        const s = this.pins[0].position.x
          , i = Math.atan2(s - this.pinsLastRowXCoords[0], this.canvas.height - t - r)
          , o = s - (s - this.pinsLastRowXCoords[0]) / 2 - this.pinDistanceX * .25
          , a = Lt.Bodies.rectangle(o, this.canvas.height / 2, 10, this.canvas.height, {
            isStatic: !0,
            angle: i,
            render: {
                visible: !1
            }
        })
          , l = Lt.Bodies.rectangle(this.canvas.width - o, this.canvas.height / 2, 10, this.canvas.height, {
            isStatic: !0,
            angle: -i,
            render: {
                visible: !1
            }
        });
        this.walls.push(a, l),
        Lt.Composite.add(this.engine.world, this.walls),
        this.updateTargetBinCenter()
    }
    removeAllBalls() {
        Lt.Composite.allBodies(this.engine.world).forEach(e => {
            e.collisionFilter.category === qn.BALL_CATEGORY && (Lt.Composite.remove(this.engine.world, e),
            this.ballGuidance.delete(e.id))
        }
        ),
        this.ballGuidance.clear()
    }
    computeBinCenterX(e) {
        const t = this.pinsLastRowXCoords.length - 1;
        if (t <= 0 || e === null)
            return null;
        const r = Math.max(0, Math.min(e, t - 1))
          , s = this.pinsLastRowXCoords[r]
          , i = this.pinsLastRowXCoords[r + 1];
        return (s + i) / 2
    }
    updateTargetBinCenter() {
        if (this.backendPath && Array.isArray(this.backendPath) && this.backendPath.length > 0) {
            const r = this.convertPathToBounceDirections(this.backendPath).filter(i => i === 1).length
              , s = this.computeBinCenterX(r);
            this.targetBinCenterX = s;
            return
        }
        if (this.targetBinIndex !== null) {
            const e = this.computeBinCenterX(this.targetBinIndex);
            if (e !== null) {
                const t = this.pinsLastRowXCoords.length - 1
                  , r = Math.max(0, Math.min(this.targetBinIndex, t - 1));
                this.targetBinIndex = r,
                this.targetBinCenterX = e;
                return
            }
        }
        this.targetBinCenterX = null
    }
    cleanupGlowTimeouts() {
        this.pinGlowTimeouts.forEach(e => clearTimeout(e)),
        this.pinGlowTimeouts.clear()
    }
}
const NG = V.createContext(void 0);
function QTe({children: n}) {
    const [e,t] = V.useState(null)
      , [r,s] = V.useState(1)
      , [i,o] = V.useState({})
      , [a,l] = V.useState(12)
      , [u,d] = V.useState(Mn.MEDIUM)
      , [h,p] = V.useState([])
      , [g,w] = V.useState([0])
      , [b,v] = V.useState(!0)
      , [S,N] = V.useState(!1)
      , [_,I] = V.useState(!1)
      , [k,B] = V.useState("")
      , [P,M] = V.useState(null)
      , {balance: R, refreshBalance: L} = Hs();
    V.useEffect( () => {
        const A = localStorage.getItem(cj.SETTINGS.ANIMATION);
        A !== null && v(A === "true")
    }
    , []),
    V.useEffect( () => {
        localStorage.setItem(cj.SETTINGS.ANIMATION, String(b))
    }
    , [b]);
    const q = V.useCallback( (A, E) => {
        const C = i[A.id] ?? 0
          , O = Number(E)
          , z = Hx[a][u][E]
          , G = C * z
          , Y = G - C
          , $ = {
            id: uy(),
            betAmount: C,
            rowCount: a,
            binIndex: E,
            binId: O,
            payout: {
                multiplier: z,
                value: G
            },
            profit: Y
        };
        p(D => {
            const U = D.slice(0, 3);
            return [$, ...U]
        }
        ),
        w(D => {
            const U = D[D.length - 1];
            return [...D, U + Y]
        }
        ),
        L(),
        o(D => {
            const U = {
                ...D
            };
            return delete U[A.id],
            U
        }
        )
    }
    , [i, a, u])
      , H = V.useCallback( () => {
        p([]),
        w([0])
    }
    , []);
    V.useEffect( () => {
        e && e.updateBetAmount(r)
    }
    , [r, e]),
    V.useEffect( () => {
        e && e.updateRowCount(a)
    }
    , [a, e]),
    V.useEffect( () => {
        e && e.updateRiskLevel(u)
    }
    , [u, e]),
    V.useEffect( () => {
        e && (P && Array.isArray(P) && P.length > 0 ? e.setBackendPath(P) : e.setBackendPath(null))
    }
    , [P, e]),
    V.useEffect( () => {
        if (!e)
            return;
        if (k === "") {
            P || e.setTargetBinIndex(null);
            return
        }
        const A = Number(k);
        Number.isFinite(A) && A >= 0 ? e.setTargetBinIndex(Math.floor(A)) : e.setTargetBinIndex(null)
    }
    , [k, e, P]);
    const j = {
        plinkoEngine: e,
        betAmount: r,
        betAmountOfExistingBalls: i,
        rowCount: a,
        riskLevel: u,
        winRecords: h,
        totalProfitHistory: g,
        balance: R,
        isAnimationOn: b,
        isGameSettingsOpen: S,
        isLiveStatsOpen: _,
        setPlinkoEngine: t,
        setBetAmount: s,
        setRowCount: l,
        setRiskLevel: d,
        setBetAmountOfExistingBalls: o,
        setIsAnimationOn: v,
        setIsGameSettingsOpen: N,
        setIsLiveStatsOpen: I,
        targetBinIndex: k,
        setTargetBinIndex: B,
        backendPath: P,
        setBackendPath: M,
        handleBallEnterBin: q,
        resetLiveStats: H
    };
    return m.jsx(NG.Provider, {
        value: j,
        children: n
    })
}
function Vx() {
    const n = V.useContext(NG);
    if (n === void 0)
        throw new Error("useGame must be used within a GameProvider");
    return n
}
function ZTe() {
    const {plinkoEngine: n, rowCount: e, riskLevel: t, winRecords: r, isAnimationOn: s} = Vx()
      , i = V.useRef([]);
    V.useEffect( () => {
        if (r.length > 0) {
            const d = r[0].binIndex;
            o(d)
        }
    }
    , [r]);
    const o = d => {
        if (!s)
            return;
        const h = i.current[d];
        h && h.animate([{
            transform: "translateY(0)"
        }, {
            transform: "translateY(30%)"
        }, {
            transform: "translateY(0)"
        }], {
            duration: 300,
            easing: "cubic-bezier(0.18, 0.89, 0.32, 1.28)"
        })
    }
    ;
    if (!n)
        return null;
    const a = n.binsWidthPercentage ?? 0
      , l = Hx[e][t]
      , u = kG[e];
    return m.jsx("div", {
        className: "flex h-[clamp(10px,0.352px+2.609vw,16px)] w-full justify-center lg:h-7",
        children: m.jsx("div", {
            className: "flex gap-[1%]",
            style: {
                width: `${a * 100}%`
            },
            children: l.map( (d, h) => m.jsxs("div", {
                ref: p => {
                    i.current[h] = p
                }
                ,
                "data-bin-id": h,
                className: "flex min-w-0 flex-1 items-center justify-center rounded-sm text-[clamp(6px,2.784px+0.87vw,8px)] font-bold text-gray-950 shadow-[0_2px_var(--shadow-color)] lg:rounded-md lg:text-[clamp(10px,-16.944px+2.632vw,12px)] lg:shadow-[0_3px_var(--shadow-color)]",
                style: {
                    backgroundColor: u.background[h],
                    "--shadow-color": u.shadow[h]
                },
                children: [d, d < 100 ? "" : ""]
            }, h))
        })
    })
}
function JTe({winCount: n=4}) {
    const {winRecords: e} = Vx();
    console.log(" ~ LastWins ~ winRecords:", e);
    const t = e;
    return m.jsx("div", {
        className: "flex w-[clamp(1.5rem,0.893rem+2.857vw,2rem)] flex-col overflow-hidden rounded-sm text-[clamp(8px,5.568px+0.714vw,10px)] md:rounded-md lg:w-12 lg:text-sm",
        style: {
            aspectRatio: `1 / ${n}`
        },
        children: t.map( ({binIndex: r, binId: s, rowCount: i, payout: {multiplier: o}}, a) => m.jsxs("div", {
            "data-bin-id": s ?? r,
            className: "flex aspect-square items-center justify-center font-bold text-gray-950",
            style: {
                backgroundColor: kG[i].background[r]
            },
            children: [o, o < 100 ? "" : ""]
        }, a))
    })
}
var DG = {
    color: void 0,
    size: void 0,
    className: void 0,
    style: void 0,
    attr: void 0
}
  , dj = ye.createContext && ye.createContext(DG)
  , eIe = ["attr", "size", "title"];
function tIe(n, e) {
    if (n == null)
        return {};
    var t = nIe(n, e), r, s;
    if (Object.getOwnPropertySymbols) {
        var i = Object.getOwnPropertySymbols(n);
        for (s = 0; s < i.length; s++)
            r = i[s],
            !(e.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(n, r) && (t[r] = n[r])
    }
    return t
}
function nIe(n, e) {
    if (n == null)
        return {};
    var t = {};
    for (var r in n)
        if (Object.prototype.hasOwnProperty.call(n, r)) {
            if (e.indexOf(r) >= 0)
                continue;
            t[r] = n[r]
        }
    return t
}
function fv() {
    return fv = Object.assign ? Object.assign.bind() : function(n) {
        for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var r in t)
                Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r])
        }
        return n
    }
    ,
    fv.apply(this, arguments)
}
function fj(n, e) {
    var t = Object.keys(n);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(n);
        e && (r = r.filter(function(s) {
            return Object.getOwnPropertyDescriptor(n, s).enumerable
        })),
        t.push.apply(t, r)
    }
    return t
}
function hv(n) {
    for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e] != null ? arguments[e] : {};
        e % 2 ? fj(Object(t), !0).forEach(function(r) {
            rIe(n, r, t[r])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t)) : fj(Object(t)).forEach(function(r) {
            Object.defineProperty(n, r, Object.getOwnPropertyDescriptor(t, r))
        })
    }
    return n
}
function rIe(n, e, t) {
    return e = sIe(e),
    e in n ? Object.defineProperty(n, e, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : n[e] = t,
    n
}
function sIe(n) {
    var e = iIe(n, "string");
    return typeof e == "symbol" ? e : e + ""
}
function iIe(n, e) {
    if (typeof n != "object" || !n)
        return n;
    var t = n[Symbol.toPrimitive];
    if (t !== void 0) {
        var r = t.call(n, e);
        if (typeof r != "object")
            return r;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (e === "string" ? String : Number)(n)
}
function TG(n) {
    return n && n.map( (e, t) => ye.createElement(e.tag, hv({
        key: t
    }, e.attr), TG(e.child)))
}
function Ik(n) {
    return e => ye.createElement(oIe, fv({
        attr: hv({}, n.attr)
    }, e), TG(n.child))
}
function oIe(n) {
    var e = t => {
        var {attr: r, size: s, title: i} = n, o = tIe(n, eIe), a = s || t.size || "1em", l;
        return t.className && (l = t.className),
        n.className && (l = (l ? l + " " : "") + n.className),
        ye.createElement("svg", fv({
            stroke: "currentColor",
            fill: "currentColor",
            strokeWidth: "0"
        }, t.attr, r, o, {
            className: l,
            style: hv(hv({
                color: n.color || t.color
            }, t.style), n.style),
            height: a,
            width: a,
            xmlns: "http://www.w3.org/2000/svg"
        }), i && ye.createElement("title", null, i), n.children)
    }
    ;
    return dj !== void 0 ? ye.createElement(dj.Consumer, null, t => e(t)) : e(DG)
}
function aIe(n) {
    return Ik({
        attr: {
            viewBox: "0 0 512 512"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M433 288.8c-7.7 0-14.3 5.9-14.9 13.6-6.9 83.1-76.8 147.9-161.8 147.9-89.5 0-162.4-72.4-162.4-161.4 0-87.6 70.6-159.2 158.2-161.4 2.3-.1 4.1 1.7 4.1 4v50.3c0 12.6 13.9 20.2 24.6 13.5L377 128c10-6.3 10-20.8 0-27.1l-96.1-66.4c-10.7-6.7-24.6.9-24.6 13.5v45.7c0 2.2-1.7 4-3.9 4C148 99.8 64 184.6 64 288.9 64 394.5 150.1 480 256.3 480c100.8 0 183.4-76.7 191.6-175.1.8-8.7-6.2-16.1-14.9-16.1z"
            },
            child: []
        }]
    })(n)
}
const {WIDTH: HA, HEIGHT: hj} = qn;
function lIe() {
    const n = V.useRef(null)
      , {plinkoEngine: e, setPlinkoEngine: t, betAmount: r, rowCount: s, riskLevel: i, handleBallEnterBin: o} = Vx();
    return V.useEffect( () => {
        if (!n.current)
            return;
        const a = n.current
          , l = new qn(a,{
            onBallEnterBin: o,
            getBetAmount: () => r,
            getRowCount: () => s,
            getRiskLevel: () => i
        });
        return l.start(),
        t(l),
        () => {
            l.stop(),
            t(null)
        }
    }
    , []),
    V.useEffect( () => {
        e && e.updateRowCount(s)
    }
    , [s, e]),
    V.useEffect( () => {
        e && e.updateRiskLevel(i)
    }
    , [i, e]),
    V.useEffect( () => {
        e && e.updateBetAmount(r)
    }
    , [r, e]),
    m.jsxs("div", {
        className: "relative bg-gray-900",
        children: [m.jsxs("div", {
            className: "mx-auto flex h-full flex-col px-4 pb-4",
            style: {
                maxWidth: `${HA}px`
            },
            children: [m.jsxs("div", {
                className: "relative w-full",
                style: {
                    aspectRatio: `${HA} / ${hj}`
                },
                children: [e === null && m.jsx("div", {
                    className: "absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2",
                    children: m.jsx(aIe, {
                        className: "size-20 animate-spin text-slate-600"
                    })
                }), m.jsx("canvas", {
                    ref: n,
                    width: HA,
                    height: hj,
                    className: "absolute inset-0 h-full w-full"
                })]
            }), m.jsx(ZTe, {})]
        }), m.jsx("div", {
            className: "absolute right-[5%] top-1/2 -translate-y-1/2",
            children: m.jsx(JTe, {})
        })]
    })
}
function cIe(n) {
    return Ik({
        attr: {
            viewBox: "0 0 512 512"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M256 64C150 64 64 150 64 256s86 192 192 192 192-86 192-192S362 64 256 64zm-6 304a20 20 0 1 1 20-20 20 20 0 0 1-20 20zm33.44-102C267.23 276.88 265 286.85 265 296a14 14 0 0 1-28 0c0-21.91 10.08-39.33 30.82-53.26C287.1 229.8 298 221.6 298 203.57c0-12.26-7-21.57-21.49-28.46-3.41-1.62-11-3.2-20.34-3.09-11.72.15-20.82 2.95-27.83 8.59C215.12 191.25 214 202.83 214 203a14 14 0 1 1-28-1.35c.11-2.43 1.8-24.32 24.77-42.8 11.91-9.58 27.06-14.56 45-14.78 12.7-.15 24.63 2 32.72 5.82C312.7 161.34 326 180.43 326 203.57c0 33.83-22.61 49.02-42.56 62.43z"
            },
            child: []
        }]
    })(n)
}
function uIe(n) {
    return Ik({
        attr: {
            viewBox: "0 0 512 512"
        },
        child: [{
            tag: "path",
            attr: {
                fill: "none",
                strokeLinecap: "round",
                strokeMiterlimit: "10",
                strokeWidth: "48",
                d: "M256 256s-48-96-126-96c-54.12 0-98 43-98 96s43.88 96 98 96c30 0 56.45-13.18 78-32m48-64s48 96 126 96c54.12 0 98-43 98-96s-43.88-96-98-96c-29.37 0-56.66 13.75-78 32"
            },
            child: []
        }]
    })(n)
}
const dIe = (n, e) => {
    const t = new Array(n.length + e.length);
    for (let r = 0; r < n.length; r++)
        t[r] = n[r];
    for (let r = 0; r < e.length; r++)
        t[n.length + r] = e[r];
    return t
}
  , fIe = (n, e) => ({
    classGroupId: n,
    validator: e
})
  , IG = (n=new Map, e=null, t) => ({
    nextPart: n,
    validators: e,
    classGroupId: t
})
  , pv = "-"
  , pj = []
  , hIe = "arbitrary.."
  , pIe = n => {
    const e = gIe(n)
      , {conflictingClassGroups: t, conflictingClassGroupModifiers: r} = n;
    return {
        getClassGroupId: o => {
            if (o.startsWith("[") && o.endsWith("]"))
                return mIe(o);
            const a = o.split(pv)
              , l = a[0] === "" && a.length > 1 ? 1 : 0;
            return MG(a, l, e)
        }
        ,
        getConflictingClassGroupIds: (o, a) => {
            if (a) {
                const l = r[o]
                  , u = t[o];
                return l ? u ? dIe(u, l) : l : u || pj
            }
            return t[o] || pj
        }
    }
}
  , MG = (n, e, t) => {
    if (n.length - e === 0)
        return t.classGroupId;
    const s = n[e]
      , i = t.nextPart.get(s);
    if (i) {
        const u = MG(n, e + 1, i);
        if (u)
            return u
    }
    const o = t.validators;
    if (o === null)
        return;
    const a = e === 0 ? n.join(pv) : n.slice(e).join(pv)
      , l = o.length;
    for (let u = 0; u < l; u++) {
        const d = o[u];
        if (d.validator(a))
            return d.classGroupId
    }
}
  , mIe = n => n.slice(1, -1).indexOf(":") === -1 ? void 0 : ( () => {
    const e = n.slice(1, -1)
      , t = e.indexOf(":")
      , r = e.slice(0, t);
    return r ? hIe + r : void 0
}
)()
  , gIe = n => {
    const {theme: e, classGroups: t} = n;
    return yIe(t, e)
}
  , yIe = (n, e) => {
    const t = IG();
    for (const r in n) {
        const s = n[r];
        Mk(s, t, r, e)
    }
    return t
}
  , Mk = (n, e, t, r) => {
    const s = n.length;
    for (let i = 0; i < s; i++) {
        const o = n[i];
        bIe(o, e, t, r)
    }
}
  , bIe = (n, e, t, r) => {
    if (typeof n == "string") {
        wIe(n, e, t);
        return
    }
    if (typeof n == "function") {
        vIe(n, e, t, r);
        return
    }
    xIe(n, e, t, r)
}
  , wIe = (n, e, t) => {
    const r = n === "" ? e : BG(e, n);
    r.classGroupId = t
}
  , vIe = (n, e, t, r) => {
    if (EIe(n)) {
        Mk(n(r), e, t, r);
        return
    }
    e.validators === null && (e.validators = []),
    e.validators.push(fIe(t, n))
}
  , xIe = (n, e, t, r) => {
    const s = Object.entries(n)
      , i = s.length;
    for (let o = 0; o < i; o++) {
        const [a,l] = s[o];
        Mk(l, BG(e, a), t, r)
    }
}
  , BG = (n, e) => {
    let t = n;
    const r = e.split(pv)
      , s = r.length;
    for (let i = 0; i < s; i++) {
        const o = r[i];
        let a = t.nextPart.get(o);
        a || (a = IG(),
        t.nextPart.set(o, a)),
        t = a
    }
    return t
}
  , EIe = n => "isThemeGetter"in n && n.isThemeGetter === !0
  , SIe = n => {
    if (n < 1)
        return {
            get: () => {}
            ,
            set: () => {}
        };
    let e = 0
      , t = Object.create(null)
      , r = Object.create(null);
    const s = (i, o) => {
        t[i] = o,
        e++,
        e > n && (e = 0,
        r = t,
        t = Object.create(null))
    }
    ;
    return {
        get(i) {
            let o = t[i];
            if (o !== void 0)
                return o;
            if ((o = r[i]) !== void 0)
                return s(i, o),
                o
        },
        set(i, o) {
            i in t ? t[i] = o : s(i, o)
        }
    }
}
  , s8 = "!"
  , mj = ":"
  , AIe = []
  , gj = (n, e, t, r, s) => ({
    modifiers: n,
    hasImportantModifier: e,
    baseClassName: t,
    maybePostfixModifierPosition: r,
    isExternal: s
})
  , CIe = n => {
    const {prefix: e, experimentalParseClassName: t} = n;
    let r = s => {
        const i = [];
        let o = 0, a = 0, l = 0, u;
        const d = s.length;
        for (let b = 0; b < d; b++) {
            const v = s[b];
            if (o === 0 && a === 0) {
                if (v === mj) {
                    i.push(s.slice(l, b)),
                    l = b + 1;
                    continue
                }
                if (v === "/") {
                    u = b;
                    continue
                }
            }
            v === "[" ? o++ : v === "]" ? o-- : v === "(" ? a++ : v === ")" && a--
        }
        const h = i.length === 0 ? s : s.slice(l);
        let p = h
          , g = !1;
        h.endsWith(s8) ? (p = h.slice(0, -1),
        g = !0) : h.startsWith(s8) && (p = h.slice(1),
        g = !0);
        const w = u && u > l ? u - l : void 0;
        return gj(i, g, p, w)
    }
    ;
    if (e) {
        const s = e + mj
          , i = r;
        r = o => o.startsWith(s) ? i(o.slice(s.length)) : gj(AIe, !1, o, void 0, !0)
    }
    if (t) {
        const s = r;
        r = i => t({
            className: i,
            parseClassName: s
        })
    }
    return r
}
  , _Ie = n => {
    const e = new Map;
    return n.orderSensitiveModifiers.forEach( (t, r) => {
        e.set(t, 1e6 + r)
    }
    ),
    t => {
        const r = [];
        let s = [];
        for (let i = 0; i < t.length; i++) {
            const o = t[i]
              , a = o[0] === "["
              , l = e.has(o);
            a || l ? (s.length > 0 && (s.sort(),
            r.push(...s),
            s = []),
            r.push(o)) : s.push(o)
        }
        return s.length > 0 && (s.sort(),
        r.push(...s)),
        r
    }
}
  , kIe = n => ({
    cache: SIe(n.cacheSize),
    parseClassName: CIe(n),
    sortModifiers: _Ie(n),
    ...pIe(n)
})
  , NIe = /\s+/
  , DIe = (n, e) => {
    const {parseClassName: t, getClassGroupId: r, getConflictingClassGroupIds: s, sortModifiers: i} = e
      , o = []
      , a = n.trim().split(NIe);
    let l = "";
    for (let u = a.length - 1; u >= 0; u -= 1) {
        const d = a[u]
          , {isExternal: h, modifiers: p, hasImportantModifier: g, baseClassName: w, maybePostfixModifierPosition: b} = t(d);
        if (h) {
            l = d + (l.length > 0 ? " " + l : l);
            continue
        }
        let v = !!b
          , S = r(v ? w.substring(0, b) : w);
        if (!S) {
            if (!v) {
                l = d + (l.length > 0 ? " " + l : l);
                continue
            }
            if (S = r(w),
            !S) {
                l = d + (l.length > 0 ? " " + l : l);
                continue
            }
            v = !1
        }
        const N = p.length === 0 ? "" : p.length === 1 ? p[0] : i(p).join(":")
          , _ = g ? N + s8 : N
          , I = _ + S;
        if (o.indexOf(I) > -1)
            continue;
        o.push(I);
        const k = s(S, v);
        for (let B = 0; B < k.length; ++B) {
            const P = k[B];
            o.push(_ + P)
        }
        l = d + (l.length > 0 ? " " + l : l)
    }
    return l
}
  , TIe = (...n) => {
    let e = 0, t, r, s = "";
    for (; e < n.length; )
        (t = n[e++]) && (r = RG(t)) && (s && (s += " "),
        s += r);
    return s
}
  , RG = n => {
    if (typeof n == "string")
        return n;
    let e, t = "";
    for (let r = 0; r < n.length; r++)
        n[r] && (e = RG(n[r])) && (t && (t += " "),
        t += e);
    return t
}
  , IIe = (n, ...e) => {
    let t, r, s, i;
    const o = l => {
        const u = e.reduce( (d, h) => h(d), n());
        return t = kIe(u),
        r = t.cache.get,
        s = t.cache.set,
        i = a,
        a(l)
    }
      , a = l => {
        const u = r(l);
        if (u)
            return u;
        const d = DIe(l, t);
        return s(l, d),
        d
    }
    ;
    return i = o,
    (...l) => i(TIe(...l))
}
  , MIe = []
  , Hr = n => {
    const e = t => t[n] || MIe;
    return e.isThemeGetter = !0,
    e
}
  , OG = /^\[(?:(\w[\w-]*):)?(.+)\]$/i
  , PG = /^\((?:(\w[\w-]*):)?(.+)\)$/i
  , BIe = /^\d+\/\d+$/
  , RIe = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/
  , OIe = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/
  , PIe = /^(rgba?|hsla?|hwb|(ok)?(lab|lch)|color-mix)\(.+\)$/
  , jIe = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/
  , LIe = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/
  , ip = n => BIe.test(n)
  , Ft = n => !!n && !Number.isNaN(Number(n))
  , Du = n => !!n && Number.isInteger(Number(n))
  , VA = n => n.endsWith("%") && Ft(n.slice(0, -1))
  , Ul = n => RIe.test(n)
  , FIe = () => !0
  , UIe = n => OIe.test(n) && !PIe.test(n)
  , jG = () => !1
  , zIe = n => jIe.test(n)
  , $Ie = n => LIe.test(n)
  , HIe = n => !at(n) && !lt(n)
  , VIe = n => O0(n, UG, jG)
  , at = n => OG.test(n)
  , jd = n => O0(n, zG, UIe)
  , qA = n => O0(n, KIe, Ft)
  , yj = n => O0(n, LG, jG)
  , qIe = n => O0(n, FG, $Ie)
  , yw = n => O0(n, $G, zIe)
  , lt = n => PG.test(n)
  , lg = n => P0(n, zG)
  , GIe = n => P0(n, XIe)
  , bj = n => P0(n, LG)
  , WIe = n => P0(n, UG)
  , YIe = n => P0(n, FG)
  , bw = n => P0(n, $G, !0)
  , O0 = (n, e, t) => {
    const r = OG.exec(n);
    return r ? r[1] ? e(r[1]) : t(r[2]) : !1
}
  , P0 = (n, e, t=!1) => {
    const r = PG.exec(n);
    return r ? r[1] ? e(r[1]) : t : !1
}
  , LG = n => n === "position" || n === "percentage"
  , FG = n => n === "image" || n === "url"
  , UG = n => n === "length" || n === "size" || n === "bg-size"
  , zG = n => n === "length"
  , KIe = n => n === "number"
  , XIe = n => n === "family-name"
  , $G = n => n === "shadow"
  , QIe = () => {
    const n = Hr("color")
      , e = Hr("font")
      , t = Hr("text")
      , r = Hr("font-weight")
      , s = Hr("tracking")
      , i = Hr("leading")
      , o = Hr("breakpoint")
      , a = Hr("container")
      , l = Hr("spacing")
      , u = Hr("radius")
      , d = Hr("shadow")
      , h = Hr("inset-shadow")
      , p = Hr("text-shadow")
      , g = Hr("drop-shadow")
      , w = Hr("blur")
      , b = Hr("perspective")
      , v = Hr("aspect")
      , S = Hr("ease")
      , N = Hr("animate")
      , _ = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"]
      , I = () => ["center", "top", "bottom", "left", "right", "top-left", "left-top", "top-right", "right-top", "bottom-right", "right-bottom", "bottom-left", "left-bottom"]
      , k = () => [...I(), lt, at]
      , B = () => ["auto", "hidden", "clip", "visible", "scroll"]
      , P = () => ["auto", "contain", "none"]
      , M = () => [lt, at, l]
      , R = () => [ip, "full", "auto", ...M()]
      , L = () => [Du, "none", "subgrid", lt, at]
      , q = () => ["auto", {
        span: ["full", Du, lt, at]
    }, Du, lt, at]
      , H = () => [Du, "auto", lt, at]
      , j = () => ["auto", "min", "max", "fr", lt, at]
      , A = () => ["start", "end", "center", "between", "around", "evenly", "stretch", "baseline", "center-safe", "end-safe"]
      , E = () => ["start", "end", "center", "stretch", "center-safe", "end-safe"]
      , C = () => ["auto", ...M()]
      , O = () => [ip, "auto", "full", "dvw", "dvh", "lvw", "lvh", "svw", "svh", "min", "max", "fit", ...M()]
      , z = () => [n, lt, at]
      , G = () => [...I(), bj, yj, {
        position: [lt, at]
    }]
      , Y = () => ["no-repeat", {
        repeat: ["", "x", "y", "space", "round"]
    }]
      , $ = () => ["auto", "cover", "contain", WIe, VIe, {
        size: [lt, at]
    }]
      , D = () => [VA, lg, jd]
      , U = () => ["", "none", "full", u, lt, at]
      , W = () => ["", Ft, lg, jd]
      , Q = () => ["solid", "dashed", "dotted", "double"]
      , J = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"]
      , ne = () => [Ft, VA, bj, yj]
      , ie = () => ["", "none", w, lt, at]
      , ae = () => ["none", Ft, lt, at]
      , xe = () => ["none", Ft, lt, at]
      , ue = () => [Ft, lt, at]
      , ce = () => [ip, "full", ...M()];
    return {
        cacheSize: 500,
        theme: {
            animate: ["spin", "ping", "pulse", "bounce"],
            aspect: ["video"],
            blur: [Ul],
            breakpoint: [Ul],
            color: [FIe],
            container: [Ul],
            "drop-shadow": [Ul],
            ease: ["in", "out", "in-out"],
            font: [HIe],
            "font-weight": ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black"],
            "inset-shadow": [Ul],
            leading: ["none", "tight", "snug", "normal", "relaxed", "loose"],
            perspective: ["dramatic", "near", "normal", "midrange", "distant", "none"],
            radius: [Ul],
            shadow: [Ul],
            spacing: ["px", Ft],
            text: [Ul],
            "text-shadow": [Ul],
            tracking: ["tighter", "tight", "normal", "wide", "wider", "widest"]
        },
        classGroups: {
            aspect: [{
                aspect: ["auto", "square", ip, at, lt, v]
            }],
            container: ["container"],
            columns: [{
                columns: [Ft, at, lt, a]
            }],
            "break-after": [{
                "break-after": _()
            }],
            "break-before": [{
                "break-before": _()
            }],
            "break-inside": [{
                "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
            }],
            "box-decoration": [{
                "box-decoration": ["slice", "clone"]
            }],
            box: [{
                box: ["border", "content"]
            }],
            display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
            sr: ["sr-only", "not-sr-only"],
            float: [{
                float: ["right", "left", "none", "start", "end"]
            }],
            clear: [{
                clear: ["left", "right", "both", "none", "start", "end"]
            }],
            isolation: ["isolate", "isolation-auto"],
            "object-fit": [{
                object: ["contain", "cover", "fill", "none", "scale-down"]
            }],
            "object-position": [{
                object: k()
            }],
            overflow: [{
                overflow: B()
            }],
            "overflow-x": [{
                "overflow-x": B()
            }],
            "overflow-y": [{
                "overflow-y": B()
            }],
            overscroll: [{
                overscroll: P()
            }],
            "overscroll-x": [{
                "overscroll-x": P()
            }],
            "overscroll-y": [{
                "overscroll-y": P()
            }],
            position: ["static", "fixed", "absolute", "relative", "sticky"],
            inset: [{
                inset: R()
            }],
            "inset-x": [{
                "inset-x": R()
            }],
            "inset-y": [{
                "inset-y": R()
            }],
            start: [{
                start: R()
            }],
            end: [{
                end: R()
            }],
            top: [{
                top: R()
            }],
            right: [{
                right: R()
            }],
            bottom: [{
                bottom: R()
            }],
            left: [{
                left: R()
            }],
            visibility: ["visible", "invisible", "collapse"],
            z: [{
                z: [Du, "auto", lt, at]
            }],
            basis: [{
                basis: [ip, "full", "auto", a, ...M()]
            }],
            "flex-direction": [{
                flex: ["row", "row-reverse", "col", "col-reverse"]
            }],
            "flex-wrap": [{
                flex: ["nowrap", "wrap", "wrap-reverse"]
            }],
            flex: [{
                flex: [Ft, ip, "auto", "initial", "none", at]
            }],
            grow: [{
                grow: ["", Ft, lt, at]
            }],
            shrink: [{
                shrink: ["", Ft, lt, at]
            }],
            order: [{
                order: [Du, "first", "last", "none", lt, at]
            }],
            "grid-cols": [{
                "grid-cols": L()
            }],
            "col-start-end": [{
                col: q()
            }],
            "col-start": [{
                "col-start": H()
            }],
            "col-end": [{
                "col-end": H()
            }],
            "grid-rows": [{
                "grid-rows": L()
            }],
            "row-start-end": [{
                row: q()
            }],
            "row-start": [{
                "row-start": H()
            }],
            "row-end": [{
                "row-end": H()
            }],
            "grid-flow": [{
                "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
            }],
            "auto-cols": [{
                "auto-cols": j()
            }],
            "auto-rows": [{
                "auto-rows": j()
            }],
            gap: [{
                gap: M()
            }],
            "gap-x": [{
                "gap-x": M()
            }],
            "gap-y": [{
                "gap-y": M()
            }],
            "justify-content": [{
                justify: [...A(), "normal"]
            }],
            "justify-items": [{
                "justify-items": [...E(), "normal"]
            }],
            "justify-self": [{
                "justify-self": ["auto", ...E()]
            }],
            "align-content": [{
                content: ["normal", ...A()]
            }],
            "align-items": [{
                items: [...E(), {
                    baseline: ["", "last"]
                }]
            }],
            "align-self": [{
                self: ["auto", ...E(), {
                    baseline: ["", "last"]
                }]
            }],
            "place-content": [{
                "place-content": A()
            }],
            "place-items": [{
                "place-items": [...E(), "baseline"]
            }],
            "place-self": [{
                "place-self": ["auto", ...E()]
            }],
            p: [{
                p: M()
            }],
            px: [{
                px: M()
            }],
            py: [{
                py: M()
            }],
            ps: [{
                ps: M()
            }],
            pe: [{
                pe: M()
            }],
            pt: [{
                pt: M()
            }],
            pr: [{
                pr: M()
            }],
            pb: [{
                pb: M()
            }],
            pl: [{
                pl: M()
            }],
            m: [{
                m: C()
            }],
            mx: [{
                mx: C()
            }],
            my: [{
                my: C()
            }],
            ms: [{
                ms: C()
            }],
            me: [{
                me: C()
            }],
            mt: [{
                mt: C()
            }],
            mr: [{
                mr: C()
            }],
            mb: [{
                mb: C()
            }],
            ml: [{
                ml: C()
            }],
            "space-x": [{
                "space-x": M()
            }],
            "space-x-reverse": ["space-x-reverse"],
            "space-y": [{
                "space-y": M()
            }],
            "space-y-reverse": ["space-y-reverse"],
            size: [{
                size: O()
            }],
            w: [{
                w: [a, "screen", ...O()]
            }],
            "min-w": [{
                "min-w": [a, "screen", "none", ...O()]
            }],
            "max-w": [{
                "max-w": [a, "screen", "none", "prose", {
                    screen: [o]
                }, ...O()]
            }],
            h: [{
                h: ["screen", "lh", ...O()]
            }],
            "min-h": [{
                "min-h": ["screen", "lh", "none", ...O()]
            }],
            "max-h": [{
                "max-h": ["screen", "lh", ...O()]
            }],
            "font-size": [{
                text: ["base", t, lg, jd]
            }],
            "font-smoothing": ["antialiased", "subpixel-antialiased"],
            "font-style": ["italic", "not-italic"],
            "font-weight": [{
                font: [r, lt, qA]
            }],
            "font-stretch": [{
                "font-stretch": ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded", VA, at]
            }],
            "font-family": [{
                font: [GIe, at, e]
            }],
            "fvn-normal": ["normal-nums"],
            "fvn-ordinal": ["ordinal"],
            "fvn-slashed-zero": ["slashed-zero"],
            "fvn-figure": ["lining-nums", "oldstyle-nums"],
            "fvn-spacing": ["proportional-nums", "tabular-nums"],
            "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
            tracking: [{
                tracking: [s, lt, at]
            }],
            "line-clamp": [{
                "line-clamp": [Ft, "none", lt, qA]
            }],
            leading: [{
                leading: [i, ...M()]
            }],
            "list-image": [{
                "list-image": ["none", lt, at]
            }],
            "list-style-position": [{
                list: ["inside", "outside"]
            }],
            "list-style-type": [{
                list: ["disc", "decimal", "none", lt, at]
            }],
            "text-alignment": [{
                text: ["left", "center", "right", "justify", "start", "end"]
            }],
            "placeholder-color": [{
                placeholder: z()
            }],
            "text-color": [{
                text: z()
            }],
            "text-decoration": ["underline", "overline", "line-through", "no-underline"],
            "text-decoration-style": [{
                decoration: [...Q(), "wavy"]
            }],
            "text-decoration-thickness": [{
                decoration: [Ft, "from-font", "auto", lt, jd]
            }],
            "text-decoration-color": [{
                decoration: z()
            }],
            "underline-offset": [{
                "underline-offset": [Ft, "auto", lt, at]
            }],
            "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
            "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
            "text-wrap": [{
                text: ["wrap", "nowrap", "balance", "pretty"]
            }],
            indent: [{
                indent: M()
            }],
            "vertical-align": [{
                align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", lt, at]
            }],
            whitespace: [{
                whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
            }],
            break: [{
                break: ["normal", "words", "all", "keep"]
            }],
            wrap: [{
                wrap: ["break-word", "anywhere", "normal"]
            }],
            hyphens: [{
                hyphens: ["none", "manual", "auto"]
            }],
            content: [{
                content: ["none", lt, at]
            }],
            "bg-attachment": [{
                bg: ["fixed", "local", "scroll"]
            }],
            "bg-clip": [{
                "bg-clip": ["border", "padding", "content", "text"]
            }],
            "bg-origin": [{
                "bg-origin": ["border", "padding", "content"]
            }],
            "bg-position": [{
                bg: G()
            }],
            "bg-repeat": [{
                bg: Y()
            }],
            "bg-size": [{
                bg: $()
            }],
            "bg-image": [{
                bg: ["none", {
                    linear: [{
                        to: ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
                    }, Du, lt, at],
                    radial: ["", lt, at],
                    conic: [Du, lt, at]
                }, YIe, qIe]
            }],
            "bg-color": [{
                bg: z()
            }],
            "gradient-from-pos": [{
                from: D()
            }],
            "gradient-via-pos": [{
                via: D()
            }],
            "gradient-to-pos": [{
                to: D()
            }],
            "gradient-from": [{
                from: z()
            }],
            "gradient-via": [{
                via: z()
            }],
            "gradient-to": [{
                to: z()
            }],
            rounded: [{
                rounded: U()
            }],
            "rounded-s": [{
                "rounded-s": U()
            }],
            "rounded-e": [{
                "rounded-e": U()
            }],
            "rounded-t": [{
                "rounded-t": U()
            }],
            "rounded-r": [{
                "rounded-r": U()
            }],
            "rounded-b": [{
                "rounded-b": U()
            }],
            "rounded-l": [{
                "rounded-l": U()
            }],
            "rounded-ss": [{
                "rounded-ss": U()
            }],
            "rounded-se": [{
                "rounded-se": U()
            }],
            "rounded-ee": [{
                "rounded-ee": U()
            }],
            "rounded-es": [{
                "rounded-es": U()
            }],
            "rounded-tl": [{
                "rounded-tl": U()
            }],
            "rounded-tr": [{
                "rounded-tr": U()
            }],
            "rounded-br": [{
                "rounded-br": U()
            }],
            "rounded-bl": [{
                "rounded-bl": U()
            }],
            "border-w": [{
                border: W()
            }],
            "border-w-x": [{
                "border-x": W()
            }],
            "border-w-y": [{
                "border-y": W()
            }],
            "border-w-s": [{
                "border-s": W()
            }],
            "border-w-e": [{
                "border-e": W()
            }],
            "border-w-t": [{
                "border-t": W()
            }],
            "border-w-r": [{
                "border-r": W()
            }],
            "border-w-b": [{
                "border-b": W()
            }],
            "border-w-l": [{
                "border-l": W()
            }],
            "divide-x": [{
                "divide-x": W()
            }],
            "divide-x-reverse": ["divide-x-reverse"],
            "divide-y": [{
                "divide-y": W()
            }],
            "divide-y-reverse": ["divide-y-reverse"],
            "border-style": [{
                border: [...Q(), "hidden", "none"]
            }],
            "divide-style": [{
                divide: [...Q(), "hidden", "none"]
            }],
            "border-color": [{
                border: z()
            }],
            "border-color-x": [{
                "border-x": z()
            }],
            "border-color-y": [{
                "border-y": z()
            }],
            "border-color-s": [{
                "border-s": z()
            }],
            "border-color-e": [{
                "border-e": z()
            }],
            "border-color-t": [{
                "border-t": z()
            }],
            "border-color-r": [{
                "border-r": z()
            }],
            "border-color-b": [{
                "border-b": z()
            }],
            "border-color-l": [{
                "border-l": z()
            }],
            "divide-color": [{
                divide: z()
            }],
            "outline-style": [{
                outline: [...Q(), "none", "hidden"]
            }],
            "outline-offset": [{
                "outline-offset": [Ft, lt, at]
            }],
            "outline-w": [{
                outline: ["", Ft, lg, jd]
            }],
            "outline-color": [{
                outline: z()
            }],
            shadow: [{
                shadow: ["", "none", d, bw, yw]
            }],
            "shadow-color": [{
                shadow: z()
            }],
            "inset-shadow": [{
                "inset-shadow": ["none", h, bw, yw]
            }],
            "inset-shadow-color": [{
                "inset-shadow": z()
            }],
            "ring-w": [{
                ring: W()
            }],
            "ring-w-inset": ["ring-inset"],
            "ring-color": [{
                ring: z()
            }],
            "ring-offset-w": [{
                "ring-offset": [Ft, jd]
            }],
            "ring-offset-color": [{
                "ring-offset": z()
            }],
            "inset-ring-w": [{
                "inset-ring": W()
            }],
            "inset-ring-color": [{
                "inset-ring": z()
            }],
            "text-shadow": [{
                "text-shadow": ["none", p, bw, yw]
            }],
            "text-shadow-color": [{
                "text-shadow": z()
            }],
            opacity: [{
                opacity: [Ft, lt, at]
            }],
            "mix-blend": [{
                "mix-blend": [...J(), "plus-darker", "plus-lighter"]
            }],
            "bg-blend": [{
                "bg-blend": J()
            }],
            "mask-clip": [{
                "mask-clip": ["border", "padding", "content", "fill", "stroke", "view"]
            }, "mask-no-clip"],
            "mask-composite": [{
                mask: ["add", "subtract", "intersect", "exclude"]
            }],
            "mask-image-linear-pos": [{
                "mask-linear": [Ft]
            }],
            "mask-image-linear-from-pos": [{
                "mask-linear-from": ne()
            }],
            "mask-image-linear-to-pos": [{
                "mask-linear-to": ne()
            }],
            "mask-image-linear-from-color": [{
                "mask-linear-from": z()
            }],
            "mask-image-linear-to-color": [{
                "mask-linear-to": z()
            }],
            "mask-image-t-from-pos": [{
                "mask-t-from": ne()
            }],
            "mask-image-t-to-pos": [{
                "mask-t-to": ne()
            }],
            "mask-image-t-from-color": [{
                "mask-t-from": z()
            }],
            "mask-image-t-to-color": [{
                "mask-t-to": z()
            }],
            "mask-image-r-from-pos": [{
                "mask-r-from": ne()
            }],
            "mask-image-r-to-pos": [{
                "mask-r-to": ne()
            }],
            "mask-image-r-from-color": [{
                "mask-r-from": z()
            }],
            "mask-image-r-to-color": [{
                "mask-r-to": z()
            }],
            "mask-image-b-from-pos": [{
                "mask-b-from": ne()
            }],
            "mask-image-b-to-pos": [{
                "mask-b-to": ne()
            }],
            "mask-image-b-from-color": [{
                "mask-b-from": z()
            }],
            "mask-image-b-to-color": [{
                "mask-b-to": z()
            }],
            "mask-image-l-from-pos": [{
                "mask-l-from": ne()
            }],
            "mask-image-l-to-pos": [{
                "mask-l-to": ne()
            }],
            "mask-image-l-from-color": [{
                "mask-l-from": z()
            }],
            "mask-image-l-to-color": [{
                "mask-l-to": z()
            }],
            "mask-image-x-from-pos": [{
                "mask-x-from": ne()
            }],
            "mask-image-x-to-pos": [{
                "mask-x-to": ne()
            }],
            "mask-image-x-from-color": [{
                "mask-x-from": z()
            }],
            "mask-image-x-to-color": [{
                "mask-x-to": z()
            }],
            "mask-image-y-from-pos": [{
                "mask-y-from": ne()
            }],
            "mask-image-y-to-pos": [{
                "mask-y-to": ne()
            }],
            "mask-image-y-from-color": [{
                "mask-y-from": z()
            }],
            "mask-image-y-to-color": [{
                "mask-y-to": z()
            }],
            "mask-image-radial": [{
                "mask-radial": [lt, at]
            }],
            "mask-image-radial-from-pos": [{
                "mask-radial-from": ne()
            }],
            "mask-image-radial-to-pos": [{
                "mask-radial-to": ne()
            }],
            "mask-image-radial-from-color": [{
                "mask-radial-from": z()
            }],
            "mask-image-radial-to-color": [{
                "mask-radial-to": z()
            }],
            "mask-image-radial-shape": [{
                "mask-radial": ["circle", "ellipse"]
            }],
            "mask-image-radial-size": [{
                "mask-radial": [{
                    closest: ["side", "corner"],
                    farthest: ["side", "corner"]
                }]
            }],
            "mask-image-radial-pos": [{
                "mask-radial-at": I()
            }],
            "mask-image-conic-pos": [{
                "mask-conic": [Ft]
            }],
            "mask-image-conic-from-pos": [{
                "mask-conic-from": ne()
            }],
            "mask-image-conic-to-pos": [{
                "mask-conic-to": ne()
            }],
            "mask-image-conic-from-color": [{
                "mask-conic-from": z()
            }],
            "mask-image-conic-to-color": [{
                "mask-conic-to": z()
            }],
            "mask-mode": [{
                mask: ["alpha", "luminance", "match"]
            }],
            "mask-origin": [{
                "mask-origin": ["border", "padding", "content", "fill", "stroke", "view"]
            }],
            "mask-position": [{
                mask: G()
            }],
            "mask-repeat": [{
                mask: Y()
            }],
            "mask-size": [{
                mask: $()
            }],
            "mask-type": [{
                "mask-type": ["alpha", "luminance"]
            }],
            "mask-image": [{
                mask: ["none", lt, at]
            }],
            filter: [{
                filter: ["", "none", lt, at]
            }],
            blur: [{
                blur: ie()
            }],
            brightness: [{
                brightness: [Ft, lt, at]
            }],
            contrast: [{
                contrast: [Ft, lt, at]
            }],
            "drop-shadow": [{
                "drop-shadow": ["", "none", g, bw, yw]
            }],
            "drop-shadow-color": [{
                "drop-shadow": z()
            }],
            grayscale: [{
                grayscale: ["", Ft, lt, at]
            }],
            "hue-rotate": [{
                "hue-rotate": [Ft, lt, at]
            }],
            invert: [{
                invert: ["", Ft, lt, at]
            }],
            saturate: [{
                saturate: [Ft, lt, at]
            }],
            sepia: [{
                sepia: ["", Ft, lt, at]
            }],
            "backdrop-filter": [{
                "backdrop-filter": ["", "none", lt, at]
            }],
            "backdrop-blur": [{
                "backdrop-blur": ie()
            }],
            "backdrop-brightness": [{
                "backdrop-brightness": [Ft, lt, at]
            }],
            "backdrop-contrast": [{
                "backdrop-contrast": [Ft, lt, at]
            }],
            "backdrop-grayscale": [{
                "backdrop-grayscale": ["", Ft, lt, at]
            }],
            "backdrop-hue-rotate": [{
                "backdrop-hue-rotate": [Ft, lt, at]
            }],
            "backdrop-invert": [{
                "backdrop-invert": ["", Ft, lt, at]
            }],
            "backdrop-opacity": [{
                "backdrop-opacity": [Ft, lt, at]
            }],
            "backdrop-saturate": [{
                "backdrop-saturate": [Ft, lt, at]
            }],
            "backdrop-sepia": [{
                "backdrop-sepia": ["", Ft, lt, at]
            }],
            "border-collapse": [{
                border: ["collapse", "separate"]
            }],
            "border-spacing": [{
                "border-spacing": M()
            }],
            "border-spacing-x": [{
                "border-spacing-x": M()
            }],
            "border-spacing-y": [{
                "border-spacing-y": M()
            }],
            "table-layout": [{
                table: ["auto", "fixed"]
            }],
            caption: [{
                caption: ["top", "bottom"]
            }],
            transition: [{
                transition: ["", "all", "colors", "opacity", "shadow", "transform", "none", lt, at]
            }],
            "transition-behavior": [{
                transition: ["normal", "discrete"]
            }],
            duration: [{
                duration: [Ft, "initial", lt, at]
            }],
            ease: [{
                ease: ["linear", "initial", S, lt, at]
            }],
            delay: [{
                delay: [Ft, lt, at]
            }],
            animate: [{
                animate: ["none", N, lt, at]
            }],
            backface: [{
                backface: ["hidden", "visible"]
            }],
            perspective: [{
                perspective: [b, lt, at]
            }],
            "perspective-origin": [{
                "perspective-origin": k()
            }],
            rotate: [{
                rotate: ae()
            }],
            "rotate-x": [{
                "rotate-x": ae()
            }],
            "rotate-y": [{
                "rotate-y": ae()
            }],
            "rotate-z": [{
                "rotate-z": ae()
            }],
            scale: [{
                scale: xe()
            }],
            "scale-x": [{
                "scale-x": xe()
            }],
            "scale-y": [{
                "scale-y": xe()
            }],
            "scale-z": [{
                "scale-z": xe()
            }],
            "scale-3d": ["scale-3d"],
            skew: [{
                skew: ue()
            }],
            "skew-x": [{
                "skew-x": ue()
            }],
            "skew-y": [{
                "skew-y": ue()
            }],
            transform: [{
                transform: [lt, at, "", "none", "gpu", "cpu"]
            }],
            "transform-origin": [{
                origin: k()
            }],
            "transform-style": [{
                transform: ["3d", "flat"]
            }],
            translate: [{
                translate: ce()
            }],
            "translate-x": [{
                "translate-x": ce()
            }],
            "translate-y": [{
                "translate-y": ce()
            }],
            "translate-z": [{
                "translate-z": ce()
            }],
            "translate-none": ["translate-none"],
            accent: [{
                accent: z()
            }],
            appearance: [{
                appearance: ["none", "auto"]
            }],
            "caret-color": [{
                caret: z()
            }],
            "color-scheme": [{
                scheme: ["normal", "dark", "light", "light-dark", "only-dark", "only-light"]
            }],
            cursor: [{
                cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", lt, at]
            }],
            "field-sizing": [{
                "field-sizing": ["fixed", "content"]
            }],
            "pointer-events": [{
                "pointer-events": ["auto", "none"]
            }],
            resize: [{
                resize: ["none", "", "y", "x"]
            }],
            "scroll-behavior": [{
                scroll: ["auto", "smooth"]
            }],
            "scroll-m": [{
                "scroll-m": M()
            }],
            "scroll-mx": [{
                "scroll-mx": M()
            }],
            "scroll-my": [{
                "scroll-my": M()
            }],
            "scroll-ms": [{
                "scroll-ms": M()
            }],
            "scroll-me": [{
                "scroll-me": M()
            }],
            "scroll-mt": [{
                "scroll-mt": M()
            }],
            "scroll-mr": [{
                "scroll-mr": M()
            }],
            "scroll-mb": [{
                "scroll-mb": M()
            }],
            "scroll-ml": [{
                "scroll-ml": M()
            }],
            "scroll-p": [{
                "scroll-p": M()
            }],
            "scroll-px": [{
                "scroll-px": M()
            }],
            "scroll-py": [{
                "scroll-py": M()
            }],
            "scroll-ps": [{
                "scroll-ps": M()
            }],
            "scroll-pe": [{
                "scroll-pe": M()
            }],
            "scroll-pt": [{
                "scroll-pt": M()
            }],
            "scroll-pr": [{
                "scroll-pr": M()
            }],
            "scroll-pb": [{
                "scroll-pb": M()
            }],
            "scroll-pl": [{
                "scroll-pl": M()
            }],
            "snap-align": [{
                snap: ["start", "end", "center", "align-none"]
            }],
            "snap-stop": [{
                snap: ["normal", "always"]
            }],
            "snap-type": [{
                snap: ["none", "x", "y", "both"]
            }],
            "snap-strictness": [{
                snap: ["mandatory", "proximity"]
            }],
            touch: [{
                touch: ["auto", "none", "manipulation"]
            }],
            "touch-x": [{
                "touch-pan": ["x", "left", "right"]
            }],
            "touch-y": [{
                "touch-pan": ["y", "up", "down"]
            }],
            "touch-pz": ["touch-pinch-zoom"],
            select: [{
                select: ["none", "text", "all", "auto"]
            }],
            "will-change": [{
                "will-change": ["auto", "scroll", "contents", "transform", lt, at]
            }],
            fill: [{
                fill: ["none", ...z()]
            }],
            "stroke-w": [{
                stroke: [Ft, lg, jd, qA]
            }],
            stroke: [{
                stroke: ["none", ...z()]
            }],
            "forced-color-adjust": [{
                "forced-color-adjust": ["auto", "none"]
            }]
        },
        conflictingClassGroups: {
            overflow: ["overflow-x", "overflow-y"],
            overscroll: ["overscroll-x", "overscroll-y"],
            inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
            "inset-x": ["right", "left"],
            "inset-y": ["top", "bottom"],
            flex: ["basis", "grow", "shrink"],
            gap: ["gap-x", "gap-y"],
            p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
            px: ["pr", "pl"],
            py: ["pt", "pb"],
            m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
            mx: ["mr", "ml"],
            my: ["mt", "mb"],
            size: ["w", "h"],
            "font-size": ["leading"],
            "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
            "fvn-ordinal": ["fvn-normal"],
            "fvn-slashed-zero": ["fvn-normal"],
            "fvn-figure": ["fvn-normal"],
            "fvn-spacing": ["fvn-normal"],
            "fvn-fraction": ["fvn-normal"],
            "line-clamp": ["display", "overflow"],
            rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
            "rounded-s": ["rounded-ss", "rounded-es"],
            "rounded-e": ["rounded-se", "rounded-ee"],
            "rounded-t": ["rounded-tl", "rounded-tr"],
            "rounded-r": ["rounded-tr", "rounded-br"],
            "rounded-b": ["rounded-br", "rounded-bl"],
            "rounded-l": ["rounded-tl", "rounded-bl"],
            "border-spacing": ["border-spacing-x", "border-spacing-y"],
            "border-w": ["border-w-x", "border-w-y", "border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
            "border-w-x": ["border-w-r", "border-w-l"],
            "border-w-y": ["border-w-t", "border-w-b"],
            "border-color": ["border-color-x", "border-color-y", "border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
            "border-color-x": ["border-color-r", "border-color-l"],
            "border-color-y": ["border-color-t", "border-color-b"],
            translate: ["translate-x", "translate-y", "translate-none"],
            "translate-none": ["translate", "translate-x", "translate-y", "translate-z"],
            "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
            "scroll-mx": ["scroll-mr", "scroll-ml"],
            "scroll-my": ["scroll-mt", "scroll-mb"],
            "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
            "scroll-px": ["scroll-pr", "scroll-pl"],
            "scroll-py": ["scroll-pt", "scroll-pb"],
            touch: ["touch-x", "touch-y", "touch-pz"],
            "touch-x": ["touch"],
            "touch-y": ["touch"],
            "touch-pz": ["touch"]
        },
        conflictingClassGroupModifiers: {
            "font-size": ["leading"]
        },
        orderSensitiveModifiers: ["*", "**", "after", "backdrop", "before", "details-content", "file", "first-letter", "first-line", "marker", "placeholder", "selection"]
    }
}
  , GA = IIe(QIe)
  , ZIe = Pc.BASE_URL.play;
async function JIe(n, e) {
    return await Wr(`${ZIe}/api/v1/game/plinko/l1x_start`, n, e)
}
function eMe() {
    const {betAmount: n, setBetAmount: e, rowCount: t, setRowCount: r, riskLevel: s, setRiskLevel: i, plinkoEngine: o, betAmountOfExistingBalls: a, setBetAmountOfExistingBalls: l, setIsGameSettingsOpen: u, setIsLiveStatsOpen: d, isGameSettingsOpen: h, isLiveStatsOpen: p, targetBinIndex: g, setTargetBinIndex: w, backendPath: b, setBackendPath: v} = Vx()
      , {balance: S, refreshBalance: N} = Hs()
      , [_,I] = V.useState(gw.MANUAL)
      , [k,B] = V.useState(0)
      , [P,M] = V.useState(null)
      , R = V.useRef(null)
      , [L,q] = V.useState("L,L,R,L,R,R,L,R,L,R,R,L")
      , [H,j] = V.useState("0.3")
      , A = Uo()
      , E = n <= 0
      , C = n > S?.l1xsBalance
      , O = k < 0
      , z = o === null || E || C || O;
    Object.keys(a).length > 0;
    const G = Q => {
        const J = parseFloat(Q.target.value.trim());
        isNaN(J) ? e(0) : e(J)
    }
      , Y = () => {
        R.current !== null && (clearInterval(R.current),
        R.current = null)
    }
      , $ = Q => {
        const J = parseInt(Q.target.value.trim());
        isNaN(J) ? B(0) : B(J)
    }
      , D = async () => {
        try {
            const Q = uy()
              , J = await A.executeV3("action")
              , ne = await JIe({
                gameId: kx,
                clientSeed: Q,
                betAmount: n
            }, J);
            return ne?.status !== "success" ? {
                status: !1,
                message: ne?.data?.[0]?.message || ne?.message || "Something went wrong!"
            } : (N(),
            {
                ...ne?.data,
                status: !0
            })
        } catch (Q) {
            return console.log("API Error:", Q),
            {
                status: !1,
                message: "Error while starting session."
            }
        }
    }
      , U = Q => {
        if (Q && Q.state && Q.state.path) {
            const J = Q.state.path
              , ne = Q.payoutMultiplier;
            if (J.length !== t) {
                console.warn(`[Plinko] Path length (${J.length}) doesn't match row count (${t}). Using random drop.`);
                const ce = o?.dropBall();
                ce !== void 0 && l(me => ({
                    ...me,
                    [ce]: n
                }));
                return
            }
            const ae = J.filter(ce => (ce || "").toUpperCase() === "R").length
              , ue = Hx[t]?.[s]?.[ae];
            Math.abs(ue - ne) > .01 && console.warn(`[Plinko] WARNING: Path results in bin ${ae} (${ue}x) but backend expects ${ne}x`),
            v(J),
            setTimeout( () => {
                const ce = o?.dropBall();
                ce !== void 0 && l(me => ({
                    ...me,
                    [ce]: n
                }))
            }
            , 50)
        } else {
            const J = o?.dropBall();
            J !== void 0 && l(ne => ({
                ...ne,
                [J]: n
            }))
        }
    }
      , W = async () => {
        if (_ === gw.MANUAL) {
            const Q = await D();
            if (!Q?.status)
                return Ze.error(Q?.message);
            const J = Q?.directions
              , ne = {
                payoutMultiplier: parseFloat(Q?.outcomeValue) || .3,
                state: {
                    path: J,
                    risk: s,
                    rows: t
                }
            };
            U(ne)
        } else
            R.current === null ? (M(k === 0 ? null : k),
            R.current = setInterval(async () => {
                if (n > S?.l1xsBalance) {
                    Y();
                    return
                }
                const J = {
                    state: {
                        path: L.split(",").map(ne => ne.trim().toUpperCase())
                    }
                };
                if (J && J.state && J.state.path)
                    v(J.state.path),
                    setTimeout( () => {
                        const ne = o?.dropBall();
                        ne !== void 0 && l(ie => ({
                            ...ie,
                            [ne]: n
                        }))
                    }
                    , 50);
                else {
                    const ne = o?.dropBall();
                    ne !== void 0 && l(ie => ({
                        ...ie,
                        [ne]: n
                    }))
                }
                M(ne => {
                    if (ne === null)
                        return null;
                    const ie = ne - 1;
                    return ie === 0 && Y(),
                    ie
                }
                )
            }
            , WTe)) : R.current !== null && Y()
    }
    ;
    return V.useEffect( () => () => {
        Y()
    }
    , []),
    m.jsxs("div", {
        className: "flex flex-col gap-5 bg-slate-700 p-3 lg:max-w-80",
        children: [m.jsx("div", {
            className: "flex items-center justify-center gap-1 rounded-full p-1",
            children: m.jsx("img", {
                src: CG,
                className: "w-24 h-auto"
            })
        }), m.jsxs("div", {
            className: "relative",
            children: [m.jsxs("div", {
                className: "flex items-center justify-between",
                children: [m.jsx("label", {
                    htmlFor: "betAmount",
                    className: "text-sm font-medium text-slate-300",
                    children: "Bet Amount"
                }), m.jsxs("label", {
                    htmlFor: "betAmount",
                    className: "text-sm font-medium text-slate-300",
                    children: ["Balance: ", wn(S?.l1xsBalance, 2), " L1XP"]
                })]
            }), m.jsxs("div", {
                className: "flex",
                children: [m.jsx("div", {
                    className: "relative flex-1 number-arrow",
                    children: m.jsx("input", {
                        id: "betAmount",
                        value: n,
                        onBlur: G,
                        onChange: Q => e(parseFloat(Q.target.value)),
                        disabled: R.current !== null,
                        type: "number",
                        min: "0",
                        step: "0.01",
                        inputMode: "decimal",
                        className: GA("w-full rounded-l-md border-2 border-slate-600 bg-slate-900 py-2  px-3 text-sm text-white transition-colors hover:cursor-pointer focus:border-slate-500 focus:outline-none disabled:cursor-not-allowed disabled:opacity-50 hover:[&:not(:disabled)]:border-slate-500", (E || C) && "border-red-500 focus:border-red-400 hover:[&:not(:disabled)]:border-red-400")
                    })
                }), m.jsx("button", {
                    disabled: R.current !== null,
                    onClick: () => {
                        e(parseFloat((n / 2).toFixed(2)))
                    }
                    ,
                    className: "touch-manipulation cursor-pointer bg-slate-600 px-4 font-bold diagonal-fractions text-white transition-colors disabled:cursor-not-allowed disabled:opacity-50 hover:[&:not(:disabled)]:bg-slate-500 active:[&:not(:disabled)]:bg-slate-400",
                    children: "1/2"
                }), m.jsx("button", {
                    disabled: R.current !== null,
                    onClick: () => {
                        e(parseFloat((n * 2).toFixed(2)))
                    }
                    ,
                    className: "relative touch-manipulation cursor-pointer rounded-r-md bg-slate-600 px-4 text-sm font-bold text-white transition-colors after:absolute after:left-0 after:inline-block after:h-1/2 after:w-[2px] after:bg-slate-800 after:content-[''] disabled:cursor-not-allowed disabled:opacity-50 hover:[&:not(:disabled)]:bg-slate-500 active:[&:not(:disabled)]:bg-slate-400",
                    children: "2"
                })]
            }), E && m.jsx("p", {
                className: "absolute text-xs leading-5 text-red-400",
                children: "This must be greater than 0."
            }), C && !S?.isLoading && m.jsx("p", {
                className: "absolute text-xs leading-5 text-red-400",
                children: "Can't bet more than your balance!"
            })]
        }), _ === gw.AUTO && m.jsxs("div", {
            children: [m.jsxs("div", {
                className: "flex items-center gap-1",
                children: [m.jsx("label", {
                    htmlFor: "autoBetInput",
                    className: "text-sm font-medium text-slate-300",
                    children: "Number of Bets"
                }), m.jsx("button", {
                    className: "p-1",
                    children: m.jsx(cIe, {
                        className: "text-slate-300"
                    })
                })]
            }), m.jsxs("div", {
                className: "relative",
                children: [m.jsx("input", {
                    id: "autoBetInput",
                    value: R.current === null ? k : P ?? 0,
                    disabled: R.current !== null,
                    onBlur: $,
                    onChange: Q => B(parseInt(Q.target.value) || 0),
                    type: "number",
                    min: "0",
                    inputMode: "numeric",
                    className: GA("w-full rounded-md border-2 border-slate-600 bg-slate-900 py-2 pl-3 pr-8 text-sm text-white transition-colors hover:cursor-pointer focus:border-slate-500 focus:outline-none disabled:cursor-not-allowed disabled:opacity-50 hover:[&:not(:disabled)]:border-slate-500", O && "border-red-500 hover:border-red-400 focus:border-red-400")
                }), k === 0 && m.jsx(uIe, {
                    className: "absolute right-3 top-3 size-4 text-slate-400"
                })]
            }), O && m.jsx("p", {
                className: "text-xs leading-5 text-red-400",
                children: "This must be greater than or equal to 0."
            })]
        }), m.jsx("button", {
            onClick: W,
            disabled: z,
            className: GA("touch-manipulation cursor-pointer rounded-md bg-green-500 py-3 font-semibold text-slate-900 transition-colors hover:bg-green-400 active:bg-green-600 disabled:bg-neutral-600 disabled:text-neutral-400", R.current !== null && "bg-yellow-500 hover:bg-yellow-400 active:bg-yellow-600"),
            children: _ === gw.MANUAL ? "Drop Ball" : R.current === null ? "Start Autobet" : "Stop Autobet"
        })]
    })
}
function ib(n) {
    return n + .5 | 0
}
const Uu = (n, e, t) => Math.max(Math.min(n, t), e);
function Eg(n) {
    return Uu(ib(n * 2.55), 0, 255)
}
function Yu(n) {
    return Uu(ib(n * 255), 0, 255)
}
function ec(n) {
    return Uu(ib(n / 2.55) / 100, 0, 1)
}
function wj(n) {
    return Uu(ib(n * 100), 0, 100)
}
const xo = {
    0: 0,
    1: 1,
    2: 2,
    3: 3,
    4: 4,
    5: 5,
    6: 6,
    7: 7,
    8: 8,
    9: 9,
    A: 10,
    B: 11,
    C: 12,
    D: 13,
    E: 14,
    F: 15,
    a: 10,
    b: 11,
    c: 12,
    d: 13,
    e: 14,
    f: 15
}
  , i8 = [..."0123456789ABCDEF"]
  , tMe = n => i8[n & 15]
  , nMe = n => i8[(n & 240) >> 4] + i8[n & 15]
  , ww = n => (n & 240) >> 4 === (n & 15)
  , rMe = n => ww(n.r) && ww(n.g) && ww(n.b) && ww(n.a);
function sMe(n) {
    var e = n.length, t;
    return n[0] === "#" && (e === 4 || e === 5 ? t = {
        r: 255 & xo[n[1]] * 17,
        g: 255 & xo[n[2]] * 17,
        b: 255 & xo[n[3]] * 17,
        a: e === 5 ? xo[n[4]] * 17 : 255
    } : (e === 7 || e === 9) && (t = {
        r: xo[n[1]] << 4 | xo[n[2]],
        g: xo[n[3]] << 4 | xo[n[4]],
        b: xo[n[5]] << 4 | xo[n[6]],
        a: e === 9 ? xo[n[7]] << 4 | xo[n[8]] : 255
    })),
    t
}
const iMe = (n, e) => n < 255 ? e(n) : "";
function oMe(n) {
    var e = rMe(n) ? tMe : nMe;
    return n ? "#" + e(n.r) + e(n.g) + e(n.b) + iMe(n.a, e) : void 0
}
const aMe = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function HG(n, e, t) {
    const r = e * Math.min(t, 1 - t)
      , s = (i, o=(i + n / 30) % 12) => t - r * Math.max(Math.min(o - 3, 9 - o, 1), -1);
    return [s(0), s(8), s(4)]
}
function lMe(n, e, t) {
    const r = (s, i=(s + n / 60) % 6) => t - t * e * Math.max(Math.min(i, 4 - i, 1), 0);
    return [r(5), r(3), r(1)]
}
function cMe(n, e, t) {
    const r = HG(n, 1, .5);
    let s;
    for (e + t > 1 && (s = 1 / (e + t),
    e *= s,
    t *= s),
    s = 0; s < 3; s++)
        r[s] *= 1 - e - t,
        r[s] += e;
    return r
}
function uMe(n, e, t, r, s) {
    return n === s ? (e - t) / r + (e < t ? 6 : 0) : e === s ? (t - n) / r + 2 : (n - e) / r + 4
}
function Bk(n) {
    const t = n.r / 255
      , r = n.g / 255
      , s = n.b / 255
      , i = Math.max(t, r, s)
      , o = Math.min(t, r, s)
      , a = (i + o) / 2;
    let l, u, d;
    return i !== o && (d = i - o,
    u = a > .5 ? d / (2 - i - o) : d / (i + o),
    l = uMe(t, r, s, d, i),
    l = l * 60 + .5),
    [l | 0, u || 0, a]
}
function Rk(n, e, t, r) {
    return (Array.isArray(e) ? n(e[0], e[1], e[2]) : n(e, t, r)).map(Yu)
}
function Ok(n, e, t) {
    return Rk(HG, n, e, t)
}
function dMe(n, e, t) {
    return Rk(cMe, n, e, t)
}
function fMe(n, e, t) {
    return Rk(lMe, n, e, t)
}
function VG(n) {
    return (n % 360 + 360) % 360
}
function hMe(n) {
    const e = aMe.exec(n);
    let t = 255, r;
    if (!e)
        return;
    e[5] !== r && (t = e[6] ? Eg(+e[5]) : Yu(+e[5]));
    const s = VG(+e[2])
      , i = +e[3] / 100
      , o = +e[4] / 100;
    return e[1] === "hwb" ? r = dMe(s, i, o) : e[1] === "hsv" ? r = fMe(s, i, o) : r = Ok(s, i, o),
    {
        r: r[0],
        g: r[1],
        b: r[2],
        a: t
    }
}
function pMe(n, e) {
    var t = Bk(n);
    t[0] = VG(t[0] + e),
    t = Ok(t),
    n.r = t[0],
    n.g = t[1],
    n.b = t[2]
}
function mMe(n) {
    if (!n)
        return;
    const e = Bk(n)
      , t = e[0]
      , r = wj(e[1])
      , s = wj(e[2]);
    return n.a < 255 ? `hsla(${t}, ${r}%, ${s}%, ${ec(n.a)})` : `hsl(${t}, ${r}%, ${s}%)`
}
const vj = {
    x: "dark",
    Z: "light",
    Y: "re",
    X: "blu",
    W: "gr",
    V: "medium",
    U: "slate",
    A: "ee",
    T: "ol",
    S: "or",
    B: "ra",
    C: "lateg",
    D: "ights",
    R: "in",
    Q: "turquois",
    E: "hi",
    P: "ro",
    O: "al",
    N: "le",
    M: "de",
    L: "yello",
    F: "en",
    K: "ch",
    G: "arks",
    H: "ea",
    I: "ightg",
    J: "wh"
}
  , xj = {
    OiceXe: "f0f8ff",
    antiquewEte: "faebd7",
    aqua: "ffff",
    aquamarRe: "7fffd4",
    azuY: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "0",
    blanKedOmond: "ffebcd",
    Xe: "ff",
    XeviTet: "8a2be2",
    bPwn: "a52a2a",
    burlywood: "deb887",
    caMtXe: "5f9ea0",
    KartYuse: "7fff00",
    KocTate: "d2691e",
    cSO: "ff7f50",
    cSnflowerXe: "6495ed",
    cSnsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "ffff",
    xXe: "8b",
    xcyan: "8b8b",
    xgTMnPd: "b8860b",
    xWay: "a9a9a9",
    xgYF: "6400",
    xgYy: "a9a9a9",
    xkhaki: "bdb76b",
    xmagFta: "8b008b",
    xTivegYF: "556b2f",
    xSange: "ff8c00",
    xScEd: "9932cc",
    xYd: "8b0000",
    xsOmon: "e9967a",
    xsHgYF: "8fbc8f",
    xUXe: "483d8b",
    xUWay: "2f4f4f",
    xUgYy: "2f4f4f",
    xQe: "ced1",
    xviTet: "9400d3",
    dAppRk: "ff1493",
    dApskyXe: "bfff",
    dimWay: "696969",
    dimgYy: "696969",
    dodgerXe: "1e90ff",
    fiYbrick: "b22222",
    flSOwEte: "fffaf0",
    foYstWAn: "228b22",
    fuKsia: "ff00ff",
    gaRsbSo: "dcdcdc",
    ghostwEte: "f8f8ff",
    gTd: "ffd700",
    gTMnPd: "daa520",
    Way: "808080",
    gYF: "8000",
    gYFLw: "adff2f",
    gYy: "808080",
    honeyMw: "f0fff0",
    hotpRk: "ff69b4",
    RdianYd: "cd5c5c",
    Rdigo: "4b0082",
    ivSy: "fffff0",
    khaki: "f0e68c",
    lavFMr: "e6e6fa",
    lavFMrXsh: "fff0f5",
    lawngYF: "7cfc00",
    NmoncEffon: "fffacd",
    ZXe: "add8e6",
    ZcSO: "f08080",
    Zcyan: "e0ffff",
    ZgTMnPdLw: "fafad2",
    ZWay: "d3d3d3",
    ZgYF: "90ee90",
    ZgYy: "d3d3d3",
    ZpRk: "ffb6c1",
    ZsOmon: "ffa07a",
    ZsHgYF: "20b2aa",
    ZskyXe: "87cefa",
    ZUWay: "778899",
    ZUgYy: "778899",
    ZstAlXe: "b0c4de",
    ZLw: "ffffe0",
    lime: "ff00",
    limegYF: "32cd32",
    lRF: "faf0e6",
    magFta: "ff00ff",
    maPon: "800000",
    VaquamarRe: "66cdaa",
    VXe: "cd",
    VScEd: "ba55d3",
    VpurpN: "9370db",
    VsHgYF: "3cb371",
    VUXe: "7b68ee",
    VsprRggYF: "fa9a",
    VQe: "48d1cc",
    VviTetYd: "c71585",
    midnightXe: "191970",
    mRtcYam: "f5fffa",
    mistyPse: "ffe4e1",
    moccasR: "ffe4b5",
    navajowEte: "ffdead",
    navy: "80",
    Tdlace: "fdf5e6",
    Tive: "808000",
    TivedBb: "6b8e23",
    Sange: "ffa500",
    SangeYd: "ff4500",
    ScEd: "da70d6",
    pOegTMnPd: "eee8aa",
    pOegYF: "98fb98",
    pOeQe: "afeeee",
    pOeviTetYd: "db7093",
    papayawEp: "ffefd5",
    pHKpuff: "ffdab9",
    peru: "cd853f",
    pRk: "ffc0cb",
    plum: "dda0dd",
    powMrXe: "b0e0e6",
    purpN: "800080",
    YbeccapurpN: "663399",
    Yd: "ff0000",
    Psybrown: "bc8f8f",
    PyOXe: "4169e1",
    saddNbPwn: "8b4513",
    sOmon: "fa8072",
    sandybPwn: "f4a460",
    sHgYF: "2e8b57",
    sHshell: "fff5ee",
    siFna: "a0522d",
    silver: "c0c0c0",
    skyXe: "87ceeb",
    UXe: "6a5acd",
    UWay: "708090",
    UgYy: "708090",
    snow: "fffafa",
    sprRggYF: "ff7f",
    stAlXe: "4682b4",
    tan: "d2b48c",
    teO: "8080",
    tEstN: "d8bfd8",
    tomato: "ff6347",
    Qe: "40e0d0",
    viTet: "ee82ee",
    JHt: "f5deb3",
    wEte: "ffffff",
    wEtesmoke: "f5f5f5",
    Lw: "ffff00",
    LwgYF: "9acd32"
};
function gMe() {
    const n = {}
      , e = Object.keys(xj)
      , t = Object.keys(vj);
    let r, s, i, o, a;
    for (r = 0; r < e.length; r++) {
        for (o = a = e[r],
        s = 0; s < t.length; s++)
            i = t[s],
            a = a.replace(i, vj[i]);
        i = parseInt(xj[o], 16),
        n[a] = [i >> 16 & 255, i >> 8 & 255, i & 255]
    }
    return n
}
let vw;
function yMe(n) {
    vw || (vw = gMe(),
    vw.transparent = [0, 0, 0, 0]);
    const e = vw[n.toLowerCase()];
    return e && {
        r: e[0],
        g: e[1],
        b: e[2],
        a: e.length === 4 ? e[3] : 255
    }
}
const bMe = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function wMe(n) {
    const e = bMe.exec(n);
    let t = 255, r, s, i;
    if (e) {
        if (e[7] !== r) {
            const o = +e[7];
            t = e[8] ? Eg(o) : Uu(o * 255, 0, 255)
        }
        return r = +e[1],
        s = +e[3],
        i = +e[5],
        r = 255 & (e[2] ? Eg(r) : Uu(r, 0, 255)),
        s = 255 & (e[4] ? Eg(s) : Uu(s, 0, 255)),
        i = 255 & (e[6] ? Eg(i) : Uu(i, 0, 255)),
        {
            r,
            g: s,
            b: i,
            a: t
        }
    }
}
function vMe(n) {
    return n && (n.a < 255 ? `rgba(${n.r}, ${n.g}, ${n.b}, ${ec(n.a)})` : `rgb(${n.r}, ${n.g}, ${n.b})`)
}
const WA = n => n <= .0031308 ? n * 12.92 : Math.pow(n, 1 / 2.4) * 1.055 - .055
  , op = n => n <= .04045 ? n / 12.92 : Math.pow((n + .055) / 1.055, 2.4);
function xMe(n, e, t) {
    const r = op(ec(n.r))
      , s = op(ec(n.g))
      , i = op(ec(n.b));
    return {
        r: Yu(WA(r + t * (op(ec(e.r)) - r))),
        g: Yu(WA(s + t * (op(ec(e.g)) - s))),
        b: Yu(WA(i + t * (op(ec(e.b)) - i))),
        a: n.a + t * (e.a - n.a)
    }
}
function xw(n, e, t) {
    if (n) {
        let r = Bk(n);
        r[e] = Math.max(0, Math.min(r[e] + r[e] * t, e === 0 ? 360 : 1)),
        r = Ok(r),
        n.r = r[0],
        n.g = r[1],
        n.b = r[2]
    }
}
function qG(n, e) {
    return n && Object.assign(e || {}, n)
}
function Ej(n) {
    var e = {
        r: 0,
        g: 0,
        b: 0,
        a: 255
    };
    return Array.isArray(n) ? n.length >= 3 && (e = {
        r: n[0],
        g: n[1],
        b: n[2],
        a: 255
    },
    n.length > 3 && (e.a = Yu(n[3]))) : (e = qG(n, {
        r: 0,
        g: 0,
        b: 0,
        a: 1
    }),
    e.a = Yu(e.a)),
    e
}
function EMe(n) {
    return n.charAt(0) === "r" ? wMe(n) : hMe(n)
}
class dy {
    constructor(e) {
        if (e instanceof dy)
            return e;
        const t = typeof e;
        let r;
        t === "object" ? r = Ej(e) : t === "string" && (r = sMe(e) || yMe(e) || EMe(e)),
        this._rgb = r,
        this._valid = !!r
    }
    get valid() {
        return this._valid
    }
    get rgb() {
        var e = qG(this._rgb);
        return e && (e.a = ec(e.a)),
        e
    }
    set rgb(e) {
        this._rgb = Ej(e)
    }
    rgbString() {
        return this._valid ? vMe(this._rgb) : void 0
    }
    hexString() {
        return this._valid ? oMe(this._rgb) : void 0
    }
    hslString() {
        return this._valid ? mMe(this._rgb) : void 0
    }
    mix(e, t) {
        if (e) {
            const r = this.rgb
              , s = e.rgb;
            let i;
            const o = t === i ? .5 : t
              , a = 2 * o - 1
              , l = r.a - s.a
              , u = ((a * l === -1 ? a : (a + l) / (1 + a * l)) + 1) / 2;
            i = 1 - u,
            r.r = 255 & u * r.r + i * s.r + .5,
            r.g = 255 & u * r.g + i * s.g + .5,
            r.b = 255 & u * r.b + i * s.b + .5,
            r.a = o * r.a + (1 - o) * s.a,
            this.rgb = r
        }
        return this
    }
    interpolate(e, t) {
        return e && (this._rgb = xMe(this._rgb, e._rgb, t)),
        this
    }
    clone() {
        return new dy(this.rgb)
    }
    alpha(e) {
        return this._rgb.a = Yu(e),
        this
    }
    clearer(e) {
        const t = this._rgb;
        return t.a *= 1 - e,
        this
    }
    greyscale() {
        const e = this._rgb
          , t = ib(e.r * .3 + e.g * .59 + e.b * .11);
        return e.r = e.g = e.b = t,
        this
    }
    opaquer(e) {
        const t = this._rgb;
        return t.a *= 1 + e,
        this
    }
    negate() {
        const e = this._rgb;
        return e.r = 255 - e.r,
        e.g = 255 - e.g,
        e.b = 255 - e.b,
        this
    }
    lighten(e) {
        return xw(this._rgb, 2, e),
        this
    }
    darken(e) {
        return xw(this._rgb, 2, -e),
        this
    }
    saturate(e) {
        return xw(this._rgb, 1, e),
        this
    }
    desaturate(e) {
        return xw(this._rgb, 1, -e),
        this
    }
    rotate(e) {
        return pMe(this._rgb, e),
        this
    }
}
function zl() {}
const SMe = ( () => {
    let n = 0;
    return () => n++
}
)();
function sr(n) {
    return n == null
}
function ns(n) {
    if (Array.isArray && Array.isArray(n))
        return !0;
    const e = Object.prototype.toString.call(n);
    return e.slice(0, 7) === "[object" && e.slice(-6) === "Array]"
}
function an(n) {
    return n !== null && Object.prototype.toString.call(n) === "[object Object]"
}
function $s(n) {
    return (typeof n == "number" || n instanceof Number) && isFinite(+n)
}
function Ma(n, e) {
    return $s(n) ? n : e
}
function on(n, e) {
    return typeof n > "u" ? e : n
}
const AMe = (n, e) => typeof n == "string" && n.endsWith("%") ? parseFloat(n) / 100 * e : +n;
function Wn(n, e, t) {
    if (n && typeof n.call == "function")
        return n.apply(t, e)
}
function _n(n, e, t, r) {
    let s, i, o;
    if (ns(n))
        for (i = n.length,
        s = 0; s < i; s++)
            e.call(t, n[s], s);
    else if (an(n))
        for (o = Object.keys(n),
        i = o.length,
        s = 0; s < i; s++)
            e.call(t, n[o[s]], o[s])
}
function mv(n, e) {
    let t, r, s, i;
    if (!n || !e || n.length !== e.length)
        return !1;
    for (t = 0,
    r = n.length; t < r; ++t)
        if (s = n[t],
        i = e[t],
        s.datasetIndex !== i.datasetIndex || s.index !== i.index)
            return !1;
    return !0
}
function gv(n) {
    if (ns(n))
        return n.map(gv);
    if (an(n)) {
        const e = Object.create(null)
          , t = Object.keys(n)
          , r = t.length;
        let s = 0;
        for (; s < r; ++s)
            e[t[s]] = gv(n[t[s]]);
        return e
    }
    return n
}
function GG(n) {
    return ["__proto__", "prototype", "constructor"].indexOf(n) === -1
}
function CMe(n, e, t, r) {
    if (!GG(n))
        return;
    const s = e[n]
      , i = t[n];
    an(s) && an(i) ? fy(s, i, r) : e[n] = gv(i)
}
function fy(n, e, t) {
    const r = ns(e) ? e : [e]
      , s = r.length;
    if (!an(n))
        return n;
    t = t || {};
    const i = t.merger || CMe;
    let o;
    for (let a = 0; a < s; ++a) {
        if (o = r[a],
        !an(o))
            continue;
        const l = Object.keys(o);
        for (let u = 0, d = l.length; u < d; ++u)
            i(l[u], n, o, t)
    }
    return n
}
function jg(n, e) {
    return fy(n, e, {
        merger: _Me
    })
}
function _Me(n, e, t) {
    if (!GG(n))
        return;
    const r = e[n]
      , s = t[n];
    an(r) && an(s) ? jg(r, s) : Object.prototype.hasOwnProperty.call(e, n) || (e[n] = gv(s))
}
const Sj = {
    "": n => n,
    x: n => n.x,
    y: n => n.y
};
function kMe(n) {
    const e = n.split(".")
      , t = [];
    let r = "";
    for (const s of e)
        r += s,
        r.endsWith("\\") ? r = r.slice(0, -1) + "." : (t.push(r),
        r = "");
    return t
}
function NMe(n) {
    const e = kMe(n);
    return t => {
        for (const r of e) {
            if (r === "")
                break;
            t = t && t[r]
        }
        return t
    }
}
function yv(n, e) {
    return (Sj[e] || (Sj[e] = NMe(e)))(n)
}
function Pk(n) {
    return n.charAt(0).toUpperCase() + n.slice(1)
}
const bv = n => typeof n < "u"
  , id = n => typeof n == "function"
  , Aj = (n, e) => {
    if (n.size !== e.size)
        return !1;
    for (const t of n)
        if (!e.has(t))
            return !1;
    return !0
}
;
function DMe(n) {
    return n.type === "mouseup" || n.type === "click" || n.type === "contextmenu"
}
const zs = Math.PI
  , ua = 2 * zs
  , TMe = ua + zs
  , wv = Number.POSITIVE_INFINITY
  , IMe = zs / 180
  , aa = zs / 2
  , Ld = zs / 4
  , Cj = zs * 2 / 3
  , WG = Math.log10
  , m0 = Math.sign;
function Lg(n, e, t) {
    return Math.abs(n - e) < t
}
function _j(n) {
    const e = Math.round(n);
    n = Lg(n, e, n / 1e3) ? e : n;
    const t = Math.pow(10, Math.floor(WG(n)))
      , r = n / t;
    return (r <= 1 ? 1 : r <= 2 ? 2 : r <= 5 ? 5 : 10) * t
}
function MMe(n) {
    const e = []
      , t = Math.sqrt(n);
    let r;
    for (r = 1; r < t; r++)
        n % r === 0 && (e.push(r),
        e.push(n / r));
    return t === (t | 0) && e.push(t),
    e.sort( (s, i) => s - i).pop(),
    e
}
function BMe(n) {
    return typeof n == "symbol" || typeof n == "object" && n !== null && !(Symbol.toPrimitive in n || "toString"in n || "valueOf"in n)
}
function vv(n) {
    return !BMe(n) && !isNaN(parseFloat(n)) && isFinite(n)
}
function RMe(n, e) {
    const t = Math.round(n);
    return t - e <= n && t + e >= n
}
function OMe(n, e, t) {
    let r, s, i;
    for (r = 0,
    s = n.length; r < s; r++)
        i = n[r][t],
        isNaN(i) || (e.min = Math.min(e.min, i),
        e.max = Math.max(e.max, i))
}
function wf(n) {
    return n * (zs / 180)
}
function PMe(n) {
    return n * (180 / zs)
}
function kj(n) {
    if (!$s(n))
        return;
    let e = 1
      , t = 0;
    for (; Math.round(n * e) / e !== n; )
        e *= 10,
        t++;
    return t
}
function jMe(n, e) {
    const t = e.x - n.x
      , r = e.y - n.y
      , s = Math.sqrt(t * t + r * r);
    let i = Math.atan2(r, t);
    return i < -.5 * zs && (i += ua),
    {
        angle: i,
        distance: s
    }
}
function o8(n, e) {
    return Math.sqrt(Math.pow(e.x - n.x, 2) + Math.pow(e.y - n.y, 2))
}
function LMe(n, e) {
    return (n - e + TMe) % ua - zs
}
function Fa(n) {
    return (n % ua + ua) % ua
}
function YG(n, e, t, r) {
    const s = Fa(n)
      , i = Fa(e)
      , o = Fa(t)
      , a = Fa(i - s)
      , l = Fa(o - s)
      , u = Fa(s - i)
      , d = Fa(s - o);
    return s === i || s === o || r && i === o || a > l && u < d
}
function Xa(n, e, t) {
    return Math.max(e, Math.min(t, n))
}
function FMe(n) {
    return Xa(n, -32768, 32767)
}
function Ep(n, e, t, r=1e-6) {
    return n >= Math.min(e, t) - r && n <= Math.max(e, t) + r
}
function jk(n, e, t) {
    t = t || (o => n[o] < e);
    let r = n.length - 1, s = 0, i;
    for (; r - s > 1; )
        i = s + r >> 1,
        t(i) ? s = i : r = i;
    return {
        lo: s,
        hi: r
    }
}
const a8 = (n, e, t, r) => jk(n, t, r ? s => {
    const i = n[s][e];
    return i < t || i === t && n[s + 1][e] === t
}
: s => n[s][e] < t)
  , UMe = (n, e, t) => jk(n, t, r => n[r][e] >= t);
function zMe(n, e, t) {
    let r = 0
      , s = n.length;
    for (; r < s && n[r] < e; )
        r++;
    for (; s > r && n[s - 1] > t; )
        s--;
    return r > 0 || s < n.length ? n.slice(r, s) : n
}
const KG = ["push", "pop", "shift", "splice", "unshift"];
function $Me(n, e) {
    if (n._chartjs) {
        n._chartjs.listeners.push(e);
        return
    }
    Object.defineProperty(n, "_chartjs", {
        configurable: !0,
        enumerable: !1,
        value: {
            listeners: [e]
        }
    }),
    KG.forEach(t => {
        const r = "_onData" + Pk(t)
          , s = n[t];
        Object.defineProperty(n, t, {
            configurable: !0,
            enumerable: !1,
            value(...i) {
                const o = s.apply(this, i);
                return n._chartjs.listeners.forEach(a => {
                    typeof a[r] == "function" && a[r](...i)
                }
                ),
                o
            }
        })
    }
    )
}
function Nj(n, e) {
    const t = n._chartjs;
    if (!t)
        return;
    const r = t.listeners
      , s = r.indexOf(e);
    s !== -1 && r.splice(s, 1),
    !(r.length > 0) && (KG.forEach(i => {
        delete n[i]
    }
    ),
    delete n._chartjs)
}
function HMe(n) {
    const e = new Set(n);
    return e.size === n.length ? n : Array.from(e)
}
const XG = (function() {
    return typeof window > "u" ? function(n) {
        return n()
    }
    : window.requestAnimationFrame
}
)();
function QG(n, e) {
    let t = []
      , r = !1;
    return function(...s) {
        t = s,
        r || (r = !0,
        XG.call(window, () => {
            r = !1,
            n.apply(e, t)
        }
        ))
    }
}
function VMe(n, e) {
    let t;
    return function(...r) {
        return e ? (clearTimeout(t),
        t = setTimeout(n, e, r)) : n.apply(this, r),
        e
    }
}
const ZG = n => n === "start" ? "left" : n === "end" ? "right" : "center"
  , Hi = (n, e, t) => n === "start" ? e : n === "end" ? t : (e + t) / 2
  , qMe = (n, e, t, r) => n === (r ? "left" : "right") ? t : n === "center" ? (e + t) / 2 : e
  , Ew = n => n === 0 || n === 1
  , Dj = (n, e, t) => -(Math.pow(2, 10 * (n -= 1)) * Math.sin((n - e) * ua / t))
  , Tj = (n, e, t) => Math.pow(2, -10 * n) * Math.sin((n - e) * ua / t) + 1
  , Fg = {
    linear: n => n,
    easeInQuad: n => n * n,
    easeOutQuad: n => -n * (n - 2),
    easeInOutQuad: n => (n /= .5) < 1 ? .5 * n * n : -.5 * (--n * (n - 2) - 1),
    easeInCubic: n => n * n * n,
    easeOutCubic: n => (n -= 1) * n * n + 1,
    easeInOutCubic: n => (n /= .5) < 1 ? .5 * n * n * n : .5 * ((n -= 2) * n * n + 2),
    easeInQuart: n => n * n * n * n,
    easeOutQuart: n => -((n -= 1) * n * n * n - 1),
    easeInOutQuart: n => (n /= .5) < 1 ? .5 * n * n * n * n : -.5 * ((n -= 2) * n * n * n - 2),
    easeInQuint: n => n * n * n * n * n,
    easeOutQuint: n => (n -= 1) * n * n * n * n + 1,
    easeInOutQuint: n => (n /= .5) < 1 ? .5 * n * n * n * n * n : .5 * ((n -= 2) * n * n * n * n + 2),
    easeInSine: n => -Math.cos(n * aa) + 1,
    easeOutSine: n => Math.sin(n * aa),
    easeInOutSine: n => -.5 * (Math.cos(zs * n) - 1),
    easeInExpo: n => n === 0 ? 0 : Math.pow(2, 10 * (n - 1)),
    easeOutExpo: n => n === 1 ? 1 : -Math.pow(2, -10 * n) + 1,
    easeInOutExpo: n => Ew(n) ? n : n < .5 ? .5 * Math.pow(2, 10 * (n * 2 - 1)) : .5 * (-Math.pow(2, -10 * (n * 2 - 1)) + 2),
    easeInCirc: n => n >= 1 ? n : -(Math.sqrt(1 - n * n) - 1),
    easeOutCirc: n => Math.sqrt(1 - (n -= 1) * n),
    easeInOutCirc: n => (n /= .5) < 1 ? -.5 * (Math.sqrt(1 - n * n) - 1) : .5 * (Math.sqrt(1 - (n -= 2) * n) + 1),
    easeInElastic: n => Ew(n) ? n : Dj(n, .075, .3),
    easeOutElastic: n => Ew(n) ? n : Tj(n, .075, .3),
    easeInOutElastic(n) {
        return Ew(n) ? n : n < .5 ? .5 * Dj(n * 2, .1125, .45) : .5 + .5 * Tj(n * 2 - 1, .1125, .45)
    },
    easeInBack(n) {
        return n * n * ((1.70158 + 1) * n - 1.70158)
    },
    easeOutBack(n) {
        return (n -= 1) * n * ((1.70158 + 1) * n + 1.70158) + 1
    },
    easeInOutBack(n) {
        let e = 1.70158;
        return (n /= .5) < 1 ? .5 * (n * n * (((e *= 1.525) + 1) * n - e)) : .5 * ((n -= 2) * n * (((e *= 1.525) + 1) * n + e) + 2)
    },
    easeInBounce: n => 1 - Fg.easeOutBounce(1 - n),
    easeOutBounce(n) {
        return n < 1 / 2.75 ? 7.5625 * n * n : n < 2 / 2.75 ? 7.5625 * (n -= 1.5 / 2.75) * n + .75 : n < 2.5 / 2.75 ? 7.5625 * (n -= 2.25 / 2.75) * n + .9375 : 7.5625 * (n -= 2.625 / 2.75) * n + .984375
    },
    easeInOutBounce: n => n < .5 ? Fg.easeInBounce(n * 2) * .5 : Fg.easeOutBounce(n * 2 - 1) * .5 + .5
};
function Lk(n) {
    if (n && typeof n == "object") {
        const e = n.toString();
        return e === "[object CanvasPattern]" || e === "[object CanvasGradient]"
    }
    return !1
}
function Ij(n) {
    return Lk(n) ? n : new dy(n)
}
function YA(n) {
    return Lk(n) ? n : new dy(n).saturate(.5).darken(.1).hexString()
}
const GMe = ["x", "y", "borderWidth", "radius", "tension"]
  , WMe = ["color", "borderColor", "backgroundColor"];
function YMe(n) {
    n.set("animation", {
        delay: void 0,
        duration: 1e3,
        easing: "easeOutQuart",
        fn: void 0,
        from: void 0,
        loop: void 0,
        to: void 0,
        type: void 0
    }),
    n.describe("animation", {
        _fallback: !1,
        _indexable: !1,
        _scriptable: e => e !== "onProgress" && e !== "onComplete" && e !== "fn"
    }),
    n.set("animations", {
        colors: {
            type: "color",
            properties: WMe
        },
        numbers: {
            type: "number",
            properties: GMe
        }
    }),
    n.describe("animations", {
        _fallback: "animation"
    }),
    n.set("transitions", {
        active: {
            animation: {
                duration: 400
            }
        },
        resize: {
            animation: {
                duration: 0
            }
        },
        show: {
            animations: {
                colors: {
                    from: "transparent"
                },
                visible: {
                    type: "boolean",
                    duration: 0
                }
            }
        },
        hide: {
            animations: {
                colors: {
                    to: "transparent"
                },
                visible: {
                    type: "boolean",
                    easing: "linear",
                    fn: e => e | 0
                }
            }
        }
    })
}
function KMe(n) {
    n.set("layout", {
        autoPadding: !0,
        padding: {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
        }
    })
}
const Mj = new Map;
function XMe(n, e) {
    e = e || {};
    const t = n + JSON.stringify(e);
    let r = Mj.get(t);
    return r || (r = new Intl.NumberFormat(n,e),
    Mj.set(t, r)),
    r
}
function JG(n, e, t) {
    return XMe(e, t).format(n)
}
const QMe = {
    values(n) {
        return ns(n) ? n : "" + n
    },
    numeric(n, e, t) {
        if (n === 0)
            return "0";
        const r = this.chart.options.locale;
        let s, i = n;
        if (t.length > 1) {
            const u = Math.max(Math.abs(t[0].value), Math.abs(t[t.length - 1].value));
            (u < 1e-4 || u > 1e15) && (s = "scientific"),
            i = ZMe(n, t)
        }
        const o = WG(Math.abs(i))
          , a = isNaN(o) ? 1 : Math.max(Math.min(-1 * Math.floor(o), 20), 0)
          , l = {
            notation: s,
            minimumFractionDigits: a,
            maximumFractionDigits: a
        };
        return Object.assign(l, this.options.ticks.format),
        JG(n, r, l)
    }
};
function ZMe(n, e) {
    let t = e.length > 3 ? e[2].value - e[1].value : e[1].value - e[0].value;
    return Math.abs(t) >= 1 && n !== Math.floor(n) && (t = n - Math.floor(n)),
    t
}
var eW = {
    formatters: QMe
};
function JMe(n) {
    n.set("scale", {
        display: !0,
        offset: !1,
        reverse: !1,
        beginAtZero: !1,
        bounds: "ticks",
        clip: !0,
        grace: 0,
        grid: {
            display: !0,
            lineWidth: 1,
            drawOnChartArea: !0,
            drawTicks: !0,
            tickLength: 8,
            tickWidth: (e, t) => t.lineWidth,
            tickColor: (e, t) => t.color,
            offset: !1
        },
        border: {
            display: !0,
            dash: [],
            dashOffset: 0,
            width: 1
        },
        title: {
            display: !1,
            text: "",
            padding: {
                top: 4,
                bottom: 4
            }
        },
        ticks: {
            minRotation: 0,
            maxRotation: 50,
            mirror: !1,
            textStrokeWidth: 0,
            textStrokeColor: "",
            padding: 3,
            display: !0,
            autoSkip: !0,
            autoSkipPadding: 3,
            labelOffset: 0,
            callback: eW.formatters.values,
            minor: {},
            major: {},
            align: "center",
            crossAlign: "near",
            showLabelBackdrop: !1,
            backdropColor: "rgba(255, 255, 255, 0.75)",
            backdropPadding: 2
        }
    }),
    n.route("scale.ticks", "color", "", "color"),
    n.route("scale.grid", "color", "", "borderColor"),
    n.route("scale.border", "color", "", "borderColor"),
    n.route("scale.title", "color", "", "color"),
    n.describe("scale", {
        _fallback: !1,
        _scriptable: e => !e.startsWith("before") && !e.startsWith("after") && e !== "callback" && e !== "parser",
        _indexable: e => e !== "borderDash" && e !== "tickBorderDash" && e !== "dash"
    }),
    n.describe("scales", {
        _fallback: "scale"
    }),
    n.describe("scale.ticks", {
        _scriptable: e => e !== "backdropPadding" && e !== "callback",
        _indexable: e => e !== "backdropPadding"
    })
}
const zf = Object.create(null)
  , l8 = Object.create(null);
function Ug(n, e) {
    if (!e)
        return n;
    const t = e.split(".");
    for (let r = 0, s = t.length; r < s; ++r) {
        const i = t[r];
        n = n[i] || (n[i] = Object.create(null))
    }
    return n
}
function KA(n, e, t) {
    return typeof e == "string" ? fy(Ug(n, e), t) : fy(Ug(n, ""), e)
}
class eBe {
    constructor(e, t) {
        this.animation = void 0,
        this.backgroundColor = "rgba(0,0,0,0.1)",
        this.borderColor = "rgba(0,0,0,0.1)",
        this.color = "#666",
        this.datasets = {},
        this.devicePixelRatio = r => r.chart.platform.getDevicePixelRatio(),
        this.elements = {},
        this.events = ["mousemove", "mouseout", "click", "touchstart", "touchmove"],
        this.font = {
            family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
            size: 12,
            style: "normal",
            lineHeight: 1.2,
            weight: null
        },
        this.hover = {},
        this.hoverBackgroundColor = (r, s) => YA(s.backgroundColor),
        this.hoverBorderColor = (r, s) => YA(s.borderColor),
        this.hoverColor = (r, s) => YA(s.color),
        this.indexAxis = "x",
        this.interaction = {
            mode: "nearest",
            intersect: !0,
            includeInvisible: !1
        },
        this.maintainAspectRatio = !0,
        this.onHover = null,
        this.onClick = null,
        this.parsing = !0,
        this.plugins = {},
        this.responsive = !0,
        this.scale = void 0,
        this.scales = {},
        this.showLine = !0,
        this.drawActiveElementsOnTop = !0,
        this.describe(e),
        this.apply(t)
    }
    set(e, t) {
        return KA(this, e, t)
    }
    get(e) {
        return Ug(this, e)
    }
    describe(e, t) {
        return KA(l8, e, t)
    }
    override(e, t) {
        return KA(zf, e, t)
    }
    route(e, t, r, s) {
        const i = Ug(this, e)
          , o = Ug(this, r)
          , a = "_" + t;
        Object.defineProperties(i, {
            [a]: {
                value: i[t],
                writable: !0
            },
            [t]: {
                enumerable: !0,
                get() {
                    const l = this[a]
                      , u = o[s];
                    return an(l) ? Object.assign({}, u, l) : on(l, u)
                },
                set(l) {
                    this[a] = l
                }
            }
        })
    }
    apply(e) {
        e.forEach(t => t(this))
    }
}
var _r = new eBe({
    _scriptable: n => !n.startsWith("on"),
    _indexable: n => n !== "events",
    hover: {
        _fallback: "interaction"
    },
    interaction: {
        _scriptable: !1,
        _indexable: !1
    }
},[YMe, KMe, JMe]);
function tBe(n) {
    return !n || sr(n.size) || sr(n.family) ? null : (n.style ? n.style + " " : "") + (n.weight ? n.weight + " " : "") + n.size + "px " + n.family
}
function Bj(n, e, t, r, s) {
    let i = e[s];
    return i || (i = e[s] = n.measureText(s).width,
    t.push(s)),
    i > r && (r = i),
    r
}
function Fd(n, e, t) {
    const r = n.currentDevicePixelRatio
      , s = t !== 0 ? Math.max(t / 2, .5) : 0;
    return Math.round((e - s) * r) / r + s
}
function Rj(n, e) {
    !e && !n || (e = e || n.getContext("2d"),
    e.save(),
    e.resetTransform(),
    e.clearRect(0, 0, n.width, n.height),
    e.restore())
}
function c8(n, e, t, r) {
    tW(n, e, t, r, null)
}
function tW(n, e, t, r, s) {
    let i, o, a, l, u, d, h, p;
    const g = e.pointStyle
      , w = e.rotation
      , b = e.radius;
    let v = (w || 0) * IMe;
    if (g && typeof g == "object" && (i = g.toString(),
    i === "[object HTMLImageElement]" || i === "[object HTMLCanvasElement]")) {
        n.save(),
        n.translate(t, r),
        n.rotate(v),
        n.drawImage(g, -g.width / 2, -g.height / 2, g.width, g.height),
        n.restore();
        return
    }
    if (!(isNaN(b) || b <= 0)) {
        switch (n.beginPath(),
        g) {
        default:
            s ? n.ellipse(t, r, s / 2, b, 0, 0, ua) : n.arc(t, r, b, 0, ua),
            n.closePath();
            break;
        case "triangle":
            d = s ? s / 2 : b,
            n.moveTo(t + Math.sin(v) * d, r - Math.cos(v) * b),
            v += Cj,
            n.lineTo(t + Math.sin(v) * d, r - Math.cos(v) * b),
            v += Cj,
            n.lineTo(t + Math.sin(v) * d, r - Math.cos(v) * b),
            n.closePath();
            break;
        case "rectRounded":
            u = b * .516,
            l = b - u,
            o = Math.cos(v + Ld) * l,
            h = Math.cos(v + Ld) * (s ? s / 2 - u : l),
            a = Math.sin(v + Ld) * l,
            p = Math.sin(v + Ld) * (s ? s / 2 - u : l),
            n.arc(t - h, r - a, u, v - zs, v - aa),
            n.arc(t + p, r - o, u, v - aa, v),
            n.arc(t + h, r + a, u, v, v + aa),
            n.arc(t - p, r + o, u, v + aa, v + zs),
            n.closePath();
            break;
        case "rect":
            if (!w) {
                l = Math.SQRT1_2 * b,
                d = s ? s / 2 : l,
                n.rect(t - d, r - l, 2 * d, 2 * l);
                break
            }
            v += Ld;
        case "rectRot":
            h = Math.cos(v) * (s ? s / 2 : b),
            o = Math.cos(v) * b,
            a = Math.sin(v) * b,
            p = Math.sin(v) * (s ? s / 2 : b),
            n.moveTo(t - h, r - a),
            n.lineTo(t + p, r - o),
            n.lineTo(t + h, r + a),
            n.lineTo(t - p, r + o),
            n.closePath();
            break;
        case "crossRot":
            v += Ld;
        case "cross":
            h = Math.cos(v) * (s ? s / 2 : b),
            o = Math.cos(v) * b,
            a = Math.sin(v) * b,
            p = Math.sin(v) * (s ? s / 2 : b),
            n.moveTo(t - h, r - a),
            n.lineTo(t + h, r + a),
            n.moveTo(t + p, r - o),
            n.lineTo(t - p, r + o);
            break;
        case "star":
            h = Math.cos(v) * (s ? s / 2 : b),
            o = Math.cos(v) * b,
            a = Math.sin(v) * b,
            p = Math.sin(v) * (s ? s / 2 : b),
            n.moveTo(t - h, r - a),
            n.lineTo(t + h, r + a),
            n.moveTo(t + p, r - o),
            n.lineTo(t - p, r + o),
            v += Ld,
            h = Math.cos(v) * (s ? s / 2 : b),
            o = Math.cos(v) * b,
            a = Math.sin(v) * b,
            p = Math.sin(v) * (s ? s / 2 : b),
            n.moveTo(t - h, r - a),
            n.lineTo(t + h, r + a),
            n.moveTo(t + p, r - o),
            n.lineTo(t - p, r + o);
            break;
        case "line":
            o = s ? s / 2 : Math.cos(v) * b,
            a = Math.sin(v) * b,
            n.moveTo(t - o, r - a),
            n.lineTo(t + o, r + a);
            break;
        case "dash":
            n.moveTo(t, r),
            n.lineTo(t + Math.cos(v) * (s ? s / 2 : b), r + Math.sin(v) * b);
            break;
        case !1:
            n.closePath();
            break
        }
        n.fill(),
        e.borderWidth > 0 && n.stroke()
    }
}
function hy(n, e, t) {
    return t = t || .5,
    !e || n && n.x > e.left - t && n.x < e.right + t && n.y > e.top - t && n.y < e.bottom + t
}
function qx(n, e) {
    n.save(),
    n.beginPath(),
    n.rect(e.left, e.top, e.right - e.left, e.bottom - e.top),
    n.clip()
}
function Gx(n) {
    n.restore()
}
function nBe(n, e, t, r, s) {
    if (!e)
        return n.lineTo(t.x, t.y);
    if (s === "middle") {
        const i = (e.x + t.x) / 2;
        n.lineTo(i, e.y),
        n.lineTo(i, t.y)
    } else
        s === "after" != !!r ? n.lineTo(e.x, t.y) : n.lineTo(t.x, e.y);
    n.lineTo(t.x, t.y)
}
function rBe(n, e, t, r) {
    if (!e)
        return n.lineTo(t.x, t.y);
    n.bezierCurveTo(r ? e.cp1x : e.cp2x, r ? e.cp1y : e.cp2y, r ? t.cp2x : t.cp1x, r ? t.cp2y : t.cp1y, t.x, t.y)
}
function sBe(n, e) {
    e.translation && n.translate(e.translation[0], e.translation[1]),
    sr(e.rotation) || n.rotate(e.rotation),
    e.color && (n.fillStyle = e.color),
    e.textAlign && (n.textAlign = e.textAlign),
    e.textBaseline && (n.textBaseline = e.textBaseline)
}
function iBe(n, e, t, r, s) {
    if (s.strikethrough || s.underline) {
        const i = n.measureText(r)
          , o = e - i.actualBoundingBoxLeft
          , a = e + i.actualBoundingBoxRight
          , l = t - i.actualBoundingBoxAscent
          , u = t + i.actualBoundingBoxDescent
          , d = s.strikethrough ? (l + u) / 2 : u;
        n.strokeStyle = n.fillStyle,
        n.beginPath(),
        n.lineWidth = s.decorationWidth || 2,
        n.moveTo(o, d),
        n.lineTo(a, d),
        n.stroke()
    }
}
function oBe(n, e) {
    const t = n.fillStyle;
    n.fillStyle = e.color,
    n.fillRect(e.left, e.top, e.width, e.height),
    n.fillStyle = t
}
function xv(n, e, t, r, s, i={}) {
    const o = ns(e) ? e : [e]
      , a = i.strokeWidth > 0 && i.strokeColor !== "";
    let l, u;
    for (n.save(),
    n.font = s.string,
    sBe(n, i),
    l = 0; l < o.length; ++l)
        u = o[l],
        i.backdrop && oBe(n, i.backdrop),
        a && (i.strokeColor && (n.strokeStyle = i.strokeColor),
        sr(i.strokeWidth) || (n.lineWidth = i.strokeWidth),
        n.strokeText(u, t, r, i.maxWidth)),
        n.fillText(u, t, r, i.maxWidth),
        iBe(n, t, r, u, i),
        r += Number(s.lineHeight);
    n.restore()
}
function u8(n, e) {
    const {x: t, y: r, w: s, h: i, radius: o} = e;
    n.arc(t + o.topLeft, r + o.topLeft, o.topLeft, 1.5 * zs, zs, !0),
    n.lineTo(t, r + i - o.bottomLeft),
    n.arc(t + o.bottomLeft, r + i - o.bottomLeft, o.bottomLeft, zs, aa, !0),
    n.lineTo(t + s - o.bottomRight, r + i),
    n.arc(t + s - o.bottomRight, r + i - o.bottomRight, o.bottomRight, aa, 0, !0),
    n.lineTo(t + s, r + o.topRight),
    n.arc(t + s - o.topRight, r + o.topRight, o.topRight, 0, -aa, !0),
    n.lineTo(t + o.topLeft, r)
}
const aBe = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/
  , lBe = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
function cBe(n, e) {
    const t = ("" + n).match(aBe);
    if (!t || t[1] === "normal")
        return e * 1.2;
    switch (n = +t[2],
    t[3]) {
    case "px":
        return n;
    case "%":
        n /= 100;
        break
    }
    return e * n
}
const uBe = n => +n || 0;
function nW(n, e) {
    const t = {}
      , r = an(e)
      , s = r ? Object.keys(e) : e
      , i = an(n) ? r ? o => on(n[o], n[e[o]]) : o => n[o] : () => n;
    for (const o of s)
        t[o] = uBe(i(o));
    return t
}
function dBe(n) {
    return nW(n, {
        top: "y",
        right: "x",
        bottom: "y",
        left: "x"
    })
}
function zg(n) {
    return nW(n, ["topLeft", "topRight", "bottomLeft", "bottomRight"])
}
function pa(n) {
    const e = dBe(n);
    return e.width = e.left + e.right,
    e.height = e.top + e.bottom,
    e
}
function ki(n, e) {
    n = n || {},
    e = e || _r.font;
    let t = on(n.size, e.size);
    typeof t == "string" && (t = parseInt(t, 10));
    let r = on(n.style, e.style);
    r && !("" + r).match(lBe) && (console.warn('Invalid font style specified: "' + r + '"'),
    r = void 0);
    const s = {
        family: on(n.family, e.family),
        lineHeight: cBe(on(n.lineHeight, e.lineHeight), t),
        size: t,
        style: r,
        weight: on(n.weight, e.weight),
        string: ""
    };
    return s.string = tBe(s),
    s
}
function Sw(n, e, t, r) {
    let s, i, o;
    for (s = 0,
    i = n.length; s < i; ++s)
        if (o = n[s],
        o !== void 0 && o !== void 0)
            return o
}
function fBe(n, e, t) {
    const {min: r, max: s} = n
      , i = AMe(e, (s - r) / 2)
      , o = (a, l) => t && a === 0 ? 0 : a + l;
    return {
        min: o(r, -Math.abs(i)),
        max: o(s, i)
    }
}
function nh(n, e) {
    return Object.assign(Object.create(n), e)
}
function Fk(n, e=[""], t, r, s= () => n[0]) {
    const i = t || n;
    typeof r > "u" && (r = oW("_fallback", n));
    const o = {
        [Symbol.toStringTag]: "Object",
        _cacheable: !0,
        _scopes: n,
        _rootScopes: i,
        _fallback: r,
        _getTarget: s,
        override: a => Fk([a, ...n], e, i, r)
    };
    return new Proxy(o,{
        deleteProperty(a, l) {
            return delete a[l],
            delete a._keys,
            delete n[0][l],
            !0
        },
        get(a, l) {
            return sW(a, l, () => vBe(l, e, n, a))
        },
        getOwnPropertyDescriptor(a, l) {
            return Reflect.getOwnPropertyDescriptor(a._scopes[0], l)
        },
        getPrototypeOf() {
            return Reflect.getPrototypeOf(n[0])
        },
        has(a, l) {
            return Pj(a).includes(l)
        },
        ownKeys(a) {
            return Pj(a)
        },
        set(a, l, u) {
            const d = a._storage || (a._storage = s());
            return a[l] = d[l] = u,
            delete a._keys,
            !0
        }
    })
}
function g0(n, e, t, r) {
    const s = {
        _cacheable: !1,
        _proxy: n,
        _context: e,
        _subProxy: t,
        _stack: new Set,
        _descriptors: rW(n, r),
        setContext: i => g0(n, i, t, r),
        override: i => g0(n.override(i), e, t, r)
    };
    return new Proxy(s,{
        deleteProperty(i, o) {
            return delete i[o],
            delete n[o],
            !0
        },
        get(i, o, a) {
            return sW(i, o, () => pBe(i, o, a))
        },
        getOwnPropertyDescriptor(i, o) {
            return i._descriptors.allKeys ? Reflect.has(n, o) ? {
                enumerable: !0,
                configurable: !0
            } : void 0 : Reflect.getOwnPropertyDescriptor(n, o)
        },
        getPrototypeOf() {
            return Reflect.getPrototypeOf(n)
        },
        has(i, o) {
            return Reflect.has(n, o)
        },
        ownKeys() {
            return Reflect.ownKeys(n)
        },
        set(i, o, a) {
            return n[o] = a,
            delete i[o],
            !0
        }
    })
}
function rW(n, e={
    scriptable: !0,
    indexable: !0
}) {
    const {_scriptable: t=e.scriptable, _indexable: r=e.indexable, _allKeys: s=e.allKeys} = n;
    return {
        allKeys: s,
        scriptable: t,
        indexable: r,
        isScriptable: id(t) ? t : () => t,
        isIndexable: id(r) ? r : () => r
    }
}
const hBe = (n, e) => n ? n + Pk(e) : e
  , Uk = (n, e) => an(e) && n !== "adapters" && (Object.getPrototypeOf(e) === null || e.constructor === Object);
function sW(n, e, t) {
    if (Object.prototype.hasOwnProperty.call(n, e) || e === "constructor")
        return n[e];
    const r = t();
    return n[e] = r,
    r
}
function pBe(n, e, t) {
    const {_proxy: r, _context: s, _subProxy: i, _descriptors: o} = n;
    let a = r[e];
    return id(a) && o.isScriptable(e) && (a = mBe(e, a, n, t)),
    ns(a) && a.length && (a = gBe(e, a, n, o.isIndexable)),
    Uk(e, a) && (a = g0(a, s, i && i[e], o)),
    a
}
function mBe(n, e, t, r) {
    const {_proxy: s, _context: i, _subProxy: o, _stack: a} = t;
    if (a.has(n))
        throw new Error("Recursion detected: " + Array.from(a).join("->") + "->" + n);
    a.add(n);
    let l = e(i, o || r);
    return a.delete(n),
    Uk(n, l) && (l = zk(s._scopes, s, n, l)),
    l
}
function gBe(n, e, t, r) {
    const {_proxy: s, _context: i, _subProxy: o, _descriptors: a} = t;
    if (typeof i.index < "u" && r(n))
        return e[i.index % e.length];
    if (an(e[0])) {
        const l = e
          , u = s._scopes.filter(d => d !== l);
        e = [];
        for (const d of l) {
            const h = zk(u, s, n, d);
            e.push(g0(h, i, o && o[n], a))
        }
    }
    return e
}
function iW(n, e, t) {
    return id(n) ? n(e, t) : n
}
const yBe = (n, e) => n === !0 ? e : typeof n == "string" ? yv(e, n) : void 0;
function bBe(n, e, t, r, s) {
    for (const i of e) {
        const o = yBe(t, i);
        if (o) {
            n.add(o);
            const a = iW(o._fallback, t, s);
            if (typeof a < "u" && a !== t && a !== r)
                return a
        } else if (o === !1 && typeof r < "u" && t !== r)
            return null
    }
    return !1
}
function zk(n, e, t, r) {
    const s = e._rootScopes
      , i = iW(e._fallback, t, r)
      , o = [...n, ...s]
      , a = new Set;
    a.add(r);
    let l = Oj(a, o, t, i || t, r);
    return l === null || typeof i < "u" && i !== t && (l = Oj(a, o, i, l, r),
    l === null) ? !1 : Fk(Array.from(a), [""], s, i, () => wBe(e, t, r))
}
function Oj(n, e, t, r, s) {
    for (; t; )
        t = bBe(n, e, t, r, s);
    return t
}
function wBe(n, e, t) {
    const r = n._getTarget();
    e in r || (r[e] = {});
    const s = r[e];
    return ns(s) && an(t) ? t : s || {}
}
function vBe(n, e, t, r) {
    let s;
    for (const i of e)
        if (s = oW(hBe(i, n), t),
        typeof s < "u")
            return Uk(n, s) ? zk(t, r, n, s) : s
}
function oW(n, e) {
    for (const t of e) {
        if (!t)
            continue;
        const r = t[n];
        if (typeof r < "u")
            return r
    }
}
function Pj(n) {
    let e = n._keys;
    return e || (e = n._keys = xBe(n._scopes)),
    e
}
function xBe(n) {
    const e = new Set;
    for (const t of n)
        for (const r of Object.keys(t).filter(s => !s.startsWith("_")))
            e.add(r);
    return Array.from(e)
}
const EBe = Number.EPSILON || 1e-14
  , y0 = (n, e) => e < n.length && !n[e].skip && n[e]
  , aW = n => n === "x" ? "y" : "x";
function SBe(n, e, t, r) {
    const s = n.skip ? e : n
      , i = e
      , o = t.skip ? e : t
      , a = o8(i, s)
      , l = o8(o, i);
    let u = a / (a + l)
      , d = l / (a + l);
    u = isNaN(u) ? 0 : u,
    d = isNaN(d) ? 0 : d;
    const h = r * u
      , p = r * d;
    return {
        previous: {
            x: i.x - h * (o.x - s.x),
            y: i.y - h * (o.y - s.y)
        },
        next: {
            x: i.x + p * (o.x - s.x),
            y: i.y + p * (o.y - s.y)
        }
    }
}
function ABe(n, e, t) {
    const r = n.length;
    let s, i, o, a, l, u = y0(n, 0);
    for (let d = 0; d < r - 1; ++d)
        if (l = u,
        u = y0(n, d + 1),
        !(!l || !u)) {
            if (Lg(e[d], 0, EBe)) {
                t[d] = t[d + 1] = 0;
                continue
            }
            s = t[d] / e[d],
            i = t[d + 1] / e[d],
            a = Math.pow(s, 2) + Math.pow(i, 2),
            !(a <= 9) && (o = 3 / Math.sqrt(a),
            t[d] = s * o * e[d],
            t[d + 1] = i * o * e[d])
        }
}
function CBe(n, e, t="x") {
    const r = aW(t)
      , s = n.length;
    let i, o, a, l = y0(n, 0);
    for (let u = 0; u < s; ++u) {
        if (o = a,
        a = l,
        l = y0(n, u + 1),
        !a)
            continue;
        const d = a[t]
          , h = a[r];
        o && (i = (d - o[t]) / 3,
        a[`cp1${t}`] = d - i,
        a[`cp1${r}`] = h - i * e[u]),
        l && (i = (l[t] - d) / 3,
        a[`cp2${t}`] = d + i,
        a[`cp2${r}`] = h + i * e[u])
    }
}
function _Be(n, e="x") {
    const t = aW(e)
      , r = n.length
      , s = Array(r).fill(0)
      , i = Array(r);
    let o, a, l, u = y0(n, 0);
    for (o = 0; o < r; ++o)
        if (a = l,
        l = u,
        u = y0(n, o + 1),
        !!l) {
            if (u) {
                const d = u[e] - l[e];
                s[o] = d !== 0 ? (u[t] - l[t]) / d : 0
            }
            i[o] = a ? u ? m0(s[o - 1]) !== m0(s[o]) ? 0 : (s[o - 1] + s[o]) / 2 : s[o - 1] : s[o]
        }
    ABe(n, s, i),
    CBe(n, i, e)
}
function Aw(n, e, t) {
    return Math.max(Math.min(n, t), e)
}
function kBe(n, e) {
    let t, r, s, i, o, a = hy(n[0], e);
    for (t = 0,
    r = n.length; t < r; ++t)
        o = i,
        i = a,
        a = t < r - 1 && hy(n[t + 1], e),
        i && (s = n[t],
        o && (s.cp1x = Aw(s.cp1x, e.left, e.right),
        s.cp1y = Aw(s.cp1y, e.top, e.bottom)),
        a && (s.cp2x = Aw(s.cp2x, e.left, e.right),
        s.cp2y = Aw(s.cp2y, e.top, e.bottom)))
}
function NBe(n, e, t, r, s) {
    let i, o, a, l;
    if (e.spanGaps && (n = n.filter(u => !u.skip)),
    e.cubicInterpolationMode === "monotone")
        _Be(n, s);
    else {
        let u = r ? n[n.length - 1] : n[0];
        for (i = 0,
        o = n.length; i < o; ++i)
            a = n[i],
            l = SBe(u, a, n[Math.min(i + 1, o - (r ? 0 : 1)) % o], e.tension),
            a.cp1x = l.previous.x,
            a.cp1y = l.previous.y,
            a.cp2x = l.next.x,
            a.cp2y = l.next.y,
            u = a
    }
    e.capBezierPoints && kBe(n, t)
}
function $k() {
    return typeof window < "u" && typeof document < "u"
}
function Hk(n) {
    let e = n.parentNode;
    return e && e.toString() === "[object ShadowRoot]" && (e = e.host),
    e
}
function Ev(n, e, t) {
    let r;
    return typeof n == "string" ? (r = parseInt(n, 10),
    n.indexOf("%") !== -1 && (r = r / 100 * e.parentNode[t])) : r = n,
    r
}
const Wx = n => n.ownerDocument.defaultView.getComputedStyle(n, null);
function DBe(n, e) {
    return Wx(n).getPropertyValue(e)
}
const TBe = ["top", "right", "bottom", "left"];
function Nf(n, e, t) {
    const r = {};
    t = t ? "-" + t : "";
    for (let s = 0; s < 4; s++) {
        const i = TBe[s];
        r[i] = parseFloat(n[e + "-" + i + t]) || 0
    }
    return r.width = r.left + r.right,
    r.height = r.top + r.bottom,
    r
}
const IBe = (n, e, t) => (n > 0 || e > 0) && (!t || !t.shadowRoot);
function MBe(n, e) {
    const t = n.touches
      , r = t && t.length ? t[0] : n
      , {offsetX: s, offsetY: i} = r;
    let o = !1, a, l;
    if (IBe(s, i, n.target))
        a = s,
        l = i;
    else {
        const u = e.getBoundingClientRect();
        a = r.clientX - u.left,
        l = r.clientY - u.top,
        o = !0
    }
    return {
        x: a,
        y: l,
        box: o
    }
}
function Wd(n, e) {
    if ("native"in n)
        return n;
    const {canvas: t, currentDevicePixelRatio: r} = e
      , s = Wx(t)
      , i = s.boxSizing === "border-box"
      , o = Nf(s, "padding")
      , a = Nf(s, "border", "width")
      , {x: l, y: u, box: d} = MBe(n, t)
      , h = o.left + (d && a.left)
      , p = o.top + (d && a.top);
    let {width: g, height: w} = e;
    return i && (g -= o.width + a.width,
    w -= o.height + a.height),
    {
        x: Math.round((l - h) / g * t.width / r),
        y: Math.round((u - p) / w * t.height / r)
    }
}
function BBe(n, e, t) {
    let r, s;
    if (e === void 0 || t === void 0) {
        const i = n && Hk(n);
        if (!i)
            e = n.clientWidth,
            t = n.clientHeight;
        else {
            const o = i.getBoundingClientRect()
              , a = Wx(i)
              , l = Nf(a, "border", "width")
              , u = Nf(a, "padding");
            e = o.width - u.width - l.width,
            t = o.height - u.height - l.height,
            r = Ev(a.maxWidth, i, "clientWidth"),
            s = Ev(a.maxHeight, i, "clientHeight")
        }
    }
    return {
        width: e,
        height: t,
        maxWidth: r || wv,
        maxHeight: s || wv
    }
}
const zu = n => Math.round(n * 10) / 10;
function RBe(n, e, t, r) {
    const s = Wx(n)
      , i = Nf(s, "margin")
      , o = Ev(s.maxWidth, n, "clientWidth") || wv
      , a = Ev(s.maxHeight, n, "clientHeight") || wv
      , l = BBe(n, e, t);
    let {width: u, height: d} = l;
    if (s.boxSizing === "content-box") {
        const p = Nf(s, "border", "width")
          , g = Nf(s, "padding");
        u -= g.width + p.width,
        d -= g.height + p.height
    }
    return u = Math.max(0, u - i.width),
    d = Math.max(0, r ? u / r : d - i.height),
    u = zu(Math.min(u, o, l.maxWidth)),
    d = zu(Math.min(d, a, l.maxHeight)),
    u && !d && (d = zu(u / 2)),
    (e !== void 0 || t !== void 0) && r && l.height && d > l.height && (d = l.height,
    u = zu(Math.floor(d * r))),
    {
        width: u,
        height: d
    }
}
function jj(n, e, t) {
    const r = e || 1
      , s = zu(n.height * r)
      , i = zu(n.width * r);
    n.height = zu(n.height),
    n.width = zu(n.width);
    const o = n.canvas;
    return o.style && (t || !o.style.height && !o.style.width) && (o.style.height = `${n.height}px`,
    o.style.width = `${n.width}px`),
    n.currentDevicePixelRatio !== r || o.height !== s || o.width !== i ? (n.currentDevicePixelRatio = r,
    o.height = s,
    o.width = i,
    n.ctx.setTransform(r, 0, 0, r, 0, 0),
    !0) : !1
}
const OBe = (function() {
    let n = !1;
    try {
        const e = {
            get passive() {
                return n = !0,
                !1
            }
        };
        $k() && (window.addEventListener("test", null, e),
        window.removeEventListener("test", null, e))
    } catch {}
    return n
}
)();
function Lj(n, e) {
    const t = DBe(n, e)
      , r = t && t.match(/^(\d+)(\.\d+)?px$/);
    return r ? +r[1] : void 0
}
function Yd(n, e, t, r) {
    return {
        x: n.x + t * (e.x - n.x),
        y: n.y + t * (e.y - n.y)
    }
}
function PBe(n, e, t, r) {
    return {
        x: n.x + t * (e.x - n.x),
        y: r === "middle" ? t < .5 ? n.y : e.y : r === "after" ? t < 1 ? n.y : e.y : t > 0 ? e.y : n.y
    }
}
function jBe(n, e, t, r) {
    const s = {
        x: n.cp2x,
        y: n.cp2y
    }
      , i = {
        x: e.cp1x,
        y: e.cp1y
    }
      , o = Yd(n, s, t)
      , a = Yd(s, i, t)
      , l = Yd(i, e, t)
      , u = Yd(o, a, t)
      , d = Yd(a, l, t);
    return Yd(u, d, t)
}
const LBe = function(n, e) {
    return {
        x(t) {
            return n + n + e - t
        },
        setWidth(t) {
            e = t
        },
        textAlign(t) {
            return t === "center" ? t : t === "right" ? "left" : "right"
        },
        xPlus(t, r) {
            return t - r
        },
        leftForLtr(t, r) {
            return t - r
        }
    }
}
  , FBe = function() {
    return {
        x(n) {
            return n
        },
        setWidth(n) {},
        textAlign(n) {
            return n
        },
        xPlus(n, e) {
            return n + e
        },
        leftForLtr(n, e) {
            return n
        }
    }
};
function Vp(n, e, t) {
    return n ? LBe(e, t) : FBe()
}
function lW(n, e) {
    let t, r;
    (e === "ltr" || e === "rtl") && (t = n.canvas.style,
    r = [t.getPropertyValue("direction"), t.getPropertyPriority("direction")],
    t.setProperty("direction", e, "important"),
    n.prevTextDirection = r)
}
function cW(n, e) {
    e !== void 0 && (delete n.prevTextDirection,
    n.canvas.style.setProperty("direction", e[0], e[1]))
}
function uW(n) {
    return n === "angle" ? {
        between: YG,
        compare: LMe,
        normalize: Fa
    } : {
        between: Ep,
        compare: (e, t) => e - t,
        normalize: e => e
    }
}
function Fj({start: n, end: e, count: t, loop: r, style: s}) {
    return {
        start: n % t,
        end: e % t,
        loop: r && (e - n + 1) % t === 0,
        style: s
    }
}
function UBe(n, e, t) {
    const {property: r, start: s, end: i} = t
      , {between: o, normalize: a} = uW(r)
      , l = e.length;
    let {start: u, end: d, loop: h} = n, p, g;
    if (h) {
        for (u += l,
        d += l,
        p = 0,
        g = l; p < g && o(a(e[u % l][r]), s, i); ++p)
            u--,
            d--;
        u %= l,
        d %= l
    }
    return d < u && (d += l),
    {
        start: u,
        end: d,
        loop: h,
        style: n.style
    }
}
function dW(n, e, t) {
    if (!t)
        return [n];
    const {property: r, start: s, end: i} = t
      , o = e.length
      , {compare: a, between: l, normalize: u} = uW(r)
      , {start: d, end: h, loop: p, style: g} = UBe(n, e, t)
      , w = [];
    let b = !1, v = null, S, N, _;
    const I = () => l(s, _, S) && a(s, _) !== 0
      , k = () => a(i, S) === 0 || l(i, _, S)
      , B = () => b || I()
      , P = () => !b || k();
    for (let M = d, R = d; M <= h; ++M)
        N = e[M % o],
        !N.skip && (S = u(N[r]),
        S !== _ && (b = l(S, s, i),
        v === null && B() && (v = a(S, s) === 0 ? M : R),
        v !== null && P() && (w.push(Fj({
            start: v,
            end: M,
            loop: p,
            count: o,
            style: g
        })),
        v = null),
        R = M,
        _ = S));
    return v !== null && w.push(Fj({
        start: v,
        end: h,
        loop: p,
        count: o,
        style: g
    })),
    w
}
function fW(n, e) {
    const t = []
      , r = n.segments;
    for (let s = 0; s < r.length; s++) {
        const i = dW(r[s], n.points, e);
        i.length && t.push(...i)
    }
    return t
}
function zBe(n, e, t, r) {
    let s = 0
      , i = e - 1;
    if (t && !r)
        for (; s < e && !n[s].skip; )
            s++;
    for (; s < e && n[s].skip; )
        s++;
    for (s %= e,
    t && (i += s); i > s && n[i % e].skip; )
        i--;
    return i %= e,
    {
        start: s,
        end: i
    }
}
function $Be(n, e, t, r) {
    const s = n.length
      , i = [];
    let o = e, a = n[e], l;
    for (l = e + 1; l <= t; ++l) {
        const u = n[l % s];
        u.skip || u.stop ? a.skip || (r = !1,
        i.push({
            start: e % s,
            end: (l - 1) % s,
            loop: r
        }),
        e = o = u.stop ? l : null) : (o = l,
        a.skip && (e = l)),
        a = u
    }
    return o !== null && i.push({
        start: e % s,
        end: o % s,
        loop: r
    }),
    i
}
function HBe(n, e) {
    const t = n.points
      , r = n.options.spanGaps
      , s = t.length;
    if (!s)
        return [];
    const i = !!n._loop
      , {start: o, end: a} = zBe(t, s, i, r);
    if (r === !0)
        return Uj(n, [{
            start: o,
            end: a,
            loop: i
        }], t, e);
    const l = a < o ? a + s : a
      , u = !!n._fullLoop && o === 0 && a === s - 1;
    return Uj(n, $Be(t, o, l, u), t, e)
}
function Uj(n, e, t, r) {
    return !r || !r.setContext || !t ? e : VBe(n, e, t, r)
}
function VBe(n, e, t, r) {
    const s = n._chart.getContext()
      , i = zj(n.options)
      , {_datasetIndex: o, options: {spanGaps: a}} = n
      , l = t.length
      , u = [];
    let d = i
      , h = e[0].start
      , p = h;
    function g(w, b, v, S) {
        const N = a ? -1 : 1;
        if (w !== b) {
            for (w += l; t[w % l].skip; )
                w -= N;
            for (; t[b % l].skip; )
                b += N;
            w % l !== b % l && (u.push({
                start: w % l,
                end: b % l,
                loop: v,
                style: S
            }),
            d = S,
            h = b % l)
        }
    }
    for (const w of e) {
        h = a ? h : w.start;
        let b = t[h % l], v;
        for (p = h + 1; p <= w.end; p++) {
            const S = t[p % l];
            v = zj(r.setContext(nh(s, {
                type: "segment",
                p0: b,
                p1: S,
                p0DataIndex: (p - 1) % l,
                p1DataIndex: p % l,
                datasetIndex: o
            }))),
            qBe(v, d) && g(h, p - 1, w.loop, d),
            b = S,
            d = v
        }
        h < p - 1 && g(h, p - 1, w.loop, d)
    }
    return u
}
function zj(n) {
    return {
        backgroundColor: n.backgroundColor,
        borderCapStyle: n.borderCapStyle,
        borderDash: n.borderDash,
        borderDashOffset: n.borderDashOffset,
        borderJoinStyle: n.borderJoinStyle,
        borderWidth: n.borderWidth,
        borderColor: n.borderColor
    }
}
function qBe(n, e) {
    if (!e)
        return !1;
    const t = []
      , r = function(s, i) {
        return Lk(i) ? (t.includes(i) || t.push(i),
        t.indexOf(i)) : i
    };
    return JSON.stringify(n, r) !== JSON.stringify(e, r)
}
function Cw(n, e, t) {
    return n.options.clip ? n[t] : e[t]
}
function GBe(n, e) {
    const {xScale: t, yScale: r} = n;
    return t && r ? {
        left: Cw(t, e, "left"),
        right: Cw(t, e, "right"),
        top: Cw(r, e, "top"),
        bottom: Cw(r, e, "bottom")
    } : e
}
function hW(n, e) {
    const t = e._clip;
    if (t.disabled)
        return !1;
    const r = GBe(e, n.chartArea);
    return {
        left: t.left === !1 ? 0 : r.left - (t.left === !0 ? 0 : t.left),
        right: t.right === !1 ? n.width : r.right + (t.right === !0 ? 0 : t.right),
        top: t.top === !1 ? 0 : r.top - (t.top === !0 ? 0 : t.top),
        bottom: t.bottom === !1 ? n.height : r.bottom + (t.bottom === !0 ? 0 : t.bottom)
    }
}
class WBe {
    constructor() {
        this._request = null,
        this._charts = new Map,
        this._running = !1,
        this._lastDate = void 0
    }
    _notify(e, t, r, s) {
        const i = t.listeners[s]
          , o = t.duration;
        i.forEach(a => a({
            chart: e,
            initial: t.initial,
            numSteps: o,
            currentStep: Math.min(r - t.start, o)
        }))
    }
    _refresh() {
        this._request || (this._running = !0,
        this._request = XG.call(window, () => {
            this._update(),
            this._request = null,
            this._running && this._refresh()
        }
        ))
    }
    _update(e=Date.now()) {
        let t = 0;
        this._charts.forEach( (r, s) => {
            if (!r.running || !r.items.length)
                return;
            const i = r.items;
            let o = i.length - 1, a = !1, l;
            for (; o >= 0; --o)
                l = i[o],
                l._active ? (l._total > r.duration && (r.duration = l._total),
                l.tick(e),
                a = !0) : (i[o] = i[i.length - 1],
                i.pop());
            a && (s.draw(),
            this._notify(s, r, e, "progress")),
            i.length || (r.running = !1,
            this._notify(s, r, e, "complete"),
            r.initial = !1),
            t += i.length
        }
        ),
        this._lastDate = e,
        t === 0 && (this._running = !1)
    }
    _getAnims(e) {
        const t = this._charts;
        let r = t.get(e);
        return r || (r = {
            running: !1,
            initial: !0,
            items: [],
            listeners: {
                complete: [],
                progress: []
            }
        },
        t.set(e, r)),
        r
    }
    listen(e, t, r) {
        this._getAnims(e).listeners[t].push(r)
    }
    add(e, t) {
        !t || !t.length || this._getAnims(e).items.push(...t)
    }
    has(e) {
        return this._getAnims(e).items.length > 0
    }
    start(e) {
        const t = this._charts.get(e);
        t && (t.running = !0,
        t.start = Date.now(),
        t.duration = t.items.reduce( (r, s) => Math.max(r, s._duration), 0),
        this._refresh())
    }
    running(e) {
        if (!this._running)
            return !1;
        const t = this._charts.get(e);
        return !(!t || !t.running || !t.items.length)
    }
    stop(e) {
        const t = this._charts.get(e);
        if (!t || !t.items.length)
            return;
        const r = t.items;
        let s = r.length - 1;
        for (; s >= 0; --s)
            r[s].cancel();
        t.items = [],
        this._notify(e, t, Date.now(), "complete")
    }
    remove(e) {
        return this._charts.delete(e)
    }
}
var ql = new WBe;
const $j = "transparent"
  , YBe = {
    boolean(n, e, t) {
        return t > .5 ? e : n
    },
    color(n, e, t) {
        const r = Ij(n || $j)
          , s = r.valid && Ij(e || $j);
        return s && s.valid ? s.mix(r, t).hexString() : e
    },
    number(n, e, t) {
        return n + (e - n) * t
    }
};
class KBe {
    constructor(e, t, r, s) {
        const i = t[r];
        s = Sw([e.to, s, i, e.from]);
        const o = Sw([e.from, i, s]);
        this._active = !0,
        this._fn = e.fn || YBe[e.type || typeof o],
        this._easing = Fg[e.easing] || Fg.linear,
        this._start = Math.floor(Date.now() + (e.delay || 0)),
        this._duration = this._total = Math.floor(e.duration),
        this._loop = !!e.loop,
        this._target = t,
        this._prop = r,
        this._from = o,
        this._to = s,
        this._promises = void 0
    }
    active() {
        return this._active
    }
    update(e, t, r) {
        if (this._active) {
            this._notify(!1);
            const s = this._target[this._prop]
              , i = r - this._start
              , o = this._duration - i;
            this._start = r,
            this._duration = Math.floor(Math.max(o, e.duration)),
            this._total += i,
            this._loop = !!e.loop,
            this._to = Sw([e.to, t, s, e.from]),
            this._from = Sw([e.from, s, t])
        }
    }
    cancel() {
        this._active && (this.tick(Date.now()),
        this._active = !1,
        this._notify(!1))
    }
    tick(e) {
        const t = e - this._start
          , r = this._duration
          , s = this._prop
          , i = this._from
          , o = this._loop
          , a = this._to;
        let l;
        if (this._active = i !== a && (o || t < r),
        !this._active) {
            this._target[s] = a,
            this._notify(!0);
            return
        }
        if (t < 0) {
            this._target[s] = i;
            return
        }
        l = t / r % 2,
        l = o && l > 1 ? 2 - l : l,
        l = this._easing(Math.min(1, Math.max(0, l))),
        this._target[s] = this._fn(i, a, l)
    }
    wait() {
        const e = this._promises || (this._promises = []);
        return new Promise( (t, r) => {
            e.push({
                res: t,
                rej: r
            })
        }
        )
    }
    _notify(e) {
        const t = e ? "res" : "rej"
          , r = this._promises || [];
        for (let s = 0; s < r.length; s++)
            r[s][t]()
    }
}
class pW {
    constructor(e, t) {
        this._chart = e,
        this._properties = new Map,
        this.configure(t)
    }
    configure(e) {
        if (!an(e))
            return;
        const t = Object.keys(_r.animation)
          , r = this._properties;
        Object.getOwnPropertyNames(e).forEach(s => {
            const i = e[s];
            if (!an(i))
                return;
            const o = {};
            for (const a of t)
                o[a] = i[a];
            (ns(i.properties) && i.properties || [s]).forEach(a => {
                (a === s || !r.has(a)) && r.set(a, o)
            }
            )
        }
        )
    }
    _animateOptions(e, t) {
        const r = t.options
          , s = QBe(e, r);
        if (!s)
            return [];
        const i = this._createAnimations(s, r);
        return r.$shared && XBe(e.options.$animations, r).then( () => {
            e.options = r
        }
        , () => {}
        ),
        i
    }
    _createAnimations(e, t) {
        const r = this._properties
          , s = []
          , i = e.$animations || (e.$animations = {})
          , o = Object.keys(t)
          , a = Date.now();
        let l;
        for (l = o.length - 1; l >= 0; --l) {
            const u = o[l];
            if (u.charAt(0) === "$")
                continue;
            if (u === "options") {
                s.push(...this._animateOptions(e, t));
                continue
            }
            const d = t[u];
            let h = i[u];
            const p = r.get(u);
            if (h)
                if (p && h.active()) {
                    h.update(p, d, a);
                    continue
                } else
                    h.cancel();
            if (!p || !p.duration) {
                e[u] = d;
                continue
            }
            i[u] = h = new KBe(p,e,u,d),
            s.push(h)
        }
        return s
    }
    update(e, t) {
        if (this._properties.size === 0) {
            Object.assign(e, t);
            return
        }
        const r = this._createAnimations(e, t);
        if (r.length)
            return ql.add(this._chart, r),
            !0
    }
}
function XBe(n, e) {
    const t = []
      , r = Object.keys(e);
    for (let s = 0; s < r.length; s++) {
        const i = n[r[s]];
        i && i.active() && t.push(i.wait())
    }
    return Promise.all(t)
}
function QBe(n, e) {
    if (!e)
        return;
    let t = n.options;
    if (!t) {
        n.options = e;
        return
    }
    return t.$shared && (n.options = t = Object.assign({}, t, {
        $shared: !1,
        $animations: {}
    })),
    t
}
function Hj(n, e) {
    const t = n && n.options || {}
      , r = t.reverse
      , s = t.min === void 0 ? e : 0
      , i = t.max === void 0 ? e : 0;
    return {
        start: r ? i : s,
        end: r ? s : i
    }
}
function ZBe(n, e, t) {
    if (t === !1)
        return !1;
    const r = Hj(n, t)
      , s = Hj(e, t);
    return {
        top: s.end,
        right: r.end,
        bottom: s.start,
        left: r.start
    }
}
function JBe(n) {
    let e, t, r, s;
    return an(n) ? (e = n.top,
    t = n.right,
    r = n.bottom,
    s = n.left) : e = t = r = s = n,
    {
        top: e,
        right: t,
        bottom: r,
        left: s,
        disabled: n === !1
    }
}
function mW(n, e) {
    const t = []
      , r = n._getSortedDatasetMetas(e);
    let s, i;
    for (s = 0,
    i = r.length; s < i; ++s)
        t.push(r[s].index);
    return t
}
function Vj(n, e, t, r={}) {
    const s = n.keys
      , i = r.mode === "single";
    let o, a, l, u;
    if (e === null)
        return;
    let d = !1;
    for (o = 0,
    a = s.length; o < a; ++o) {
        if (l = +s[o],
        l === t) {
            if (d = !0,
            r.all)
                continue;
            break
        }
        u = n.values[l],
        $s(u) && (i || e === 0 || m0(e) === m0(u)) && (e += u)
    }
    return !d && !r.all ? 0 : e
}
function eRe(n, e) {
    const {iScale: t, vScale: r} = e
      , s = t.axis === "x" ? "x" : "y"
      , i = r.axis === "x" ? "x" : "y"
      , o = Object.keys(n)
      , a = new Array(o.length);
    let l, u, d;
    for (l = 0,
    u = o.length; l < u; ++l)
        d = o[l],
        a[l] = {
            [s]: d,
            [i]: n[d]
        };
    return a
}
function XA(n, e) {
    const t = n && n.options.stacked;
    return t || t === void 0 && e.stack !== void 0
}
function tRe(n, e, t) {
    return `${n.id}.${e.id}.${t.stack || t.type}`
}
function nRe(n) {
    const {min: e, max: t, minDefined: r, maxDefined: s} = n.getUserBounds();
    return {
        min: r ? e : Number.NEGATIVE_INFINITY,
        max: s ? t : Number.POSITIVE_INFINITY
    }
}
function rRe(n, e, t) {
    const r = n[e] || (n[e] = {});
    return r[t] || (r[t] = {})
}
function qj(n, e, t, r) {
    for (const s of e.getMatchingVisibleMetas(r).reverse()) {
        const i = n[s.index];
        if (t && i > 0 || !t && i < 0)
            return s.index
    }
    return null
}
function Gj(n, e) {
    const {chart: t, _cachedMeta: r} = n
      , s = t._stacks || (t._stacks = {})
      , {iScale: i, vScale: o, index: a} = r
      , l = i.axis
      , u = o.axis
      , d = tRe(i, o, r)
      , h = e.length;
    let p;
    for (let g = 0; g < h; ++g) {
        const w = e[g]
          , {[l]: b, [u]: v} = w
          , S = w._stacks || (w._stacks = {});
        p = S[u] = rRe(s, d, b),
        p[a] = v,
        p._top = qj(p, o, !0, r.type),
        p._bottom = qj(p, o, !1, r.type);
        const N = p._visualValues || (p._visualValues = {});
        N[a] = v
    }
}
function QA(n, e) {
    const t = n.scales;
    return Object.keys(t).filter(r => t[r].axis === e).shift()
}
function sRe(n, e) {
    return nh(n, {
        active: !1,
        dataset: void 0,
        datasetIndex: e,
        index: e,
        mode: "default",
        type: "dataset"
    })
}
function iRe(n, e, t) {
    return nh(n, {
        active: !1,
        dataIndex: e,
        parsed: void 0,
        raw: void 0,
        element: t,
        index: e,
        mode: "default",
        type: "data"
    })
}
function cg(n, e) {
    const t = n.controller.index
      , r = n.vScale && n.vScale.axis;
    if (r) {
        e = e || n._parsed;
        for (const s of e) {
            const i = s._stacks;
            if (!i || i[r] === void 0 || i[r][t] === void 0)
                return;
            delete i[r][t],
            i[r]._visualValues !== void 0 && i[r]._visualValues[t] !== void 0 && delete i[r]._visualValues[t]
        }
    }
}
const ZA = n => n === "reset" || n === "none"
  , Wj = (n, e) => e ? n : Object.assign({}, n)
  , oRe = (n, e, t) => n && !e.hidden && e._stacked && {
    keys: mW(t, !0),
    values: null
};
class aRe {
    static defaults = {};
    static datasetElementType = null;
    static dataElementType = null;
    constructor(e, t) {
        this.chart = e,
        this._ctx = e.ctx,
        this.index = t,
        this._cachedDataOpts = {},
        this._cachedMeta = this.getMeta(),
        this._type = this._cachedMeta.type,
        this.options = void 0,
        this._parsing = !1,
        this._data = void 0,
        this._objectData = void 0,
        this._sharedOptions = void 0,
        this._drawStart = void 0,
        this._drawCount = void 0,
        this.enableOptionSharing = !1,
        this.supportsDecimation = !1,
        this.$context = void 0,
        this._syncList = [],
        this.datasetElementType = new.target.datasetElementType,
        this.dataElementType = new.target.dataElementType,
        this.initialize()
    }
    initialize() {
        const e = this._cachedMeta;
        this.configure(),
        this.linkScales(),
        e._stacked = XA(e.vScale, e),
        this.addElements(),
        this.options.fill && !this.chart.isPluginEnabled("filler") && console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options")
    }
    updateIndex(e) {
        this.index !== e && cg(this._cachedMeta),
        this.index = e
    }
    linkScales() {
        const e = this.chart
          , t = this._cachedMeta
          , r = this.getDataset()
          , s = (h, p, g, w) => h === "x" ? p : h === "r" ? w : g
          , i = t.xAxisID = on(r.xAxisID, QA(e, "x"))
          , o = t.yAxisID = on(r.yAxisID, QA(e, "y"))
          , a = t.rAxisID = on(r.rAxisID, QA(e, "r"))
          , l = t.indexAxis
          , u = t.iAxisID = s(l, i, o, a)
          , d = t.vAxisID = s(l, o, i, a);
        t.xScale = this.getScaleForId(i),
        t.yScale = this.getScaleForId(o),
        t.rScale = this.getScaleForId(a),
        t.iScale = this.getScaleForId(u),
        t.vScale = this.getScaleForId(d)
    }
    getDataset() {
        return this.chart.data.datasets[this.index]
    }
    getMeta() {
        return this.chart.getDatasetMeta(this.index)
    }
    getScaleForId(e) {
        return this.chart.scales[e]
    }
    _getOtherScale(e) {
        const t = this._cachedMeta;
        return e === t.iScale ? t.vScale : t.iScale
    }
    reset() {
        this._update("reset")
    }
    _destroy() {
        const e = this._cachedMeta;
        this._data && Nj(this._data, this),
        e._stacked && cg(e)
    }
    _dataCheck() {
        const e = this.getDataset()
          , t = e.data || (e.data = [])
          , r = this._data;
        if (an(t)) {
            const s = this._cachedMeta;
            this._data = eRe(t, s)
        } else if (r !== t) {
            if (r) {
                Nj(r, this);
                const s = this._cachedMeta;
                cg(s),
                s._parsed = []
            }
            t && Object.isExtensible(t) && $Me(t, this),
            this._syncList = [],
            this._data = t
        }
    }
    addElements() {
        const e = this._cachedMeta;
        this._dataCheck(),
        this.datasetElementType && (e.dataset = new this.datasetElementType)
    }
    buildOrUpdateElements(e) {
        const t = this._cachedMeta
          , r = this.getDataset();
        let s = !1;
        this._dataCheck();
        const i = t._stacked;
        t._stacked = XA(t.vScale, t),
        t.stack !== r.stack && (s = !0,
        cg(t),
        t.stack = r.stack),
        this._resyncElements(e),
        (s || i !== t._stacked) && (Gj(this, t._parsed),
        t._stacked = XA(t.vScale, t))
    }
    configure() {
        const e = this.chart.config
          , t = e.datasetScopeKeys(this._type)
          , r = e.getOptionScopes(this.getDataset(), t, !0);
        this.options = e.createResolver(r, this.getContext()),
        this._parsing = this.options.parsing,
        this._cachedDataOpts = {}
    }
    parse(e, t) {
        const {_cachedMeta: r, _data: s} = this
          , {iScale: i, _stacked: o} = r
          , a = i.axis;
        let l = e === 0 && t === s.length ? !0 : r._sorted, u = e > 0 && r._parsed[e - 1], d, h, p;
        if (this._parsing === !1)
            r._parsed = s,
            r._sorted = !0,
            p = s;
        else {
            ns(s[e]) ? p = this.parseArrayData(r, s, e, t) : an(s[e]) ? p = this.parseObjectData(r, s, e, t) : p = this.parsePrimitiveData(r, s, e, t);
            const g = () => h[a] === null || u && h[a] < u[a];
            for (d = 0; d < t; ++d)
                r._parsed[d + e] = h = p[d],
                l && (g() && (l = !1),
                u = h);
            r._sorted = l
        }
        o && Gj(this, p)
    }
    parsePrimitiveData(e, t, r, s) {
        const {iScale: i, vScale: o} = e
          , a = i.axis
          , l = o.axis
          , u = i.getLabels()
          , d = i === o
          , h = new Array(s);
        let p, g, w;
        for (p = 0,
        g = s; p < g; ++p)
            w = p + r,
            h[p] = {
                [a]: d || i.parse(u[w], w),
                [l]: o.parse(t[w], w)
            };
        return h
    }
    parseArrayData(e, t, r, s) {
        const {xScale: i, yScale: o} = e
          , a = new Array(s);
        let l, u, d, h;
        for (l = 0,
        u = s; l < u; ++l)
            d = l + r,
            h = t[d],
            a[l] = {
                x: i.parse(h[0], d),
                y: o.parse(h[1], d)
            };
        return a
    }
    parseObjectData(e, t, r, s) {
        const {xScale: i, yScale: o} = e
          , {xAxisKey: a="x", yAxisKey: l="y"} = this._parsing
          , u = new Array(s);
        let d, h, p, g;
        for (d = 0,
        h = s; d < h; ++d)
            p = d + r,
            g = t[p],
            u[d] = {
                x: i.parse(yv(g, a), p),
                y: o.parse(yv(g, l), p)
            };
        return u
    }
    getParsed(e) {
        return this._cachedMeta._parsed[e]
    }
    getDataElement(e) {
        return this._cachedMeta.data[e]
    }
    applyStack(e, t, r) {
        const s = this.chart
          , i = this._cachedMeta
          , o = t[e.axis]
          , a = {
            keys: mW(s, !0),
            values: t._stacks[e.axis]._visualValues
        };
        return Vj(a, o, i.index, {
            mode: r
        })
    }
    updateRangeFromParsed(e, t, r, s) {
        const i = r[t.axis];
        let o = i === null ? NaN : i;
        const a = s && r._stacks[t.axis];
        s && a && (s.values = a,
        o = Vj(s, i, this._cachedMeta.index)),
        e.min = Math.min(e.min, o),
        e.max = Math.max(e.max, o)
    }
    getMinMax(e, t) {
        const r = this._cachedMeta
          , s = r._parsed
          , i = r._sorted && e === r.iScale
          , o = s.length
          , a = this._getOtherScale(e)
          , l = oRe(t, r, this.chart)
          , u = {
            min: Number.POSITIVE_INFINITY,
            max: Number.NEGATIVE_INFINITY
        }
          , {min: d, max: h} = nRe(a);
        let p, g;
        function w() {
            g = s[p];
            const b = g[a.axis];
            return !$s(g[e.axis]) || d > b || h < b
        }
        for (p = 0; p < o && !(!w() && (this.updateRangeFromParsed(u, e, g, l),
        i)); ++p)
            ;
        if (i) {
            for (p = o - 1; p >= 0; --p)
                if (!w()) {
                    this.updateRangeFromParsed(u, e, g, l);
                    break
                }
        }
        return u
    }
    getAllParsedValues(e) {
        const t = this._cachedMeta._parsed
          , r = [];
        let s, i, o;
        for (s = 0,
        i = t.length; s < i; ++s)
            o = t[s][e.axis],
            $s(o) && r.push(o);
        return r
    }
    getMaxOverflow() {
        return !1
    }
    getLabelAndValue(e) {
        const t = this._cachedMeta
          , r = t.iScale
          , s = t.vScale
          , i = this.getParsed(e);
        return {
            label: r ? "" + r.getLabelForValue(i[r.axis]) : "",
            value: s ? "" + s.getLabelForValue(i[s.axis]) : ""
        }
    }
    _update(e) {
        const t = this._cachedMeta;
        this.update(e || "default"),
        t._clip = JBe(on(this.options.clip, ZBe(t.xScale, t.yScale, this.getMaxOverflow())))
    }
    update(e) {}
    draw() {
        const e = this._ctx
          , t = this.chart
          , r = this._cachedMeta
          , s = r.data || []
          , i = t.chartArea
          , o = []
          , a = this._drawStart || 0
          , l = this._drawCount || s.length - a
          , u = this.options.drawActiveElementsOnTop;
        let d;
        for (r.dataset && r.dataset.draw(e, i, a, l),
        d = a; d < a + l; ++d) {
            const h = s[d];
            h.hidden || (h.active && u ? o.push(h) : h.draw(e, i))
        }
        for (d = 0; d < o.length; ++d)
            o[d].draw(e, i)
    }
    getStyle(e, t) {
        const r = t ? "active" : "default";
        return e === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(r) : this.resolveDataElementOptions(e || 0, r)
    }
    getContext(e, t, r) {
        const s = this.getDataset();
        let i;
        if (e >= 0 && e < this._cachedMeta.data.length) {
            const o = this._cachedMeta.data[e];
            i = o.$context || (o.$context = iRe(this.getContext(), e, o)),
            i.parsed = this.getParsed(e),
            i.raw = s.data[e],
            i.index = i.dataIndex = e
        } else
            i = this.$context || (this.$context = sRe(this.chart.getContext(), this.index)),
            i.dataset = s,
            i.index = i.datasetIndex = this.index;
        return i.active = !!t,
        i.mode = r,
        i
    }
    resolveDatasetElementOptions(e) {
        return this._resolveElementOptions(this.datasetElementType.id, e)
    }
    resolveDataElementOptions(e, t) {
        return this._resolveElementOptions(this.dataElementType.id, t, e)
    }
    _resolveElementOptions(e, t="default", r) {
        const s = t === "active"
          , i = this._cachedDataOpts
          , o = e + "-" + t
          , a = i[o]
          , l = this.enableOptionSharing && bv(r);
        if (a)
            return Wj(a, l);
        const u = this.chart.config
          , d = u.datasetElementScopeKeys(this._type, e)
          , h = s ? [`${e}Hover`, "hover", e, ""] : [e, ""]
          , p = u.getOptionScopes(this.getDataset(), d)
          , g = Object.keys(_r.elements[e])
          , w = () => this.getContext(r, s, t)
          , b = u.resolveNamedOptions(p, g, w, h);
        return b.$shared && (b.$shared = l,
        i[o] = Object.freeze(Wj(b, l))),
        b
    }
    _resolveAnimations(e, t, r) {
        const s = this.chart
          , i = this._cachedDataOpts
          , o = `animation-${t}`
          , a = i[o];
        if (a)
            return a;
        let l;
        if (s.options.animation !== !1) {
            const d = this.chart.config
              , h = d.datasetAnimationScopeKeys(this._type, t)
              , p = d.getOptionScopes(this.getDataset(), h);
            l = d.createResolver(p, this.getContext(e, r, t))
        }
        const u = new pW(s,l && l.animations);
        return l && l._cacheable && (i[o] = Object.freeze(u)),
        u
    }
    getSharedOptions(e) {
        if (e.$shared)
            return this._sharedOptions || (this._sharedOptions = Object.assign({}, e))
    }
    includeOptions(e, t) {
        return !t || ZA(e) || this.chart._animationsDisabled
    }
    _getSharedOptions(e, t) {
        const r = this.resolveDataElementOptions(e, t)
          , s = this._sharedOptions
          , i = this.getSharedOptions(r)
          , o = this.includeOptions(t, i) || i !== s;
        return this.updateSharedOptions(i, t, r),
        {
            sharedOptions: i,
            includeOptions: o
        }
    }
    updateElement(e, t, r, s) {
        ZA(s) ? Object.assign(e, r) : this._resolveAnimations(t, s).update(e, r)
    }
    updateSharedOptions(e, t, r) {
        e && !ZA(t) && this._resolveAnimations(void 0, t).update(e, r)
    }
    _setStyle(e, t, r, s) {
        e.active = s;
        const i = this.getStyle(t, s);
        this._resolveAnimations(t, r, s).update(e, {
            options: !s && this.getSharedOptions(i) || i
        })
    }
    removeHoverStyle(e, t, r) {
        this._setStyle(e, r, "active", !1)
    }
    setHoverStyle(e, t, r) {
        this._setStyle(e, r, "active", !0)
    }
    _removeDatasetHoverStyle() {
        const e = this._cachedMeta.dataset;
        e && this._setStyle(e, void 0, "active", !1)
    }
    _setDatasetHoverStyle() {
        const e = this._cachedMeta.dataset;
        e && this._setStyle(e, void 0, "active", !0)
    }
    _resyncElements(e) {
        const t = this._data
          , r = this._cachedMeta.data;
        for (const [a,l,u] of this._syncList)
            this[a](l, u);
        this._syncList = [];
        const s = r.length
          , i = t.length
          , o = Math.min(i, s);
        o && this.parse(0, o),
        i > s ? this._insertElements(s, i - s, e) : i < s && this._removeElements(i, s - i)
    }
    _insertElements(e, t, r=!0) {
        const s = this._cachedMeta
          , i = s.data
          , o = e + t;
        let a;
        const l = u => {
            for (u.length += t,
            a = u.length - 1; a >= o; a--)
                u[a] = u[a - t]
        }
        ;
        for (l(i),
        a = e; a < o; ++a)
            i[a] = new this.dataElementType;
        this._parsing && l(s._parsed),
        this.parse(e, t),
        r && this.updateElements(i, e, t, "reset")
    }
    updateElements(e, t, r, s) {}
    _removeElements(e, t) {
        const r = this._cachedMeta;
        if (this._parsing) {
            const s = r._parsed.splice(e, t);
            r._stacked && cg(r, s)
        }
        r.data.splice(e, t)
    }
    _sync(e) {
        if (this._parsing)
            this._syncList.push(e);
        else {
            const [t,r,s] = e;
            this[t](r, s)
        }
        this.chart._dataChanges.push([this.index, ...e])
    }
    _onDataPush() {
        const e = arguments.length;
        this._sync(["_insertElements", this.getDataset().data.length - e, e])
    }
    _onDataPop() {
        this._sync(["_removeElements", this._cachedMeta.data.length - 1, 1])
    }
    _onDataShift() {
        this._sync(["_removeElements", 0, 1])
    }
    _onDataSplice(e, t) {
        t && this._sync(["_removeElements", e, t]);
        const r = arguments.length - 2;
        r && this._sync(["_insertElements", e, r])
    }
    _onDataUnshift() {
        this._sync(["_insertElements", 0, arguments.length])
    }
}
function Ud() {
    throw new Error("This method is not implemented: Check that a complete date adapter is provided.")
}
class Vk {
    static override(e) {
        Object.assign(Vk.prototype, e)
    }
    options;
    constructor(e) {
        this.options = e || {}
    }
    init() {}
    formats() {
        return Ud()
    }
    parse() {
        return Ud()
    }
    format() {
        return Ud()
    }
    add() {
        return Ud()
    }
    diff() {
        return Ud()
    }
    startOf() {
        return Ud()
    }
    endOf() {
        return Ud()
    }
}
var lRe = {
    _date: Vk
};
function cRe(n, e, t, r) {
    const {controller: s, data: i, _sorted: o} = n
      , a = s._cachedMeta.iScale
      , l = n.dataset && n.dataset.options ? n.dataset.options.spanGaps : null;
    if (a && e === a.axis && e !== "r" && o && i.length) {
        const u = a._reversePixels ? UMe : a8;
        if (r) {
            if (s._sharedOptions) {
                const d = i[0]
                  , h = typeof d.getRange == "function" && d.getRange(e);
                if (h) {
                    const p = u(i, e, t - h)
                      , g = u(i, e, t + h);
                    return {
                        lo: p.lo,
                        hi: g.hi
                    }
                }
            }
        } else {
            const d = u(i, e, t);
            if (l) {
                const {vScale: h} = s._cachedMeta
                  , {_parsed: p} = n
                  , g = p.slice(0, d.lo + 1).reverse().findIndex(b => !sr(b[h.axis]));
                d.lo -= Math.max(0, g);
                const w = p.slice(d.hi).findIndex(b => !sr(b[h.axis]));
                d.hi += Math.max(0, w)
            }
            return d
        }
    }
    return {
        lo: 0,
        hi: i.length - 1
    }
}
function Yx(n, e, t, r, s) {
    const i = n.getSortedVisibleDatasetMetas()
      , o = t[e];
    for (let a = 0, l = i.length; a < l; ++a) {
        const {index: u, data: d} = i[a]
          , {lo: h, hi: p} = cRe(i[a], e, o, s);
        for (let g = h; g <= p; ++g) {
            const w = d[g];
            w.skip || r(w, u, g)
        }
    }
}
function uRe(n) {
    const e = n.indexOf("x") !== -1
      , t = n.indexOf("y") !== -1;
    return function(r, s) {
        const i = e ? Math.abs(r.x - s.x) : 0
          , o = t ? Math.abs(r.y - s.y) : 0;
        return Math.sqrt(Math.pow(i, 2) + Math.pow(o, 2))
    }
}
function JA(n, e, t, r, s) {
    const i = [];
    return !s && !n.isPointInArea(e) || Yx(n, t, e, function(a, l, u) {
        !s && !hy(a, n.chartArea, 0) || a.inRange(e.x, e.y, r) && i.push({
            element: a,
            datasetIndex: l,
            index: u
        })
    }, !0),
    i
}
function dRe(n, e, t, r) {
    let s = [];
    function i(o, a, l) {
        const {startAngle: u, endAngle: d} = o.getProps(["startAngle", "endAngle"], r)
          , {angle: h} = jMe(o, {
            x: e.x,
            y: e.y
        });
        YG(h, u, d) && s.push({
            element: o,
            datasetIndex: a,
            index: l
        })
    }
    return Yx(n, t, e, i),
    s
}
function fRe(n, e, t, r, s, i) {
    let o = [];
    const a = uRe(t);
    let l = Number.POSITIVE_INFINITY;
    function u(d, h, p) {
        const g = d.inRange(e.x, e.y, s);
        if (r && !g)
            return;
        const w = d.getCenterPoint(s);
        if (!(!!i || n.isPointInArea(w)) && !g)
            return;
        const v = a(e, w);
        v < l ? (o = [{
            element: d,
            datasetIndex: h,
            index: p
        }],
        l = v) : v === l && o.push({
            element: d,
            datasetIndex: h,
            index: p
        })
    }
    return Yx(n, t, e, u),
    o
}
function e4(n, e, t, r, s, i) {
    return !i && !n.isPointInArea(e) ? [] : t === "r" && !r ? dRe(n, e, t, s) : fRe(n, e, t, r, s, i)
}
function Yj(n, e, t, r, s) {
    const i = []
      , o = t === "x" ? "inXRange" : "inYRange";
    let a = !1;
    return Yx(n, t, e, (l, u, d) => {
        l[o] && l[o](e[t], s) && (i.push({
            element: l,
            datasetIndex: u,
            index: d
        }),
        a = a || l.inRange(e.x, e.y, s))
    }
    ),
    r && !a ? [] : i
}
var hRe = {
    modes: {
        index(n, e, t, r) {
            const s = Wd(e, n)
              , i = t.axis || "x"
              , o = t.includeInvisible || !1
              , a = t.intersect ? JA(n, s, i, r, o) : e4(n, s, i, !1, r, o)
              , l = [];
            return a.length ? (n.getSortedVisibleDatasetMetas().forEach(u => {
                const d = a[0].index
                  , h = u.data[d];
                h && !h.skip && l.push({
                    element: h,
                    datasetIndex: u.index,
                    index: d
                })
            }
            ),
            l) : []
        },
        dataset(n, e, t, r) {
            const s = Wd(e, n)
              , i = t.axis || "xy"
              , o = t.includeInvisible || !1;
            let a = t.intersect ? JA(n, s, i, r, o) : e4(n, s, i, !1, r, o);
            if (a.length > 0) {
                const l = a[0].datasetIndex
                  , u = n.getDatasetMeta(l).data;
                a = [];
                for (let d = 0; d < u.length; ++d)
                    a.push({
                        element: u[d],
                        datasetIndex: l,
                        index: d
                    })
            }
            return a
        },
        point(n, e, t, r) {
            const s = Wd(e, n)
              , i = t.axis || "xy"
              , o = t.includeInvisible || !1;
            return JA(n, s, i, r, o)
        },
        nearest(n, e, t, r) {
            const s = Wd(e, n)
              , i = t.axis || "xy"
              , o = t.includeInvisible || !1;
            return e4(n, s, i, t.intersect, r, o)
        },
        x(n, e, t, r) {
            const s = Wd(e, n);
            return Yj(n, s, "x", t.intersect, r)
        },
        y(n, e, t, r) {
            const s = Wd(e, n);
            return Yj(n, s, "y", t.intersect, r)
        }
    }
};
const gW = ["left", "top", "right", "bottom"];
function ug(n, e) {
    return n.filter(t => t.pos === e)
}
function Kj(n, e) {
    return n.filter(t => gW.indexOf(t.pos) === -1 && t.box.axis === e)
}
function dg(n, e) {
    return n.sort( (t, r) => {
        const s = e ? r : t
          , i = e ? t : r;
        return s.weight === i.weight ? s.index - i.index : s.weight - i.weight
    }
    )
}
function pRe(n) {
    const e = [];
    let t, r, s, i, o, a;
    for (t = 0,
    r = (n || []).length; t < r; ++t)
        s = n[t],
        {position: i, options: {stack: o, stackWeight: a=1}} = s,
        e.push({
            index: t,
            box: s,
            pos: i,
            horizontal: s.isHorizontal(),
            weight: s.weight,
            stack: o && i + o,
            stackWeight: a
        });
    return e
}
function mRe(n) {
    const e = {};
    for (const t of n) {
        const {stack: r, pos: s, stackWeight: i} = t;
        if (!r || !gW.includes(s))
            continue;
        const o = e[r] || (e[r] = {
            count: 0,
            placed: 0,
            weight: 0,
            size: 0
        });
        o.count++,
        o.weight += i
    }
    return e
}
function gRe(n, e) {
    const t = mRe(n)
      , {vBoxMaxWidth: r, hBoxMaxHeight: s} = e;
    let i, o, a;
    for (i = 0,
    o = n.length; i < o; ++i) {
        a = n[i];
        const {fullSize: l} = a.box
          , u = t[a.stack]
          , d = u && a.stackWeight / u.weight;
        a.horizontal ? (a.width = d ? d * r : l && e.availableWidth,
        a.height = s) : (a.width = r,
        a.height = d ? d * s : l && e.availableHeight)
    }
    return t
}
function yRe(n) {
    const e = pRe(n)
      , t = dg(e.filter(u => u.box.fullSize), !0)
      , r = dg(ug(e, "left"), !0)
      , s = dg(ug(e, "right"))
      , i = dg(ug(e, "top"), !0)
      , o = dg(ug(e, "bottom"))
      , a = Kj(e, "x")
      , l = Kj(e, "y");
    return {
        fullSize: t,
        leftAndTop: r.concat(i),
        rightAndBottom: s.concat(l).concat(o).concat(a),
        chartArea: ug(e, "chartArea"),
        vertical: r.concat(s).concat(l),
        horizontal: i.concat(o).concat(a)
    }
}
function Xj(n, e, t, r) {
    return Math.max(n[t], e[t]) + Math.max(n[r], e[r])
}
function yW(n, e) {
    n.top = Math.max(n.top, e.top),
    n.left = Math.max(n.left, e.left),
    n.bottom = Math.max(n.bottom, e.bottom),
    n.right = Math.max(n.right, e.right)
}
function bRe(n, e, t, r) {
    const {pos: s, box: i} = t
      , o = n.maxPadding;
    if (!an(s)) {
        t.size && (n[s] -= t.size);
        const h = r[t.stack] || {
            size: 0,
            count: 1
        };
        h.size = Math.max(h.size, t.horizontal ? i.height : i.width),
        t.size = h.size / h.count,
        n[s] += t.size
    }
    i.getPadding && yW(o, i.getPadding());
    const a = Math.max(0, e.outerWidth - Xj(o, n, "left", "right"))
      , l = Math.max(0, e.outerHeight - Xj(o, n, "top", "bottom"))
      , u = a !== n.w
      , d = l !== n.h;
    return n.w = a,
    n.h = l,
    t.horizontal ? {
        same: u,
        other: d
    } : {
        same: d,
        other: u
    }
}
function wRe(n) {
    const e = n.maxPadding;
    function t(r) {
        const s = Math.max(e[r] - n[r], 0);
        return n[r] += s,
        s
    }
    n.y += t("top"),
    n.x += t("left"),
    t("right"),
    t("bottom")
}
function vRe(n, e) {
    const t = e.maxPadding;
    function r(s) {
        const i = {
            left: 0,
            top: 0,
            right: 0,
            bottom: 0
        };
        return s.forEach(o => {
            i[o] = Math.max(e[o], t[o])
        }
        ),
        i
    }
    return r(n ? ["left", "right"] : ["top", "bottom"])
}
function Sg(n, e, t, r) {
    const s = [];
    let i, o, a, l, u, d;
    for (i = 0,
    o = n.length,
    u = 0; i < o; ++i) {
        a = n[i],
        l = a.box,
        l.update(a.width || e.w, a.height || e.h, vRe(a.horizontal, e));
        const {same: h, other: p} = bRe(e, t, a, r);
        u |= h && s.length,
        d = d || p,
        l.fullSize || s.push(a)
    }
    return u && Sg(s, e, t, r) || d
}
function _w(n, e, t, r, s) {
    n.top = t,
    n.left = e,
    n.right = e + r,
    n.bottom = t + s,
    n.width = r,
    n.height = s
}
function Qj(n, e, t, r) {
    const s = t.padding;
    let {x: i, y: o} = e;
    for (const a of n) {
        const l = a.box
          , u = r[a.stack] || {
            placed: 0,
            weight: 1
        }
          , d = a.stackWeight / u.weight || 1;
        if (a.horizontal) {
            const h = e.w * d
              , p = u.size || l.height;
            bv(u.start) && (o = u.start),
            l.fullSize ? _w(l, s.left, o, t.outerWidth - s.right - s.left, p) : _w(l, e.left + u.placed, o, h, p),
            u.start = o,
            u.placed += h,
            o = l.bottom
        } else {
            const h = e.h * d
              , p = u.size || l.width;
            bv(u.start) && (i = u.start),
            l.fullSize ? _w(l, i, s.top, p, t.outerHeight - s.bottom - s.top) : _w(l, i, e.top + u.placed, p, h),
            u.start = i,
            u.placed += h,
            i = l.right
        }
    }
    e.x = i,
    e.y = o
}
var $u = {
    addBox(n, e) {
        n.boxes || (n.boxes = []),
        e.fullSize = e.fullSize || !1,
        e.position = e.position || "top",
        e.weight = e.weight || 0,
        e._layers = e._layers || function() {
            return [{
                z: 0,
                draw(t) {
                    e.draw(t)
                }
            }]
        }
        ,
        n.boxes.push(e)
    },
    removeBox(n, e) {
        const t = n.boxes ? n.boxes.indexOf(e) : -1;
        t !== -1 && n.boxes.splice(t, 1)
    },
    configure(n, e, t) {
        e.fullSize = t.fullSize,
        e.position = t.position,
        e.weight = t.weight
    },
    update(n, e, t, r) {
        if (!n)
            return;
        const s = pa(n.options.layout.padding)
          , i = Math.max(e - s.width, 0)
          , o = Math.max(t - s.height, 0)
          , a = yRe(n.boxes)
          , l = a.vertical
          , u = a.horizontal;
        _n(n.boxes, b => {
            typeof b.beforeLayout == "function" && b.beforeLayout()
        }
        );
        const d = l.reduce( (b, v) => v.box.options && v.box.options.display === !1 ? b : b + 1, 0) || 1
          , h = Object.freeze({
            outerWidth: e,
            outerHeight: t,
            padding: s,
            availableWidth: i,
            availableHeight: o,
            vBoxMaxWidth: i / 2 / d,
            hBoxMaxHeight: o / 2
        })
          , p = Object.assign({}, s);
        yW(p, pa(r));
        const g = Object.assign({
            maxPadding: p,
            w: i,
            h: o,
            x: s.left,
            y: s.top
        }, s)
          , w = gRe(l.concat(u), h);
        Sg(a.fullSize, g, h, w),
        Sg(l, g, h, w),
        Sg(u, g, h, w) && Sg(l, g, h, w),
        wRe(g),
        Qj(a.leftAndTop, g, h, w),
        g.x += g.w,
        g.y += g.h,
        Qj(a.rightAndBottom, g, h, w),
        n.chartArea = {
            left: g.left,
            top: g.top,
            right: g.left + g.w,
            bottom: g.top + g.h,
            height: g.h,
            width: g.w
        },
        _n(a.chartArea, b => {
            const v = b.box;
            Object.assign(v, n.chartArea),
            v.update(g.w, g.h, {
                left: 0,
                top: 0,
                right: 0,
                bottom: 0
            })
        }
        )
    }
};
class bW {
    acquireContext(e, t) {}
    releaseContext(e) {
        return !1
    }
    addEventListener(e, t, r) {}
    removeEventListener(e, t, r) {}
    getDevicePixelRatio() {
        return 1
    }
    getMaximumSize(e, t, r, s) {
        return t = Math.max(0, t || e.width),
        r = r || e.height,
        {
            width: t,
            height: Math.max(0, s ? Math.floor(t / s) : r)
        }
    }
    isAttached(e) {
        return !0
    }
    updateConfig(e) {}
}
class xRe extends bW {
    acquireContext(e) {
        return e && e.getContext && e.getContext("2d") || null
    }
    updateConfig(e) {
        e.options.animation = !1
    }
}
const s2 = "$chartjs"
  , ERe = {
    touchstart: "mousedown",
    touchmove: "mousemove",
    touchend: "mouseup",
    pointerenter: "mouseenter",
    pointerdown: "mousedown",
    pointermove: "mousemove",
    pointerup: "mouseup",
    pointerleave: "mouseout",
    pointerout: "mouseout"
}
  , Zj = n => n === null || n === "";
function SRe(n, e) {
    const t = n.style
      , r = n.getAttribute("height")
      , s = n.getAttribute("width");
    if (n[s2] = {
        initial: {
            height: r,
            width: s,
            style: {
                display: t.display,
                height: t.height,
                width: t.width
            }
        }
    },
    t.display = t.display || "block",
    t.boxSizing = t.boxSizing || "border-box",
    Zj(s)) {
        const i = Lj(n, "width");
        i !== void 0 && (n.width = i)
    }
    if (Zj(r))
        if (n.style.height === "")
            n.height = n.width / (e || 2);
        else {
            const i = Lj(n, "height");
            i !== void 0 && (n.height = i)
        }
    return n
}
const wW = OBe ? {
    passive: !0
} : !1;
function ARe(n, e, t) {
    n && n.addEventListener(e, t, wW)
}
function CRe(n, e, t) {
    n && n.canvas && n.canvas.removeEventListener(e, t, wW)
}
function _Re(n, e) {
    const t = ERe[n.type] || n.type
      , {x: r, y: s} = Wd(n, e);
    return {
        type: t,
        chart: e,
        native: n,
        x: r !== void 0 ? r : null,
        y: s !== void 0 ? s : null
    }
}
function Sv(n, e) {
    for (const t of n)
        if (t === e || t.contains(e))
            return !0
}
function kRe(n, e, t) {
    const r = n.canvas
      , s = new MutationObserver(i => {
        let o = !1;
        for (const a of i)
            o = o || Sv(a.addedNodes, r),
            o = o && !Sv(a.removedNodes, r);
        o && t()
    }
    );
    return s.observe(document, {
        childList: !0,
        subtree: !0
    }),
    s
}
function NRe(n, e, t) {
    const r = n.canvas
      , s = new MutationObserver(i => {
        let o = !1;
        for (const a of i)
            o = o || Sv(a.removedNodes, r),
            o = o && !Sv(a.addedNodes, r);
        o && t()
    }
    );
    return s.observe(document, {
        childList: !0,
        subtree: !0
    }),
    s
}
const py = new Map;
let Jj = 0;
function vW() {
    const n = window.devicePixelRatio;
    n !== Jj && (Jj = n,
    py.forEach( (e, t) => {
        t.currentDevicePixelRatio !== n && e()
    }
    ))
}
function DRe(n, e) {
    py.size || window.addEventListener("resize", vW),
    py.set(n, e)
}
function TRe(n) {
    py.delete(n),
    py.size || window.removeEventListener("resize", vW)
}
function IRe(n, e, t) {
    const r = n.canvas
      , s = r && Hk(r);
    if (!s)
        return;
    const i = QG( (a, l) => {
        const u = s.clientWidth;
        t(a, l),
        u < s.clientWidth && t()
    }
    , window)
      , o = new ResizeObserver(a => {
        const l = a[0]
          , u = l.contentRect.width
          , d = l.contentRect.height;
        u === 0 && d === 0 || i(u, d)
    }
    );
    return o.observe(s),
    DRe(n, i),
    o
}
function t4(n, e, t) {
    t && t.disconnect(),
    e === "resize" && TRe(n)
}
function MRe(n, e, t) {
    const r = n.canvas
      , s = QG(i => {
        n.ctx !== null && t(_Re(i, n))
    }
    , n);
    return ARe(r, e, s),
    s
}
class BRe extends bW {
    acquireContext(e, t) {
        const r = e && e.getContext && e.getContext("2d");
        return r && r.canvas === e ? (SRe(e, t),
        r) : null
    }
    releaseContext(e) {
        const t = e.canvas;
        if (!t[s2])
            return !1;
        const r = t[s2].initial;
        ["height", "width"].forEach(i => {
            const o = r[i];
            sr(o) ? t.removeAttribute(i) : t.setAttribute(i, o)
        }
        );
        const s = r.style || {};
        return Object.keys(s).forEach(i => {
            t.style[i] = s[i]
        }
        ),
        t.width = t.width,
        delete t[s2],
        !0
    }
    addEventListener(e, t, r) {
        this.removeEventListener(e, t);
        const s = e.$proxies || (e.$proxies = {})
          , o = {
            attach: kRe,
            detach: NRe,
            resize: IRe
        }[t] || MRe;
        s[t] = o(e, t, r)
    }
    removeEventListener(e, t) {
        const r = e.$proxies || (e.$proxies = {})
          , s = r[t];
        if (!s)
            return;
        ({
            attach: t4,
            detach: t4,
            resize: t4
        }[t] || CRe)(e, t, s),
        r[t] = void 0
    }
    getDevicePixelRatio() {
        return window.devicePixelRatio
    }
    getMaximumSize(e, t, r, s) {
        return RBe(e, t, r, s)
    }
    isAttached(e) {
        const t = e && Hk(e);
        return !!(t && t.isConnected)
    }
}
function RRe(n) {
    return !$k() || typeof OffscreenCanvas < "u" && n instanceof OffscreenCanvas ? xRe : BRe
}
let j0 = class {
    static defaults = {};
    static defaultRoutes = void 0;
    x;
    y;
    active = !1;
    options;
    $animations;
    tooltipPosition(e) {
        const {x: t, y: r} = this.getProps(["x", "y"], e);
        return {
            x: t,
            y: r
        }
    }
    hasValue() {
        return vv(this.x) && vv(this.y)
    }
    getProps(e, t) {
        const r = this.$animations;
        if (!t || !r)
            return this;
        const s = {};
        return e.forEach(i => {
            s[i] = r[i] && r[i].active() ? r[i]._to : this[i]
        }
        ),
        s
    }
}
;
function ORe(n, e) {
    const t = n.options.ticks
      , r = PRe(n)
      , s = Math.min(t.maxTicksLimit || r, r)
      , i = t.major.enabled ? LRe(e) : []
      , o = i.length
      , a = i[0]
      , l = i[o - 1]
      , u = [];
    if (o > s)
        return FRe(e, u, i, o / s),
        u;
    const d = jRe(i, e, s);
    if (o > 0) {
        let h, p;
        const g = o > 1 ? Math.round((l - a) / (o - 1)) : null;
        for (kw(e, u, d, sr(g) ? 0 : a - g, a),
        h = 0,
        p = o - 1; h < p; h++)
            kw(e, u, d, i[h], i[h + 1]);
        return kw(e, u, d, l, sr(g) ? e.length : l + g),
        u
    }
    return kw(e, u, d),
    u
}
function PRe(n) {
    const e = n.options.offset
      , t = n._tickSize()
      , r = n._length / t + (e ? 0 : 1)
      , s = n._maxLength / t;
    return Math.floor(Math.min(r, s))
}
function jRe(n, e, t) {
    const r = URe(n)
      , s = e.length / t;
    if (!r)
        return Math.max(s, 1);
    const i = MMe(r);
    for (let o = 0, a = i.length - 1; o < a; o++) {
        const l = i[o];
        if (l > s)
            return l
    }
    return Math.max(s, 1)
}
function LRe(n) {
    const e = [];
    let t, r;
    for (t = 0,
    r = n.length; t < r; t++)
        n[t].major && e.push(t);
    return e
}
function FRe(n, e, t, r) {
    let s = 0, i = t[0], o;
    for (r = Math.ceil(r),
    o = 0; o < n.length; o++)
        o === i && (e.push(n[o]),
        s++,
        i = t[s * r])
}
function kw(n, e, t, r, s) {
    const i = on(r, 0)
      , o = Math.min(on(s, n.length), n.length);
    let a = 0, l, u, d;
    for (t = Math.ceil(t),
    s && (l = s - r,
    t = l / Math.floor(l / t)),
    d = i; d < 0; )
        a++,
        d = Math.round(i + a * t);
    for (u = Math.max(i, 0); u < o; u++)
        u === d && (e.push(n[u]),
        a++,
        d = Math.round(i + a * t))
}
function URe(n) {
    const e = n.length;
    let t, r;
    if (e < 2)
        return !1;
    for (r = n[0],
    t = 1; t < e; ++t)
        if (n[t] - n[t - 1] !== r)
            return !1;
    return r
}
const zRe = n => n === "left" ? "right" : n === "right" ? "left" : n
  , e9 = (n, e, t) => e === "top" || e === "left" ? n[e] + t : n[e] - t
  , t9 = (n, e) => Math.min(e || n, n);
function n9(n, e) {
    const t = []
      , r = n.length / e
      , s = n.length;
    let i = 0;
    for (; i < s; i += r)
        t.push(n[Math.floor(i)]);
    return t
}
function $Re(n, e, t) {
    const r = n.ticks.length
      , s = Math.min(e, r - 1)
      , i = n._startPixel
      , o = n._endPixel
      , a = 1e-6;
    let l = n.getPixelForTick(s), u;
    if (!(t && (r === 1 ? u = Math.max(l - i, o - l) : e === 0 ? u = (n.getPixelForTick(1) - l) / 2 : u = (l - n.getPixelForTick(s - 1)) / 2,
    l += s < e ? u : -u,
    l < i - a || l > o + a)))
        return l
}
function HRe(n, e) {
    _n(n, t => {
        const r = t.gc
          , s = r.length / 2;
        let i;
        if (s > e) {
            for (i = 0; i < s; ++i)
                delete t.data[r[i]];
            r.splice(0, s)
        }
    }
    )
}
function fg(n) {
    return n.drawTicks ? n.tickLength : 0
}
function r9(n, e) {
    if (!n.display)
        return 0;
    const t = ki(n.font, e)
      , r = pa(n.padding);
    return (ns(n.text) ? n.text.length : 1) * t.lineHeight + r.height
}
function VRe(n, e) {
    return nh(n, {
        scale: e,
        type: "scale"
    })
}
function qRe(n, e, t) {
    return nh(n, {
        tick: t,
        index: e,
        type: "tick"
    })
}
function GRe(n, e, t) {
    let r = ZG(n);
    return (t && e !== "right" || !t && e === "right") && (r = zRe(r)),
    r
}
function WRe(n, e, t, r) {
    const {top: s, left: i, bottom: o, right: a, chart: l} = n
      , {chartArea: u, scales: d} = l;
    let h = 0, p, g, w;
    const b = o - s
      , v = a - i;
    if (n.isHorizontal()) {
        if (g = Hi(r, i, a),
        an(t)) {
            const S = Object.keys(t)[0]
              , N = t[S];
            w = d[S].getPixelForValue(N) + b - e
        } else
            t === "center" ? w = (u.bottom + u.top) / 2 + b - e : w = e9(n, t, e);
        p = a - i
    } else {
        if (an(t)) {
            const S = Object.keys(t)[0]
              , N = t[S];
            g = d[S].getPixelForValue(N) - v + e
        } else
            t === "center" ? g = (u.left + u.right) / 2 - v + e : g = e9(n, t, e);
        w = Hi(r, o, s),
        h = t === "left" ? -aa : aa
    }
    return {
        titleX: g,
        titleY: w,
        maxWidth: p,
        rotation: h
    }
}
class L0 extends j0 {
    constructor(e) {
        super(),
        this.id = e.id,
        this.type = e.type,
        this.options = void 0,
        this.ctx = e.ctx,
        this.chart = e.chart,
        this.top = void 0,
        this.bottom = void 0,
        this.left = void 0,
        this.right = void 0,
        this.width = void 0,
        this.height = void 0,
        this._margins = {
            left: 0,
            right: 0,
            top: 0,
            bottom: 0
        },
        this.maxWidth = void 0,
        this.maxHeight = void 0,
        this.paddingTop = void 0,
        this.paddingBottom = void 0,
        this.paddingLeft = void 0,
        this.paddingRight = void 0,
        this.axis = void 0,
        this.labelRotation = void 0,
        this.min = void 0,
        this.max = void 0,
        this._range = void 0,
        this.ticks = [],
        this._gridLineItems = null,
        this._labelItems = null,
        this._labelSizes = null,
        this._length = 0,
        this._maxLength = 0,
        this._longestTextCache = {},
        this._startPixel = void 0,
        this._endPixel = void 0,
        this._reversePixels = !1,
        this._userMax = void 0,
        this._userMin = void 0,
        this._suggestedMax = void 0,
        this._suggestedMin = void 0,
        this._ticksLength = 0,
        this._borderValue = 0,
        this._cache = {},
        this._dataLimitsCached = !1,
        this.$context = void 0
    }
    init(e) {
        this.options = e.setContext(this.getContext()),
        this.axis = e.axis,
        this._userMin = this.parse(e.min),
        this._userMax = this.parse(e.max),
        this._suggestedMin = this.parse(e.suggestedMin),
        this._suggestedMax = this.parse(e.suggestedMax)
    }
    parse(e, t) {
        return e
    }
    getUserBounds() {
        let {_userMin: e, _userMax: t, _suggestedMin: r, _suggestedMax: s} = this;
        return e = Ma(e, Number.POSITIVE_INFINITY),
        t = Ma(t, Number.NEGATIVE_INFINITY),
        r = Ma(r, Number.POSITIVE_INFINITY),
        s = Ma(s, Number.NEGATIVE_INFINITY),
        {
            min: Ma(e, r),
            max: Ma(t, s),
            minDefined: $s(e),
            maxDefined: $s(t)
        }
    }
    getMinMax(e) {
        let {min: t, max: r, minDefined: s, maxDefined: i} = this.getUserBounds(), o;
        if (s && i)
            return {
                min: t,
                max: r
            };
        const a = this.getMatchingVisibleMetas();
        for (let l = 0, u = a.length; l < u; ++l)
            o = a[l].controller.getMinMax(this, e),
            s || (t = Math.min(t, o.min)),
            i || (r = Math.max(r, o.max));
        return t = i && t > r ? r : t,
        r = s && t > r ? t : r,
        {
            min: Ma(t, Ma(r, t)),
            max: Ma(r, Ma(t, r))
        }
    }
    getPadding() {
        return {
            left: this.paddingLeft || 0,
            top: this.paddingTop || 0,
            right: this.paddingRight || 0,
            bottom: this.paddingBottom || 0
        }
    }
    getTicks() {
        return this.ticks
    }
    getLabels() {
        const e = this.chart.data;
        return this.options.labels || (this.isHorizontal() ? e.xLabels : e.yLabels) || e.labels || []
    }
    getLabelItems(e=this.chart.chartArea) {
        return this._labelItems || (this._labelItems = this._computeLabelItems(e))
    }
    beforeLayout() {
        this._cache = {},
        this._dataLimitsCached = !1
    }
    beforeUpdate() {
        Wn(this.options.beforeUpdate, [this])
    }
    update(e, t, r) {
        const {beginAtZero: s, grace: i, ticks: o} = this.options
          , a = o.sampleSize;
        this.beforeUpdate(),
        this.maxWidth = e,
        this.maxHeight = t,
        this._margins = r = Object.assign({
            left: 0,
            right: 0,
            top: 0,
            bottom: 0
        }, r),
        this.ticks = null,
        this._labelSizes = null,
        this._gridLineItems = null,
        this._labelItems = null,
        this.beforeSetDimensions(),
        this.setDimensions(),
        this.afterSetDimensions(),
        this._maxLength = this.isHorizontal() ? this.width + r.left + r.right : this.height + r.top + r.bottom,
        this._dataLimitsCached || (this.beforeDataLimits(),
        this.determineDataLimits(),
        this.afterDataLimits(),
        this._range = fBe(this, i, s),
        this._dataLimitsCached = !0),
        this.beforeBuildTicks(),
        this.ticks = this.buildTicks() || [],
        this.afterBuildTicks();
        const l = a < this.ticks.length;
        this._convertTicksToLabels(l ? n9(this.ticks, a) : this.ticks),
        this.configure(),
        this.beforeCalculateLabelRotation(),
        this.calculateLabelRotation(),
        this.afterCalculateLabelRotation(),
        o.display && (o.autoSkip || o.source === "auto") && (this.ticks = ORe(this, this.ticks),
        this._labelSizes = null,
        this.afterAutoSkip()),
        l && this._convertTicksToLabels(this.ticks),
        this.beforeFit(),
        this.fit(),
        this.afterFit(),
        this.afterUpdate()
    }
    configure() {
        let e = this.options.reverse, t, r;
        this.isHorizontal() ? (t = this.left,
        r = this.right) : (t = this.top,
        r = this.bottom,
        e = !e),
        this._startPixel = t,
        this._endPixel = r,
        this._reversePixels = e,
        this._length = r - t,
        this._alignToPixels = this.options.alignToPixels
    }
    afterUpdate() {
        Wn(this.options.afterUpdate, [this])
    }
    beforeSetDimensions() {
        Wn(this.options.beforeSetDimensions, [this])
    }
    setDimensions() {
        this.isHorizontal() ? (this.width = this.maxWidth,
        this.left = 0,
        this.right = this.width) : (this.height = this.maxHeight,
        this.top = 0,
        this.bottom = this.height),
        this.paddingLeft = 0,
        this.paddingTop = 0,
        this.paddingRight = 0,
        this.paddingBottom = 0
    }
    afterSetDimensions() {
        Wn(this.options.afterSetDimensions, [this])
    }
    _callHooks(e) {
        this.chart.notifyPlugins(e, this.getContext()),
        Wn(this.options[e], [this])
    }
    beforeDataLimits() {
        this._callHooks("beforeDataLimits")
    }
    determineDataLimits() {}
    afterDataLimits() {
        this._callHooks("afterDataLimits")
    }
    beforeBuildTicks() {
        this._callHooks("beforeBuildTicks")
    }
    buildTicks() {
        return []
    }
    afterBuildTicks() {
        this._callHooks("afterBuildTicks")
    }
    beforeTickToLabelConversion() {
        Wn(this.options.beforeTickToLabelConversion, [this])
    }
    generateTickLabels(e) {
        const t = this.options.ticks;
        let r, s, i;
        for (r = 0,
        s = e.length; r < s; r++)
            i = e[r],
            i.label = Wn(t.callback, [i.value, r, e], this)
    }
    afterTickToLabelConversion() {
        Wn(this.options.afterTickToLabelConversion, [this])
    }
    beforeCalculateLabelRotation() {
        Wn(this.options.beforeCalculateLabelRotation, [this])
    }
    calculateLabelRotation() {
        const e = this.options
          , t = e.ticks
          , r = t9(this.ticks.length, e.ticks.maxTicksLimit)
          , s = t.minRotation || 0
          , i = t.maxRotation;
        let o = s, a, l, u;
        if (!this._isVisible() || !t.display || s >= i || r <= 1 || !this.isHorizontal()) {
            this.labelRotation = s;
            return
        }
        const d = this._getLabelSizes()
          , h = d.widest.width
          , p = d.highest.height
          , g = Xa(this.chart.width - h, 0, this.maxWidth);
        a = e.offset ? this.maxWidth / r : g / (r - 1),
        h + 6 > a && (a = g / (r - (e.offset ? .5 : 1)),
        l = this.maxHeight - fg(e.grid) - t.padding - r9(e.title, this.chart.options.font),
        u = Math.sqrt(h * h + p * p),
        o = PMe(Math.min(Math.asin(Xa((d.highest.height + 6) / a, -1, 1)), Math.asin(Xa(l / u, -1, 1)) - Math.asin(Xa(p / u, -1, 1)))),
        o = Math.max(s, Math.min(i, o))),
        this.labelRotation = o
    }
    afterCalculateLabelRotation() {
        Wn(this.options.afterCalculateLabelRotation, [this])
    }
    afterAutoSkip() {}
    beforeFit() {
        Wn(this.options.beforeFit, [this])
    }
    fit() {
        const e = {
            width: 0,
            height: 0
        }
          , {chart: t, options: {ticks: r, title: s, grid: i}} = this
          , o = this._isVisible()
          , a = this.isHorizontal();
        if (o) {
            const l = r9(s, t.options.font);
            if (a ? (e.width = this.maxWidth,
            e.height = fg(i) + l) : (e.height = this.maxHeight,
            e.width = fg(i) + l),
            r.display && this.ticks.length) {
                const {first: u, last: d, widest: h, highest: p} = this._getLabelSizes()
                  , g = r.padding * 2
                  , w = wf(this.labelRotation)
                  , b = Math.cos(w)
                  , v = Math.sin(w);
                if (a) {
                    const S = r.mirror ? 0 : v * h.width + b * p.height;
                    e.height = Math.min(this.maxHeight, e.height + S + g)
                } else {
                    const S = r.mirror ? 0 : b * h.width + v * p.height;
                    e.width = Math.min(this.maxWidth, e.width + S + g)
                }
                this._calculatePadding(u, d, v, b)
            }
        }
        this._handleMargins(),
        a ? (this.width = this._length = t.width - this._margins.left - this._margins.right,
        this.height = e.height) : (this.width = e.width,
        this.height = this._length = t.height - this._margins.top - this._margins.bottom)
    }
    _calculatePadding(e, t, r, s) {
        const {ticks: {align: i, padding: o}, position: a} = this.options
          , l = this.labelRotation !== 0
          , u = a !== "top" && this.axis === "x";
        if (this.isHorizontal()) {
            const d = this.getPixelForTick(0) - this.left
              , h = this.right - this.getPixelForTick(this.ticks.length - 1);
            let p = 0
              , g = 0;
            l ? u ? (p = s * e.width,
            g = r * t.height) : (p = r * e.height,
            g = s * t.width) : i === "start" ? g = t.width : i === "end" ? p = e.width : i !== "inner" && (p = e.width / 2,
            g = t.width / 2),
            this.paddingLeft = Math.max((p - d + o) * this.width / (this.width - d), 0),
            this.paddingRight = Math.max((g - h + o) * this.width / (this.width - h), 0)
        } else {
            let d = t.height / 2
              , h = e.height / 2;
            i === "start" ? (d = 0,
            h = e.height) : i === "end" && (d = t.height,
            h = 0),
            this.paddingTop = d + o,
            this.paddingBottom = h + o
        }
    }
    _handleMargins() {
        this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left),
        this._margins.top = Math.max(this.paddingTop, this._margins.top),
        this._margins.right = Math.max(this.paddingRight, this._margins.right),
        this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom))
    }
    afterFit() {
        Wn(this.options.afterFit, [this])
    }
    isHorizontal() {
        const {axis: e, position: t} = this.options;
        return t === "top" || t === "bottom" || e === "x"
    }
    isFullSize() {
        return this.options.fullSize
    }
    _convertTicksToLabels(e) {
        this.beforeTickToLabelConversion(),
        this.generateTickLabels(e);
        let t, r;
        for (t = 0,
        r = e.length; t < r; t++)
            sr(e[t].label) && (e.splice(t, 1),
            r--,
            t--);
        this.afterTickToLabelConversion()
    }
    _getLabelSizes() {
        let e = this._labelSizes;
        if (!e) {
            const t = this.options.ticks.sampleSize;
            let r = this.ticks;
            t < r.length && (r = n9(r, t)),
            this._labelSizes = e = this._computeLabelSizes(r, r.length, this.options.ticks.maxTicksLimit)
        }
        return e
    }
    _computeLabelSizes(e, t, r) {
        const {ctx: s, _longestTextCache: i} = this
          , o = []
          , a = []
          , l = Math.floor(t / t9(t, r));
        let u = 0, d = 0, h, p, g, w, b, v, S, N, _, I, k;
        for (h = 0; h < t; h += l) {
            if (w = e[h].label,
            b = this._resolveTickFontOptions(h),
            s.font = v = b.string,
            S = i[v] = i[v] || {
                data: {},
                gc: []
            },
            N = b.lineHeight,
            _ = I = 0,
            !sr(w) && !ns(w))
                _ = Bj(s, S.data, S.gc, _, w),
                I = N;
            else if (ns(w))
                for (p = 0,
                g = w.length; p < g; ++p)
                    k = w[p],
                    !sr(k) && !ns(k) && (_ = Bj(s, S.data, S.gc, _, k),
                    I += N);
            o.push(_),
            a.push(I),
            u = Math.max(_, u),
            d = Math.max(I, d)
        }
        HRe(i, t);
        const B = o.indexOf(u)
          , P = a.indexOf(d)
          , M = R => ({
            width: o[R] || 0,
            height: a[R] || 0
        });
        return {
            first: M(0),
            last: M(t - 1),
            widest: M(B),
            highest: M(P),
            widths: o,
            heights: a
        }
    }
    getLabelForValue(e) {
        return e
    }
    getPixelForValue(e, t) {
        return NaN
    }
    getValueForPixel(e) {}
    getPixelForTick(e) {
        const t = this.ticks;
        return e < 0 || e > t.length - 1 ? null : this.getPixelForValue(t[e].value)
    }
    getPixelForDecimal(e) {
        this._reversePixels && (e = 1 - e);
        const t = this._startPixel + e * this._length;
        return FMe(this._alignToPixels ? Fd(this.chart, t, 0) : t)
    }
    getDecimalForPixel(e) {
        const t = (e - this._startPixel) / this._length;
        return this._reversePixels ? 1 - t : t
    }
    getBasePixel() {
        return this.getPixelForValue(this.getBaseValue())
    }
    getBaseValue() {
        const {min: e, max: t} = this;
        return e < 0 && t < 0 ? t : e > 0 && t > 0 ? e : 0
    }
    getContext(e) {
        const t = this.ticks || [];
        if (e >= 0 && e < t.length) {
            const r = t[e];
            return r.$context || (r.$context = qRe(this.getContext(), e, r))
        }
        return this.$context || (this.$context = VRe(this.chart.getContext(), this))
    }
    _tickSize() {
        const e = this.options.ticks
          , t = wf(this.labelRotation)
          , r = Math.abs(Math.cos(t))
          , s = Math.abs(Math.sin(t))
          , i = this._getLabelSizes()
          , o = e.autoSkipPadding || 0
          , a = i ? i.widest.width + o : 0
          , l = i ? i.highest.height + o : 0;
        return this.isHorizontal() ? l * r > a * s ? a / r : l / s : l * s < a * r ? l / r : a / s
    }
    _isVisible() {
        const e = this.options.display;
        return e !== "auto" ? !!e : this.getMatchingVisibleMetas().length > 0
    }
    _computeGridLineItems(e) {
        const t = this.axis
          , r = this.chart
          , s = this.options
          , {grid: i, position: o, border: a} = s
          , l = i.offset
          , u = this.isHorizontal()
          , h = this.ticks.length + (l ? 1 : 0)
          , p = fg(i)
          , g = []
          , w = a.setContext(this.getContext())
          , b = w.display ? w.width : 0
          , v = b / 2
          , S = function(C) {
            return Fd(r, C, b)
        };
        let N, _, I, k, B, P, M, R, L, q, H, j;
        if (o === "top")
            N = S(this.bottom),
            P = this.bottom - p,
            R = N - v,
            q = S(e.top) + v,
            j = e.bottom;
        else if (o === "bottom")
            N = S(this.top),
            q = e.top,
            j = S(e.bottom) - v,
            P = N + v,
            R = this.top + p;
        else if (o === "left")
            N = S(this.right),
            B = this.right - p,
            M = N - v,
            L = S(e.left) + v,
            H = e.right;
        else if (o === "right")
            N = S(this.left),
            L = e.left,
            H = S(e.right) - v,
            B = N + v,
            M = this.left + p;
        else if (t === "x") {
            if (o === "center")
                N = S((e.top + e.bottom) / 2 + .5);
            else if (an(o)) {
                const C = Object.keys(o)[0]
                  , O = o[C];
                N = S(this.chart.scales[C].getPixelForValue(O))
            }
            q = e.top,
            j = e.bottom,
            P = N + v,
            R = P + p
        } else if (t === "y") {
            if (o === "center")
                N = S((e.left + e.right) / 2);
            else if (an(o)) {
                const C = Object.keys(o)[0]
                  , O = o[C];
                N = S(this.chart.scales[C].getPixelForValue(O))
            }
            B = N - v,
            M = B - p,
            L = e.left,
            H = e.right
        }
        const A = on(s.ticks.maxTicksLimit, h)
          , E = Math.max(1, Math.ceil(h / A));
        for (_ = 0; _ < h; _ += E) {
            const C = this.getContext(_)
              , O = i.setContext(C)
              , z = a.setContext(C)
              , G = O.lineWidth
              , Y = O.color
              , $ = z.dash || []
              , D = z.dashOffset
              , U = O.tickWidth
              , W = O.tickColor
              , Q = O.tickBorderDash || []
              , J = O.tickBorderDashOffset;
            I = $Re(this, _, l),
            I !== void 0 && (k = Fd(r, I, G),
            u ? B = M = L = H = k : P = R = q = j = k,
            g.push({
                tx1: B,
                ty1: P,
                tx2: M,
                ty2: R,
                x1: L,
                y1: q,
                x2: H,
                y2: j,
                width: G,
                color: Y,
                borderDash: $,
                borderDashOffset: D,
                tickWidth: U,
                tickColor: W,
                tickBorderDash: Q,
                tickBorderDashOffset: J
            }))
        }
        return this._ticksLength = h,
        this._borderValue = N,
        g
    }
    _computeLabelItems(e) {
        const t = this.axis
          , r = this.options
          , {position: s, ticks: i} = r
          , o = this.isHorizontal()
          , a = this.ticks
          , {align: l, crossAlign: u, padding: d, mirror: h} = i
          , p = fg(r.grid)
          , g = p + d
          , w = h ? -d : g
          , b = -wf(this.labelRotation)
          , v = [];
        let S, N, _, I, k, B, P, M, R, L, q, H, j = "middle";
        if (s === "top")
            B = this.bottom - w,
            P = this._getXAxisLabelAlignment();
        else if (s === "bottom")
            B = this.top + w,
            P = this._getXAxisLabelAlignment();
        else if (s === "left") {
            const E = this._getYAxisLabelAlignment(p);
            P = E.textAlign,
            k = E.x
        } else if (s === "right") {
            const E = this._getYAxisLabelAlignment(p);
            P = E.textAlign,
            k = E.x
        } else if (t === "x") {
            if (s === "center")
                B = (e.top + e.bottom) / 2 + g;
            else if (an(s)) {
                const E = Object.keys(s)[0]
                  , C = s[E];
                B = this.chart.scales[E].getPixelForValue(C) + g
            }
            P = this._getXAxisLabelAlignment()
        } else if (t === "y") {
            if (s === "center")
                k = (e.left + e.right) / 2 - g;
            else if (an(s)) {
                const E = Object.keys(s)[0]
                  , C = s[E];
                k = this.chart.scales[E].getPixelForValue(C)
            }
            P = this._getYAxisLabelAlignment(p).textAlign
        }
        t === "y" && (l === "start" ? j = "top" : l === "end" && (j = "bottom"));
        const A = this._getLabelSizes();
        for (S = 0,
        N = a.length; S < N; ++S) {
            _ = a[S],
            I = _.label;
            const E = i.setContext(this.getContext(S));
            M = this.getPixelForTick(S) + i.labelOffset,
            R = this._resolveTickFontOptions(S),
            L = R.lineHeight,
            q = ns(I) ? I.length : 1;
            const C = q / 2
              , O = E.color
              , z = E.textStrokeColor
              , G = E.textStrokeWidth;
            let Y = P;
            o ? (k = M,
            P === "inner" && (S === N - 1 ? Y = this.options.reverse ? "left" : "right" : S === 0 ? Y = this.options.reverse ? "right" : "left" : Y = "center"),
            s === "top" ? u === "near" || b !== 0 ? H = -q * L + L / 2 : u === "center" ? H = -A.highest.height / 2 - C * L + L : H = -A.highest.height + L / 2 : u === "near" || b !== 0 ? H = L / 2 : u === "center" ? H = A.highest.height / 2 - C * L : H = A.highest.height - q * L,
            h && (H *= -1),
            b !== 0 && !E.showLabelBackdrop && (k += L / 2 * Math.sin(b))) : (B = M,
            H = (1 - q) * L / 2);
            let $;
            if (E.showLabelBackdrop) {
                const D = pa(E.backdropPadding)
                  , U = A.heights[S]
                  , W = A.widths[S];
                let Q = H - D.top
                  , J = 0 - D.left;
                switch (j) {
                case "middle":
                    Q -= U / 2;
                    break;
                case "bottom":
                    Q -= U;
                    break
                }
                switch (P) {
                case "center":
                    J -= W / 2;
                    break;
                case "right":
                    J -= W;
                    break;
                case "inner":
                    S === N - 1 ? J -= W : S > 0 && (J -= W / 2);
                    break
                }
                $ = {
                    left: J,
                    top: Q,
                    width: W + D.width,
                    height: U + D.height,
                    color: E.backdropColor
                }
            }
            v.push({
                label: I,
                font: R,
                textOffset: H,
                options: {
                    rotation: b,
                    color: O,
                    strokeColor: z,
                    strokeWidth: G,
                    textAlign: Y,
                    textBaseline: j,
                    translation: [k, B],
                    backdrop: $
                }
            })
        }
        return v
    }
    _getXAxisLabelAlignment() {
        const {position: e, ticks: t} = this.options;
        if (-wf(this.labelRotation))
            return e === "top" ? "left" : "right";
        let s = "center";
        return t.align === "start" ? s = "left" : t.align === "end" ? s = "right" : t.align === "inner" && (s = "inner"),
        s
    }
    _getYAxisLabelAlignment(e) {
        const {position: t, ticks: {crossAlign: r, mirror: s, padding: i}} = this.options
          , o = this._getLabelSizes()
          , a = e + i
          , l = o.widest.width;
        let u, d;
        return t === "left" ? s ? (d = this.right + i,
        r === "near" ? u = "left" : r === "center" ? (u = "center",
        d += l / 2) : (u = "right",
        d += l)) : (d = this.right - a,
        r === "near" ? u = "right" : r === "center" ? (u = "center",
        d -= l / 2) : (u = "left",
        d = this.left)) : t === "right" ? s ? (d = this.left + i,
        r === "near" ? u = "right" : r === "center" ? (u = "center",
        d -= l / 2) : (u = "left",
        d -= l)) : (d = this.left + a,
        r === "near" ? u = "left" : r === "center" ? (u = "center",
        d += l / 2) : (u = "right",
        d = this.right)) : u = "right",
        {
            textAlign: u,
            x: d
        }
    }
    _computeLabelArea() {
        if (this.options.ticks.mirror)
            return;
        const e = this.chart
          , t = this.options.position;
        if (t === "left" || t === "right")
            return {
                top: 0,
                left: this.left,
                bottom: e.height,
                right: this.right
            };
        if (t === "top" || t === "bottom")
            return {
                top: this.top,
                left: 0,
                bottom: this.bottom,
                right: e.width
            }
    }
    drawBackground() {
        const {ctx: e, options: {backgroundColor: t}, left: r, top: s, width: i, height: o} = this;
        t && (e.save(),
        e.fillStyle = t,
        e.fillRect(r, s, i, o),
        e.restore())
    }
    getLineWidthForValue(e) {
        const t = this.options.grid;
        if (!this._isVisible() || !t.display)
            return 0;
        const s = this.ticks.findIndex(i => i.value === e);
        return s >= 0 ? t.setContext(this.getContext(s)).lineWidth : 0
    }
    drawGrid(e) {
        const t = this.options.grid
          , r = this.ctx
          , s = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(e));
        let i, o;
        const a = (l, u, d) => {
            !d.width || !d.color || (r.save(),
            r.lineWidth = d.width,
            r.strokeStyle = d.color,
            r.setLineDash(d.borderDash || []),
            r.lineDashOffset = d.borderDashOffset,
            r.beginPath(),
            r.moveTo(l.x, l.y),
            r.lineTo(u.x, u.y),
            r.stroke(),
            r.restore())
        }
        ;
        if (t.display)
            for (i = 0,
            o = s.length; i < o; ++i) {
                const l = s[i];
                t.drawOnChartArea && a({
                    x: l.x1,
                    y: l.y1
                }, {
                    x: l.x2,
                    y: l.y2
                }, l),
                t.drawTicks && a({
                    x: l.tx1,
                    y: l.ty1
                }, {
                    x: l.tx2,
                    y: l.ty2
                }, {
                    color: l.tickColor,
                    width: l.tickWidth,
                    borderDash: l.tickBorderDash,
                    borderDashOffset: l.tickBorderDashOffset
                })
            }
    }
    drawBorder() {
        const {chart: e, ctx: t, options: {border: r, grid: s}} = this
          , i = r.setContext(this.getContext())
          , o = r.display ? i.width : 0;
        if (!o)
            return;
        const a = s.setContext(this.getContext(0)).lineWidth
          , l = this._borderValue;
        let u, d, h, p;
        this.isHorizontal() ? (u = Fd(e, this.left, o) - o / 2,
        d = Fd(e, this.right, a) + a / 2,
        h = p = l) : (h = Fd(e, this.top, o) - o / 2,
        p = Fd(e, this.bottom, a) + a / 2,
        u = d = l),
        t.save(),
        t.lineWidth = i.width,
        t.strokeStyle = i.color,
        t.beginPath(),
        t.moveTo(u, h),
        t.lineTo(d, p),
        t.stroke(),
        t.restore()
    }
    drawLabels(e) {
        if (!this.options.ticks.display)
            return;
        const r = this.ctx
          , s = this._computeLabelArea();
        s && qx(r, s);
        const i = this.getLabelItems(e);
        for (const o of i) {
            const a = o.options
              , l = o.font
              , u = o.label
              , d = o.textOffset;
            xv(r, u, 0, d, l, a)
        }
        s && Gx(r)
    }
    drawTitle() {
        const {ctx: e, options: {position: t, title: r, reverse: s}} = this;
        if (!r.display)
            return;
        const i = ki(r.font)
          , o = pa(r.padding)
          , a = r.align;
        let l = i.lineHeight / 2;
        t === "bottom" || t === "center" || an(t) ? (l += o.bottom,
        ns(r.text) && (l += i.lineHeight * (r.text.length - 1))) : l += o.top;
        const {titleX: u, titleY: d, maxWidth: h, rotation: p} = WRe(this, l, t, a);
        xv(e, r.text, 0, 0, i, {
            color: r.color,
            maxWidth: h,
            rotation: p,
            textAlign: GRe(a, t, s),
            textBaseline: "middle",
            translation: [u, d]
        })
    }
    draw(e) {
        this._isVisible() && (this.drawBackground(),
        this.drawGrid(e),
        this.drawBorder(),
        this.drawTitle(),
        this.drawLabels(e))
    }
    _layers() {
        const e = this.options
          , t = e.ticks && e.ticks.z || 0
          , r = on(e.grid && e.grid.z, -1)
          , s = on(e.border && e.border.z, 0);
        return !this._isVisible() || this.draw !== L0.prototype.draw ? [{
            z: t,
            draw: i => {
                this.draw(i)
            }
        }] : [{
            z: r,
            draw: i => {
                this.drawBackground(),
                this.drawGrid(i),
                this.drawTitle()
            }
        }, {
            z: s,
            draw: () => {
                this.drawBorder()
            }
        }, {
            z: t,
            draw: i => {
                this.drawLabels(i)
            }
        }]
    }
    getMatchingVisibleMetas(e) {
        const t = this.chart.getSortedVisibleDatasetMetas()
          , r = this.axis + "AxisID"
          , s = [];
        let i, o;
        for (i = 0,
        o = t.length; i < o; ++i) {
            const a = t[i];
            a[r] === this.id && (!e || a.type === e) && s.push(a)
        }
        return s
    }
    _resolveTickFontOptions(e) {
        const t = this.options.ticks.setContext(this.getContext(e));
        return ki(t.font)
    }
    _maxDigits() {
        const e = this._resolveTickFontOptions(0).lineHeight;
        return (this.isHorizontal() ? this.width : this.height) / e
    }
}
class Nw {
    constructor(e, t, r) {
        this.type = e,
        this.scope = t,
        this.override = r,
        this.items = Object.create(null)
    }
    isForType(e) {
        return Object.prototype.isPrototypeOf.call(this.type.prototype, e.prototype)
    }
    register(e) {
        const t = Object.getPrototypeOf(e);
        let r;
        XRe(t) && (r = this.register(t));
        const s = this.items
          , i = e.id
          , o = this.scope + "." + i;
        if (!i)
            throw new Error("class does not have id: " + e);
        return i in s || (s[i] = e,
        YRe(e, o, r),
        this.override && _r.override(e.id, e.overrides)),
        o
    }
    get(e) {
        return this.items[e]
    }
    unregister(e) {
        const t = this.items
          , r = e.id
          , s = this.scope;
        r in t && delete t[r],
        s && r in _r[s] && (delete _r[s][r],
        this.override && delete zf[r])
    }
}
function YRe(n, e, t) {
    const r = fy(Object.create(null), [t ? _r.get(t) : {}, _r.get(e), n.defaults]);
    _r.set(e, r),
    n.defaultRoutes && KRe(e, n.defaultRoutes),
    n.descriptors && _r.describe(e, n.descriptors)
}
function KRe(n, e) {
    Object.keys(e).forEach(t => {
        const r = t.split(".")
          , s = r.pop()
          , i = [n].concat(r).join(".")
          , o = e[t].split(".")
          , a = o.pop()
          , l = o.join(".");
        _r.route(i, s, l, a)
    }
    )
}
function XRe(n) {
    return "id"in n && "defaults"in n
}
class QRe {
    constructor() {
        this.controllers = new Nw(aRe,"datasets",!0),
        this.elements = new Nw(j0,"elements"),
        this.plugins = new Nw(Object,"plugins"),
        this.scales = new Nw(L0,"scales"),
        this._typedRegistries = [this.controllers, this.scales, this.elements]
    }
    add(...e) {
        this._each("register", e)
    }
    remove(...e) {
        this._each("unregister", e)
    }
    addControllers(...e) {
        this._each("register", e, this.controllers)
    }
    addElements(...e) {
        this._each("register", e, this.elements)
    }
    addPlugins(...e) {
        this._each("register", e, this.plugins)
    }
    addScales(...e) {
        this._each("register", e, this.scales)
    }
    getController(e) {
        return this._get(e, this.controllers, "controller")
    }
    getElement(e) {
        return this._get(e, this.elements, "element")
    }
    getPlugin(e) {
        return this._get(e, this.plugins, "plugin")
    }
    getScale(e) {
        return this._get(e, this.scales, "scale")
    }
    removeControllers(...e) {
        this._each("unregister", e, this.controllers)
    }
    removeElements(...e) {
        this._each("unregister", e, this.elements)
    }
    removePlugins(...e) {
        this._each("unregister", e, this.plugins)
    }
    removeScales(...e) {
        this._each("unregister", e, this.scales)
    }
    _each(e, t, r) {
        [...t].forEach(s => {
            const i = r || this._getRegistryForType(s);
            r || i.isForType(s) || i === this.plugins && s.id ? this._exec(e, i, s) : _n(s, o => {
                const a = r || this._getRegistryForType(o);
                this._exec(e, a, o)
            }
            )
        }
        )
    }
    _exec(e, t, r) {
        const s = Pk(e);
        Wn(r["before" + s], [], r),
        t[e](r),
        Wn(r["after" + s], [], r)
    }
    _getRegistryForType(e) {
        for (let t = 0; t < this._typedRegistries.length; t++) {
            const r = this._typedRegistries[t];
            if (r.isForType(e))
                return r
        }
        return this.plugins
    }
    _get(e, t, r) {
        const s = t.get(e);
        if (s === void 0)
            throw new Error('"' + e + '" is not a registered ' + r + ".");
        return s
    }
}
var ja = new QRe;
class ZRe {
    constructor() {
        this._init = void 0
    }
    notify(e, t, r, s) {
        if (t === "beforeInit" && (this._init = this._createDescriptors(e, !0),
        this._notify(this._init, e, "install")),
        this._init === void 0)
            return;
        const i = s ? this._descriptors(e).filter(s) : this._descriptors(e)
          , o = this._notify(i, e, t, r);
        return t === "afterDestroy" && (this._notify(i, e, "stop"),
        this._notify(this._init, e, "uninstall"),
        this._init = void 0),
        o
    }
    _notify(e, t, r, s) {
        s = s || {};
        for (const i of e) {
            const o = i.plugin
              , a = o[r]
              , l = [t, s, i.options];
            if (Wn(a, l, o) === !1 && s.cancelable)
                return !1
        }
        return !0
    }
    invalidate() {
        sr(this._cache) || (this._oldCache = this._cache,
        this._cache = void 0)
    }
    _descriptors(e) {
        if (this._cache)
            return this._cache;
        const t = this._cache = this._createDescriptors(e);
        return this._notifyStateChanges(e),
        t
    }
    _createDescriptors(e, t) {
        const r = e && e.config
          , s = on(r.options && r.options.plugins, {})
          , i = JRe(r);
        return s === !1 && !t ? [] : tOe(e, i, s, t)
    }
    _notifyStateChanges(e) {
        const t = this._oldCache || []
          , r = this._cache
          , s = (i, o) => i.filter(a => !o.some(l => a.plugin.id === l.plugin.id));
        this._notify(s(t, r), e, "stop"),
        this._notify(s(r, t), e, "start")
    }
}
function JRe(n) {
    const e = {}
      , t = []
      , r = Object.keys(ja.plugins.items);
    for (let i = 0; i < r.length; i++)
        t.push(ja.getPlugin(r[i]));
    const s = n.plugins || [];
    for (let i = 0; i < s.length; i++) {
        const o = s[i];
        t.indexOf(o) === -1 && (t.push(o),
        e[o.id] = !0)
    }
    return {
        plugins: t,
        localIds: e
    }
}
function eOe(n, e) {
    return !e && n === !1 ? null : n === !0 ? {} : n
}
function tOe(n, {plugins: e, localIds: t}, r, s) {
    const i = []
      , o = n.getContext();
    for (const a of e) {
        const l = a.id
          , u = eOe(r[l], s);
        u !== null && i.push({
            plugin: a,
            options: nOe(n.config, {
                plugin: a,
                local: t[l]
            }, u, o)
        })
    }
    return i
}
function nOe(n, {plugin: e, local: t}, r, s) {
    const i = n.pluginScopeKeys(e)
      , o = n.getOptionScopes(r, i);
    return t && e.defaults && o.push(e.defaults),
    n.createResolver(o, s, [""], {
        scriptable: !1,
        indexable: !1,
        allKeys: !0
    })
}
function d8(n, e) {
    const t = _r.datasets[n] || {};
    return ((e.datasets || {})[n] || {}).indexAxis || e.indexAxis || t.indexAxis || "x"
}
function rOe(n, e) {
    let t = n;
    return n === "_index_" ? t = e : n === "_value_" && (t = e === "x" ? "y" : "x"),
    t
}
function sOe(n, e) {
    return n === e ? "_index_" : "_value_"
}
function s9(n) {
    if (n === "x" || n === "y" || n === "r")
        return n
}
function iOe(n) {
    if (n === "top" || n === "bottom")
        return "x";
    if (n === "left" || n === "right")
        return "y"
}
function f8(n, ...e) {
    if (s9(n))
        return n;
    for (const t of e) {
        const r = t.axis || iOe(t.position) || n.length > 1 && s9(n[0].toLowerCase());
        if (r)
            return r
    }
    throw new Error(`Cannot determine type of '${n}' axis. Please provide 'axis' or 'position' option.`)
}
function i9(n, e, t) {
    if (t[e + "AxisID"] === n)
        return {
            axis: e
        }
}
function oOe(n, e) {
    if (e.data && e.data.datasets) {
        const t = e.data.datasets.filter(r => r.xAxisID === n || r.yAxisID === n);
        if (t.length)
            return i9(n, "x", t[0]) || i9(n, "y", t[0])
    }
    return {}
}
function aOe(n, e) {
    const t = zf[n.type] || {
        scales: {}
    }
      , r = e.scales || {}
      , s = d8(n.type, e)
      , i = Object.create(null);
    return Object.keys(r).forEach(o => {
        const a = r[o];
        if (!an(a))
            return console.error(`Invalid scale configuration for scale: ${o}`);
        if (a._proxy)
            return console.warn(`Ignoring resolver passed as options for scale: ${o}`);
        const l = f8(o, a, oOe(o, n), _r.scales[a.type])
          , u = sOe(l, s)
          , d = t.scales || {};
        i[o] = jg(Object.create(null), [{
            axis: l
        }, a, d[l], d[u]])
    }
    ),
    n.data.datasets.forEach(o => {
        const a = o.type || n.type
          , l = o.indexAxis || d8(a, e)
          , d = (zf[a] || {}).scales || {};
        Object.keys(d).forEach(h => {
            const p = rOe(h, l)
              , g = o[p + "AxisID"] || p;
            i[g] = i[g] || Object.create(null),
            jg(i[g], [{
                axis: p
            }, r[g], d[h]])
        }
        )
    }
    ),
    Object.keys(i).forEach(o => {
        const a = i[o];
        jg(a, [_r.scales[a.type], _r.scale])
    }
    ),
    i
}
function xW(n) {
    const e = n.options || (n.options = {});
    e.plugins = on(e.plugins, {}),
    e.scales = aOe(n, e)
}
function EW(n) {
    return n = n || {},
    n.datasets = n.datasets || [],
    n.labels = n.labels || [],
    n
}
function lOe(n) {
    return n = n || {},
    n.data = EW(n.data),
    xW(n),
    n
}
const o9 = new Map
  , SW = new Set;
function Dw(n, e) {
    let t = o9.get(n);
    return t || (t = e(),
    o9.set(n, t),
    SW.add(t)),
    t
}
const hg = (n, e, t) => {
    const r = yv(e, t);
    r !== void 0 && n.add(r)
}
;
class cOe {
    constructor(e) {
        this._config = lOe(e),
        this._scopeCache = new Map,
        this._resolverCache = new Map
    }
    get platform() {
        return this._config.platform
    }
    get type() {
        return this._config.type
    }
    set type(e) {
        this._config.type = e
    }
    get data() {
        return this._config.data
    }
    set data(e) {
        this._config.data = EW(e)
    }
    get options() {
        return this._config.options
    }
    set options(e) {
        this._config.options = e
    }
    get plugins() {
        return this._config.plugins
    }
    update() {
        const e = this._config;
        this.clearCache(),
        xW(e)
    }
    clearCache() {
        this._scopeCache.clear(),
        this._resolverCache.clear()
    }
    datasetScopeKeys(e) {
        return Dw(e, () => [[`datasets.${e}`, ""]])
    }
    datasetAnimationScopeKeys(e, t) {
        return Dw(`${e}.transition.${t}`, () => [[`datasets.${e}.transitions.${t}`, `transitions.${t}`], [`datasets.${e}`, ""]])
    }
    datasetElementScopeKeys(e, t) {
        return Dw(`${e}-${t}`, () => [[`datasets.${e}.elements.${t}`, `datasets.${e}`, `elements.${t}`, ""]])
    }
    pluginScopeKeys(e) {
        const t = e.id
          , r = this.type;
        return Dw(`${r}-plugin-${t}`, () => [[`plugins.${t}`, ...e.additionalOptionScopes || []]])
    }
    _cachedScopes(e, t) {
        const r = this._scopeCache;
        let s = r.get(e);
        return (!s || t) && (s = new Map,
        r.set(e, s)),
        s
    }
    getOptionScopes(e, t, r) {
        const {options: s, type: i} = this
          , o = this._cachedScopes(e, r)
          , a = o.get(t);
        if (a)
            return a;
        const l = new Set;
        t.forEach(d => {
            e && (l.add(e),
            d.forEach(h => hg(l, e, h))),
            d.forEach(h => hg(l, s, h)),
            d.forEach(h => hg(l, zf[i] || {}, h)),
            d.forEach(h => hg(l, _r, h)),
            d.forEach(h => hg(l, l8, h))
        }
        );
        const u = Array.from(l);
        return u.length === 0 && u.push(Object.create(null)),
        SW.has(t) && o.set(t, u),
        u
    }
    chartOptionScopes() {
        const {options: e, type: t} = this;
        return [e, zf[t] || {}, _r.datasets[t] || {}, {
            type: t
        }, _r, l8]
    }
    resolveNamedOptions(e, t, r, s=[""]) {
        const i = {
            $shared: !0
        }
          , {resolver: o, subPrefixes: a} = a9(this._resolverCache, e, s);
        let l = o;
        if (dOe(o, t)) {
            i.$shared = !1,
            r = id(r) ? r() : r;
            const u = this.createResolver(e, r, a);
            l = g0(o, r, u)
        }
        for (const u of t)
            i[u] = l[u];
        return i
    }
    createResolver(e, t, r=[""], s) {
        const {resolver: i} = a9(this._resolverCache, e, r);
        return an(t) ? g0(i, t, void 0, s) : i
    }
}
function a9(n, e, t) {
    let r = n.get(e);
    r || (r = new Map,
    n.set(e, r));
    const s = t.join();
    let i = r.get(s);
    return i || (i = {
        resolver: Fk(e, t),
        subPrefixes: t.filter(a => !a.toLowerCase().includes("hover"))
    },
    r.set(s, i)),
    i
}
const uOe = n => an(n) && Object.getOwnPropertyNames(n).some(e => id(n[e]));
function dOe(n, e) {
    const {isScriptable: t, isIndexable: r} = rW(n);
    for (const s of e) {
        const i = t(s)
          , o = r(s)
          , a = (o || i) && n[s];
        if (i && (id(a) || uOe(a)) || o && ns(a))
            return !0
    }
    return !1
}
var fOe = "4.5.1";
const hOe = ["top", "bottom", "left", "right", "chartArea"];
function l9(n, e) {
    return n === "top" || n === "bottom" || hOe.indexOf(n) === -1 && e === "x"
}
function c9(n, e) {
    return function(t, r) {
        return t[n] === r[n] ? t[e] - r[e] : t[n] - r[n]
    }
}
function u9(n) {
    const e = n.chart
      , t = e.options.animation;
    e.notifyPlugins("afterRender"),
    Wn(t && t.onComplete, [n], e)
}
function pOe(n) {
    const e = n.chart
      , t = e.options.animation;
    Wn(t && t.onProgress, [n], e)
}
function AW(n) {
    return $k() && typeof n == "string" ? n = document.getElementById(n) : n && n.length && (n = n[0]),
    n && n.canvas && (n = n.canvas),
    n
}
const i2 = {}
  , d9 = n => {
    const e = AW(n);
    return Object.values(i2).filter(t => t.canvas === e).pop()
}
;
function mOe(n, e, t) {
    const r = Object.keys(n);
    for (const s of r) {
        const i = +s;
        if (i >= e) {
            const o = n[s];
            delete n[s],
            (t > 0 || i > e) && (n[i + t] = o)
        }
    }
}
function gOe(n, e, t, r) {
    return !t || n.type === "mouseout" ? null : r ? e : n
}
class CW {
    static defaults = _r;
    static instances = i2;
    static overrides = zf;
    static registry = ja;
    static version = fOe;
    static getChart = d9;
    static register(...e) {
        ja.add(...e),
        f9()
    }
    static unregister(...e) {
        ja.remove(...e),
        f9()
    }
    constructor(e, t) {
        const r = this.config = new cOe(t)
          , s = AW(e)
          , i = d9(s);
        if (i)
            throw new Error("Canvas is already in use. Chart with ID '" + i.id + "' must be destroyed before the canvas with ID '" + i.canvas.id + "' can be reused.");
        const o = r.createResolver(r.chartOptionScopes(), this.getContext());
        this.platform = new (r.platform || RRe(s)),
        this.platform.updateConfig(r);
        const a = this.platform.acquireContext(s, o.aspectRatio)
          , l = a && a.canvas
          , u = l && l.height
          , d = l && l.width;
        if (this.id = SMe(),
        this.ctx = a,
        this.canvas = l,
        this.width = d,
        this.height = u,
        this._options = o,
        this._aspectRatio = this.aspectRatio,
        this._layers = [],
        this._metasets = [],
        this._stacks = void 0,
        this.boxes = [],
        this.currentDevicePixelRatio = void 0,
        this.chartArea = void 0,
        this._active = [],
        this._lastEvent = void 0,
        this._listeners = {},
        this._responsiveListeners = void 0,
        this._sortedMetasets = [],
        this.scales = {},
        this._plugins = new ZRe,
        this.$proxies = {},
        this._hiddenIndices = {},
        this.attached = !1,
        this._animationsDisabled = void 0,
        this.$context = void 0,
        this._doResize = VMe(h => this.update(h), o.resizeDelay || 0),
        this._dataChanges = [],
        i2[this.id] = this,
        !a || !l) {
            console.error("Failed to create chart: can't acquire context from the given item");
            return
        }
        ql.listen(this, "complete", u9),
        ql.listen(this, "progress", pOe),
        this._initialize(),
        this.attached && this.update()
    }
    get aspectRatio() {
        const {options: {aspectRatio: e, maintainAspectRatio: t}, width: r, height: s, _aspectRatio: i} = this;
        return sr(e) ? t && i ? i : s ? r / s : null : e
    }
    get data() {
        return this.config.data
    }
    set data(e) {
        this.config.data = e
    }
    get options() {
        return this._options
    }
    set options(e) {
        this.config.options = e
    }
    get registry() {
        return ja
    }
    _initialize() {
        return this.notifyPlugins("beforeInit"),
        this.options.responsive ? this.resize() : jj(this, this.options.devicePixelRatio),
        this.bindEvents(),
        this.notifyPlugins("afterInit"),
        this
    }
    clear() {
        return Rj(this.canvas, this.ctx),
        this
    }
    stop() {
        return ql.stop(this),
        this
    }
    resize(e, t) {
        ql.running(this) ? this._resizeBeforeDraw = {
            width: e,
            height: t
        } : this._resize(e, t)
    }
    _resize(e, t) {
        const r = this.options
          , s = this.canvas
          , i = r.maintainAspectRatio && this.aspectRatio
          , o = this.platform.getMaximumSize(s, e, t, i)
          , a = r.devicePixelRatio || this.platform.getDevicePixelRatio()
          , l = this.width ? "resize" : "attach";
        this.width = o.width,
        this.height = o.height,
        this._aspectRatio = this.aspectRatio,
        jj(this, a, !0) && (this.notifyPlugins("resize", {
            size: o
        }),
        Wn(r.onResize, [this, o], this),
        this.attached && this._doResize(l) && this.render())
    }
    ensureScalesHaveIDs() {
        const t = this.options.scales || {};
        _n(t, (r, s) => {
            r.id = s
        }
        )
    }
    buildOrUpdateScales() {
        const e = this.options
          , t = e.scales
          , r = this.scales
          , s = Object.keys(r).reduce( (o, a) => (o[a] = !1,
        o), {});
        let i = [];
        t && (i = i.concat(Object.keys(t).map(o => {
            const a = t[o]
              , l = f8(o, a)
              , u = l === "r"
              , d = l === "x";
            return {
                options: a,
                dposition: u ? "chartArea" : d ? "bottom" : "left",
                dtype: u ? "radialLinear" : d ? "category" : "linear"
            }
        }
        ))),
        _n(i, o => {
            const a = o.options
              , l = a.id
              , u = f8(l, a)
              , d = on(a.type, o.dtype);
            (a.position === void 0 || l9(a.position, u) !== l9(o.dposition)) && (a.position = o.dposition),
            s[l] = !0;
            let h = null;
            if (l in r && r[l].type === d)
                h = r[l];
            else {
                const p = ja.getScale(d);
                h = new p({
                    id: l,
                    type: d,
                    ctx: this.ctx,
                    chart: this
                }),
                r[h.id] = h
            }
            h.init(a, e)
        }
        ),
        _n(s, (o, a) => {
            o || delete r[a]
        }
        ),
        _n(r, o => {
            $u.configure(this, o, o.options),
            $u.addBox(this, o)
        }
        )
    }
    _updateMetasets() {
        const e = this._metasets
          , t = this.data.datasets.length
          , r = e.length;
        if (e.sort( (s, i) => s.index - i.index),
        r > t) {
            for (let s = t; s < r; ++s)
                this._destroyDatasetMeta(s);
            e.splice(t, r - t)
        }
        this._sortedMetasets = e.slice(0).sort(c9("order", "index"))
    }
    _removeUnreferencedMetasets() {
        const {_metasets: e, data: {datasets: t}} = this;
        e.length > t.length && delete this._stacks,
        e.forEach( (r, s) => {
            t.filter(i => i === r._dataset).length === 0 && this._destroyDatasetMeta(s)
        }
        )
    }
    buildOrUpdateControllers() {
        const e = []
          , t = this.data.datasets;
        let r, s;
        for (this._removeUnreferencedMetasets(),
        r = 0,
        s = t.length; r < s; r++) {
            const i = t[r];
            let o = this.getDatasetMeta(r);
            const a = i.type || this.config.type;
            if (o.type && o.type !== a && (this._destroyDatasetMeta(r),
            o = this.getDatasetMeta(r)),
            o.type = a,
            o.indexAxis = i.indexAxis || d8(a, this.options),
            o.order = i.order || 0,
            o.index = r,
            o.label = "" + i.label,
            o.visible = this.isDatasetVisible(r),
            o.controller)
                o.controller.updateIndex(r),
                o.controller.linkScales();
            else {
                const l = ja.getController(a)
                  , {datasetElementType: u, dataElementType: d} = _r.datasets[a];
                Object.assign(l, {
                    dataElementType: ja.getElement(d),
                    datasetElementType: u && ja.getElement(u)
                }),
                o.controller = new l(this,r),
                e.push(o.controller)
            }
        }
        return this._updateMetasets(),
        e
    }
    _resetElements() {
        _n(this.data.datasets, (e, t) => {
            this.getDatasetMeta(t).controller.reset()
        }
        , this)
    }
    reset() {
        this._resetElements(),
        this.notifyPlugins("reset")
    }
    update(e) {
        const t = this.config;
        t.update();
        const r = this._options = t.createResolver(t.chartOptionScopes(), this.getContext())
          , s = this._animationsDisabled = !r.animation;
        if (this._updateScales(),
        this._checkEventBindings(),
        this._updateHiddenIndices(),
        this._plugins.invalidate(),
        this.notifyPlugins("beforeUpdate", {
            mode: e,
            cancelable: !0
        }) === !1)
            return;
        const i = this.buildOrUpdateControllers();
        this.notifyPlugins("beforeElementsUpdate");
        let o = 0;
        for (let u = 0, d = this.data.datasets.length; u < d; u++) {
            const {controller: h} = this.getDatasetMeta(u)
              , p = !s && i.indexOf(h) === -1;
            h.buildOrUpdateElements(p),
            o = Math.max(+h.getMaxOverflow(), o)
        }
        o = this._minPadding = r.layout.autoPadding ? o : 0,
        this._updateLayout(o),
        s || _n(i, u => {
            u.reset()
        }
        ),
        this._updateDatasets(e),
        this.notifyPlugins("afterUpdate", {
            mode: e
        }),
        this._layers.sort(c9("z", "_idx"));
        const {_active: a, _lastEvent: l} = this;
        l ? this._eventHandler(l, !0) : a.length && this._updateHoverStyles(a, a, !0),
        this.render()
    }
    _updateScales() {
        _n(this.scales, e => {
            $u.removeBox(this, e)
        }
        ),
        this.ensureScalesHaveIDs(),
        this.buildOrUpdateScales()
    }
    _checkEventBindings() {
        const e = this.options
          , t = new Set(Object.keys(this._listeners))
          , r = new Set(e.events);
        (!Aj(t, r) || !!this._responsiveListeners !== e.responsive) && (this.unbindEvents(),
        this.bindEvents())
    }
    _updateHiddenIndices() {
        const {_hiddenIndices: e} = this
          , t = this._getUniformDataChanges() || [];
        for (const {method: r, start: s, count: i} of t) {
            const o = r === "_removeElements" ? -i : i;
            mOe(e, s, o)
        }
    }
    _getUniformDataChanges() {
        const e = this._dataChanges;
        if (!e || !e.length)
            return;
        this._dataChanges = [];
        const t = this.data.datasets.length
          , r = i => new Set(e.filter(o => o[0] === i).map( (o, a) => a + "," + o.splice(1).join(",")))
          , s = r(0);
        for (let i = 1; i < t; i++)
            if (!Aj(s, r(i)))
                return;
        return Array.from(s).map(i => i.split(",")).map(i => ({
            method: i[1],
            start: +i[2],
            count: +i[3]
        }))
    }
    _updateLayout(e) {
        if (this.notifyPlugins("beforeLayout", {
            cancelable: !0
        }) === !1)
            return;
        $u.update(this, this.width, this.height, e);
        const t = this.chartArea
          , r = t.width <= 0 || t.height <= 0;
        this._layers = [],
        _n(this.boxes, s => {
            r && s.position === "chartArea" || (s.configure && s.configure(),
            this._layers.push(...s._layers()))
        }
        , this),
        this._layers.forEach( (s, i) => {
            s._idx = i
        }
        ),
        this.notifyPlugins("afterLayout")
    }
    _updateDatasets(e) {
        if (this.notifyPlugins("beforeDatasetsUpdate", {
            mode: e,
            cancelable: !0
        }) !== !1) {
            for (let t = 0, r = this.data.datasets.length; t < r; ++t)
                this.getDatasetMeta(t).controller.configure();
            for (let t = 0, r = this.data.datasets.length; t < r; ++t)
                this._updateDataset(t, id(e) ? e({
                    datasetIndex: t
                }) : e);
            this.notifyPlugins("afterDatasetsUpdate", {
                mode: e
            })
        }
    }
    _updateDataset(e, t) {
        const r = this.getDatasetMeta(e)
          , s = {
            meta: r,
            index: e,
            mode: t,
            cancelable: !0
        };
        this.notifyPlugins("beforeDatasetUpdate", s) !== !1 && (r.controller._update(t),
        s.cancelable = !1,
        this.notifyPlugins("afterDatasetUpdate", s))
    }
    render() {
        this.notifyPlugins("beforeRender", {
            cancelable: !0
        }) !== !1 && (ql.has(this) ? this.attached && !ql.running(this) && ql.start(this) : (this.draw(),
        u9({
            chart: this
        })))
    }
    draw() {
        let e;
        if (this._resizeBeforeDraw) {
            const {width: r, height: s} = this._resizeBeforeDraw;
            this._resizeBeforeDraw = null,
            this._resize(r, s)
        }
        if (this.clear(),
        this.width <= 0 || this.height <= 0 || this.notifyPlugins("beforeDraw", {
            cancelable: !0
        }) === !1)
            return;
        const t = this._layers;
        for (e = 0; e < t.length && t[e].z <= 0; ++e)
            t[e].draw(this.chartArea);
        for (this._drawDatasets(); e < t.length; ++e)
            t[e].draw(this.chartArea);
        this.notifyPlugins("afterDraw")
    }
    _getSortedDatasetMetas(e) {
        const t = this._sortedMetasets
          , r = [];
        let s, i;
        for (s = 0,
        i = t.length; s < i; ++s) {
            const o = t[s];
            (!e || o.visible) && r.push(o)
        }
        return r
    }
    getSortedVisibleDatasetMetas() {
        return this._getSortedDatasetMetas(!0)
    }
    _drawDatasets() {
        if (this.notifyPlugins("beforeDatasetsDraw", {
            cancelable: !0
        }) === !1)
            return;
        const e = this.getSortedVisibleDatasetMetas();
        for (let t = e.length - 1; t >= 0; --t)
            this._drawDataset(e[t]);
        this.notifyPlugins("afterDatasetsDraw")
    }
    _drawDataset(e) {
        const t = this.ctx
          , r = {
            meta: e,
            index: e.index,
            cancelable: !0
        }
          , s = hW(this, e);
        this.notifyPlugins("beforeDatasetDraw", r) !== !1 && (s && qx(t, s),
        e.controller.draw(),
        s && Gx(t),
        r.cancelable = !1,
        this.notifyPlugins("afterDatasetDraw", r))
    }
    isPointInArea(e) {
        return hy(e, this.chartArea, this._minPadding)
    }
    getElementsAtEventForMode(e, t, r, s) {
        const i = hRe.modes[t];
        return typeof i == "function" ? i(this, e, r, s) : []
    }
    getDatasetMeta(e) {
        const t = this.data.datasets[e]
          , r = this._metasets;
        let s = r.filter(i => i && i._dataset === t).pop();
        return s || (s = {
            type: null,
            data: [],
            dataset: null,
            controller: null,
            hidden: null,
            xAxisID: null,
            yAxisID: null,
            order: t && t.order || 0,
            index: e,
            _dataset: t,
            _parsed: [],
            _sorted: !1
        },
        r.push(s)),
        s
    }
    getContext() {
        return this.$context || (this.$context = nh(null, {
            chart: this,
            type: "chart"
        }))
    }
    getVisibleDatasetCount() {
        return this.getSortedVisibleDatasetMetas().length
    }
    isDatasetVisible(e) {
        const t = this.data.datasets[e];
        if (!t)
            return !1;
        const r = this.getDatasetMeta(e);
        return typeof r.hidden == "boolean" ? !r.hidden : !t.hidden
    }
    setDatasetVisibility(e, t) {
        const r = this.getDatasetMeta(e);
        r.hidden = !t
    }
    toggleDataVisibility(e) {
        this._hiddenIndices[e] = !this._hiddenIndices[e]
    }
    getDataVisibility(e) {
        return !this._hiddenIndices[e]
    }
    _updateVisibility(e, t, r) {
        const s = r ? "show" : "hide"
          , i = this.getDatasetMeta(e)
          , o = i.controller._resolveAnimations(void 0, s);
        bv(t) ? (i.data[t].hidden = !r,
        this.update()) : (this.setDatasetVisibility(e, r),
        o.update(i, {
            visible: r
        }),
        this.update(a => a.datasetIndex === e ? s : void 0))
    }
    hide(e, t) {
        this._updateVisibility(e, t, !1)
    }
    show(e, t) {
        this._updateVisibility(e, t, !0)
    }
    _destroyDatasetMeta(e) {
        const t = this._metasets[e];
        t && t.controller && t.controller._destroy(),
        delete this._metasets[e]
    }
    _stop() {
        let e, t;
        for (this.stop(),
        ql.remove(this),
        e = 0,
        t = this.data.datasets.length; e < t; ++e)
            this._destroyDatasetMeta(e)
    }
    destroy() {
        this.notifyPlugins("beforeDestroy");
        const {canvas: e, ctx: t} = this;
        this._stop(),
        this.config.clearCache(),
        e && (this.unbindEvents(),
        Rj(e, t),
        this.platform.releaseContext(t),
        this.canvas = null,
        this.ctx = null),
        delete i2[this.id],
        this.notifyPlugins("afterDestroy")
    }
    toBase64Image(...e) {
        return this.canvas.toDataURL(...e)
    }
    bindEvents() {
        this.bindUserEvents(),
        this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0
    }
    bindUserEvents() {
        const e = this._listeners
          , t = this.platform
          , r = (i, o) => {
            t.addEventListener(this, i, o),
            e[i] = o
        }
          , s = (i, o, a) => {
            i.offsetX = o,
            i.offsetY = a,
            this._eventHandler(i)
        }
        ;
        _n(this.options.events, i => r(i, s))
    }
    bindResponsiveEvents() {
        this._responsiveListeners || (this._responsiveListeners = {});
        const e = this._responsiveListeners
          , t = this.platform
          , r = (l, u) => {
            t.addEventListener(this, l, u),
            e[l] = u
        }
          , s = (l, u) => {
            e[l] && (t.removeEventListener(this, l, u),
            delete e[l])
        }
          , i = (l, u) => {
            this.canvas && this.resize(l, u)
        }
        ;
        let o;
        const a = () => {
            s("attach", a),
            this.attached = !0,
            this.resize(),
            r("resize", i),
            r("detach", o)
        }
        ;
        o = () => {
            this.attached = !1,
            s("resize", i),
            this._stop(),
            this._resize(0, 0),
            r("attach", a)
        }
        ,
        t.isAttached(this.canvas) ? a() : o()
    }
    unbindEvents() {
        _n(this._listeners, (e, t) => {
            this.platform.removeEventListener(this, t, e)
        }
        ),
        this._listeners = {},
        _n(this._responsiveListeners, (e, t) => {
            this.platform.removeEventListener(this, t, e)
        }
        ),
        this._responsiveListeners = void 0
    }
    updateHoverStyle(e, t, r) {
        const s = r ? "set" : "remove";
        let i, o, a, l;
        for (t === "dataset" && (i = this.getDatasetMeta(e[0].datasetIndex),
        i.controller["_" + s + "DatasetHoverStyle"]()),
        a = 0,
        l = e.length; a < l; ++a) {
            o = e[a];
            const u = o && this.getDatasetMeta(o.datasetIndex).controller;
            u && u[s + "HoverStyle"](o.element, o.datasetIndex, o.index)
        }
    }
    getActiveElements() {
        return this._active || []
    }
    setActiveElements(e) {
        const t = this._active || []
          , r = e.map( ({datasetIndex: i, index: o}) => {
            const a = this.getDatasetMeta(i);
            if (!a)
                throw new Error("No dataset found at index " + i);
            return {
                datasetIndex: i,
                element: a.data[o],
                index: o
            }
        }
        );
        !mv(r, t) && (this._active = r,
        this._lastEvent = null,
        this._updateHoverStyles(r, t))
    }
    notifyPlugins(e, t, r) {
        return this._plugins.notify(this, e, t, r)
    }
    isPluginEnabled(e) {
        return this._plugins._cache.filter(t => t.plugin.id === e).length === 1
    }
    _updateHoverStyles(e, t, r) {
        const s = this.options.hover
          , i = (l, u) => l.filter(d => !u.some(h => d.datasetIndex === h.datasetIndex && d.index === h.index))
          , o = i(t, e)
          , a = r ? e : i(e, t);
        o.length && this.updateHoverStyle(o, s.mode, !1),
        a.length && s.mode && this.updateHoverStyle(a, s.mode, !0)
    }
    _eventHandler(e, t) {
        const r = {
            event: e,
            replay: t,
            cancelable: !0,
            inChartArea: this.isPointInArea(e)
        }
          , s = o => (o.options.events || this.options.events).includes(e.native.type);
        if (this.notifyPlugins("beforeEvent", r, s) === !1)
            return;
        const i = this._handleEvent(e, t, r.inChartArea);
        return r.cancelable = !1,
        this.notifyPlugins("afterEvent", r, s),
        (i || r.changed) && this.render(),
        this
    }
    _handleEvent(e, t, r) {
        const {_active: s=[], options: i} = this
          , o = t
          , a = this._getActiveElements(e, s, r, o)
          , l = DMe(e)
          , u = gOe(e, this._lastEvent, r, l);
        r && (this._lastEvent = null,
        Wn(i.onHover, [e, a, this], this),
        l && Wn(i.onClick, [e, a, this], this));
        const d = !mv(a, s);
        return (d || t) && (this._active = a,
        this._updateHoverStyles(a, s, t)),
        this._lastEvent = u,
        d
    }
    _getActiveElements(e, t, r, s) {
        if (e.type === "mouseout")
            return [];
        if (!r)
            return t;
        const i = this.options.hover;
        return this.getElementsAtEventForMode(e, i.mode, i, s)
    }
}
function f9() {
    return _n(CW.instances, n => n._plugins.invalidate())
}
function _W(n, e, t=e) {
    n.lineCap = on(t.borderCapStyle, e.borderCapStyle),
    n.setLineDash(on(t.borderDash, e.borderDash)),
    n.lineDashOffset = on(t.borderDashOffset, e.borderDashOffset),
    n.lineJoin = on(t.borderJoinStyle, e.borderJoinStyle),
    n.lineWidth = on(t.borderWidth, e.borderWidth),
    n.strokeStyle = on(t.borderColor, e.borderColor)
}
function yOe(n, e, t) {
    n.lineTo(t.x, t.y)
}
function bOe(n) {
    return n.stepped ? nBe : n.tension || n.cubicInterpolationMode === "monotone" ? rBe : yOe
}
function kW(n, e, t={}) {
    const r = n.length
      , {start: s=0, end: i=r - 1} = t
      , {start: o, end: a} = e
      , l = Math.max(s, o)
      , u = Math.min(i, a)
      , d = s < o && i < o || s > a && i > a;
    return {
        count: r,
        start: l,
        loop: e.loop,
        ilen: u < l && !d ? r + u - l : u - l
    }
}
function wOe(n, e, t, r) {
    const {points: s, options: i} = e
      , {count: o, start: a, loop: l, ilen: u} = kW(s, t, r)
      , d = bOe(i);
    let {move: h=!0, reverse: p} = r || {}, g, w, b;
    for (g = 0; g <= u; ++g)
        w = s[(a + (p ? u - g : g)) % o],
        !w.skip && (h ? (n.moveTo(w.x, w.y),
        h = !1) : d(n, b, w, p, i.stepped),
        b = w);
    return l && (w = s[(a + (p ? u : 0)) % o],
    d(n, b, w, p, i.stepped)),
    !!l
}
function vOe(n, e, t, r) {
    const s = e.points
      , {count: i, start: o, ilen: a} = kW(s, t, r)
      , {move: l=!0, reverse: u} = r || {};
    let d = 0, h = 0, p, g, w, b, v, S;
    const N = I => (o + (u ? a - I : I)) % i
      , _ = () => {
        b !== v && (n.lineTo(d, v),
        n.lineTo(d, b),
        n.lineTo(d, S))
    }
    ;
    for (l && (g = s[N(0)],
    n.moveTo(g.x, g.y)),
    p = 0; p <= a; ++p) {
        if (g = s[N(p)],
        g.skip)
            continue;
        const I = g.x
          , k = g.y
          , B = I | 0;
        B === w ? (k < b ? b = k : k > v && (v = k),
        d = (h * d + I) / ++h) : (_(),
        n.lineTo(I, k),
        w = B,
        h = 0,
        b = v = k),
        S = k
    }
    _()
}
function h8(n) {
    const e = n.options
      , t = e.borderDash && e.borderDash.length;
    return !n._decimated && !n._loop && !e.tension && e.cubicInterpolationMode !== "monotone" && !e.stepped && !t ? vOe : wOe
}
function xOe(n) {
    return n.stepped ? PBe : n.tension || n.cubicInterpolationMode === "monotone" ? jBe : Yd
}
function EOe(n, e, t, r) {
    let s = e._path;
    s || (s = e._path = new Path2D,
    e.path(s, t, r) && s.closePath()),
    _W(n, e.options),
    n.stroke(s)
}
function SOe(n, e, t, r) {
    const {segments: s, options: i} = e
      , o = h8(e);
    for (const a of s)
        _W(n, i, a.style),
        n.beginPath(),
        o(n, e, a, {
            start: t,
            end: t + r - 1
        }) && n.closePath(),
        n.stroke()
}
const AOe = typeof Path2D == "function";
function COe(n, e, t, r) {
    AOe && !e.options.segment ? EOe(n, e, t, r) : SOe(n, e, t, r)
}
class Kx extends j0 {
    static id = "line";
    static defaults = {
        borderCapStyle: "butt",
        borderDash: [],
        borderDashOffset: 0,
        borderJoinStyle: "miter",
        borderWidth: 3,
        capBezierPoints: !0,
        cubicInterpolationMode: "default",
        fill: !1,
        spanGaps: !1,
        stepped: !1,
        tension: 0
    };
    static defaultRoutes = {
        backgroundColor: "backgroundColor",
        borderColor: "borderColor"
    };
    static descriptors = {
        _scriptable: !0,
        _indexable: e => e !== "borderDash" && e !== "fill"
    };
    constructor(e) {
        super(),
        this.animated = !0,
        this.options = void 0,
        this._chart = void 0,
        this._loop = void 0,
        this._fullLoop = void 0,
        this._path = void 0,
        this._points = void 0,
        this._segments = void 0,
        this._decimated = !1,
        this._pointsUpdated = !1,
        this._datasetIndex = void 0,
        e && Object.assign(this, e)
    }
    updateControlPoints(e, t) {
        const r = this.options;
        if ((r.tension || r.cubicInterpolationMode === "monotone") && !r.stepped && !this._pointsUpdated) {
            const s = r.spanGaps ? this._loop : this._fullLoop;
            NBe(this._points, r, e, s, t),
            this._pointsUpdated = !0
        }
    }
    set points(e) {
        this._points = e,
        delete this._segments,
        delete this._path,
        this._pointsUpdated = !1
    }
    get points() {
        return this._points
    }
    get segments() {
        return this._segments || (this._segments = HBe(this, this.options.segment))
    }
    first() {
        const e = this.segments
          , t = this.points;
        return e.length && t[e[0].start]
    }
    last() {
        const e = this.segments
          , t = this.points
          , r = e.length;
        return r && t[e[r - 1].end]
    }
    interpolate(e, t) {
        const r = this.options
          , s = e[t]
          , i = this.points
          , o = fW(this, {
            property: t,
            start: s,
            end: s
        });
        if (!o.length)
            return;
        const a = []
          , l = xOe(r);
        let u, d;
        for (u = 0,
        d = o.length; u < d; ++u) {
            const {start: h, end: p} = o[u]
              , g = i[h]
              , w = i[p];
            if (g === w) {
                a.push(g);
                continue
            }
            const b = Math.abs((s - g[t]) / (w[t] - g[t]))
              , v = l(g, w, b, r.stepped);
            v[t] = e[t],
            a.push(v)
        }
        return a.length === 1 ? a[0] : a
    }
    pathSegment(e, t, r) {
        return h8(this)(e, this, t, r)
    }
    path(e, t, r) {
        const s = this.segments
          , i = h8(this);
        let o = this._loop;
        t = t || 0,
        r = r || this.points.length - t;
        for (const a of s)
            o &= i(e, this, a, {
                start: t,
                end: t + r - 1
            });
        return !!o
    }
    draw(e, t, r, s) {
        const i = this.options || {};
        (this.points || []).length && i.borderWidth && (e.save(),
        COe(e, this, r, s),
        e.restore()),
        this.animated && (this._pointsUpdated = !1,
        this._path = void 0)
    }
}
function h9(n, e, t, r) {
    const s = n.options
      , {[t]: i} = n.getProps([t], r);
    return Math.abs(e - i) < s.radius + s.hitRadius
}
class _Oe extends j0 {
    static id = "point";
    parsed;
    skip;
    stop;
    static defaults = {
        borderWidth: 1,
        hitRadius: 1,
        hoverBorderWidth: 1,
        hoverRadius: 4,
        pointStyle: "circle",
        radius: 3,
        rotation: 0
    };
    static defaultRoutes = {
        backgroundColor: "backgroundColor",
        borderColor: "borderColor"
    };
    constructor(e) {
        super(),
        this.options = void 0,
        this.parsed = void 0,
        this.skip = void 0,
        this.stop = void 0,
        e && Object.assign(this, e)
    }
    inRange(e, t, r) {
        const s = this.options
          , {x: i, y: o} = this.getProps(["x", "y"], r);
        return Math.pow(e - i, 2) + Math.pow(t - o, 2) < Math.pow(s.hitRadius + s.radius, 2)
    }
    inXRange(e, t) {
        return h9(this, e, "x", t)
    }
    inYRange(e, t) {
        return h9(this, e, "y", t)
    }
    getCenterPoint(e) {
        const {x: t, y: r} = this.getProps(["x", "y"], e);
        return {
            x: t,
            y: r
        }
    }
    size(e) {
        e = e || this.options || {};
        let t = e.radius || 0;
        t = Math.max(t, t && e.hoverRadius || 0);
        const r = t && e.borderWidth || 0;
        return (t + r) * 2
    }
    draw(e, t) {
        const r = this.options;
        this.skip || r.radius < .1 || !hy(this, t, this.size(r) / 2) || (e.strokeStyle = r.borderColor,
        e.lineWidth = r.borderWidth,
        e.fillStyle = r.backgroundColor,
        c8(e, r, this.x, this.y))
    }
    getRange() {
        const e = this.options || {};
        return e.radius + e.hitRadius
    }
}
function kOe(n, e, t) {
    const r = n.segments
      , s = n.points
      , i = e.points
      , o = [];
    for (const a of r) {
        let {start: l, end: u} = a;
        u = Xx(l, u, s);
        const d = p8(t, s[l], s[u], a.loop);
        if (!e.segments) {
            o.push({
                source: a,
                target: d,
                start: s[l],
                end: s[u]
            });
            continue
        }
        const h = fW(e, d);
        for (const p of h) {
            const g = p8(t, i[p.start], i[p.end], p.loop)
              , w = dW(a, s, g);
            for (const b of w)
                o.push({
                    source: b,
                    target: p,
                    start: {
                        [t]: p9(d, g, "start", Math.max)
                    },
                    end: {
                        [t]: p9(d, g, "end", Math.min)
                    }
                })
        }
    }
    return o
}
function p8(n, e, t, r) {
    if (r)
        return;
    let s = e[n]
      , i = t[n];
    return n === "angle" && (s = Fa(s),
    i = Fa(i)),
    {
        property: n,
        start: s,
        end: i
    }
}
function NOe(n, e) {
    const {x: t=null, y: r=null} = n || {}
      , s = e.points
      , i = [];
    return e.segments.forEach( ({start: o, end: a}) => {
        a = Xx(o, a, s);
        const l = s[o]
          , u = s[a];
        r !== null ? (i.push({
            x: l.x,
            y: r
        }),
        i.push({
            x: u.x,
            y: r
        })) : t !== null && (i.push({
            x: t,
            y: l.y
        }),
        i.push({
            x: t,
            y: u.y
        }))
    }
    ),
    i
}
function Xx(n, e, t) {
    for (; e > n; e--) {
        const r = t[e];
        if (!isNaN(r.x) && !isNaN(r.y))
            break
    }
    return e
}
function p9(n, e, t, r) {
    return n && e ? r(n[t], e[t]) : n ? n[t] : e ? e[t] : 0
}
function NW(n, e) {
    let t = []
      , r = !1;
    return ns(n) ? (r = !0,
    t = n) : t = NOe(n, e),
    t.length ? new Kx({
        points: t,
        options: {
            tension: 0
        },
        _loop: r,
        _fullLoop: r
    }) : null
}
function m9(n) {
    return n && n.fill !== !1
}
function DOe(n, e, t) {
    let s = n[e].fill;
    const i = [e];
    let o;
    if (!t)
        return s;
    for (; s !== !1 && i.indexOf(s) === -1; ) {
        if (!$s(s))
            return s;
        if (o = n[s],
        !o)
            return !1;
        if (o.visible)
            return s;
        i.push(s),
        s = o.fill
    }
    return !1
}
function TOe(n, e, t) {
    const r = ROe(n);
    if (an(r))
        return isNaN(r.value) ? !1 : r;
    let s = parseFloat(r);
    return $s(s) && Math.floor(s) === s ? IOe(r[0], e, s, t) : ["origin", "start", "end", "stack", "shape"].indexOf(r) >= 0 && r
}
function IOe(n, e, t, r) {
    return (n === "-" || n === "+") && (t = e + t),
    t === e || t < 0 || t >= r ? !1 : t
}
function MOe(n, e) {
    let t = null;
    return n === "start" ? t = e.bottom : n === "end" ? t = e.top : an(n) ? t = e.getPixelForValue(n.value) : e.getBasePixel && (t = e.getBasePixel()),
    t
}
function BOe(n, e, t) {
    let r;
    return n === "start" ? r = t : n === "end" ? r = e.options.reverse ? e.min : e.max : an(n) ? r = n.value : r = e.getBaseValue(),
    r
}
function ROe(n) {
    const e = n.options
      , t = e.fill;
    let r = on(t && t.target, t);
    return r === void 0 && (r = !!e.backgroundColor),
    r === !1 || r === null ? !1 : r === !0 ? "origin" : r
}
function OOe(n) {
    const {scale: e, index: t, line: r} = n
      , s = []
      , i = r.segments
      , o = r.points
      , a = POe(e, t);
    a.push(NW({
        x: null,
        y: e.bottom
    }, r));
    for (let l = 0; l < i.length; l++) {
        const u = i[l];
        for (let d = u.start; d <= u.end; d++)
            jOe(s, o[d], a)
    }
    return new Kx({
        points: s,
        options: {}
    })
}
function POe(n, e) {
    const t = []
      , r = n.getMatchingVisibleMetas("line");
    for (let s = 0; s < r.length; s++) {
        const i = r[s];
        if (i.index === e)
            break;
        i.hidden || t.unshift(i.dataset)
    }
    return t
}
function jOe(n, e, t) {
    const r = [];
    for (let s = 0; s < t.length; s++) {
        const i = t[s]
          , {first: o, last: a, point: l} = LOe(i, e, "x");
        if (!(!l || o && a)) {
            if (o)
                r.unshift(l);
            else if (n.push(l),
            !a)
                break
        }
    }
    n.push(...r)
}
function LOe(n, e, t) {
    const r = n.interpolate(e, t);
    if (!r)
        return {};
    const s = r[t]
      , i = n.segments
      , o = n.points;
    let a = !1
      , l = !1;
    for (let u = 0; u < i.length; u++) {
        const d = i[u]
          , h = o[d.start][t]
          , p = o[d.end][t];
        if (Ep(s, h, p)) {
            a = s === h,
            l = s === p;
            break
        }
    }
    return {
        first: a,
        last: l,
        point: r
    }
}
class DW {
    constructor(e) {
        this.x = e.x,
        this.y = e.y,
        this.radius = e.radius
    }
    pathSegment(e, t, r) {
        const {x: s, y: i, radius: o} = this;
        return t = t || {
            start: 0,
            end: ua
        },
        e.arc(s, i, o, t.end, t.start, !0),
        !r.bounds
    }
    interpolate(e) {
        const {x: t, y: r, radius: s} = this
          , i = e.angle;
        return {
            x: t + Math.cos(i) * s,
            y: r + Math.sin(i) * s,
            angle: i
        }
    }
}
function FOe(n) {
    const {chart: e, fill: t, line: r} = n;
    if ($s(t))
        return UOe(e, t);
    if (t === "stack")
        return OOe(n);
    if (t === "shape")
        return !0;
    const s = zOe(n);
    return s instanceof DW ? s : NW(s, r)
}
function UOe(n, e) {
    const t = n.getDatasetMeta(e);
    return t && n.isDatasetVisible(e) ? t.dataset : null
}
function zOe(n) {
    return (n.scale || {}).getPointPositionForValue ? HOe(n) : $Oe(n)
}
function $Oe(n) {
    const {scale: e={}, fill: t} = n
      , r = MOe(t, e);
    if ($s(r)) {
        const s = e.isHorizontal();
        return {
            x: s ? r : null,
            y: s ? null : r
        }
    }
    return null
}
function HOe(n) {
    const {scale: e, fill: t} = n
      , r = e.options
      , s = e.getLabels().length
      , i = r.reverse ? e.max : e.min
      , o = BOe(t, e, i)
      , a = [];
    if (r.grid.circular) {
        const l = e.getPointPositionForValue(0, i);
        return new DW({
            x: l.x,
            y: l.y,
            radius: e.getDistanceFromCenterForValue(o)
        })
    }
    for (let l = 0; l < s; ++l)
        a.push(e.getPointPositionForValue(l, o));
    return a
}
function n4(n, e, t) {
    const r = FOe(e)
      , {chart: s, index: i, line: o, scale: a, axis: l} = e
      , u = o.options
      , d = u.fill
      , h = u.backgroundColor
      , {above: p=h, below: g=h} = d || {}
      , w = s.getDatasetMeta(i)
      , b = hW(s, w);
    r && o.points.length && (qx(n, t),
    VOe(n, {
        line: o,
        target: r,
        above: p,
        below: g,
        area: t,
        scale: a,
        axis: l,
        clip: b
    }),
    Gx(n))
}
function VOe(n, e) {
    const {line: t, target: r, above: s, below: i, area: o, scale: a, clip: l} = e
      , u = t._loop ? "angle" : e.axis;
    n.save();
    let d = i;
    i !== s && (u === "x" ? (g9(n, r, o.top),
    r4(n, {
        line: t,
        target: r,
        color: s,
        scale: a,
        property: u,
        clip: l
    }),
    n.restore(),
    n.save(),
    g9(n, r, o.bottom)) : u === "y" && (y9(n, r, o.left),
    r4(n, {
        line: t,
        target: r,
        color: i,
        scale: a,
        property: u,
        clip: l
    }),
    n.restore(),
    n.save(),
    y9(n, r, o.right),
    d = s)),
    r4(n, {
        line: t,
        target: r,
        color: d,
        scale: a,
        property: u,
        clip: l
    }),
    n.restore()
}
function g9(n, e, t) {
    const {segments: r, points: s} = e;
    let i = !0
      , o = !1;
    n.beginPath();
    for (const a of r) {
        const {start: l, end: u} = a
          , d = s[l]
          , h = s[Xx(l, u, s)];
        i ? (n.moveTo(d.x, d.y),
        i = !1) : (n.lineTo(d.x, t),
        n.lineTo(d.x, d.y)),
        o = !!e.pathSegment(n, a, {
            move: o
        }),
        o ? n.closePath() : n.lineTo(h.x, t)
    }
    n.lineTo(e.first().x, t),
    n.closePath(),
    n.clip()
}
function y9(n, e, t) {
    const {segments: r, points: s} = e;
    let i = !0
      , o = !1;
    n.beginPath();
    for (const a of r) {
        const {start: l, end: u} = a
          , d = s[l]
          , h = s[Xx(l, u, s)];
        i ? (n.moveTo(d.x, d.y),
        i = !1) : (n.lineTo(t, d.y),
        n.lineTo(d.x, d.y)),
        o = !!e.pathSegment(n, a, {
            move: o
        }),
        o ? n.closePath() : n.lineTo(t, h.y)
    }
    n.lineTo(t, e.first().y),
    n.closePath(),
    n.clip()
}
function r4(n, e) {
    const {line: t, target: r, property: s, color: i, scale: o, clip: a} = e
      , l = kOe(t, r, s);
    for (const {source: u, target: d, start: h, end: p} of l) {
        const {style: {backgroundColor: g=i}={}} = u
          , w = r !== !0;
        n.save(),
        n.fillStyle = g,
        qOe(n, o, a, w && p8(s, h, p)),
        n.beginPath();
        const b = !!t.pathSegment(n, u);
        let v;
        if (w) {
            b ? n.closePath() : b9(n, r, p, s);
            const S = !!r.pathSegment(n, d, {
                move: b,
                reverse: !0
            });
            v = b && S,
            v || b9(n, r, h, s)
        }
        n.closePath(),
        n.fill(v ? "evenodd" : "nonzero"),
        n.restore()
    }
}
function qOe(n, e, t, r) {
    const s = e.chart.chartArea
      , {property: i, start: o, end: a} = r || {};
    if (i === "x" || i === "y") {
        let l, u, d, h;
        i === "x" ? (l = o,
        u = s.top,
        d = a,
        h = s.bottom) : (l = s.left,
        u = o,
        d = s.right,
        h = a),
        n.beginPath(),
        t && (l = Math.max(l, t.left),
        d = Math.min(d, t.right),
        u = Math.max(u, t.top),
        h = Math.min(h, t.bottom)),
        n.rect(l, u, d - l, h - u),
        n.clip()
    }
}
function b9(n, e, t, r) {
    const s = e.interpolate(t, r);
    s && n.lineTo(s.x, s.y)
}
var GOe = {
    id: "filler",
    afterDatasetsUpdate(n, e, t) {
        const r = (n.data.datasets || []).length
          , s = [];
        let i, o, a, l;
        for (o = 0; o < r; ++o)
            i = n.getDatasetMeta(o),
            a = i.dataset,
            l = null,
            a && a.options && a instanceof Kx && (l = {
                visible: n.isDatasetVisible(o),
                index: o,
                fill: TOe(a, o, r),
                chart: n,
                axis: i.controller.options.indexAxis,
                scale: i.vScale,
                line: a
            }),
            i.$filler = l,
            s.push(l);
        for (o = 0; o < r; ++o)
            l = s[o],
            !(!l || l.fill === !1) && (l.fill = DOe(s, o, t.propagate))
    },
    beforeDraw(n, e, t) {
        const r = t.drawTime === "beforeDraw"
          , s = n.getSortedVisibleDatasetMetas()
          , i = n.chartArea;
        for (let o = s.length - 1; o >= 0; --o) {
            const a = s[o].$filler;
            a && (a.line.updateControlPoints(i, a.axis),
            r && a.fill && n4(n.ctx, a, i))
        }
    },
    beforeDatasetsDraw(n, e, t) {
        if (t.drawTime !== "beforeDatasetsDraw")
            return;
        const r = n.getSortedVisibleDatasetMetas();
        for (let s = r.length - 1; s >= 0; --s) {
            const i = r[s].$filler;
            m9(i) && n4(n.ctx, i, n.chartArea)
        }
    },
    beforeDatasetDraw(n, e, t) {
        const r = e.meta.$filler;
        !m9(r) || t.drawTime !== "beforeDatasetDraw" || n4(n.ctx, r, n.chartArea)
    },
    defaults: {
        propagate: !0,
        drawTime: "beforeDatasetDraw"
    }
};
const w9 = (n, e) => {
    let {boxHeight: t=e, boxWidth: r=e} = n;
    return n.usePointStyle && (t = Math.min(t, e),
    r = n.pointStyleWidth || Math.min(r, e)),
    {
        boxWidth: r,
        boxHeight: t,
        itemHeight: Math.max(e, t)
    }
}
  , WOe = (n, e) => n !== null && e !== null && n.datasetIndex === e.datasetIndex && n.index === e.index;
class v9 extends j0 {
    constructor(e) {
        super(),
        this._added = !1,
        this.legendHitBoxes = [],
        this._hoveredItem = null,
        this.doughnutMode = !1,
        this.chart = e.chart,
        this.options = e.options,
        this.ctx = e.ctx,
        this.legendItems = void 0,
        this.columnSizes = void 0,
        this.lineWidths = void 0,
        this.maxHeight = void 0,
        this.maxWidth = void 0,
        this.top = void 0,
        this.bottom = void 0,
        this.left = void 0,
        this.right = void 0,
        this.height = void 0,
        this.width = void 0,
        this._margins = void 0,
        this.position = void 0,
        this.weight = void 0,
        this.fullSize = void 0
    }
    update(e, t, r) {
        this.maxWidth = e,
        this.maxHeight = t,
        this._margins = r,
        this.setDimensions(),
        this.buildLabels(),
        this.fit()
    }
    setDimensions() {
        this.isHorizontal() ? (this.width = this.maxWidth,
        this.left = this._margins.left,
        this.right = this.width) : (this.height = this.maxHeight,
        this.top = this._margins.top,
        this.bottom = this.height)
    }
    buildLabels() {
        const e = this.options.labels || {};
        let t = Wn(e.generateLabels, [this.chart], this) || [];
        e.filter && (t = t.filter(r => e.filter(r, this.chart.data))),
        e.sort && (t = t.sort( (r, s) => e.sort(r, s, this.chart.data))),
        this.options.reverse && t.reverse(),
        this.legendItems = t
    }
    fit() {
        const {options: e, ctx: t} = this;
        if (!e.display) {
            this.width = this.height = 0;
            return
        }
        const r = e.labels
          , s = ki(r.font)
          , i = s.size
          , o = this._computeTitleHeight()
          , {boxWidth: a, itemHeight: l} = w9(r, i);
        let u, d;
        t.font = s.string,
        this.isHorizontal() ? (u = this.maxWidth,
        d = this._fitRows(o, i, a, l) + 10) : (d = this.maxHeight,
        u = this._fitCols(o, s, a, l) + 10),
        this.width = Math.min(u, e.maxWidth || this.maxWidth),
        this.height = Math.min(d, e.maxHeight || this.maxHeight)
    }
    _fitRows(e, t, r, s) {
        const {ctx: i, maxWidth: o, options: {labels: {padding: a}}} = this
          , l = this.legendHitBoxes = []
          , u = this.lineWidths = [0]
          , d = s + a;
        let h = e;
        i.textAlign = "left",
        i.textBaseline = "middle";
        let p = -1
          , g = -d;
        return this.legendItems.forEach( (w, b) => {
            const v = r + t / 2 + i.measureText(w.text).width;
            (b === 0 || u[u.length - 1] + v + 2 * a > o) && (h += d,
            u[u.length - (b > 0 ? 0 : 1)] = 0,
            g += d,
            p++),
            l[b] = {
                left: 0,
                top: g,
                row: p,
                width: v,
                height: s
            },
            u[u.length - 1] += v + a
        }
        ),
        h
    }
    _fitCols(e, t, r, s) {
        const {ctx: i, maxHeight: o, options: {labels: {padding: a}}} = this
          , l = this.legendHitBoxes = []
          , u = this.columnSizes = []
          , d = o - e;
        let h = a
          , p = 0
          , g = 0
          , w = 0
          , b = 0;
        return this.legendItems.forEach( (v, S) => {
            const {itemWidth: N, itemHeight: _} = YOe(r, t, i, v, s);
            S > 0 && g + _ + 2 * a > d && (h += p + a,
            u.push({
                width: p,
                height: g
            }),
            w += p + a,
            b++,
            p = g = 0),
            l[S] = {
                left: w,
                top: g,
                col: b,
                width: N,
                height: _
            },
            p = Math.max(p, N),
            g += _ + a
        }
        ),
        h += p,
        u.push({
            width: p,
            height: g
        }),
        h
    }
    adjustHitBoxes() {
        if (!this.options.display)
            return;
        const e = this._computeTitleHeight()
          , {legendHitBoxes: t, options: {align: r, labels: {padding: s}, rtl: i}} = this
          , o = Vp(i, this.left, this.width);
        if (this.isHorizontal()) {
            let a = 0
              , l = Hi(r, this.left + s, this.right - this.lineWidths[a]);
            for (const u of t)
                a !== u.row && (a = u.row,
                l = Hi(r, this.left + s, this.right - this.lineWidths[a])),
                u.top += this.top + e + s,
                u.left = o.leftForLtr(o.x(l), u.width),
                l += u.width + s
        } else {
            let a = 0
              , l = Hi(r, this.top + e + s, this.bottom - this.columnSizes[a].height);
            for (const u of t)
                u.col !== a && (a = u.col,
                l = Hi(r, this.top + e + s, this.bottom - this.columnSizes[a].height)),
                u.top = l,
                u.left += this.left + s,
                u.left = o.leftForLtr(o.x(u.left), u.width),
                l += u.height + s
        }
    }
    isHorizontal() {
        return this.options.position === "top" || this.options.position === "bottom"
    }
    draw() {
        if (this.options.display) {
            const e = this.ctx;
            qx(e, this),
            this._draw(),
            Gx(e)
        }
    }
    _draw() {
        const {options: e, columnSizes: t, lineWidths: r, ctx: s} = this
          , {align: i, labels: o} = e
          , a = _r.color
          , l = Vp(e.rtl, this.left, this.width)
          , u = ki(o.font)
          , {padding: d} = o
          , h = u.size
          , p = h / 2;
        let g;
        this.drawTitle(),
        s.textAlign = l.textAlign("left"),
        s.textBaseline = "middle",
        s.lineWidth = .5,
        s.font = u.string;
        const {boxWidth: w, boxHeight: b, itemHeight: v} = w9(o, h)
          , S = function(B, P, M) {
            if (isNaN(w) || w <= 0 || isNaN(b) || b < 0)
                return;
            s.save();
            const R = on(M.lineWidth, 1);
            if (s.fillStyle = on(M.fillStyle, a),
            s.lineCap = on(M.lineCap, "butt"),
            s.lineDashOffset = on(M.lineDashOffset, 0),
            s.lineJoin = on(M.lineJoin, "miter"),
            s.lineWidth = R,
            s.strokeStyle = on(M.strokeStyle, a),
            s.setLineDash(on(M.lineDash, [])),
            o.usePointStyle) {
                const L = {
                    radius: b * Math.SQRT2 / 2,
                    pointStyle: M.pointStyle,
                    rotation: M.rotation,
                    borderWidth: R
                }
                  , q = l.xPlus(B, w / 2)
                  , H = P + p;
                tW(s, L, q, H, o.pointStyleWidth && w)
            } else {
                const L = P + Math.max((h - b) / 2, 0)
                  , q = l.leftForLtr(B, w)
                  , H = zg(M.borderRadius);
                s.beginPath(),
                Object.values(H).some(j => j !== 0) ? u8(s, {
                    x: q,
                    y: L,
                    w,
                    h: b,
                    radius: H
                }) : s.rect(q, L, w, b),
                s.fill(),
                R !== 0 && s.stroke()
            }
            s.restore()
        }
          , N = function(B, P, M) {
            xv(s, M.text, B, P + v / 2, u, {
                strikethrough: M.hidden,
                textAlign: l.textAlign(M.textAlign)
            })
        }
          , _ = this.isHorizontal()
          , I = this._computeTitleHeight();
        _ ? g = {
            x: Hi(i, this.left + d, this.right - r[0]),
            y: this.top + d + I,
            line: 0
        } : g = {
            x: this.left + d,
            y: Hi(i, this.top + I + d, this.bottom - t[0].height),
            line: 0
        },
        lW(this.ctx, e.textDirection);
        const k = v + d;
        this.legendItems.forEach( (B, P) => {
            s.strokeStyle = B.fontColor,
            s.fillStyle = B.fontColor;
            const M = s.measureText(B.text).width
              , R = l.textAlign(B.textAlign || (B.textAlign = o.textAlign))
              , L = w + p + M;
            let q = g.x
              , H = g.y;
            l.setWidth(this.width),
            _ ? P > 0 && q + L + d > this.right && (H = g.y += k,
            g.line++,
            q = g.x = Hi(i, this.left + d, this.right - r[g.line])) : P > 0 && H + k > this.bottom && (q = g.x = q + t[g.line].width + d,
            g.line++,
            H = g.y = Hi(i, this.top + I + d, this.bottom - t[g.line].height));
            const j = l.x(q);
            if (S(j, H, B),
            q = qMe(R, q + w + p, _ ? q + L : this.right, e.rtl),
            N(l.x(q), H, B),
            _)
                g.x += L + d;
            else if (typeof B.text != "string") {
                const A = u.lineHeight;
                g.y += TW(B, A) + d
            } else
                g.y += k
        }
        ),
        cW(this.ctx, e.textDirection)
    }
    drawTitle() {
        const e = this.options
          , t = e.title
          , r = ki(t.font)
          , s = pa(t.padding);
        if (!t.display)
            return;
        const i = Vp(e.rtl, this.left, this.width)
          , o = this.ctx
          , a = t.position
          , l = r.size / 2
          , u = s.top + l;
        let d, h = this.left, p = this.width;
        if (this.isHorizontal())
            p = Math.max(...this.lineWidths),
            d = this.top + u,
            h = Hi(e.align, h, this.right - p);
        else {
            const w = this.columnSizes.reduce( (b, v) => Math.max(b, v.height), 0);
            d = u + Hi(e.align, this.top, this.bottom - w - e.labels.padding - this._computeTitleHeight())
        }
        const g = Hi(a, h, h + p);
        o.textAlign = i.textAlign(ZG(a)),
        o.textBaseline = "middle",
        o.strokeStyle = t.color,
        o.fillStyle = t.color,
        o.font = r.string,
        xv(o, t.text, g, d, r)
    }
    _computeTitleHeight() {
        const e = this.options.title
          , t = ki(e.font)
          , r = pa(e.padding);
        return e.display ? t.lineHeight + r.height : 0
    }
    _getLegendItemAt(e, t) {
        let r, s, i;
        if (Ep(e, this.left, this.right) && Ep(t, this.top, this.bottom)) {
            for (i = this.legendHitBoxes,
            r = 0; r < i.length; ++r)
                if (s = i[r],
                Ep(e, s.left, s.left + s.width) && Ep(t, s.top, s.top + s.height))
                    return this.legendItems[r]
        }
        return null
    }
    handleEvent(e) {
        const t = this.options;
        if (!QOe(e.type, t))
            return;
        const r = this._getLegendItemAt(e.x, e.y);
        if (e.type === "mousemove" || e.type === "mouseout") {
            const s = this._hoveredItem
              , i = WOe(s, r);
            s && !i && Wn(t.onLeave, [e, s, this], this),
            this._hoveredItem = r,
            r && !i && Wn(t.onHover, [e, r, this], this)
        } else
            r && Wn(t.onClick, [e, r, this], this)
    }
}
function YOe(n, e, t, r, s) {
    const i = KOe(r, n, e, t)
      , o = XOe(s, r, e.lineHeight);
    return {
        itemWidth: i,
        itemHeight: o
    }
}
function KOe(n, e, t, r) {
    let s = n.text;
    return s && typeof s != "string" && (s = s.reduce( (i, o) => i.length > o.length ? i : o)),
    e + t.size / 2 + r.measureText(s).width
}
function XOe(n, e, t) {
    let r = n;
    return typeof e.text != "string" && (r = TW(e, t)),
    r
}
function TW(n, e) {
    const t = n.text ? n.text.length : 0;
    return e * t
}
function QOe(n, e) {
    return !!((n === "mousemove" || n === "mouseout") && (e.onHover || e.onLeave) || e.onClick && (n === "click" || n === "mouseup"))
}
var ZOe = {
    id: "legend",
    _element: v9,
    start(n, e, t) {
        const r = n.legend = new v9({
            ctx: n.ctx,
            options: t,
            chart: n
        });
        $u.configure(n, r, t),
        $u.addBox(n, r)
    },
    stop(n) {
        $u.removeBox(n, n.legend),
        delete n.legend
    },
    beforeUpdate(n, e, t) {
        const r = n.legend;
        $u.configure(n, r, t),
        r.options = t
    },
    afterUpdate(n) {
        const e = n.legend;
        e.buildLabels(),
        e.adjustHitBoxes()
    },
    afterEvent(n, e) {
        e.replay || n.legend.handleEvent(e.event)
    },
    defaults: {
        display: !0,
        position: "top",
        align: "center",
        fullSize: !0,
        reverse: !1,
        weight: 1e3,
        onClick(n, e, t) {
            const r = e.datasetIndex
              , s = t.chart;
            s.isDatasetVisible(r) ? (s.hide(r),
            e.hidden = !0) : (s.show(r),
            e.hidden = !1)
        },
        onHover: null,
        onLeave: null,
        labels: {
            color: n => n.chart.options.color,
            boxWidth: 40,
            padding: 10,
            generateLabels(n) {
                const e = n.data.datasets
                  , {labels: {usePointStyle: t, pointStyle: r, textAlign: s, color: i, useBorderRadius: o, borderRadius: a}} = n.legend.options;
                return n._getSortedDatasetMetas().map(l => {
                    const u = l.controller.getStyle(t ? 0 : void 0)
                      , d = pa(u.borderWidth);
                    return {
                        text: e[l.index].label,
                        fillStyle: u.backgroundColor,
                        fontColor: i,
                        hidden: !l.visible,
                        lineCap: u.borderCapStyle,
                        lineDash: u.borderDash,
                        lineDashOffset: u.borderDashOffset,
                        lineJoin: u.borderJoinStyle,
                        lineWidth: (d.width + d.height) / 4,
                        strokeStyle: u.borderColor,
                        pointStyle: r || u.pointStyle,
                        rotation: u.rotation,
                        textAlign: s || u.textAlign,
                        borderRadius: o && (a || u.borderRadius),
                        datasetIndex: l.index
                    }
                }
                , this)
            }
        },
        title: {
            color: n => n.chart.options.color,
            display: !1,
            position: "center",
            text: ""
        }
    },
    descriptors: {
        _scriptable: n => !n.startsWith("on"),
        labels: {
            _scriptable: n => !["generateLabels", "filter", "sort"].includes(n)
        }
    }
};
const Ag = {
    average(n) {
        if (!n.length)
            return !1;
        let e, t, r = new Set, s = 0, i = 0;
        for (e = 0,
        t = n.length; e < t; ++e) {
            const a = n[e].element;
            if (a && a.hasValue()) {
                const l = a.tooltipPosition();
                r.add(l.x),
                s += l.y,
                ++i
            }
        }
        return i === 0 || r.size === 0 ? !1 : {
            x: [...r].reduce( (a, l) => a + l) / r.size,
            y: s / i
        }
    },
    nearest(n, e) {
        if (!n.length)
            return !1;
        let t = e.x, r = e.y, s = Number.POSITIVE_INFINITY, i, o, a;
        for (i = 0,
        o = n.length; i < o; ++i) {
            const l = n[i].element;
            if (l && l.hasValue()) {
                const u = l.getCenterPoint()
                  , d = o8(e, u);
                d < s && (s = d,
                a = l)
            }
        }
        if (a) {
            const l = a.tooltipPosition();
            t = l.x,
            r = l.y
        }
        return {
            x: t,
            y: r
        }
    }
};
function Ra(n, e) {
    return e && (ns(e) ? Array.prototype.push.apply(n, e) : n.push(e)),
    n
}
function Gl(n) {
    return (typeof n == "string" || n instanceof String) && n.indexOf(`
`) > -1 ? n.split(`
`) : n
}
function JOe(n, e) {
    const {element: t, datasetIndex: r, index: s} = e
      , i = n.getDatasetMeta(r).controller
      , {label: o, value: a} = i.getLabelAndValue(s);
    return {
        chart: n,
        label: o,
        parsed: i.getParsed(s),
        raw: n.data.datasets[r].data[s],
        formattedValue: a,
        dataset: i.getDataset(),
        dataIndex: s,
        datasetIndex: r,
        element: t
    }
}
function x9(n, e) {
    const t = n.chart.ctx
      , {body: r, footer: s, title: i} = n
      , {boxWidth: o, boxHeight: a} = e
      , l = ki(e.bodyFont)
      , u = ki(e.titleFont)
      , d = ki(e.footerFont)
      , h = i.length
      , p = s.length
      , g = r.length
      , w = pa(e.padding);
    let b = w.height
      , v = 0
      , S = r.reduce( (I, k) => I + k.before.length + k.lines.length + k.after.length, 0);
    if (S += n.beforeBody.length + n.afterBody.length,
    h && (b += h * u.lineHeight + (h - 1) * e.titleSpacing + e.titleMarginBottom),
    S) {
        const I = e.displayColors ? Math.max(a, l.lineHeight) : l.lineHeight;
        b += g * I + (S - g) * l.lineHeight + (S - 1) * e.bodySpacing
    }
    p && (b += e.footerMarginTop + p * d.lineHeight + (p - 1) * e.footerSpacing);
    let N = 0;
    const _ = function(I) {
        v = Math.max(v, t.measureText(I).width + N)
    };
    return t.save(),
    t.font = u.string,
    _n(n.title, _),
    t.font = l.string,
    _n(n.beforeBody.concat(n.afterBody), _),
    N = e.displayColors ? o + 2 + e.boxPadding : 0,
    _n(r, I => {
        _n(I.before, _),
        _n(I.lines, _),
        _n(I.after, _)
    }
    ),
    N = 0,
    t.font = d.string,
    _n(n.footer, _),
    t.restore(),
    v += w.width,
    {
        width: v,
        height: b
    }
}
function e7e(n, e) {
    const {y: t, height: r} = e;
    return t < r / 2 ? "top" : t > n.height - r / 2 ? "bottom" : "center"
}
function t7e(n, e, t, r) {
    const {x: s, width: i} = r
      , o = t.caretSize + t.caretPadding;
    if (n === "left" && s + i + o > e.width || n === "right" && s - i - o < 0)
        return !0
}
function n7e(n, e, t, r) {
    const {x: s, width: i} = t
      , {width: o, chartArea: {left: a, right: l}} = n;
    let u = "center";
    return r === "center" ? u = s <= (a + l) / 2 ? "left" : "right" : s <= i / 2 ? u = "left" : s >= o - i / 2 && (u = "right"),
    t7e(u, n, e, t) && (u = "center"),
    u
}
function E9(n, e, t) {
    const r = t.yAlign || e.yAlign || e7e(n, t);
    return {
        xAlign: t.xAlign || e.xAlign || n7e(n, e, t, r),
        yAlign: r
    }
}
function r7e(n, e) {
    let {x: t, width: r} = n;
    return e === "right" ? t -= r : e === "center" && (t -= r / 2),
    t
}
function s7e(n, e, t) {
    let {y: r, height: s} = n;
    return e === "top" ? r += t : e === "bottom" ? r -= s + t : r -= s / 2,
    r
}
function S9(n, e, t, r) {
    const {caretSize: s, caretPadding: i, cornerRadius: o} = n
      , {xAlign: a, yAlign: l} = t
      , u = s + i
      , {topLeft: d, topRight: h, bottomLeft: p, bottomRight: g} = zg(o);
    let w = r7e(e, a);
    const b = s7e(e, l, u);
    return l === "center" ? a === "left" ? w += u : a === "right" && (w -= u) : a === "left" ? w -= Math.max(d, p) + s : a === "right" && (w += Math.max(h, g) + s),
    {
        x: Xa(w, 0, r.width - e.width),
        y: Xa(b, 0, r.height - e.height)
    }
}
function Tw(n, e, t) {
    const r = pa(t.padding);
    return e === "center" ? n.x + n.width / 2 : e === "right" ? n.x + n.width - r.right : n.x + r.left
}
function A9(n) {
    return Ra([], Gl(n))
}
function i7e(n, e, t) {
    return nh(n, {
        tooltip: e,
        tooltipItems: t,
        type: "tooltip"
    })
}
function C9(n, e) {
    const t = e && e.dataset && e.dataset.tooltip && e.dataset.tooltip.callbacks;
    return t ? n.override(t) : n
}
const IW = {
    beforeTitle: zl,
    title(n) {
        if (n.length > 0) {
            const e = n[0]
              , t = e.chart.data.labels
              , r = t ? t.length : 0;
            if (this && this.options && this.options.mode === "dataset")
                return e.dataset.label || "";
            if (e.label)
                return e.label;
            if (r > 0 && e.dataIndex < r)
                return t[e.dataIndex]
        }
        return ""
    },
    afterTitle: zl,
    beforeBody: zl,
    beforeLabel: zl,
    label(n) {
        if (this && this.options && this.options.mode === "dataset")
            return n.label + ": " + n.formattedValue || n.formattedValue;
        let e = n.dataset.label || "";
        e && (e += ": ");
        const t = n.formattedValue;
        return sr(t) || (e += t),
        e
    },
    labelColor(n) {
        const t = n.chart.getDatasetMeta(n.datasetIndex).controller.getStyle(n.dataIndex);
        return {
            borderColor: t.borderColor,
            backgroundColor: t.backgroundColor,
            borderWidth: t.borderWidth,
            borderDash: t.borderDash,
            borderDashOffset: t.borderDashOffset,
            borderRadius: 0
        }
    },
    labelTextColor() {
        return this.options.bodyColor
    },
    labelPointStyle(n) {
        const t = n.chart.getDatasetMeta(n.datasetIndex).controller.getStyle(n.dataIndex);
        return {
            pointStyle: t.pointStyle,
            rotation: t.rotation
        }
    },
    afterLabel: zl,
    afterBody: zl,
    beforeFooter: zl,
    footer: zl,
    afterFooter: zl
};
function mi(n, e, t, r) {
    const s = n[e].call(t, r);
    return typeof s > "u" ? IW[e].call(t, r) : s
}
class _9 extends j0 {
    static positioners = Ag;
    constructor(e) {
        super(),
        this.opacity = 0,
        this._active = [],
        this._eventPosition = void 0,
        this._size = void 0,
        this._cachedAnimations = void 0,
        this._tooltipItems = [],
        this.$animations = void 0,
        this.$context = void 0,
        this.chart = e.chart,
        this.options = e.options,
        this.dataPoints = void 0,
        this.title = void 0,
        this.beforeBody = void 0,
        this.body = void 0,
        this.afterBody = void 0,
        this.footer = void 0,
        this.xAlign = void 0,
        this.yAlign = void 0,
        this.x = void 0,
        this.y = void 0,
        this.height = void 0,
        this.width = void 0,
        this.caretX = void 0,
        this.caretY = void 0,
        this.labelColors = void 0,
        this.labelPointStyles = void 0,
        this.labelTextColors = void 0
    }
    initialize(e) {
        this.options = e,
        this._cachedAnimations = void 0,
        this.$context = void 0
    }
    _resolveAnimations() {
        const e = this._cachedAnimations;
        if (e)
            return e;
        const t = this.chart
          , r = this.options.setContext(this.getContext())
          , s = r.enabled && t.options.animation && r.animations
          , i = new pW(this.chart,s);
        return s._cacheable && (this._cachedAnimations = Object.freeze(i)),
        i
    }
    getContext() {
        return this.$context || (this.$context = i7e(this.chart.getContext(), this, this._tooltipItems))
    }
    getTitle(e, t) {
        const {callbacks: r} = t
          , s = mi(r, "beforeTitle", this, e)
          , i = mi(r, "title", this, e)
          , o = mi(r, "afterTitle", this, e);
        let a = [];
        return a = Ra(a, Gl(s)),
        a = Ra(a, Gl(i)),
        a = Ra(a, Gl(o)),
        a
    }
    getBeforeBody(e, t) {
        return A9(mi(t.callbacks, "beforeBody", this, e))
    }
    getBody(e, t) {
        const {callbacks: r} = t
          , s = [];
        return _n(e, i => {
            const o = {
                before: [],
                lines: [],
                after: []
            }
              , a = C9(r, i);
            Ra(o.before, Gl(mi(a, "beforeLabel", this, i))),
            Ra(o.lines, mi(a, "label", this, i)),
            Ra(o.after, Gl(mi(a, "afterLabel", this, i))),
            s.push(o)
        }
        ),
        s
    }
    getAfterBody(e, t) {
        return A9(mi(t.callbacks, "afterBody", this, e))
    }
    getFooter(e, t) {
        const {callbacks: r} = t
          , s = mi(r, "beforeFooter", this, e)
          , i = mi(r, "footer", this, e)
          , o = mi(r, "afterFooter", this, e);
        let a = [];
        return a = Ra(a, Gl(s)),
        a = Ra(a, Gl(i)),
        a = Ra(a, Gl(o)),
        a
    }
    _createItems(e) {
        const t = this._active
          , r = this.chart.data
          , s = []
          , i = []
          , o = [];
        let a = [], l, u;
        for (l = 0,
        u = t.length; l < u; ++l)
            a.push(JOe(this.chart, t[l]));
        return e.filter && (a = a.filter( (d, h, p) => e.filter(d, h, p, r))),
        e.itemSort && (a = a.sort( (d, h) => e.itemSort(d, h, r))),
        _n(a, d => {
            const h = C9(e.callbacks, d);
            s.push(mi(h, "labelColor", this, d)),
            i.push(mi(h, "labelPointStyle", this, d)),
            o.push(mi(h, "labelTextColor", this, d))
        }
        ),
        this.labelColors = s,
        this.labelPointStyles = i,
        this.labelTextColors = o,
        this.dataPoints = a,
        a
    }
    update(e, t) {
        const r = this.options.setContext(this.getContext())
          , s = this._active;
        let i, o = [];
        if (!s.length)
            this.opacity !== 0 && (i = {
                opacity: 0
            });
        else {
            const a = Ag[r.position].call(this, s, this._eventPosition);
            o = this._createItems(r),
            this.title = this.getTitle(o, r),
            this.beforeBody = this.getBeforeBody(o, r),
            this.body = this.getBody(o, r),
            this.afterBody = this.getAfterBody(o, r),
            this.footer = this.getFooter(o, r);
            const l = this._size = x9(this, r)
              , u = Object.assign({}, a, l)
              , d = E9(this.chart, r, u)
              , h = S9(r, u, d, this.chart);
            this.xAlign = d.xAlign,
            this.yAlign = d.yAlign,
            i = {
                opacity: 1,
                x: h.x,
                y: h.y,
                width: l.width,
                height: l.height,
                caretX: a.x,
                caretY: a.y
            }
        }
        this._tooltipItems = o,
        this.$context = void 0,
        i && this._resolveAnimations().update(this, i),
        e && r.external && r.external.call(this, {
            chart: this.chart,
            tooltip: this,
            replay: t
        })
    }
    drawCaret(e, t, r, s) {
        const i = this.getCaretPosition(e, r, s);
        t.lineTo(i.x1, i.y1),
        t.lineTo(i.x2, i.y2),
        t.lineTo(i.x3, i.y3)
    }
    getCaretPosition(e, t, r) {
        const {xAlign: s, yAlign: i} = this
          , {caretSize: o, cornerRadius: a} = r
          , {topLeft: l, topRight: u, bottomLeft: d, bottomRight: h} = zg(a)
          , {x: p, y: g} = e
          , {width: w, height: b} = t;
        let v, S, N, _, I, k;
        return i === "center" ? (I = g + b / 2,
        s === "left" ? (v = p,
        S = v - o,
        _ = I + o,
        k = I - o) : (v = p + w,
        S = v + o,
        _ = I - o,
        k = I + o),
        N = v) : (s === "left" ? S = p + Math.max(l, d) + o : s === "right" ? S = p + w - Math.max(u, h) - o : S = this.caretX,
        i === "top" ? (_ = g,
        I = _ - o,
        v = S - o,
        N = S + o) : (_ = g + b,
        I = _ + o,
        v = S + o,
        N = S - o),
        k = _),
        {
            x1: v,
            x2: S,
            x3: N,
            y1: _,
            y2: I,
            y3: k
        }
    }
    drawTitle(e, t, r) {
        const s = this.title
          , i = s.length;
        let o, a, l;
        if (i) {
            const u = Vp(r.rtl, this.x, this.width);
            for (e.x = Tw(this, r.titleAlign, r),
            t.textAlign = u.textAlign(r.titleAlign),
            t.textBaseline = "middle",
            o = ki(r.titleFont),
            a = r.titleSpacing,
            t.fillStyle = r.titleColor,
            t.font = o.string,
            l = 0; l < i; ++l)
                t.fillText(s[l], u.x(e.x), e.y + o.lineHeight / 2),
                e.y += o.lineHeight + a,
                l + 1 === i && (e.y += r.titleMarginBottom - a)
        }
    }
    _drawColorBox(e, t, r, s, i) {
        const o = this.labelColors[r]
          , a = this.labelPointStyles[r]
          , {boxHeight: l, boxWidth: u} = i
          , d = ki(i.bodyFont)
          , h = Tw(this, "left", i)
          , p = s.x(h)
          , g = l < d.lineHeight ? (d.lineHeight - l) / 2 : 0
          , w = t.y + g;
        if (i.usePointStyle) {
            const b = {
                radius: Math.min(u, l) / 2,
                pointStyle: a.pointStyle,
                rotation: a.rotation,
                borderWidth: 1
            }
              , v = s.leftForLtr(p, u) + u / 2
              , S = w + l / 2;
            e.strokeStyle = i.multiKeyBackground,
            e.fillStyle = i.multiKeyBackground,
            c8(e, b, v, S),
            e.strokeStyle = o.borderColor,
            e.fillStyle = o.backgroundColor,
            c8(e, b, v, S)
        } else {
            e.lineWidth = an(o.borderWidth) ? Math.max(...Object.values(o.borderWidth)) : o.borderWidth || 1,
            e.strokeStyle = o.borderColor,
            e.setLineDash(o.borderDash || []),
            e.lineDashOffset = o.borderDashOffset || 0;
            const b = s.leftForLtr(p, u)
              , v = s.leftForLtr(s.xPlus(p, 1), u - 2)
              , S = zg(o.borderRadius);
            Object.values(S).some(N => N !== 0) ? (e.beginPath(),
            e.fillStyle = i.multiKeyBackground,
            u8(e, {
                x: b,
                y: w,
                w: u,
                h: l,
                radius: S
            }),
            e.fill(),
            e.stroke(),
            e.fillStyle = o.backgroundColor,
            e.beginPath(),
            u8(e, {
                x: v,
                y: w + 1,
                w: u - 2,
                h: l - 2,
                radius: S
            }),
            e.fill()) : (e.fillStyle = i.multiKeyBackground,
            e.fillRect(b, w, u, l),
            e.strokeRect(b, w, u, l),
            e.fillStyle = o.backgroundColor,
            e.fillRect(v, w + 1, u - 2, l - 2))
        }
        e.fillStyle = this.labelTextColors[r]
    }
    drawBody(e, t, r) {
        const {body: s} = this
          , {bodySpacing: i, bodyAlign: o, displayColors: a, boxHeight: l, boxWidth: u, boxPadding: d} = r
          , h = ki(r.bodyFont);
        let p = h.lineHeight
          , g = 0;
        const w = Vp(r.rtl, this.x, this.width)
          , b = function(M) {
            t.fillText(M, w.x(e.x + g), e.y + p / 2),
            e.y += p + i
        }
          , v = w.textAlign(o);
        let S, N, _, I, k, B, P;
        for (t.textAlign = o,
        t.textBaseline = "middle",
        t.font = h.string,
        e.x = Tw(this, v, r),
        t.fillStyle = r.bodyColor,
        _n(this.beforeBody, b),
        g = a && v !== "right" ? o === "center" ? u / 2 + d : u + 2 + d : 0,
        I = 0,
        B = s.length; I < B; ++I) {
            for (S = s[I],
            N = this.labelTextColors[I],
            t.fillStyle = N,
            _n(S.before, b),
            _ = S.lines,
            a && _.length && (this._drawColorBox(t, e, I, w, r),
            p = Math.max(h.lineHeight, l)),
            k = 0,
            P = _.length; k < P; ++k)
                b(_[k]),
                p = h.lineHeight;
            _n(S.after, b)
        }
        g = 0,
        p = h.lineHeight,
        _n(this.afterBody, b),
        e.y -= i
    }
    drawFooter(e, t, r) {
        const s = this.footer
          , i = s.length;
        let o, a;
        if (i) {
            const l = Vp(r.rtl, this.x, this.width);
            for (e.x = Tw(this, r.footerAlign, r),
            e.y += r.footerMarginTop,
            t.textAlign = l.textAlign(r.footerAlign),
            t.textBaseline = "middle",
            o = ki(r.footerFont),
            t.fillStyle = r.footerColor,
            t.font = o.string,
            a = 0; a < i; ++a)
                t.fillText(s[a], l.x(e.x), e.y + o.lineHeight / 2),
                e.y += o.lineHeight + r.footerSpacing
        }
    }
    drawBackground(e, t, r, s) {
        const {xAlign: i, yAlign: o} = this
          , {x: a, y: l} = e
          , {width: u, height: d} = r
          , {topLeft: h, topRight: p, bottomLeft: g, bottomRight: w} = zg(s.cornerRadius);
        t.fillStyle = s.backgroundColor,
        t.strokeStyle = s.borderColor,
        t.lineWidth = s.borderWidth,
        t.beginPath(),
        t.moveTo(a + h, l),
        o === "top" && this.drawCaret(e, t, r, s),
        t.lineTo(a + u - p, l),
        t.quadraticCurveTo(a + u, l, a + u, l + p),
        o === "center" && i === "right" && this.drawCaret(e, t, r, s),
        t.lineTo(a + u, l + d - w),
        t.quadraticCurveTo(a + u, l + d, a + u - w, l + d),
        o === "bottom" && this.drawCaret(e, t, r, s),
        t.lineTo(a + g, l + d),
        t.quadraticCurveTo(a, l + d, a, l + d - g),
        o === "center" && i === "left" && this.drawCaret(e, t, r, s),
        t.lineTo(a, l + h),
        t.quadraticCurveTo(a, l, a + h, l),
        t.closePath(),
        t.fill(),
        s.borderWidth > 0 && t.stroke()
    }
    _updateAnimationTarget(e) {
        const t = this.chart
          , r = this.$animations
          , s = r && r.x
          , i = r && r.y;
        if (s || i) {
            const o = Ag[e.position].call(this, this._active, this._eventPosition);
            if (!o)
                return;
            const a = this._size = x9(this, e)
              , l = Object.assign({}, o, this._size)
              , u = E9(t, e, l)
              , d = S9(e, l, u, t);
            (s._to !== d.x || i._to !== d.y) && (this.xAlign = u.xAlign,
            this.yAlign = u.yAlign,
            this.width = a.width,
            this.height = a.height,
            this.caretX = o.x,
            this.caretY = o.y,
            this._resolveAnimations().update(this, d))
        }
    }
    _willRender() {
        return !!this.opacity
    }
    draw(e) {
        const t = this.options.setContext(this.getContext());
        let r = this.opacity;
        if (!r)
            return;
        this._updateAnimationTarget(t);
        const s = {
            width: this.width,
            height: this.height
        }
          , i = {
            x: this.x,
            y: this.y
        };
        r = Math.abs(r) < .001 ? 0 : r;
        const o = pa(t.padding)
          , a = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
        t.enabled && a && (e.save(),
        e.globalAlpha = r,
        this.drawBackground(i, e, s, t),
        lW(e, t.textDirection),
        i.y += o.top,
        this.drawTitle(i, e, t),
        this.drawBody(i, e, t),
        this.drawFooter(i, e, t),
        cW(e, t.textDirection),
        e.restore())
    }
    getActiveElements() {
        return this._active || []
    }
    setActiveElements(e, t) {
        const r = this._active
          , s = e.map( ({datasetIndex: a, index: l}) => {
            const u = this.chart.getDatasetMeta(a);
            if (!u)
                throw new Error("Cannot find a dataset at index " + a);
            return {
                datasetIndex: a,
                element: u.data[l],
                index: l
            }
        }
        )
          , i = !mv(r, s)
          , o = this._positionChanged(s, t);
        (i || o) && (this._active = s,
        this._eventPosition = t,
        this._ignoreReplayEvents = !0,
        this.update(!0))
    }
    handleEvent(e, t, r=!0) {
        if (t && this._ignoreReplayEvents)
            return !1;
        this._ignoreReplayEvents = !1;
        const s = this.options
          , i = this._active || []
          , o = this._getActiveElements(e, i, t, r)
          , a = this._positionChanged(o, e)
          , l = t || !mv(o, i) || a;
        return l && (this._active = o,
        (s.enabled || s.external) && (this._eventPosition = {
            x: e.x,
            y: e.y
        },
        this.update(!0, t))),
        l
    }
    _getActiveElements(e, t, r, s) {
        const i = this.options;
        if (e.type === "mouseout")
            return [];
        if (!s)
            return t.filter(a => this.chart.data.datasets[a.datasetIndex] && this.chart.getDatasetMeta(a.datasetIndex).controller.getParsed(a.index) !== void 0);
        const o = this.chart.getElementsAtEventForMode(e, i.mode, i, r);
        return i.reverse && o.reverse(),
        o
    }
    _positionChanged(e, t) {
        const {caretX: r, caretY: s, options: i} = this
          , o = Ag[i.position].call(this, e, t);
        return o !== !1 && (r !== o.x || s !== o.y)
    }
}
var o7e = {
    id: "tooltip",
    _element: _9,
    positioners: Ag,
    afterInit(n, e, t) {
        t && (n.tooltip = new _9({
            chart: n,
            options: t
        }))
    },
    beforeUpdate(n, e, t) {
        n.tooltip && n.tooltip.initialize(t)
    },
    reset(n, e, t) {
        n.tooltip && n.tooltip.initialize(t)
    },
    afterDraw(n) {
        const e = n.tooltip;
        if (e && e._willRender()) {
            const t = {
                tooltip: e
            };
            if (n.notifyPlugins("beforeTooltipDraw", {
                ...t,
                cancelable: !0
            }) === !1)
                return;
            e.draw(n.ctx),
            n.notifyPlugins("afterTooltipDraw", t)
        }
    },
    afterEvent(n, e) {
        if (n.tooltip) {
            const t = e.replay;
            n.tooltip.handleEvent(e.event, t, e.inChartArea) && (e.changed = !0)
        }
    },
    defaults: {
        enabled: !0,
        external: null,
        position: "average",
        backgroundColor: "rgba(0,0,0,0.8)",
        titleColor: "#fff",
        titleFont: {
            weight: "bold"
        },
        titleSpacing: 2,
        titleMarginBottom: 6,
        titleAlign: "left",
        bodyColor: "#fff",
        bodySpacing: 2,
        bodyFont: {},
        bodyAlign: "left",
        footerColor: "#fff",
        footerSpacing: 2,
        footerMarginTop: 6,
        footerFont: {
            weight: "bold"
        },
        footerAlign: "left",
        padding: 6,
        caretPadding: 2,
        caretSize: 5,
        cornerRadius: 6,
        boxHeight: (n, e) => e.bodyFont.size,
        boxWidth: (n, e) => e.bodyFont.size,
        multiKeyBackground: "#fff",
        displayColors: !0,
        boxPadding: 0,
        borderColor: "rgba(0,0,0,0)",
        borderWidth: 0,
        animation: {
            duration: 400,
            easing: "easeOutQuart"
        },
        animations: {
            numbers: {
                type: "number",
                properties: ["x", "y", "width", "height", "caretX", "caretY"]
            },
            opacity: {
                easing: "linear",
                duration: 200
            }
        },
        callbacks: IW
    },
    defaultRoutes: {
        bodyFont: "font",
        footerFont: "font",
        titleFont: "font"
    },
    descriptors: {
        _scriptable: n => n !== "filter" && n !== "itemSort" && n !== "external",
        _indexable: !1,
        callbacks: {
            _scriptable: !1,
            _indexable: !1
        },
        animation: {
            _fallback: !1
        },
        animations: {
            _fallback: "animation"
        }
    },
    additionalOptionScopes: ["interaction"]
};
const a7e = (n, e, t, r) => (typeof e == "string" ? (t = n.push(e) - 1,
r.unshift({
    index: t,
    label: e
})) : isNaN(e) && (t = null),
t);
function l7e(n, e, t, r) {
    const s = n.indexOf(e);
    if (s === -1)
        return a7e(n, e, t, r);
    const i = n.lastIndexOf(e);
    return s !== i ? t : s
}
const c7e = (n, e) => n === null ? null : Xa(Math.round(n), 0, e);
function k9(n) {
    const e = this.getLabels();
    return n >= 0 && n < e.length ? e[n] : n
}
class u7e extends L0 {
    static id = "category";
    static defaults = {
        ticks: {
            callback: k9
        }
    };
    constructor(e) {
        super(e),
        this._startValue = void 0,
        this._valueRange = 0,
        this._addedLabels = []
    }
    init(e) {
        const t = this._addedLabels;
        if (t.length) {
            const r = this.getLabels();
            for (const {index: s, label: i} of t)
                r[s] === i && r.splice(s, 1);
            this._addedLabels = []
        }
        super.init(e)
    }
    parse(e, t) {
        if (sr(e))
            return null;
        const r = this.getLabels();
        return t = isFinite(t) && r[t] === e ? t : l7e(r, e, on(t, e), this._addedLabels),
        c7e(t, r.length - 1)
    }
    determineDataLimits() {
        const {minDefined: e, maxDefined: t} = this.getUserBounds();
        let {min: r, max: s} = this.getMinMax(!0);
        this.options.bounds === "ticks" && (e || (r = 0),
        t || (s = this.getLabels().length - 1)),
        this.min = r,
        this.max = s
    }
    buildTicks() {
        const e = this.min
          , t = this.max
          , r = this.options.offset
          , s = [];
        let i = this.getLabels();
        i = e === 0 && t === i.length - 1 ? i : i.slice(e, t + 1),
        this._valueRange = Math.max(i.length - (r ? 0 : 1), 1),
        this._startValue = this.min - (r ? .5 : 0);
        for (let o = e; o <= t; o++)
            s.push({
                value: o
            });
        return s
    }
    getLabelForValue(e) {
        return k9.call(this, e)
    }
    configure() {
        super.configure(),
        this.isHorizontal() || (this._reversePixels = !this._reversePixels)
    }
    getPixelForValue(e) {
        return typeof e != "number" && (e = this.parse(e)),
        e === null ? NaN : this.getPixelForDecimal((e - this._startValue) / this._valueRange)
    }
    getPixelForTick(e) {
        const t = this.ticks;
        return e < 0 || e > t.length - 1 ? null : this.getPixelForValue(t[e].value)
    }
    getValueForPixel(e) {
        return Math.round(this._startValue + this.getDecimalForPixel(e) * this._valueRange)
    }
    getBasePixel() {
        return this.bottom
    }
}
function d7e(n, e) {
    const t = []
      , {bounds: s, step: i, min: o, max: a, precision: l, count: u, maxTicks: d, maxDigits: h, includeBounds: p} = n
      , g = i || 1
      , w = d - 1
      , {min: b, max: v} = e
      , S = !sr(o)
      , N = !sr(a)
      , _ = !sr(u)
      , I = (v - b) / (h + 1);
    let k = _j((v - b) / w / g) * g, B, P, M, R;
    if (k < 1e-14 && !S && !N)
        return [{
            value: b
        }, {
            value: v
        }];
    R = Math.ceil(v / k) - Math.floor(b / k),
    R > w && (k = _j(R * k / w / g) * g),
    sr(l) || (B = Math.pow(10, l),
    k = Math.ceil(k * B) / B),
    s === "ticks" ? (P = Math.floor(b / k) * k,
    M = Math.ceil(v / k) * k) : (P = b,
    M = v),
    S && N && i && RMe((a - o) / i, k / 1e3) ? (R = Math.round(Math.min((a - o) / k, d)),
    k = (a - o) / R,
    P = o,
    M = a) : _ ? (P = S ? o : P,
    M = N ? a : M,
    R = u - 1,
    k = (M - P) / R) : (R = (M - P) / k,
    Lg(R, Math.round(R), k / 1e3) ? R = Math.round(R) : R = Math.ceil(R));
    const L = Math.max(kj(k), kj(P));
    B = Math.pow(10, sr(l) ? L : l),
    P = Math.round(P * B) / B,
    M = Math.round(M * B) / B;
    let q = 0;
    for (S && (p && P !== o ? (t.push({
        value: o
    }),
    P < o && q++,
    Lg(Math.round((P + q * k) * B) / B, o, N9(o, I, n)) && q++) : P < o && q++); q < R; ++q) {
        const H = Math.round((P + q * k) * B) / B;
        if (N && H > a)
            break;
        t.push({
            value: H
        })
    }
    return N && p && M !== a ? t.length && Lg(t[t.length - 1].value, a, N9(a, I, n)) ? t[t.length - 1].value = a : t.push({
        value: a
    }) : (!N || M === a) && t.push({
        value: M
    }),
    t
}
function N9(n, e, {horizontal: t, minRotation: r}) {
    const s = wf(r)
      , i = (t ? Math.sin(s) : Math.cos(s)) || .001
      , o = .75 * e * ("" + n).length;
    return Math.min(e / i, o)
}
class f7e extends L0 {
    constructor(e) {
        super(e),
        this.start = void 0,
        this.end = void 0,
        this._startValue = void 0,
        this._endValue = void 0,
        this._valueRange = 0
    }
    parse(e, t) {
        return sr(e) || (typeof e == "number" || e instanceof Number) && !isFinite(+e) ? null : +e
    }
    handleTickRangeOptions() {
        const {beginAtZero: e} = this.options
          , {minDefined: t, maxDefined: r} = this.getUserBounds();
        let {min: s, max: i} = this;
        const o = l => s = t ? s : l
          , a = l => i = r ? i : l;
        if (e) {
            const l = m0(s)
              , u = m0(i);
            l < 0 && u < 0 ? a(0) : l > 0 && u > 0 && o(0)
        }
        if (s === i) {
            let l = i === 0 ? 1 : Math.abs(i * .05);
            a(i + l),
            e || o(s - l)
        }
        this.min = s,
        this.max = i
    }
    getTickLimit() {
        const e = this.options.ticks;
        let {maxTicksLimit: t, stepSize: r} = e, s;
        return r ? (s = Math.ceil(this.max / r) - Math.floor(this.min / r) + 1,
        s > 1e3 && (console.warn(`scales.${this.id}.ticks.stepSize: ${r} would result generating up to ${s} ticks. Limiting to 1000.`),
        s = 1e3)) : (s = this.computeTickLimit(),
        t = t || 11),
        t && (s = Math.min(t, s)),
        s
    }
    computeTickLimit() {
        return Number.POSITIVE_INFINITY
    }
    buildTicks() {
        const e = this.options
          , t = e.ticks;
        let r = this.getTickLimit();
        r = Math.max(2, r);
        const s = {
            maxTicks: r,
            bounds: e.bounds,
            min: e.min,
            max: e.max,
            precision: t.precision,
            step: t.stepSize,
            count: t.count,
            maxDigits: this._maxDigits(),
            horizontal: this.isHorizontal(),
            minRotation: t.minRotation || 0,
            includeBounds: t.includeBounds !== !1
        }
          , i = this._range || this
          , o = d7e(s, i);
        return e.bounds === "ticks" && OMe(o, this, "value"),
        e.reverse ? (o.reverse(),
        this.start = this.max,
        this.end = this.min) : (this.start = this.min,
        this.end = this.max),
        o
    }
    configure() {
        const e = this.ticks;
        let t = this.min
          , r = this.max;
        if (super.configure(),
        this.options.offset && e.length) {
            const s = (r - t) / Math.max(e.length - 1, 1) / 2;
            t -= s,
            r += s
        }
        this._startValue = t,
        this._endValue = r,
        this._valueRange = r - t
    }
    getLabelForValue(e) {
        return JG(e, this.chart.options.locale, this.options.ticks.format)
    }
}
class h7e extends f7e {
    static id = "linear";
    static defaults = {
        ticks: {
            callback: eW.formatters.numeric
        }
    };
    determineDataLimits() {
        const {min: e, max: t} = this.getMinMax(!0);
        this.min = $s(e) ? e : 0,
        this.max = $s(t) ? t : 1,
        this.handleTickRangeOptions()
    }
    computeTickLimit() {
        const e = this.isHorizontal()
          , t = e ? this.width : this.height
          , r = wf(this.options.ticks.minRotation)
          , s = (e ? Math.sin(r) : Math.cos(r)) || .001
          , i = this._resolveTickFontOptions(0);
        return Math.ceil(t / Math.min(40, i.lineHeight / s))
    }
    getPixelForValue(e) {
        return e === null ? NaN : this.getPixelForDecimal((e - this._startValue) / this._valueRange)
    }
    getValueForPixel(e) {
        return this._startValue + this.getDecimalForPixel(e) * this._valueRange
    }
}
const Qx = {
    millisecond: {
        common: !0,
        size: 1,
        steps: 1e3
    },
    second: {
        common: !0,
        size: 1e3,
        steps: 60
    },
    minute: {
        common: !0,
        size: 6e4,
        steps: 60
    },
    hour: {
        common: !0,
        size: 36e5,
        steps: 24
    },
    day: {
        common: !0,
        size: 864e5,
        steps: 30
    },
    week: {
        common: !1,
        size: 6048e5,
        steps: 4
    },
    month: {
        common: !0,
        size: 2628e6,
        steps: 12
    },
    quarter: {
        common: !1,
        size: 7884e6,
        steps: 4
    },
    year: {
        common: !0,
        size: 3154e7
    }
}
  , Si = Object.keys(Qx);
function D9(n, e) {
    return n - e
}
function T9(n, e) {
    if (sr(e))
        return null;
    const t = n._adapter
      , {parser: r, round: s, isoWeekday: i} = n._parseOpts;
    let o = e;
    return typeof r == "function" && (o = r(o)),
    $s(o) || (o = typeof r == "string" ? t.parse(o, r) : t.parse(o)),
    o === null ? null : (s && (o = s === "week" && (vv(i) || i === !0) ? t.startOf(o, "isoWeek", i) : t.startOf(o, s)),
    +o)
}
function I9(n, e, t, r) {
    const s = Si.length;
    for (let i = Si.indexOf(n); i < s - 1; ++i) {
        const o = Qx[Si[i]]
          , a = o.steps ? o.steps : Number.MAX_SAFE_INTEGER;
        if (o.common && Math.ceil((t - e) / (a * o.size)) <= r)
            return Si[i]
    }
    return Si[s - 1]
}
function p7e(n, e, t, r, s) {
    for (let i = Si.length - 1; i >= Si.indexOf(t); i--) {
        const o = Si[i];
        if (Qx[o].common && n._adapter.diff(s, r, o) >= e - 1)
            return o
    }
    return Si[t ? Si.indexOf(t) : 0]
}
function m7e(n) {
    for (let e = Si.indexOf(n) + 1, t = Si.length; e < t; ++e)
        if (Qx[Si[e]].common)
            return Si[e]
}
function M9(n, e, t) {
    if (!t)
        n[e] = !0;
    else if (t.length) {
        const {lo: r, hi: s} = jk(t, e)
          , i = t[r] >= e ? t[r] : t[s];
        n[i] = !0
    }
}
function g7e(n, e, t, r) {
    const s = n._adapter
      , i = +s.startOf(e[0].value, r)
      , o = e[e.length - 1].value;
    let a, l;
    for (a = i; a <= o; a = +s.add(a, 1, r))
        l = t[a],
        l >= 0 && (e[l].major = !0);
    return e
}
function B9(n, e, t) {
    const r = []
      , s = {}
      , i = e.length;
    let o, a;
    for (o = 0; o < i; ++o)
        a = e[o],
        s[a] = o,
        r.push({
            value: a,
            major: !1
        });
    return i === 0 || !t ? r : g7e(n, r, s, t)
}
class R9 extends L0 {
    static id = "time";
    static defaults = {
        bounds: "data",
        adapters: {},
        time: {
            parser: !1,
            unit: !1,
            round: !1,
            isoWeekday: !1,
            minUnit: "millisecond",
            displayFormats: {}
        },
        ticks: {
            source: "auto",
            callback: !1,
            major: {
                enabled: !1
            }
        }
    };
    constructor(e) {
        super(e),
        this._cache = {
            data: [],
            labels: [],
            all: []
        },
        this._unit = "day",
        this._majorUnit = void 0,
        this._offsets = {},
        this._normalized = !1,
        this._parseOpts = void 0
    }
    init(e, t={}) {
        const r = e.time || (e.time = {})
          , s = this._adapter = new lRe._date(e.adapters.date);
        s.init(t),
        jg(r.displayFormats, s.formats()),
        this._parseOpts = {
            parser: r.parser,
            round: r.round,
            isoWeekday: r.isoWeekday
        },
        super.init(e),
        this._normalized = t.normalized
    }
    parse(e, t) {
        return e === void 0 ? null : T9(this, e)
    }
    beforeLayout() {
        super.beforeLayout(),
        this._cache = {
            data: [],
            labels: [],
            all: []
        }
    }
    determineDataLimits() {
        const e = this.options
          , t = this._adapter
          , r = e.time.unit || "day";
        let {min: s, max: i, minDefined: o, maxDefined: a} = this.getUserBounds();
        function l(u) {
            !o && !isNaN(u.min) && (s = Math.min(s, u.min)),
            !a && !isNaN(u.max) && (i = Math.max(i, u.max))
        }
        (!o || !a) && (l(this._getLabelBounds()),
        (e.bounds !== "ticks" || e.ticks.source !== "labels") && l(this.getMinMax(!1))),
        s = $s(s) && !isNaN(s) ? s : +t.startOf(Date.now(), r),
        i = $s(i) && !isNaN(i) ? i : +t.endOf(Date.now(), r) + 1,
        this.min = Math.min(s, i - 1),
        this.max = Math.max(s + 1, i)
    }
    _getLabelBounds() {
        const e = this.getLabelTimestamps();
        let t = Number.POSITIVE_INFINITY
          , r = Number.NEGATIVE_INFINITY;
        return e.length && (t = e[0],
        r = e[e.length - 1]),
        {
            min: t,
            max: r
        }
    }
    buildTicks() {
        const e = this.options
          , t = e.time
          , r = e.ticks
          , s = r.source === "labels" ? this.getLabelTimestamps() : this._generate();
        e.bounds === "ticks" && s.length && (this.min = this._userMin || s[0],
        this.max = this._userMax || s[s.length - 1]);
        const i = this.min
          , o = this.max
          , a = zMe(s, i, o);
        return this._unit = t.unit || (r.autoSkip ? I9(t.minUnit, this.min, this.max, this._getLabelCapacity(i)) : p7e(this, a.length, t.minUnit, this.min, this.max)),
        this._majorUnit = !r.major.enabled || this._unit === "year" ? void 0 : m7e(this._unit),
        this.initOffsets(s),
        e.reverse && a.reverse(),
        B9(this, a, this._majorUnit)
    }
    afterAutoSkip() {
        this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map(e => +e.value))
    }
    initOffsets(e=[]) {
        let t = 0, r = 0, s, i;
        this.options.offset && e.length && (s = this.getDecimalForValue(e[0]),
        e.length === 1 ? t = 1 - s : t = (this.getDecimalForValue(e[1]) - s) / 2,
        i = this.getDecimalForValue(e[e.length - 1]),
        e.length === 1 ? r = i : r = (i - this.getDecimalForValue(e[e.length - 2])) / 2);
        const o = e.length < 3 ? .5 : .25;
        t = Xa(t, 0, o),
        r = Xa(r, 0, o),
        this._offsets = {
            start: t,
            end: r,
            factor: 1 / (t + 1 + r)
        }
    }
    _generate() {
        const e = this._adapter
          , t = this.min
          , r = this.max
          , s = this.options
          , i = s.time
          , o = i.unit || I9(i.minUnit, t, r, this._getLabelCapacity(t))
          , a = on(s.ticks.stepSize, 1)
          , l = o === "week" ? i.isoWeekday : !1
          , u = vv(l) || l === !0
          , d = {};
        let h = t, p, g;
        if (u && (h = +e.startOf(h, "isoWeek", l)),
        h = +e.startOf(h, u ? "day" : o),
        e.diff(r, t, o) > 1e5 * a)
            throw new Error(t + " and " + r + " are too far apart with stepSize of " + a + " " + o);
        const w = s.ticks.source === "data" && this.getDataTimestamps();
        for (p = h,
        g = 0; p < r; p = +e.add(p, a, o),
        g++)
            M9(d, p, w);
        return (p === r || s.bounds === "ticks" || g === 1) && M9(d, p, w),
        Object.keys(d).sort(D9).map(b => +b)
    }
    getLabelForValue(e) {
        const t = this._adapter
          , r = this.options.time;
        return r.tooltipFormat ? t.format(e, r.tooltipFormat) : t.format(e, r.displayFormats.datetime)
    }
    format(e, t) {
        const s = this.options.time.displayFormats
          , i = this._unit
          , o = t || s[i];
        return this._adapter.format(e, o)
    }
    _tickFormatFunction(e, t, r, s) {
        const i = this.options
          , o = i.ticks.callback;
        if (o)
            return Wn(o, [e, t, r], this);
        const a = i.time.displayFormats
          , l = this._unit
          , u = this._majorUnit
          , d = l && a[l]
          , h = u && a[u]
          , p = r[t]
          , g = u && h && p && p.major;
        return this._adapter.format(e, s || (g ? h : d))
    }
    generateTickLabels(e) {
        let t, r, s;
        for (t = 0,
        r = e.length; t < r; ++t)
            s = e[t],
            s.label = this._tickFormatFunction(s.value, t, e)
    }
    getDecimalForValue(e) {
        return e === null ? NaN : (e - this.min) / (this.max - this.min)
    }
    getPixelForValue(e) {
        const t = this._offsets
          , r = this.getDecimalForValue(e);
        return this.getPixelForDecimal((t.start + r) * t.factor)
    }
    getValueForPixel(e) {
        const t = this._offsets
          , r = this.getDecimalForPixel(e) / t.factor - t.end;
        return this.min + r * (this.max - this.min)
    }
    _getLabelSize(e) {
        const t = this.options.ticks
          , r = this.ctx.measureText(e).width
          , s = wf(this.isHorizontal() ? t.maxRotation : t.minRotation)
          , i = Math.cos(s)
          , o = Math.sin(s)
          , a = this._resolveTickFontOptions(0).size;
        return {
            w: r * i + a * o,
            h: r * o + a * i
        }
    }
    _getLabelCapacity(e) {
        const t = this.options.time
          , r = t.displayFormats
          , s = r[t.unit] || r.millisecond
          , i = this._tickFormatFunction(e, 0, B9(this, [e], this._majorUnit), s)
          , o = this._getLabelSize(i)
          , a = Math.floor(this.isHorizontal() ? this.width / o.w : this.height / o.h) - 1;
        return a > 0 ? a : 1
    }
    getDataTimestamps() {
        let e = this._cache.data || [], t, r;
        if (e.length)
            return e;
        const s = this.getMatchingVisibleMetas();
        if (this._normalized && s.length)
            return this._cache.data = s[0].controller.getAllParsedValues(this);
        for (t = 0,
        r = s.length; t < r; ++t)
            e = e.concat(s[t].controller.getAllParsedValues(this));
        return this._cache.data = this.normalize(e)
    }
    getLabelTimestamps() {
        const e = this._cache.labels || [];
        let t, r;
        if (e.length)
            return e;
        const s = this.getLabels();
        for (t = 0,
        r = s.length; t < r; ++t)
            e.push(T9(this, s[t]));
        return this._cache.labels = this._normalized ? e : this.normalize(e)
    }
    normalize(e) {
        return HMe(e.sort(D9))
    }
}
function Iw(n, e, t) {
    let r = 0, s = n.length - 1, i, o, a, l;
    t ? (e >= n[r].pos && e <= n[s].pos && ({lo: r, hi: s} = a8(n, "pos", e)),
    {pos: i, time: a} = n[r],
    {pos: o, time: l} = n[s]) : (e >= n[r].time && e <= n[s].time && ({lo: r, hi: s} = a8(n, "time", e)),
    {time: i, pos: a} = n[r],
    {time: o, pos: l} = n[s]);
    const u = o - i;
    return u ? a + (l - a) * (e - i) / u : a
}
class g9e extends R9 {
    static id = "timeseries";
    static defaults = R9.defaults;
    constructor(e) {
        super(e),
        this._table = [],
        this._minPos = void 0,
        this._tableRange = void 0
    }
    initOffsets() {
        const e = this._getTimestampsForTable()
          , t = this._table = this.buildLookupTable(e);
        this._minPos = Iw(t, this.min),
        this._tableRange = Iw(t, this.max) - this._minPos,
        super.initOffsets(e)
    }
    buildLookupTable(e) {
        const {min: t, max: r} = this
          , s = []
          , i = [];
        let o, a, l, u, d;
        for (o = 0,
        a = e.length; o < a; ++o)
            u = e[o],
            u >= t && u <= r && s.push(u);
        if (s.length < 2)
            return [{
                time: t,
                pos: 0
            }, {
                time: r,
                pos: 1
            }];
        for (o = 0,
        a = s.length; o < a; ++o)
            d = s[o + 1],
            l = s[o - 1],
            u = s[o],
            Math.round((d + l) / 2) !== u && i.push({
                time: u,
                pos: o / (a - 1)
            });
        return i
    }
    _generate() {
        const e = this.min
          , t = this.max;
        let r = super.getDataTimestamps();
        return (!r.includes(e) || !r.length) && r.splice(0, 0, e),
        (!r.includes(t) || r.length === 1) && r.push(t),
        r.sort( (s, i) => s - i)
    }
    _getTimestampsForTable() {
        let e = this._cache.all || [];
        if (e.length)
            return e;
        const t = this.getDataTimestamps()
          , r = this.getLabelTimestamps();
        return t.length && r.length ? e = this.normalize(t.concat(r)) : e = t.length ? t : r,
        e = this._cache.all = e,
        e
    }
    getDecimalForValue(e) {
        return (Iw(this._table, e) - this._minPos) / this._tableRange
    }
    getValueForPixel(e) {
        const t = this._offsets
          , r = this.getDecimalForPixel(e) / t.factor - t.end;
        return Iw(this._table, r * this._tableRange + this._minPos, !0)
    }
}
CW.register(u7e, h7e, _Oe, Kx, GOe, o7e, ZOe);
function y7e() {
    return m.jsx(QTe, {
        children: m.jsx("div", {
            className: "relative flex w-full flex-col bg-gray-800",
            children: m.jsx("div", {
                className: "flex-1 md:px-5",
                children: m.jsx("div", {
                    className: "mx-auto md:my-5 mt-0 min-w-[300px] ",
                    children: m.jsxs("div", {
                        className: "flex flex-col-reverse overflow-hidden rounded-lg lg:w-full lg:flex-row",
                        children: [m.jsx("div", {
                            className: "flex-1 has768-order-1",
                            children: m.jsx(lIe, {})
                        }), m.jsx(eMe, {})]
                    })
                })
            })
        })
    })
}
const MW = ({isOpen: n, onClose: e, data: t}) => {
    if (!n)
        return null;
    const [r,s] = V.useState("result")
      , [i,o] = V.useState(!1)
      , [a,l] = V.useState(!1)
      , [u,d] = V.useState(!1)
      , [h,p] = V.useState(!1)
      , [g,w] = V.useState(!1)
      , [b,v] = V.useState(!1)
      , [S,N] = V.useState(!1)
      , [_,I] = V.useState([])
      , k = new Date(t?.timestamp).toLocaleDateString("en-US", {
        day: "2-digit",
        month: "2-digit",
        year: "numeric"
    })
      , B = new Date(t?.timestamp).toLocaleTimeString("en-US", {
        hour: "2-digit",
        minute: "2-digit"
    })
      , P = t?.multiplier
      , M = t?.serverSeed
      , R = t?.clientSeed
      , L = t?.riskLevel
      , q = t?.rows
      , H = t?.nonce
      , j = (A, E) => {
        navigator.clipboard.writeText(A),
        E === "hash" ? (o(!0),
        setTimeout( () => o(!1), 2e3)) : E === "seed" ? (l(!0),
        setTimeout( () => l(!1), 2e3)) : E === "gameId" ? (d(!0),
        setTimeout( () => d(!1), 2e3)) : E === "clientSeed" ? (p(!0),
        setTimeout( () => p(!1), 2e3)) : E === "risk" ? (w(!0),
        setTimeout( () => w(!1), 2e3)) : E === "rows" ? (v(!0),
        setTimeout( () => v(!1), 2e3)) : E === "nonce" && (N(!0),
        setTimeout( () => N(!1), 2e3))
    }
    ;
    return m.jsx("div", {
        className: "fixed inset-0 z-[101] flex items-center justify-center bg-black/30 bg-opacity-60 backdrop-blur-sm",
        children: m.jsxs("div", {
            className: "relative w-full max-w-xl mx-4 bg-[#1C2837] rounded-2xl shadow-2xl overflow-hidden",
            children: [m.jsxs("div", {
                className: "p-6 border-b border-[#2F3E53]",
                children: [m.jsxs("div", {
                    className: "flex items-center justify-between mb-0",
                    children: [m.jsxs("div", {
                        className: "flex items-center gap-3",
                        children: [m.jsxs("h3", {
                            className: "text-lg font-semibold text-white",
                            children: ["Plinko Game: ", zo(M, 8)]
                        }), m.jsx("button", {
                            onClick: () => j(M, "gameId"),
                            className: "p-1.5 hover:bg-[#2F3E53] rounded transition-colors",
                            title: "Copy Game ID",
                            children: u ? m.jsx("svg", {
                                xmlns: "http://www.w3.org/2000/svg",
                                fill: "none",
                                viewBox: "0 0 24 24",
                                strokeWidth: 2,
                                stroke: "currentColor",
                                className: "w-4 h-4 text-green-400",
                                children: m.jsx("path", {
                                    strokeLinecap: "round",
                                    strokeLinejoin: "round",
                                    d: "M4.5 12.75l6 6 9-13.5"
                                })
                            }) : m.jsx("svg", {
                                xmlns: "http://www.w3.org/2000/svg",
                                fill: "none",
                                viewBox: "0 0 24 24",
                                strokeWidth: 1.5,
                                stroke: "currentColor",
                                className: "w-4 h-4 text-gray-400",
                                children: m.jsx("path", {
                                    strokeLinecap: "round",
                                    strokeLinejoin: "round",
                                    d: "M15.666 3.888A2.25 2.25 0 0013.5 2.25h-3c-1.03 0-1.9.693-2.166 1.638m7.332 0c.055.194.084.4.084.612v0a.75.75 0 01-.75.75H9a.75.75 0 01-.75-.75v0c0-.212.03-.418.084-.612m7.332 0c.646.049 1.288.11 1.927.184 1.1.128 1.907 1.077 1.907 2.185V19.5a2.25 2.25 0 01-2.25 2.25H6.75A2.25 2.25 0 014.5 19.5V6.257c0-1.108.806-2.057 1.907-2.185a48.208 48.208 0 011.927-.184"
                                })
                            })
                        })]
                    }), m.jsx("button", {
                        onClick: e,
                        className: "p-2 hover:bg-[#2F3E53] rounded-lg transition-colors",
                        children: m.jsx("svg", {
                            xmlns: "http://www.w3.org/2000/svg",
                            fill: "none",
                            viewBox: "0 0 24 24",
                            strokeWidth: 1.5,
                            stroke: "currentColor",
                            className: "w-6 h-6 text-gray-400",
                            children: m.jsx("path", {
                                strokeLinecap: "round",
                                strokeLinejoin: "round",
                                d: "M6 18L18 6M6 6l12 12"
                            })
                        })
                    })]
                }), m.jsxs("p", {
                    className: "text-sm text-gray-400",
                    children: ["on ", k, " at ", B]
                })]
            }), m.jsx("div", {
                className: "p-6",
                children: m.jsxs("div", {
                    className: "space-y-6",
                    children: [m.jsx("div", {
                        className: "text-center py-4",
                        children: m.jsxs("div", {
                            className: "text-7xl font-bold bg-gradient-to-r from-[#FF7124] to-[#FF9000] bg-clip-text text-transparent mb-2",
                            children: [Af(P), "x"]
                        })
                    }), m.jsxs("div", {
                        className: "space-y-4",
                        children: [m.jsx("h4", {
                            className: "text-lg font-semibold text-white mb-4 text-center",
                            children: "Provable Fairness"
                        }), m.jsxs("div", {
                            children: [m.jsx("label", {
                                className: "block text-sm font-medium text-gray-400 mb-2",
                                children: "Client Seed"
                            }), m.jsxs("div", {
                                className: "relative",
                                children: [m.jsx("input", {
                                    type: "text",
                                    value: R,
                                    readOnly: !0,
                                    className: "w-full bg-[#2F3E53] border border-[#3a4a5f] rounded-xl px-4 py-3 pr-12 text-sm text-gray-300 focus:outline-none focus:border-[#EE5B35]"
                                }), m.jsx("button", {
                                    onClick: () => j(R, "clientSeed"),
                                    className: "absolute right-3 top-1/2 -translate-y-1/2 p-2 hover:bg-[#3a4a5f] rounded-lg transition-colors",
                                    title: "Copy Hash",
                                    children: m.jsx(pg, {
                                        isCopied: h
                                    })
                                })]
                            })]
                        }), m.jsxs("div", {
                            children: [m.jsx("label", {
                                className: "block text-sm font-medium text-gray-400 mb-2",
                                children: m.jsxs("span", {
                                    className: "flex items-center gap-2",
                                    children: ["Server Seed", m.jsx("button", {
                                        className: "p-1 hover:bg-[#2F3E53] rounded transition-colors",
                                        title: "Learn more about Seed",
                                        children: m.jsx("svg", {
                                            xmlns: "http://www.w3.org/2000/svg",
                                            fill: "none",
                                            viewBox: "0 0 24 24",
                                            strokeWidth: 1.5,
                                            stroke: "currentColor",
                                            className: "w-4 h-4 text-gray-400",
                                            children: m.jsx("path", {
                                                strokeLinecap: "round",
                                                strokeLinejoin: "round",
                                                d: "M9.879 7.519c1.171-1.025 3.071-1.025 4.242 0 1.172 1.025 1.172 2.687 0 3.712-.203.179-.43.326-.67.442-.745.361-1.45.999-1.45 1.827v.75M21 12a9 9 0 11-18 0 9 9 0 0118 0zm-9 5.25h.008v.008H12v-.008z"
                                            })
                                        })
                                    })]
                                })
                            }), m.jsxs("div", {
                                className: "relative",
                                children: [m.jsx("input", {
                                    type: "text",
                                    value: M,
                                    readOnly: !0,
                                    className: "w-full bg-[#2F3E53] border border-[#3a4a5f] rounded-xl px-4 py-3 pr-12 text-sm text-gray-300 focus:outline-none focus:border-[#EE5B35]"
                                }), m.jsx("button", {
                                    onClick: () => j(M, "seed"),
                                    className: "absolute right-3 top-1/2 -translate-y-1/2 p-2 hover:bg-[#3a4a5f] rounded-lg transition-colors",
                                    title: "Copy Seed",
                                    children: m.jsx(pg, {
                                        isCopied: a
                                    })
                                })]
                            })]
                        }), m.jsxs("div", {
                            children: [m.jsx("label", {
                                className: "block text-sm font-medium text-gray-400 mb-2",
                                children: m.jsxs("span", {
                                    className: "flex items-center gap-2",
                                    children: ["Nonce", m.jsx("button", {
                                        className: "p-1 hover:bg-[#2F3E53] rounded transition-colors",
                                        title: "Learn more about Seed",
                                        children: m.jsx("svg", {
                                            xmlns: "http://www.w3.org/2000/svg",
                                            fill: "none",
                                            viewBox: "0 0 24 24",
                                            strokeWidth: 1.5,
                                            stroke: "currentColor",
                                            className: "w-4 h-4 text-gray-400",
                                            children: m.jsx("path", {
                                                strokeLinecap: "round",
                                                strokeLinejoin: "round",
                                                d: "M9.879 7.519c1.171-1.025 3.071-1.025 4.242 0 1.172 1.025 1.172 2.687 0 3.712-.203.179-.43.326-.67.442-.745.361-1.45.999-1.45 1.827v.75M21 12a9 9 0 11-18 0 9 9 0 0118 0zm-9 5.25h.008v.008H12v-.008z"
                                            })
                                        })
                                    })]
                                })
                            }), m.jsxs("div", {
                                className: "relative",
                                children: [m.jsx("input", {
                                    type: "text",
                                    value: H,
                                    readOnly: !0,
                                    className: "w-full bg-[#2F3E53] border border-[#3a4a5f] rounded-xl px-4 py-3 pr-12 text-sm text-gray-300 focus:outline-none focus:border-[#EE5B35]"
                                }), m.jsx("button", {
                                    onClick: () => j(H, "nonce"),
                                    className: "absolute right-3 top-1/2 -translate-y-1/2 p-2 hover:bg-[#3a4a5f] rounded-lg transition-colors",
                                    title: "Copy Seed",
                                    children: m.jsx(pg, {
                                        isCopied: S
                                    })
                                })]
                            })]
                        }), m.jsxs("div", {
                            children: [m.jsx("label", {
                                className: "block text-sm font-medium text-gray-400 mb-2",
                                children: m.jsxs("span", {
                                    className: "flex items-center gap-2",
                                    children: ["Risk", m.jsx("button", {
                                        className: "p-1 hover:bg-[#2F3E53] rounded transition-colors",
                                        title: "Learn more about Seed",
                                        children: m.jsx("svg", {
                                            xmlns: "http://www.w3.org/2000/svg",
                                            fill: "none",
                                            viewBox: "0 0 24 24",
                                            strokeWidth: 1.5,
                                            stroke: "currentColor",
                                            className: "w-4 h-4 text-gray-400",
                                            children: m.jsx("path", {
                                                strokeLinecap: "round",
                                                strokeLinejoin: "round",
                                                d: "M9.879 7.519c1.171-1.025 3.071-1.025 4.242 0 1.172 1.025 1.172 2.687 0 3.712-.203.179-.43.326-.67.442-.745.361-1.45.999-1.45 1.827v.75M21 12a9 9 0 11-18 0 9 9 0 0118 0zm-9 5.25h.008v.008H12v-.008z"
                                            })
                                        })
                                    })]
                                })
                            }), m.jsxs("div", {
                                className: "relative",
                                children: [m.jsx("input", {
                                    type: "text",
                                    value: L || "Medium",
                                    readOnly: !0,
                                    className: "w-full bg-[#2F3E53] border border-[#3a4a5f] rounded-xl px-4 py-3 pr-12 text-sm text-gray-300 focus:outline-none focus:border-[#EE5B35]"
                                }), m.jsx("button", {
                                    onClick: () => j(L, "risk"),
                                    className: "absolute right-3 top-1/2 -translate-y-1/2 p-2 hover:bg-[#3a4a5f] rounded-lg transition-colors",
                                    title: "Copy Seed",
                                    children: m.jsx(pg, {
                                        isCopied: g
                                    })
                                })]
                            })]
                        }), m.jsxs("div", {
                            children: [m.jsx("label", {
                                className: "block text-sm font-medium text-gray-400 mb-2",
                                children: m.jsxs("span", {
                                    className: "flex items-center gap-2",
                                    children: ["Rows", m.jsx("button", {
                                        className: "p-1 hover:bg-[#2F3E53] rounded transition-colors",
                                        title: "Learn more about Seed",
                                        children: m.jsx("svg", {
                                            xmlns: "http://www.w3.org/2000/svg",
                                            fill: "none",
                                            viewBox: "0 0 24 24",
                                            strokeWidth: 1.5,
                                            stroke: "currentColor",
                                            className: "w-4 h-4 text-gray-400",
                                            children: m.jsx("path", {
                                                strokeLinecap: "round",
                                                strokeLinejoin: "round",
                                                d: "M9.879 7.519c1.171-1.025 3.071-1.025 4.242 0 1.172 1.025 1.172 2.687 0 3.712-.203.179-.43.326-.67.442-.745.361-1.45.999-1.45 1.827v.75M21 12a9 9 0 11-18 0 9 9 0 0118 0zm-9 5.25h.008v.008H12v-.008z"
                                            })
                                        })
                                    })]
                                })
                            }), m.jsxs("div", {
                                className: "relative",
                                children: [m.jsx("input", {
                                    type: "text",
                                    value: q,
                                    readOnly: !0,
                                    className: "w-full bg-[#2F3E53] border border-[#3a4a5f] rounded-xl px-4 py-3 pr-12 text-sm text-gray-300 focus:outline-none focus:border-[#EE5B35]"
                                }), m.jsx("button", {
                                    onClick: () => j(q, "rows"),
                                    className: "absolute right-3 top-1/2 -translate-y-1/2 p-2 hover:bg-[#3a4a5f] rounded-lg transition-colors",
                                    title: "Copy Seed",
                                    children: m.jsx(pg, {
                                        isCopied: b
                                    })
                                })]
                            })]
                        }), m.jsx("div", {
                            className: "flex gap-4 pt-2 justify-center",
                            children: m.jsx("button", {
                                onClick: () => {
                                    window.open("/verify-games", "_blank")
                                }
                                ,
                                className: "text-sm bg-[#2F3E53]/50 text-white px-4 py-2 rounded-full transition-colors font-medium cursor-pointer",
                                children: "Verify Game"
                            })
                        })]
                    })]
                })
            })]
        })
    })
}
  , pg = ({isCopied: n}) => n ? m.jsx("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 2,
    stroke: "currentColor",
    className: "w-4 h-4 text-green-400",
    children: m.jsx("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M4.5 12.75l6 6 9-13.5"
    })
}) : m.jsx("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    className: "w-4 h-4 text-gray-400",
    children: m.jsx("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M15.666 3.888A2.25 2.25 0 0013.5 2.25h-3c-1.03 0-1.9.693-2.166 1.638m7.332 0c.055.194.084.4.084.612v0a.75.75 0 01-.75.75H9a.75.75 0 01-.75-.75v0c0-.212.03-.418.084-.612m7.332 0c.646.049 1.288.11 1.927.184 1.1.128 1.907 1.077 1.907 2.185V19.5a2.25 2.25 0 01-2.25 2.25H6.75A2.25 2.25 0 014.5 19.5V6.257c0-1.108.806-2.057 1.907-2.185a48.208 48.208 0 011.927-.184"
    })
})
  , BW = ({isOpen: n, onClose: e}) => (V.useEffect( () => {
    if (n) {
        const t = document.body.style.overflow || "";
        return document.body.style.overflow = "hidden",
        () => {
            document.body.style.overflow = t
        }
    }
}
, [n]),
n ? m.jsxs("div", {
    className: "absolute inset-0 z-10 flex items-center justify-center px-4 py-6 backdrop-blur-sm",
    onClick: e,
    children: [m.jsx("div", {
        className: "absolute inset-0 bg-black/70 backdrop-blur-md"
    }), m.jsxs("div", {
        className: "relative bg-linear-to-br from-[#1A1F2E] via-[#2A3441] to-[#1A1F2E] rounded-2xl shadow-2xl border-2 border-[#FFC12C]/30 max-w-md w-full mx-4 z-10 overflow-hidden",
        onClick: t => t.stopPropagation(),
        children: [m.jsx("div", {
            className: "absolute inset-0 bg-linear-to-r from-[#FF6B35]/10 via-[#FFC12C]/10 to-[#FF6B35]/10 animate-pulse pointer-events-none"
        }), m.jsxs("div", {
            className: "relative z-10 p-8 text-center",
            children: [m.jsx("div", {
                className: "flex items-center justify-center mb-6",
                children: m.jsx("div", {
                    className: "w-20 h-20 rounded-full bg-linear-to-br from-[#FF6B35]/20 to-[#FFC12C]/20 border-2 border-[#FFC12C]/40 flex items-center justify-center",
                    children: m.jsx("svg", {
                        xmlns: "http://www.w3.org/2000/svg",
                        fill: "none",
                        viewBox: "0 0 24 24",
                        strokeWidth: 1.5,
                        stroke: "currentColor",
                        className: "w-10 h-10 text-[#FFC12C]",
                        children: m.jsx("path", {
                            strokeLinecap: "round",
                            strokeLinejoin: "round",
                            d: "M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126zM12 15.75h.007v.008H12v-.008z"
                        })
                    })
                })
            }), m.jsx("h2", {
                className: "text-2xl font-bold text-white mb-4",
                children: "This game is currently unavailable."
            }), m.jsx("p", {
                className: "text-[#A8B8CC] text-base",
                children: "Please try again later."
            })]
        }), m.jsx("div", {
            className: "absolute top-0 left-0 w-24 h-24 bg-linear-to-br from-[#FFC12C]/20 to-transparent rounded-br-full"
        }), m.jsx("div", {
            className: "absolute bottom-0 right-0 w-24 h-24 bg-linear-to-tl from-[#FF6B35]/20 to-transparent rounded-tl-full"
        })]
    })]
}) : null)
  , b7e = () => {
    const n = kr()
      , [e,t] = V.useState(!1)
      , [r,s] = V.useState(null)
      , {backendConfig: i} = Hs()
      , {showGameHistory: o, setShowGameHistory: a, history: l, isFullscreen: u, toggleFullscreen: d, gameHistoryRef: h} = $x(kx);
    return m.jsxs("div", {
        className: u ? "" : "py-10 px-4",
        children: [m.jsxs("div", {
            className: `game-area ${u ? "" : "p-4 border border-white rounded-2xl"}  transition-all duration-300 ${u ? "fixed inset-0 z-[9999] w-screen h-screen m-0 p-2 bg-black" : "relative bg-black/50"}`,
            style: u ? {
                top: 0,
                left: 0,
                right: 0,
                bottom: 0
            } : {},
            children: [!u && m.jsxs("div", {
                className: "flex items-center justify-between lg:mb-4 mb-0",
                children: [m.jsxs("div", {
                    className: "flex items-center gap-4",
                    children: [m.jsx("button", {
                        onClick: () => n(-1),
                        className: "bg-[#314258] w-10 h-10 rounded-full flex items-center justify-center hover:bg-[#3d5269] transition-colors",
                        children: m.jsx("svg", {
                            xmlns: "http://www.w3.org/2000/svg",
                            fill: "none",
                            viewBox: "0 0 24 24",
                            strokeWidth: 1.5,
                            stroke: "currentColor",
                            className: "size-6",
                            children: m.jsx("path", {
                                strokeLinecap: "round",
                                strokeLinejoin: "round",
                                d: "M10.5 19.5 3 12m0 0 7.5-7.5M3 12h18"
                            })
                        })
                    }), m.jsx("img", {
                        src: CG,
                        className: "w-24 h-auto md:block hidden"
                    })]
                }), m.jsxs("div", {
                    className: "flex items-center gap-2",
                    children: [m.jsxs("button", {
                        onClick: () => a(!0),
                        className: "bg-white rounded-2xl text-black px-4 py-2 flex items-center text-base cursor-pointer gap-1.5 hover:bg-gray-100 transition-colors",
                        children: [m.jsx("svg", {
                            xmlns: "http://www.w3.org/2000/svg",
                            fill: "none",
                            viewBox: "0 0 24 24",
                            strokeWidth: 1.5,
                            stroke: "currentColor",
                            className: "size-6",
                            children: m.jsx("path", {
                                strokeLinecap: "round",
                                strokeLinejoin: "round",
                                d: "M12 6v6h4.5m4.5 0a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"
                            })
                        }), "Game History"]
                    }), m.jsx("button", {
                        onClick: d,
                        className: "w-10 h-10 rounded-full bg-black/50 flex items-center justify-center hover:bg-black/70 transition-colors",
                        title: "Enter Fullscreen",
                        children: m.jsx("svg", {
                            xmlns: "http://www.w3.org/2000/svg",
                            fill: "none",
                            viewBox: "0 0 24 24",
                            strokeWidth: 1.5,
                            stroke: "currentColor",
                            className: "size-6",
                            children: m.jsx("path", {
                                strokeLinecap: "round",
                                strokeLinejoin: "round",
                                d: "M3.75 3.75v4.5m0-4.5h4.5m-4.5 0L9 9M3.75 20.25v-4.5m0 4.5h4.5m-4.5 0L9 15M20.25 3.75h-4.5m4.5 0v4.5m0-4.5L15 9m5.25 11.25h-4.5m4.5 0v-4.5m0 4.5L15 15"
                            })
                        })
                    })]
                })]
            }), m.jsxs("div", {
                className: "play-area pt-4 md:pt-0 rounded-2xl overflow-hidden relative ",
                children: [u && m.jsx("div", {
                    className: "absolute top-4 right-4 z-50",
                    children: m.jsx("button", {
                        onClick: d,
                        className: "w-12 h-12 rounded-full bg-black/70 flex items-center justify-center hover:bg-black/90 transition-colors border-2 border-white/20",
                        title: "Exit Fullscreen (ESC)",
                        children: m.jsx("svg", {
                            xmlns: "http://www.w3.org/2000/svg",
                            fill: "none",
                            viewBox: "0 0 24 24",
                            strokeWidth: 2,
                            stroke: "currentColor",
                            className: "size-6 text-white",
                            children: m.jsx("path", {
                                strokeLinecap: "round",
                                strokeLinejoin: "round",
                                d: "M9 9V4.5M9 9H4.5M9 9 3.75 3.75M9 15v4.5M9 15H4.5M9 15l-5.25 5.25M15 9h4.5M15 9V4.5M15 9l5.25-5.25M15 15h4.5M15 15v4.5m0-4.5 5.25 5.25"
                            })
                        })
                    })
                }), m.jsx(y7e, {}), m.jsx(BW, {
                    isOpen: i?.PLINKO_ENABLED === 0 || i?.PLINKO_ENABLED === "0",
                    onClose: () => {}
                })]
            }), o && !u && m.jsxs("div", {
                ref: h,
                className: "gameHistory bg-black/90 p-4 border border-white rounded-2xl absolute top-0 right-0 max-w-[500px] w-full z-10 h-full overflow-y-auto",
                children: [m.jsxs("div", {
                    className: "flex items-center justify-start gap-2 mb-4",
                    children: [m.jsx("button", {
                        onClick: () => a(!1),
                        className: "rounded-2xl text-white flex items-center text-base cursor-pointer gap-1.5",
                        children: m.jsx("svg", {
                            xmlns: "http://www.w3.org/2000/svg",
                            fill: "none",
                            viewBox: "0 0 24 24",
                            strokeWidth: 1.5,
                            stroke: "currentColor",
                            className: "size-6",
                            children: m.jsx("path", {
                                strokeLinecap: "round",
                                strokeLinejoin: "round",
                                d: "M15.75 19.5 8.25 12l7.5-7.5"
                            })
                        })
                    }), m.jsx("h3", {
                        className: "text-white text-xl font-bold",
                        children: "Game History"
                    })]
                }), m.jsxs("div", {
                    className: "flex flex-col gap-2",
                    children: [m.jsx("div", {
                        className: "grid grid-cols-3 px-4 pb-1 uppercase opacity-70 text-sm"
                    }), l?.map( (p, g) => {
                        const w = p?.multiplier ? Af(p?.multiplier) : "0.00"
                          , b = p?.winAmount ? Af(p?.winAmount) : "0.00"
                          , v = p?.betAmount ? Af(p?.betAmount) : "0.00"
                          , S = new Date(p?.timestamp)
                          , N = S.toLocaleString("en-IN", {
                            month: "short"
                        }) + " " + S.toLocaleString("en-IN", {
                            day: "2-digit"
                        }) + ", " + S.toLocaleString("en-IN", {
                            hour: "2-digit",
                            minute: "2-digit",
                            hour12: !0
                        }).toLowerCase();
                        return m.jsxs("div", {
                            onClick: () => {
                                t(!0),
                                s(p)
                            }
                            ,
                            className: "p-3 rounded-lg text-white text-sm space-y-1 bg-[#1e2840] hover:bg-[#2e3a52] transition-colors cursor-pointer",
                            children: [m.jsxs("div", {
                                className: "flex justify-between items-center",
                                children: [m.jsxs("span", {
                                    children: ["Multiplier: ", w, "x ", w === "1.00" && ""]
                                }), m.jsxs("span", {
                                    className: p?.won ? "text-green-400 font-semibold" : "text-red-400 font-semibold",
                                    children: ["Cashed: ", b]
                                }), m.jsx("span", {
                                    className: p?.won ? "text-green-400 font-semibold" : "text-red-400 font-semibold",
                                    children: v
                                })]
                            }), m.jsxs("div", {
                                className: "flex justify-between",
                                children: [m.jsxs("span", {
                                    className: "text-xs text-gray-400 font-mono",
                                    children: ["Date : ", N || "N/A"]
                                }), m.jsxs("span", {
                                    className: "text-xs text-gray-400 font-mono",
                                    children: ["gameID: ", zo(p.sessionId)]
                                })]
                            })]
                        }, g)
                    }
                    )]
                })]
            })]
        }), m.jsx(MW, {
            isOpen: e,
            onClose: () => t(!1),
            data: r
        })]
    })
}
  , RW = "/assets/awebo-logo-CAHgEQaR.svg"
  , OW = "/assets/bird-BNr3TDqD.png";
function w7e(n) {
    const {y: e, x: t, width: r, height: s, rotation: i, birdSkin: o=OW} = n;
    return m.jsx("div", {
        ref: n.birdRef,
        className: "bird",
        style: {
            position: "absolute",
            top: `${e}px`,
            left: `${t}px`,
            width: `${r}px`,
            height: `${s}px`,
            transform: `rotate(${i}deg)`,
            transformOrigin: "50% 50%",
            zIndex: 20
        },
        children: m.jsx("img", {
            src: o,
            alt: "",
            style: {
                width: "100%",
                height: "100%",
                display: "block"
            }
        })
    })
}
const v7e = "/assets/foreground-BZIRIgMc.png"
  , x7e = "/assets/pipe-top-HYvGtcuq.png"
  , E7e = "/assets/pipe-bottom-CuE-dEzc.png"
  , S7e = "/assets/pipe-top-alt-A6Js68fw.png"
  , A7e = "/assets/pipe-bottom-alt-U389wy50.png";
function C7e({pipes: n}) {
    return m.jsx(m.Fragment, {
        children: n.map( (e, t) => m.jsxs(ye.Fragment, {
            children: [m.jsx("div", {
                className: "pipe-top",
                style: {
                    position: "absolute",
                    top: 0,
                    left: `${e.x}px`,
                    width: `${e.width}px`,
                    height: `${e.topHeight}px`,
                    zIndex: 15,
                    overflow: "visible"
                },
                children: m.jsx("img", {
                    src: e.isAlt ? S7e : x7e,
                    alt: "pipe-top",
                    className: e.collidedPart === "top" ? "fall-down" : "swing-wind",
                    style: {
                        width: "100%",
                        height: "100%",
                        objectFit: "cover",
                        objectPosition: "bottom",
                        display: "block"
                    }
                })
            }), m.jsx("div", {
                className: "pipe-bottom",
                style: {
                    position: "absolute",
                    left: `${e.x}px`,
                    top: `${e.bottomPipeY}px`,
                    width: `${e.width}px`,
                    height: `${e.bottomPipeHeight}px`,
                    zIndex: 15,
                    overflow: "hidden"
                },
                children: m.jsx("img", {
                    src: e.isAlt ? A7e : E7e,
                    alt: "pipe-bottom",
                    className: e.collidedPart === "bottom" ? "topple" : "",
                    style: {
                        width: "100%",
                        height: "100%",
                        objectFit: "cover",
                        objectPosition: "top",
                        display: "block"
                    }
                })
            })]
        }, `pipe-${e.id || t}`))
    })
}
var s4 = {
    exports: {}
}
  , i4 = {};
var O9;
function _7e() {
    if (O9)
        return i4;
    O9 = 1;
    var n = by();
    function e(l, u) {
        return l === u && (l !== 0 || 1 / l === 1 / u) || l !== l && u !== u
    }
    var t = typeof Object.is == "function" ? Object.is : e
      , r = n.useSyncExternalStore
      , s = n.useRef
      , i = n.useEffect
      , o = n.useMemo
      , a = n.useDebugValue;
    return i4.useSyncExternalStoreWithSelector = function(l, u, d, h, p) {
        var g = s(null);
        if (g.current === null) {
            var w = {
                hasValue: !1,
                value: null
            };
            g.current = w
        } else
            w = g.current;
        g = o(function() {
            function v(k) {
                if (!S) {
                    if (S = !0,
                    N = k,
                    k = h(k),
                    p !== void 0 && w.hasValue) {
                        var B = w.value;
                        if (p(B, k))
                            return _ = B
                    }
                    return _ = k
                }
                if (B = _,
                t(N, k))
                    return B;
                var P = h(k);
                return p !== void 0 && p(B, P) ? (N = k,
                B) : (N = k,
                _ = P)
            }
            var S = !1, N, _, I = d === void 0 ? null : d;
            return [function() {
                return v(u())
            }
            , I === null ? void 0 : function() {
                return v(I())
            }
            ]
        }, [u, d, h, p]);
        var b = r(l, g[0], g[1]);
        return i(function() {
            w.hasValue = !0,
            w.value = b
        }, [b]),
        a(b),
        b
    }
    ,
    i4
}
var P9;
function k7e() {
    return P9 || (P9 = 1,
    s4.exports = _7e()),
    s4.exports
}
var N7e = k7e();
function D7e(n) {
    n()
}
function T7e() {
    let n = null
      , e = null;
    return {
        clear() {
            n = null,
            e = null
        },
        notify() {
            D7e( () => {
                let t = n;
                for (; t; )
                    t.callback(),
                    t = t.next
            }
            )
        },
        get() {
            const t = [];
            let r = n;
            for (; r; )
                t.push(r),
                r = r.next;
            return t
        },
        subscribe(t) {
            let r = !0;
            const s = e = {
                callback: t,
                next: null,
                prev: e
            };
            return s.prev ? s.prev.next = s : n = s,
            function() {
                !r || n === null || (r = !1,
                s.next ? s.next.prev = s.prev : e = s.prev,
                s.prev ? s.prev.next = s.next : n = s.next)
            }
        }
    }
}
var j9 = {
    notify() {},
    get: () => []
};
function I7e(n, e) {
    let t, r = j9, s = 0, i = !1;
    function o(b) {
        d();
        const v = r.subscribe(b);
        let S = !1;
        return () => {
            S || (S = !0,
            v(),
            h())
        }
    }
    function a() {
        r.notify()
    }
    function l() {
        w.onStateChange && w.onStateChange()
    }
    function u() {
        return i
    }
    function d() {
        s++,
        t || (t = n.subscribe(l),
        r = T7e())
    }
    function h() {
        s--,
        t && s === 0 && (t(),
        t = void 0,
        r.clear(),
        r = j9)
    }
    function p() {
        i || (i = !0,
        d())
    }
    function g() {
        i && (i = !1,
        h())
    }
    const w = {
        addNestedSub: o,
        notifyNestedSubs: a,
        handleChangeWrapper: l,
        isSubscribed: u,
        trySubscribe: p,
        tryUnsubscribe: g,
        getListeners: () => r
    };
    return w
}
var M7e = () => typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u"
  , B7e = M7e()
  , R7e = () => typeof navigator < "u" && navigator.product === "ReactNative"
  , O7e = R7e()
  , P7e = () => B7e || O7e ? V.useLayoutEffect : V.useEffect
  , j7e = P7e()
  , L7e = Symbol.for("react-redux-context")
  , F7e = typeof globalThis < "u" ? globalThis : {};
function U7e() {
    if (!V.createContext)
        return {};
    const n = F7e[L7e] ??= new Map;
    let e = n.get(V.createContext);
    return e || (e = V.createContext(null),
    n.set(V.createContext, e)),
    e
}
var od = U7e();
function z7e(n) {
    const {children: e, context: t, serverState: r, store: s} = n
      , i = V.useMemo( () => {
        const l = I7e(s);
        return {
            store: s,
            subscription: l,
            getServerState: r ? () => r : void 0
        }
    }
    , [s, r])
      , o = V.useMemo( () => s.getState(), [s]);
    j7e( () => {
        const {subscription: l} = i;
        return l.onStateChange = l.notifyNestedSubs,
        l.trySubscribe(),
        o !== s.getState() && l.notifyNestedSubs(),
        () => {
            l.tryUnsubscribe(),
            l.onStateChange = void 0
        }
    }
    , [i, o]);
    const a = t || od;
    return V.createElement(a.Provider, {
        value: i
    }, e)
}
var $7e = z7e;
function qk(n=od) {
    return function() {
        return V.useContext(n)
    }
}
var PW = qk();
function jW(n=od) {
    const e = n === od ? PW : qk(n)
      , t = () => {
        const {store: r} = e();
        return r
    }
    ;
    return Object.assign(t, {
        withTypes: () => t
    }),
    t
}
var H7e = jW();
function V7e(n=od) {
    const e = n === od ? H7e : jW(n)
      , t = () => e().dispatch;
    return Object.assign(t, {
        withTypes: () => t
    }),
    t
}
var q7e = V7e()
  , G7e = (n, e) => n === e;
function W7e(n=od) {
    const e = n === od ? PW : qk(n)
      , t = (r, s={}) => {
        const {equalityFn: i=G7e} = typeof s == "function" ? {
            equalityFn: s
        } : s
          , o = e()
          , {store: a, subscription: l, getServerState: u} = o;
        V.useRef(!0);
        const d = V.useCallback({
            [r.name](p) {
                return r(p)
            }
        }[r.name], [r])
          , h = N7e.useSyncExternalStoreWithSelector(l.addNestedSub, a.getState, u || a.getState, d, i);
        return V.useDebugValue(h),
        h
    }
    ;
    return Object.assign(t, {
        withTypes: () => t
    }),
    t
}
var Y7e = W7e();
function ms(n) {
    return `Minified Redux error #${n}; visit https://redux.js.org/Errors?code=${n} for the full message or use the non-minified dev environment for full errors. `
}
var K7e = typeof Symbol == "function" && Symbol.observable || "@@observable"
  , L9 = K7e
  , o4 = () => Math.random().toString(36).substring(7).split("").join(".")
  , X7e = {
    INIT: `@@redux/INIT${o4()}`,
    REPLACE: `@@redux/REPLACE${o4()}`,
    PROBE_UNKNOWN_ACTION: () => `@@redux/PROBE_UNKNOWN_ACTION${o4()}`
}
  , Av = X7e;
function Gk(n) {
    if (typeof n != "object" || n === null)
        return !1;
    let e = n;
    for (; Object.getPrototypeOf(e) !== null; )
        e = Object.getPrototypeOf(e);
    return Object.getPrototypeOf(n) === e || Object.getPrototypeOf(n) === null
}
function LW(n, e, t) {
    if (typeof n != "function")
        throw new Error(ms(2));
    if (typeof e == "function" && typeof t == "function" || typeof t == "function" && typeof arguments[3] == "function")
        throw new Error(ms(0));
    if (typeof e == "function" && typeof t > "u" && (t = e,
    e = void 0),
    typeof t < "u") {
        if (typeof t != "function")
            throw new Error(ms(1));
        return t(LW)(n, e)
    }
    let r = n
      , s = e
      , i = new Map
      , o = i
      , a = 0
      , l = !1;
    function u() {
        o === i && (o = new Map,
        i.forEach( (v, S) => {
            o.set(S, v)
        }
        ))
    }
    function d() {
        if (l)
            throw new Error(ms(3));
        return s
    }
    function h(v) {
        if (typeof v != "function")
            throw new Error(ms(4));
        if (l)
            throw new Error(ms(5));
        let S = !0;
        u();
        const N = a++;
        return o.set(N, v),
        function() {
            if (S) {
                if (l)
                    throw new Error(ms(6));
                S = !1,
                u(),
                o.delete(N),
                i = null
            }
        }
    }
    function p(v) {
        if (!Gk(v))
            throw new Error(ms(7));
        if (typeof v.type > "u")
            throw new Error(ms(8));
        if (typeof v.type != "string")
            throw new Error(ms(17));
        if (l)
            throw new Error(ms(9));
        try {
            l = !0,
            s = r(s, v)
        } finally {
            l = !1
        }
        return (i = o).forEach(N => {
            N()
        }
        ),
        v
    }
    function g(v) {
        if (typeof v != "function")
            throw new Error(ms(10));
        r = v,
        p({
            type: Av.REPLACE
        })
    }
    function w() {
        const v = h;
        return {
            subscribe(S) {
                if (typeof S != "object" || S === null)
                    throw new Error(ms(11));
                function N() {
                    const I = S;
                    I.next && I.next(d())
                }
                return N(),
                {
                    unsubscribe: v(N)
                }
            },
            [L9]() {
                return this
            }
        }
    }
    return p({
        type: Av.INIT
    }),
    {
        dispatch: p,
        subscribe: h,
        getState: d,
        replaceReducer: g,
        [L9]: w
    }
}
function Q7e(n) {
    Object.keys(n).forEach(e => {
        const t = n[e];
        if (typeof t(void 0, {
            type: Av.INIT
        }) > "u")
            throw new Error(ms(12));
        if (typeof t(void 0, {
            type: Av.PROBE_UNKNOWN_ACTION()
        }) > "u")
            throw new Error(ms(13))
    }
    )
}
function Z7e(n) {
    const e = Object.keys(n)
      , t = {};
    for (let i = 0; i < e.length; i++) {
        const o = e[i];
        typeof n[o] == "function" && (t[o] = n[o])
    }
    const r = Object.keys(t);
    let s;
    try {
        Q7e(t)
    } catch (i) {
        s = i
    }
    return function(o={}, a) {
        if (s)
            throw s;
        let l = !1;
        const u = {};
        for (let d = 0; d < r.length; d++) {
            const h = r[d]
              , p = t[h]
              , g = o[h]
              , w = p(g, a);
            if (typeof w > "u")
                throw a && a.type,
                new Error(ms(14));
            u[h] = w,
            l = l || w !== g
        }
        return l = l || r.length !== Object.keys(o).length,
        l ? u : o
    }
}
function Cv(...n) {
    return n.length === 0 ? e => e : n.length === 1 ? n[0] : n.reduce( (e, t) => (...r) => e(t(...r)))
}
function J7e(...n) {
    return e => (t, r) => {
        const s = e(t, r);
        let i = () => {
            throw new Error(ms(15))
        }
        ;
        const o = {
            getState: s.getState,
            dispatch: (l, ...u) => i(l, ...u)
        }
          , a = n.map(l => l(o));
        return i = Cv(...a)(s.dispatch),
        {
            ...s,
            dispatch: i
        }
    }
}
function ePe(n) {
    return Gk(n) && "type"in n && typeof n.type == "string"
}
var FW = Symbol.for("immer-nothing")
  , F9 = Symbol.for("immer-draftable")
  , ii = Symbol.for("immer-state");
function ia(n, ...e) {
    throw new Error(`[Immer] minified error nr: ${n}. Full error at: https://bit.ly/3cXEKWf`)
}
var eo = Object
  , b0 = eo.getPrototypeOf
  , _v = "constructor"
  , Zx = "prototype"
  , m8 = "configurable"
  , kv = "enumerable"
  , o2 = "writable"
  , my = "value"
  , Oc = n => !!n && !!n[ii];
function ma(n) {
    return n ? UW(n) || Jx(n) || !!n[F9] || !!n[_v]?.[F9] || e3(n) || t3(n) : !1
}
var tPe = eo[Zx][_v].toString()
  , U9 = new WeakMap;
function UW(n) {
    if (!n || !Wk(n))
        return !1;
    const e = b0(n);
    if (e === null || e === eo[Zx])
        return !0;
    const t = eo.hasOwnProperty.call(e, _v) && e[_v];
    if (t === Object)
        return !0;
    if (!fp(t))
        return !1;
    let r = U9.get(t);
    return r === void 0 && (r = Function.toString.call(t),
    U9.set(t, r)),
    r === tPe
}
function ob(n, e, t=!0) {
    ab(n) === 0 ? (t ? Reflect.ownKeys(n) : eo.keys(n)).forEach(s => {
        e(s, n[s], n)
    }
    ) : n.forEach( (r, s) => e(s, r, n))
}
function ab(n) {
    const e = n[ii];
    return e ? e.type_ : Jx(n) ? 1 : e3(n) ? 2 : t3(n) ? 3 : 0
}
var z9 = (n, e, t=ab(n)) => t === 2 ? n.has(e) : eo[Zx].hasOwnProperty.call(n, e)
  , g8 = (n, e, t=ab(n)) => t === 2 ? n.get(e) : n[e]
  , Nv = (n, e, t, r=ab(n)) => {
    r === 2 ? n.set(e, t) : r === 3 ? n.add(t) : n[e] = t
}
;
function nPe(n, e) {
    return n === e ? n !== 0 || 1 / n === 1 / e : n !== n && e !== e
}
var Jx = Array.isArray
  , e3 = n => n instanceof Map
  , t3 = n => n instanceof Set
  , Wk = n => typeof n == "object"
  , fp = n => typeof n == "function"
  , a4 = n => typeof n == "boolean"
  , tc = n => n.copy_ || n.base_
  , Yk = n => n.modified_ ? n.copy_ : n.base_;
function y8(n, e) {
    if (e3(n))
        return new Map(n);
    if (t3(n))
        return new Set(n);
    if (Jx(n))
        return Array[Zx].slice.call(n);
    const t = UW(n);
    if (e === !0 || e === "class_only" && !t) {
        const r = eo.getOwnPropertyDescriptors(n);
        delete r[ii];
        let s = Reflect.ownKeys(r);
        for (let i = 0; i < s.length; i++) {
            const o = s[i]
              , a = r[o];
            a[o2] === !1 && (a[o2] = !0,
            a[m8] = !0),
            (a.get || a.set) && (r[o] = {
                [m8]: !0,
                [o2]: !0,
                [kv]: a[kv],
                [my]: n[o]
            })
        }
        return eo.create(b0(n), r)
    } else {
        const r = b0(n);
        if (r !== null && t)
            return {
                ...n
            };
        const s = eo.create(r);
        return eo.assign(s, n)
    }
}
function Kk(n, e=!1) {
    return n3(n) || Oc(n) || !ma(n) || (ab(n) > 1 && eo.defineProperties(n, {
        set: Mw,
        add: Mw,
        clear: Mw,
        delete: Mw
    }),
    eo.freeze(n),
    e && ob(n, (t, r) => {
        Kk(r, !0)
    }
    , !1)),
    n
}
function rPe() {
    ia(2)
}
var Mw = {
    [my]: rPe
};
function n3(n) {
    return n === null || !Wk(n) ? !0 : eo.isFrozen(n)
}
var Dv = "MapSet"
  , b8 = "Patches"
  , zW = {};
function w0(n) {
    const e = zW[n];
    return e || ia(0, n),
    e
}
var sPe = n => !!zW[n], gy, $W = () => gy, iPe = (n, e) => ({
    drafts_: [],
    parent_: n,
    immer_: e,
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0,
    handledSet_: new Set,
    processedForPatches_: new Set,
    mapSetPlugin_: sPe(Dv) ? w0(Dv) : void 0
});
function $9(n, e) {
    e && (n.patchPlugin_ = w0(b8),
    n.patches_ = [],
    n.inversePatches_ = [],
    n.patchListener_ = e)
}
function w8(n) {
    v8(n),
    n.drafts_.forEach(oPe),
    n.drafts_ = null
}
function v8(n) {
    n === gy && (gy = n.parent_)
}
var H9 = n => gy = iPe(gy, n);
function oPe(n) {
    const e = n[ii];
    e.type_ === 0 || e.type_ === 1 ? e.revoke_() : e.revoked_ = !0
}
function V9(n, e) {
    e.unfinalizedDrafts_ = e.drafts_.length;
    const t = e.drafts_[0];
    if (n !== void 0 && n !== t) {
        t[ii].modified_ && (w8(e),
        ia(4)),
        ma(n) && (n = q9(e, n));
        const {patchPlugin_: s} = e;
        s && s.generateReplacementPatches_(t[ii].base_, n, e)
    } else
        n = q9(e, t);
    return aPe(e, n, !0),
    w8(e),
    e.patches_ && e.patchListener_(e.patches_, e.inversePatches_),
    n !== FW ? n : void 0
}
function q9(n, e) {
    if (n3(e))
        return e;
    const t = e[ii];
    if (!t)
        return Xk(e, n.handledSet_, n);
    if (!r3(t, n))
        return e;
    if (!t.modified_)
        return t.base_;
    if (!t.finalized_) {
        const {callbacks_: r} = t;
        if (r)
            for (; r.length > 0; )
                r.pop()(n);
        qW(t, n)
    }
    return t.copy_
}
function aPe(n, e, t=!1) {
    !n.parent_ && n.immer_.autoFreeze_ && n.canAutoFreeze_ && Kk(e, t)
}
function HW(n) {
    n.finalized_ = !0,
    n.scope_.unfinalizedDrafts_--
}
var r3 = (n, e) => n.scope_ === e
  , lPe = [];
function VW(n, e, t, r) {
    const s = tc(n)
      , i = n.type_;
    if (r !== void 0 && g8(s, r, i) === e) {
        Nv(s, r, t, i);
        return
    }
    if (!n.draftLocations_) {
        const a = n.draftLocations_ = new Map;
        ob(s, (l, u) => {
            if (Oc(u)) {
                const d = a.get(u) || [];
                d.push(l),
                a.set(u, d)
            }
        }
        )
    }
    const o = n.draftLocations_.get(e) ?? lPe;
    for (const a of o)
        Nv(s, a, t, i)
}
function cPe(n, e, t) {
    n.callbacks_.push(function(s) {
        const i = e;
        if (!i || !r3(i, s))
            return;
        s.mapSetPlugin_?.fixSetContents(i);
        const o = Yk(i);
        VW(n, i.draft_ ?? i, o, t),
        qW(i, s)
    })
}
function qW(n, e) {
    if (n.modified_ && !n.finalized_ && (n.type_ === 3 || (n.assigned_?.size ?? 0) > 0)) {
        const {patchPlugin_: r} = e;
        if (r) {
            const s = r.getPath(n);
            s && r.generatePatches_(n, s, e)
        }
        HW(n)
    }
}
function uPe(n, e, t) {
    const {scope_: r} = n;
    if (Oc(t)) {
        const s = t[ii];
        r3(s, r) && s.callbacks_.push(function() {
            a2(n);
            const o = Yk(s);
            VW(n, t, o, e)
        })
    } else
        ma(t) && n.callbacks_.push(function() {
            const i = tc(n);
            g8(i, e, n.type_) === t && r.drafts_.length > 1 && (n.assigned_.get(e) ?? !1) === !0 && n.copy_ && Xk(g8(n.copy_, e, n.type_), r.handledSet_, r)
        })
}
function Xk(n, e, t) {
    return !t.immer_.autoFreeze_ && t.unfinalizedDrafts_ < 1 || Oc(n) || e.has(n) || !ma(n) || n3(n) || (e.add(n),
    ob(n, (r, s) => {
        if (Oc(s)) {
            const i = s[ii];
            if (r3(i, t)) {
                const o = Yk(i);
                Nv(n, r, o, n.type_),
                HW(i)
            }
        } else
            ma(s) && Xk(s, e, t)
    }
    )),
    n
}
function dPe(n, e) {
    const t = Jx(n)
      , r = {
        type_: t ? 1 : 0,
        scope_: e ? e.scope_ : $W(),
        modified_: !1,
        finalized_: !1,
        assigned_: void 0,
        parent_: e,
        base_: n,
        draft_: null,
        copy_: null,
        revoke_: null,
        isManual_: !1,
        callbacks_: void 0
    };
    let s = r
      , i = Qk;
    t && (s = [r],
    i = yy);
    const {revoke: o, proxy: a} = Proxy.revocable(s, i);
    return r.draft_ = a,
    r.revoke_ = o,
    [a, r]
}
var Qk = {
    get(n, e) {
        if (e === ii)
            return n;
        const t = tc(n);
        if (!z9(t, e, n.type_))
            return fPe(n, t, e);
        const r = t[e];
        if (n.finalized_ || !ma(r))
            return r;
        if (r === l4(n.base_, e)) {
            a2(n);
            const s = n.type_ === 1 ? +e : e
              , i = E8(n.scope_, r, n, s);
            return n.copy_[s] = i
        }
        return r
    },
    has(n, e) {
        return e in tc(n)
    },
    ownKeys(n) {
        return Reflect.ownKeys(tc(n))
    },
    set(n, e, t) {
        const r = GW(tc(n), e);
        if (r?.set)
            return r.set.call(n.draft_, t),
            !0;
        if (!n.modified_) {
            const s = l4(tc(n), e)
              , i = s?.[ii];
            if (i && i.base_ === t)
                return n.copy_[e] = t,
                n.assigned_.set(e, !1),
                !0;
            if (nPe(t, s) && (t !== void 0 || z9(n.base_, e, n.type_)))
                return !0;
            a2(n),
            x8(n)
        }
        return n.copy_[e] === t && (t !== void 0 || e in n.copy_) || Number.isNaN(t) && Number.isNaN(n.copy_[e]) || (n.copy_[e] = t,
        n.assigned_.set(e, !0),
        uPe(n, e, t)),
        !0
    },
    deleteProperty(n, e) {
        return a2(n),
        l4(n.base_, e) !== void 0 || e in n.base_ ? (n.assigned_.set(e, !1),
        x8(n)) : n.assigned_.delete(e),
        n.copy_ && delete n.copy_[e],
        !0
    },
    getOwnPropertyDescriptor(n, e) {
        const t = tc(n)
          , r = Reflect.getOwnPropertyDescriptor(t, e);
        return r && {
            [o2]: !0,
            [m8]: n.type_ !== 1 || e !== "length",
            [kv]: r[kv],
            [my]: t[e]
        }
    },
    defineProperty() {
        ia(11)
    },
    getPrototypeOf(n) {
        return b0(n.base_)
    },
    setPrototypeOf() {
        ia(12)
    }
}
  , yy = {};
ob(Qk, (n, e) => {
    yy[n] = function() {
        const t = arguments;
        return t[0] = t[0][0],
        e.apply(this, t)
    }
}
);
yy.deleteProperty = function(n, e) {
    return yy.set.call(this, n, e, void 0)
}
;
yy.set = function(n, e, t) {
    return Qk.set.call(this, n[0], e, t, n[0])
}
;
function l4(n, e) {
    const t = n[ii];
    return (t ? tc(t) : n)[e]
}
function fPe(n, e, t) {
    const r = GW(e, t);
    return r ? my in r ? r[my] : r.get?.call(n.draft_) : void 0
}
function GW(n, e) {
    if (!(e in n))
        return;
    let t = b0(n);
    for (; t; ) {
        const r = Object.getOwnPropertyDescriptor(t, e);
        if (r)
            return r;
        t = b0(t)
    }
}
function x8(n) {
    n.modified_ || (n.modified_ = !0,
    n.parent_ && x8(n.parent_))
}
function a2(n) {
    n.copy_ || (n.assigned_ = new Map,
    n.copy_ = y8(n.base_, n.scope_.immer_.useStrictShallowCopy_))
}
var hPe = class {
    constructor(n) {
        this.autoFreeze_ = !0,
        this.useStrictShallowCopy_ = !1,
        this.useStrictIteration_ = !1,
        this.produce = (e, t, r) => {
            if (fp(e) && !fp(t)) {
                const i = t;
                t = e;
                const o = this;
                return function(l=i, ...u) {
                    return o.produce(l, d => t.call(this, d, ...u))
                }
            }
            fp(t) || ia(6),
            r !== void 0 && !fp(r) && ia(7);
            let s;
            if (ma(e)) {
                const i = H9(this)
                  , o = E8(i, e, void 0);
                let a = !0;
                try {
                    s = t(o),
                    a = !1
                } finally {
                    a ? w8(i) : v8(i)
                }
                return $9(i, r),
                V9(s, i)
            } else if (!e || !Wk(e)) {
                if (s = t(e),
                s === void 0 && (s = e),
                s === FW && (s = void 0),
                this.autoFreeze_ && Kk(s, !0),
                r) {
                    const i = []
                      , o = [];
                    w0(b8).generateReplacementPatches_(e, s, {
                        patches_: i,
                        inversePatches_: o
                    }),
                    r(i, o)
                }
                return s
            } else
                ia(1, e)
        }
        ,
        this.produceWithPatches = (e, t) => {
            if (fp(e))
                return (o, ...a) => this.produceWithPatches(o, l => e(l, ...a));
            let r, s;
            return [this.produce(e, t, (o, a) => {
                r = o,
                s = a
            }
            ), r, s]
        }
        ,
        a4(n?.autoFreeze) && this.setAutoFreeze(n.autoFreeze),
        a4(n?.useStrictShallowCopy) && this.setUseStrictShallowCopy(n.useStrictShallowCopy),
        a4(n?.useStrictIteration) && this.setUseStrictIteration(n.useStrictIteration)
    }
    createDraft(n) {
        ma(n) || ia(8),
        Oc(n) && (n = pPe(n));
        const e = H9(this)
          , t = E8(e, n, void 0);
        return t[ii].isManual_ = !0,
        v8(e),
        t
    }
    finishDraft(n, e) {
        const t = n && n[ii];
        (!t || !t.isManual_) && ia(9);
        const {scope_: r} = t;
        return $9(r, e),
        V9(void 0, r)
    }
    setAutoFreeze(n) {
        this.autoFreeze_ = n
    }
    setUseStrictShallowCopy(n) {
        this.useStrictShallowCopy_ = n
    }
    setUseStrictIteration(n) {
        this.useStrictIteration_ = n
    }
    shouldUseStrictIteration() {
        return this.useStrictIteration_
    }
    applyPatches(n, e) {
        let t;
        for (t = e.length - 1; t >= 0; t--) {
            const s = e[t];
            if (s.path.length === 0 && s.op === "replace") {
                n = s.value;
                break
            }
        }
        t > -1 && (e = e.slice(t + 1));
        const r = w0(b8).applyPatches_;
        return Oc(n) ? r(n, e) : this.produce(n, s => r(s, e))
    }
}
;
function E8(n, e, t, r) {
    const [s,i] = e3(e) ? w0(Dv).proxyMap_(e, t) : t3(e) ? w0(Dv).proxySet_(e, t) : dPe(e, t);
    return (t?.scope_ ?? $W()).drafts_.push(s),
    i.callbacks_ = t?.callbacks_ ?? [],
    i.key_ = r,
    t && r !== void 0 ? cPe(t, i, r) : i.callbacks_.push(function(l) {
        l.mapSetPlugin_?.fixSetContents(i);
        const {patchPlugin_: u} = l;
        i.modified_ && u && u.generatePatches_(i, [], l)
    }),
    s
}
function pPe(n) {
    return Oc(n) || ia(10, n),
    WW(n)
}
function WW(n) {
    if (!ma(n) || n3(n))
        return n;
    const e = n[ii];
    let t, r = !0;
    if (e) {
        if (!e.modified_)
            return e.base_;
        e.finalized_ = !0,
        t = y8(n, e.scope_.immer_.useStrictShallowCopy_),
        r = e.scope_.immer_.shouldUseStrictIteration()
    } else
        t = y8(n, !0);
    return ob(t, (s, i) => {
        Nv(t, s, WW(i))
    }
    , r),
    e && (e.finalized_ = !1),
    t
}
var mPe = new hPe
  , YW = mPe.produce;
function KW(n) {
    return ({dispatch: t, getState: r}) => s => i => typeof i == "function" ? i(t, r, n) : s(i)
}
var gPe = KW()
  , yPe = KW
  , bPe = typeof window < "u" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function() {
    if (arguments.length !== 0)
        return typeof arguments[0] == "object" ? Cv : Cv.apply(null, arguments)
}
;
function G9(n, e) {
    function t(...r) {
        if (e) {
            let s = e(...r);
            if (!s)
                throw new Error(Sc(0));
            return {
                type: n,
                payload: s.payload,
                ..."meta"in s && {
                    meta: s.meta
                },
                ..."error"in s && {
                    error: s.error
                }
            }
        }
        return {
            type: n,
            payload: r[0]
        }
    }
    return t.toString = () => `${n}`,
    t.type = n,
    t.match = r => ePe(r) && r.type === n,
    t
}
var XW = class Cg extends Array {
    constructor(...e) {
        super(...e),
        Object.setPrototypeOf(this, Cg.prototype)
    }
    static get[Symbol.species]() {
        return Cg
    }
    concat(...e) {
        return super.concat.apply(this, e)
    }
    prepend(...e) {
        return e.length === 1 && Array.isArray(e[0]) ? new Cg(...e[0].concat(this)) : new Cg(...e.concat(this))
    }
}
;
function W9(n) {
    return ma(n) ? YW(n, () => {}
    ) : n
}
function Bw(n, e, t) {
    return n.has(e) ? n.get(e) : n.set(e, t(e)).get(e)
}
function wPe(n) {
    return typeof n == "boolean"
}
var vPe = () => function(e) {
    const {thunk: t=!0, immutableCheck: r=!0, serializableCheck: s=!0, actionCreatorCheck: i=!0} = e ?? {};
    let o = new XW;
    return t && (wPe(t) ? o.push(gPe) : o.push(yPe(t.extraArgument))),
    o
}
  , xPe = "RTK_autoBatch"
  , Y9 = n => e => {
    setTimeout(e, n)
}
  , EPe = (n={
    type: "raf"
}) => e => (...t) => {
    const r = e(...t);
    let s = !0
      , i = !1
      , o = !1;
    const a = new Set
      , l = n.type === "tick" ? queueMicrotask : n.type === "raf" ? typeof window < "u" && window.requestAnimationFrame ? window.requestAnimationFrame : Y9(10) : n.type === "callback" ? n.queueNotification : Y9(n.timeout)
      , u = () => {
        o = !1,
        i && (i = !1,
        a.forEach(d => d()))
    }
    ;
    return Object.assign({}, r, {
        subscribe(d) {
            const h = () => s && d()
              , p = r.subscribe(h);
            return a.add(d),
            () => {
                p(),
                a.delete(d)
            }
        },
        dispatch(d) {
            try {
                return s = !d?.meta?.[xPe],
                i = !s,
                i && (o || (o = !0,
                l(u))),
                r.dispatch(d)
            } finally {
                s = !0
            }
        }
    })
}
  , SPe = n => function(t) {
    const {autoBatch: r=!0} = t ?? {};
    let s = new XW(n);
    return r && s.push(EPe(typeof r == "object" ? r : void 0)),
    s
}
;
function APe(n) {
    const e = vPe()
      , {reducer: t=void 0, middleware: r, devTools: s=!0, preloadedState: i=void 0, enhancers: o=void 0} = n || {};
    let a;
    if (typeof t == "function")
        a = t;
    else if (Gk(t))
        a = Z7e(t);
    else
        throw new Error(Sc(1));
    let l;
    typeof r == "function" ? l = r(e) : l = e();
    let u = Cv;
    s && (u = bPe({
        trace: !1,
        ...typeof s == "object" && s
    }));
    const d = J7e(...l)
      , h = SPe(d);
    let p = typeof o == "function" ? o(h) : h();
    const g = u(...p);
    return LW(a, i, g)
}
function QW(n) {
    const e = {}
      , t = [];
    let r;
    const s = {
        addCase(i, o) {
            const a = typeof i == "string" ? i : i.type;
            if (!a)
                throw new Error(Sc(28));
            if (a in e)
                throw new Error(Sc(29));
            return e[a] = o,
            s
        },
        addAsyncThunk(i, o) {
            return o.pending && (e[i.pending.type] = o.pending),
            o.rejected && (e[i.rejected.type] = o.rejected),
            o.fulfilled && (e[i.fulfilled.type] = o.fulfilled),
            o.settled && t.push({
                matcher: i.settled,
                reducer: o.settled
            }),
            s
        },
        addMatcher(i, o) {
            return t.push({
                matcher: i,
                reducer: o
            }),
            s
        },
        addDefaultCase(i) {
            return r = i,
            s
        }
    };
    return n(s),
    [e, t, r]
}
function CPe(n) {
    return typeof n == "function"
}
function _Pe(n, e) {
    let[t,r,s] = QW(e), i;
    if (CPe(n))
        i = () => W9(n());
    else {
        const a = W9(n);
        i = () => a
    }
    function o(a=i(), l) {
        let u = [t[l.type], ...r.filter( ({matcher: d}) => d(l)).map( ({reducer: d}) => d)];
        return u.filter(d => !!d).length === 0 && (u = [s]),
        u.reduce( (d, h) => {
            if (h)
                if (Oc(d)) {
                    const g = h(d, l);
                    return g === void 0 ? d : g
                } else {
                    if (ma(d))
                        return YW(d, p => h(p, l));
                    {
                        const p = h(d, l);
                        if (p === void 0) {
                            if (d === null)
                                return d;
                            throw Error("A case reducer on a non-draftable value must not return undefined")
                        }
                        return p
                    }
                }
            return d
        }
        , a)
    }
    return o.getInitialState = i,
    o
}
var kPe = Symbol.for("rtk-slice-createasyncthunk");
function NPe(n, e) {
    return `${n}/${e}`
}
function DPe({creators: n}={}) {
    const e = n?.asyncThunk?.[kPe];
    return function(r) {
        const {name: s, reducerPath: i=s} = r;
        if (!s)
            throw new Error(Sc(11));
        const o = (typeof r.reducers == "function" ? r.reducers(IPe()) : r.reducers) || {}
          , a = Object.keys(o)
          , l = {
            sliceCaseReducersByName: {},
            sliceCaseReducersByType: {},
            actionCreators: {},
            sliceMatchers: []
        }
          , u = {
            addCase(_, I) {
                const k = typeof _ == "string" ? _ : _.type;
                if (!k)
                    throw new Error(Sc(12));
                if (k in l.sliceCaseReducersByType)
                    throw new Error(Sc(13));
                return l.sliceCaseReducersByType[k] = I,
                u
            },
            addMatcher(_, I) {
                return l.sliceMatchers.push({
                    matcher: _,
                    reducer: I
                }),
                u
            },
            exposeAction(_, I) {
                return l.actionCreators[_] = I,
                u
            },
            exposeCaseReducer(_, I) {
                return l.sliceCaseReducersByName[_] = I,
                u
            }
        };
        a.forEach(_ => {
            const I = o[_]
              , k = {
                reducerName: _,
                type: NPe(s, _),
                createNotation: typeof r.reducers == "function"
            };
            BPe(I) ? OPe(k, I, u, e) : MPe(k, I, u)
        }
        );
        function d() {
            const [_={},I=[],k=void 0] = typeof r.extraReducers == "function" ? QW(r.extraReducers) : [r.extraReducers]
              , B = {
                ..._,
                ...l.sliceCaseReducersByType
            };
            return _Pe(r.initialState, P => {
                for (let M in B)
                    P.addCase(M, B[M]);
                for (let M of l.sliceMatchers)
                    P.addMatcher(M.matcher, M.reducer);
                for (let M of I)
                    P.addMatcher(M.matcher, M.reducer);
                k && P.addDefaultCase(k)
            }
            )
        }
        const h = _ => _
          , p = new Map
          , g = new WeakMap;
        let w;
        function b(_, I) {
            return w || (w = d()),
            w(_, I)
        }
        function v() {
            return w || (w = d()),
            w.getInitialState()
        }
        function S(_, I=!1) {
            function k(P) {
                let M = P[_];
                return typeof M > "u" && I && (M = Bw(g, k, v)),
                M
            }
            function B(P=h) {
                const M = Bw(p, I, () => new WeakMap);
                return Bw(M, P, () => {
                    const R = {};
                    for (const [L,q] of Object.entries(r.selectors ?? {}))
                        R[L] = TPe(q, P, () => Bw(g, P, v), I);
                    return R
                }
                )
            }
            return {
                reducerPath: _,
                getSelectors: B,
                get selectors() {
                    return B(k)
                },
                selectSlice: k
            }
        }
        const N = {
            name: s,
            reducer: b,
            actions: l.actionCreators,
            caseReducers: l.sliceCaseReducersByName,
            getInitialState: v,
            ...S(i),
            injectInto(_, {reducerPath: I, ...k}={}) {
                const B = I ?? i;
                return _.inject({
                    reducerPath: B,
                    reducer: b
                }, k),
                {
                    ...N,
                    ...S(B, !0)
                }
            }
        };
        return N
    }
}
function TPe(n, e, t, r) {
    function s(i, ...o) {
        let a = e(i);
        return typeof a > "u" && r && (a = t()),
        n(a, ...o)
    }
    return s.unwrapped = n,
    s
}
var Zk = DPe();
function IPe() {
    function n(e, t) {
        return {
            _reducerDefinitionType: "asyncThunk",
            payloadCreator: e,
            ...t
        }
    }
    return n.withTypes = () => n,
    {
        reducer(e) {
            return Object.assign({
                [e.name](...t) {
                    return e(...t)
                }
            }[e.name], {
                _reducerDefinitionType: "reducer"
            })
        },
        preparedReducer(e, t) {
            return {
                _reducerDefinitionType: "reducerWithPrepare",
                prepare: e,
                reducer: t
            }
        },
        asyncThunk: n
    }
}
function MPe({type: n, reducerName: e, createNotation: t}, r, s) {
    let i, o;
    if ("reducer"in r) {
        if (t && !RPe(r))
            throw new Error(Sc(17));
        i = r.reducer,
        o = r.prepare
    } else
        i = r;
    s.addCase(n, i).exposeCaseReducer(e, i).exposeAction(e, o ? G9(n, o) : G9(n))
}
function BPe(n) {
    return n._reducerDefinitionType === "asyncThunk"
}
function RPe(n) {
    return n._reducerDefinitionType === "reducerWithPrepare"
}
function OPe({type: n, reducerName: e}, t, r, s) {
    if (!s)
        throw new Error(Sc(18));
    const {payloadCreator: i, fulfilled: o, pending: a, rejected: l, settled: u, options: d} = t
      , h = s(n, i, d);
    r.exposeAction(e, h),
    o && r.addCase(h.fulfilled, o),
    a && r.addCase(h.pending, a),
    l && r.addCase(h.rejected, l),
    u && r.addMatcher(h.settled, u),
    r.exposeCaseReducer(e, {
        fulfilled: o || Rw,
        pending: a || Rw,
        rejected: l || Rw,
        settled: u || Rw
    })
}
function Rw() {}
function Sc(n) {
    return `Minified Redux Toolkit error #${n}; visit https://redux-toolkit.js.org/Errors?code=${n} for the full message or use the non-minified dev environment for full errors. `
}
const PPe = {
    game: {
        status: "NEW_GAME",
        score: 0
    }
}
  , ZW = Zk({
    name: "game",
    initialState: PPe,
    reducers: {
        start: (n, e) => {
            n.game.status = "PLAYING",
            n.game.score = 0
        }
        ,
        gameOver: (n, e) => {
            n.game.status = "GAME_OVER"
        }
        ,
        newGame: (n, e) => {
            n.game.status = "NEW_GAME",
            n.game.score = 0
        }
        ,
        addScore: (n, e) => {
            n.game.status === "PLAYING" && (n.game.score += 1)
        }
    }
})
  , {start: jPe, gameOver: LPe, newGame: FPe, updatePipe: y9e, addScore: UPe} = ZW.actions
  , zPe = ZW.reducer
  , $Pe = () => m.jsxs("div", {
    className: "snow-container",
    children: [m.jsx("div", {
        className: "snow layer1"
    }), m.jsx("div", {
        className: "snow layer2"
    }), m.jsx("div", {
        className: "snow layer3"
    })]
})
  , HPe = () => m.jsxs("div", {
    className: "wind-container",
    children: [m.jsx("div", {
        className: "wind-line wD-1"
    }), m.jsx("div", {
        className: "wind-line wD-2"
    }), m.jsx("div", {
        className: "wind-line wD-3"
    }), m.jsx("div", {
        className: "wind-line wD-4"
    }), m.jsx("div", {
        className: "wind-line wD-5"
    })]
});
function VPe({trigger: n, x: e, y: t, count: r=20, color: s="#FFD700"}) {
    const i = V.useRef(null)
      , o = V.useRef([])
      , a = V.useRef(null);
    return V.useEffect( () => {
        if (!n || !i.current)
            return;
        const u = window.innerWidth < 768 ? Math.min(r, 35) : r
          , d = e || window.innerWidth / 2
          , h = t || window.innerHeight / 2;
        o.current = Array.from({
            length: u
        }, (v, S) => ({
            id: Date.now() + S,
            x: d,
            y: h,
            vx: (Math.random() - .5) * 10,
            vy: (Math.random() - .5) * 10 - 2,
            life: 1,
            size: Math.random() * 6 + 4,
            color: s
        }));
        const p = i.current;
        p.innerHTML = "";
        const g = document.createDocumentFragment();
        o.current.forEach(v => {
            const S = document.createElement("div")
              , N = Math.min(v.size * 1.2, 12);
            S.style.cssText = `
        position: absolute;
        width: ${v.size}px;
        height: ${v.size}px;
        background-color: ${v.color};
        border-radius: 50%;
        pointer-events: none;
        will-change: transform, opacity;
        transform: translate(-50%, -50%);
        box-shadow: 0 0 ${N}px ${v.color};
      `,
            S.dataset.initialSize = v.size,
            g.appendChild(S),
            v.element = S
        }
        ),
        requestAnimationFrame( () => {
            i.current && i.current.appendChild(g)
        }
        );
        let w = performance.now();
        const b = v => {
            const S = Math.min((v - w) / 16.67, 2);
            w = v,
            o.current = o.current.filter(N => {
                if (N.life <= 0 || N.size < .5)
                    return N.element && N.element.remove(),
                    !1;
                if (N.x += N.vx * S,
                N.y += N.vy * S,
                N.vy += .2 * S,
                N.life -= .02 * S,
                N.size *= .98,
                N.element) {
                    const _ = N.element.dataset.initialSize || N.size;
                    N.element.dataset.initialSize || (N.element.dataset.initialSize = N.size);
                    const I = N.size / _;
                    N.element.style.transform = `translate(${N.x}px, ${N.y}px) translate(-50%, -50%) scale(${I})`,
                    N.element.style.opacity = N.life
                }
                return !0
            }
            ),
            o.current.length > 0 && (a.current = requestAnimationFrame(b))
        }
        ;
        return a.current = requestAnimationFrame(b),
        () => {
            a.current && cancelAnimationFrame(a.current),
            i.current && (i.current.innerHTML = ""),
            o.current = []
        }
    }
    , [n, e, t, r, s]),
    m.jsx("div", {
        ref: i,
        style: {
            position: "absolute",
            top: 0,
            left: 0,
            width: "100%",
            height: "100%",
            pointerEvents: "none",
            zIndex: 100
        }
    })
}
const qPe = ({isOpen: n, onClose: e, handleConfirm: t, balance: r, gameFees: s, gameLogo: i, isSubmitting: o}) => {
    if (!n)
        return null;
    const a = kr();
    return m.jsx("div", {
        className: "fixed inset-0 flex lg:items-center items-start lg:py-0 py-5 justify-center z-50 backdrop-blur-lg bg-black/70 overflow-auto",
        children: m.jsx("div", {
            className: "bg-[#27364b] max-w-lg w-full rounded-3xl relative mx-4 z-50 text-white overflow-hidden",
            children: m.jsxs("div", {
                className: "bg-[#2B3A4F] p-8 relative",
                children: [m.jsx("div", {
                    className: "cursor-pointer w-12 h-12 absolute right-1 top-1 flex items-center justify-center flex-col opacity-55",
                    onClick: l => {
                        l.stopPropagation(),
                        e()
                    }
                    ,
                    children: m.jsx("svg", {
                        xmlns: "http://www.w3.org/2000/svg",
                        fill: "none",
                        viewBox: "0 0 24 24",
                        strokeWidth: 1.5,
                        stroke: "currentColor",
                        className: "size-6",
                        children: m.jsx("path", {
                            strokeLinecap: "round",
                            strokeLinejoin: "round",
                            d: "M6 18 18 6M6 6l12 12"
                        })
                    })
                }), m.jsxs("div", {
                    className: "rounded-2xl mt-5",
                    children: [m.jsxs("div", {
                        children: [" ", m.jsx("img", {
                            src: i,
                            className: "max-w-[180px] mx-auto"
                        })]
                    }), m.jsx("h2", {
                        className: "text-2xl font-medium text-center mb-8",
                        children: "Play Entry Confirmation"
                    })]
                }), m.jsxs("div", {
                    className: "py-4 rounded-2xl bg-[#192330]",
                    children: [m.jsxs("div", {
                        className: "flex items-center justify-between py-3 px-4 border-b border-[#2b3a4d]",
                        children: [m.jsx("span", {
                            className: "block text-sm font-light text-[#95a5bb]",
                            children: "Entry Fee:"
                        }), " ", m.jsxs("h4", {
                            className: "font-bold text-xl flex items-center gap-2",
                            children: [m.jsx("img", {
                                src: ri,
                                className: "w-5"
                            }), s, " L1XP"]
                        })]
                    }), m.jsxs("div", {
                        className: "flex items-center justify-between py-3 px-4",
                        children: [m.jsx("span", {
                            className: "block text-sm font-light text-[#95a5bb]",
                            children: "Your Balance:"
                        }), " ", m.jsxs("h4", {
                            className: "font-bold text-xl flex items-center gap-2",
                            children: [m.jsx("img", {
                                src: ri,
                                className: "w-5"
                            }), " ", wn(r?.l1xsBalance, 2), " L1XP"]
                        })]
                    })]
                }), m.jsxs("div", {
                    className: "text-center my-8",
                    children: [m.jsx("h4", {
                        className: "text-xl font-medium",
                        children: "Ready to join"
                    }), m.jsx("p", {
                        className: "text-sm text-[#95a5bb] font-light",
                        children: "Confirm your payment to start playing!"
                    })]
                }), m.jsxs("div", {
                    className: "mt-8 flex items-center gap-3",
                    children: [r?.l1xsBalance > s ? m.jsx("button", {
                        disabled: o,
                        onClick: t,
                        className: "cursor-pointer w-full gap-3 py-4 px-5 rounded-xl text-base font-semibold hover:brightness-90 hover:scale-[1.02] transition-all duration-200 brand-gradient-bg",
                        children: o ? "Submitting..." : "Confirm & Play"
                    }) : m.jsx("button", {
                        onClick: () => a("/deposit", {
                            state: {
                                activeTab: "deposit"
                            }
                        }),
                        className: "cursor-pointer w-full gap-3 py-4 px-5 rounded-xl text-base font-semibold hover:brightness-90 hover:scale-[1.02] transition-all duration-200 brand-gradient-bg",
                        children: "Purchase L1XP"
                    }), m.jsx("button", {
                        className: "cursor-pointer w-full gap-3 py-4 px-5 rounded-xl text-base font-semibold hover:brightness-90 hover:scale-[1.02] transition-all duration-200 bg-[#46576f]",
                        onClick: l => {
                            l.stopPropagation(),
                            e()
                        }
                        ,
                        children: "Cancel"
                    })]
                })]
            })
        })
    })
}
  , GPe = "/assets/bird-20-D7MZDQJk.png"
  , WPe = "/assets/bird-35-CHEOA4Wf.png"
  , YPe = "/assets/bird-50-C1V_pbmj.png"
  , c4 = "/assets/background-day-CRpsjOJ3.png"
  , KPe = "/assets/background-night-fPvfEXAl.png"
  , XPe = "/assets/background-winter-B2eW2h_t.png"
  , QPe = "/assets/hit-DWS5ECmd.mp3"
  , ZPe = "/assets/point-BdO02iYw.mp3"
  , JPe = "/assets/wing-Bp4VN4cU.mp3"
  , K9 = n => {
    const e = n < 768;
    return {
        birdWidth: e ? 69 : 115,
        birdHeight: e ? 69 : 115,
        pipeWidth: e ? 60 : 80,
        pipeGap: e ? 240 : 280,
        gravity: .25,
        jumpStrength: e ? -5 : -5.5,
        pipeSpeed: e ? 2.5 : 3.5,
        pipeSpacing: e ? 320 : 400,
        groundHeight: e ? 60 : 80
    }
}
  , eje = n => n >= 50 ? YPe : n >= 35 ? WPe : n >= 20 ? GPe : OW
  , tje = n => {
    const t = Math.floor(n / 20) % 3;
    return t === 0 ? "day" : t === 1 ? "winter" : "night"
}
  , nje = n => {
    let e = 0;
    for (let t = 0; t < n.length; t++) {
        const r = n.charCodeAt(t);
        e = (e << 5) - e + r,
        e = e & e
    }
    return e.toString(36)
}
  , u4 = (n, e, t, r, s, i, o=!1) => {
    const a = `${n}|${e}|${Math.floor(t)}|${Math.floor(r * 100)}|${s}`
      , l = nje(a + (i || ""));
    return {
        score: n,
        timestamp: e,
        elapsedTime: 0,
        gameState: "active",
        lives: Math.floor(t),
        enemiesPassed: s,
        gameSpeed: 0,
        checksum: l,
        tampered: o,
        validated: !1,
        tamperReason: "NA"
    }
}
  , Ow = (n, e=.5, t=!1) => {
    if (!(!n?.current || t))
        try {
            const r = n.current;
            r.volume = e,
            r.currentTime = 0;
            const s = r.play();
            s !== void 0 && s.catch(i => {
                console.debug("Audio play prevented:", i.message)
            }
            )
        } catch (r) {
            console.debug("Audio play error:", r)
        }
}
;
function rje() {
    const n = q7e()
      , {game: e} = Y7e(se => se.game)
      , t = V.useRef(null)
      , r = V.useRef(null)
      , s = V.useRef(null)
      , i = V.useRef(null)
      , o = V.useRef(null)
      , {backendConfig: a, balance: l, refreshBalance: u} = Hs()
      , d = B0()
      , {gameId: h} = E0()
      , [p,g] = V.useState(!1)
      , [w,b] = V.useState(!1)
      , v = V.useRef(null)
      , S = V.useRef(null)
      , N = V.useRef(null)
      , _ = V.useRef(null)
      , {executeV3: I} = Uo()
      , [k,B] = V.useState( () => {
        const se = localStorage.getItem("flappyBirdHighScore");
        return se ? parseInt(se, 10) : 0
    }
    )
      , [P,M] = V.useState(!1)
      , [R,L] = V.useState(0)
      , [q,H] = V.useState({
        x: 0,
        y: 0
    })
      , [j,A] = V.useState("#FFD700")
      , [E,C] = V.useState(!1)
      , [O,z] = V.useState(!1)
      , [G,Y] = V.useState( () => localStorage.getItem("flappyBirdAudioMuted") === "true")
      , [$,D] = V.useState({
        current: {
            image: c4,
            color: "#70c5ce",
            opacity: 1
        },
        next: {
            image: c4,
            color: "#70c5ce",
            opacity: 0
        }
    })
      , U = V.useRef(null)
      , W = V.useRef(null)
      , Q = V.useRef(null)
      , J = V.useRef(null)
      , ne = V.useRef([])
      , ie = V.useRef(0)
      , ae = V.useRef(0)
      , [xe,ue] = V.useState({
        width: window.innerWidth,
        height: window.innerHeight
    })
      , ce = V.useRef(K9(window.innerWidth))
      , me = V.useRef({
        birdY: window.innerHeight / 2,
        velocity: 0,
        rotation: 0,
        pipes: [],
        isPlaying: !1,
        score: 0,
        speed: ce.current.pipeSpeed,
        spawnedCount: 0,
        hasStarted: !1,
        groundPos: 0
    })
      , [Ee,Oe] = V.useState({
        birdY: window.innerHeight * .3,
        rotation: 0,
        pipes: [],
        score: 0
    })
      , mt = V.useRef({
        birdY: window.innerHeight * .3,
        rotation: 0,
        pipes: [],
        score: 0
    })
      , st = V.useRef(!1);
    V.useEffect( () => {
        const se = () => {
            ue({
                width: window.innerWidth,
                height: window.innerHeight
            }),
            ce.current = K9(window.innerWidth)
        }
        ;
        return window.addEventListener("resize", se),
        () => window.removeEventListener("resize", se)
    }
    , []);
    const ot = V.useRef(null)
      , Ct = V.useRef()
      , ct = V.useCallback(async () => {
        me.current.isPlaying = !1,
        Ct.current && cancelAnimationFrame(Ct.current),
        Ow(r, .6, G);
        const se = [...me.current.pipes];
        mt.current = {
            birdY: me.current.birdY,
            rotation: me.current.rotation,
            pipes: se,
            score: me.current.score
        },
        Oe({
            birdY: me.current.birdY,
            rotation: me.current.rotation,
            pipes: se,
            score: me.current.score
        });
        const fe = me.current.score;
        fe > k ? (B(fe),
        M(!0),
        localStorage.setItem("flappyBirdHighScore", fe.toString()),
        A("#FFD700"),
        H({
            x: window.innerWidth / 2,
            y: window.innerHeight / 2
        }),
        L(Nn => Nn + 1)) : M(!1);
        const ge = Date.now() - J.current
          , _e = u4(fe, ge, me.current.birdY, me.current.velocity, ae.current, Q.current, !1);
        ne.current.push(_e);
        const Qe = ne.current?.[ne.current.length - 1].checksum
          , Ve = await F7(JSON.stringify(ne.current))
          , jt = ne.current?.[0].checksum
          , dt = await F7(Ve + jt + Qe)
          , Qt = {
            gameId: h,
            sessionId: U.current,
            clientSeed: W.current,
            finalScore: fe,
            duration: ge,
            actionCount: ae.current,
            snapshotArray: ne.current,
            checksum: dt,
            avgReactionTime: ae.current > 0 ? ge / ae.current : 0,
            snapshotCount: ne.current.length
        };
        try {
            if (!v.current)
                try {
                    v.current = await I("game_end")
                } catch (ln) {
                    console.error(" Failed to generate end-game token", ln)
                }
            const Nn = await vG(Qt, v.current);
            Nn?.status !== "success" && (console.error(" Game validation failed:", Nn?.message),
            Ze.error(Nn?.message))
        } catch (Nn) {
            console.error(" Error sending game data:", Nn)
        }
        _.current && clearTimeout(_.current),
        n(LPe()),
        _.current = null
    }
    , [G, n, h, I, k])
      , Xe = V.useCallback(se => {
        if (typeof se != "number" && (se = performance.now()),
        ot.current === null) {
            ot.current = se,
            Ct.current = requestAnimationFrame(Xe);
            return
        }
        const fe = se - ot.current;
        ot.current = se;
        const ge = Math.min(fe, 64) / 16.667
          , _e = me.current;
        if (!_e.isPlaying)
            return;
        if (_e.groundPos = (_e.groundPos || 0) - _e.speed * ge,
        i.current && (i.current.style.backgroundPositionX = `${_e.groundPos}px`),
        !_e.hasStarted) {
            const Pe = Date.now() / 300;
            _e.birdY = window.innerHeight * .3 + Math.sin(Pe) * 10,
            _e.velocity = 0,
            _e.rotation = 0,
            Math.abs(_e.birdY - mt.current.birdY) > .1 && (mt.current.birdY = _e.birdY,
            mt.current.rotation = 0,
            Oe(et => ({
                ...et,
                birdY: _e.birdY,
                rotation: 0
            }))),
            Ct.current = requestAnimationFrame(Xe);
            return
        }
        const Qe = window.innerHeight
          , Ve = window.innerWidth;
        _e.velocity += ce.current.gravity * ge,
        _e.birdY += _e.velocity * ge,
        _e.velocity < 0 ? _e.rotation = Math.max(-25, _e.rotation - 5 * ge) : _e.velocity > 0 && (_e.rotation += 3 * ge,
        _e.rotation > 90 && (_e.rotation = 90)),
        _e.pipes.forEach(Pe => Pe.x -= _e.speed * ge),
        _e.pipes.length > 0 && _e.pipes[0].x < -ce.current.pipeWidth && (_e.pipes.shift(),
        st.current = !0);
        const jt = _e.pipes[_e.pipes.length - 1];
        if ((jt ? jt.x : Ve - ce.current.pipeSpacing) < Ve - ce.current.pipeSpacing) {
            const et = Math.floor(Qe * .35)
              , Nt = Math.floor(Qe * .06)
              , pt = Qe - ce.current.groundHeight - et - Nt
              , wt = Math.max(Nt, pt)
              , Rn = Math.floor(Math.random() * (wt - Nt + 1)) + Nt
              , Zt = Rn + et
              , Jt = Qe - ce.current.groundHeight - Zt + Math.floor(Qe * .12)
              , oi = _e.spawnedCount % 2 !== 0;
            _e.pipes.push({
                id: Date.now(),
                x: Ve,
                topHeight: Rn,
                bottomPipeY: Zt,
                bottomPipeHeight: Math.max(0, Jt),
                width: ce.current.pipeWidth,
                passed: !1,
                isAlt: oi
            }),
            _e.spawnedCount++,
            st.current = !0
        }
        const Qt = Ve * .3
          , Nn = Qt + 15
          , ln = Qt + ce.current.birdWidth - 15
          , $t = _e.birdY + 15
          , $e = _e.birdY + ce.current.birdHeight - 15;
        let Ue = !1;
        if (_e.birdY + ce.current.birdHeight >= Qe - ce.current.groundHeight && (Ue = !0),
        _e.birdY < -ce.current.birdHeight && (_e.birdY = -ce.current.birdHeight,
        _e.velocity = 0),
        _e.pipes.forEach(Pe => {
            const Nt = Pe.x + 15
              , pt = Pe.x + ce.current.pipeWidth - 15;
            if (ln > Nt && Nn < pt && ($t > Pe.topHeight && $e < Pe.bottomPipeY || (Ue = !0,
            $t <= Pe.topHeight ? Pe.collidedPart = "top" : $e >= Pe.bottomPipeY && (Pe.collidedPart = "bottom"))),
            !Pe.passed && Nn > pt) {
                if (Pe.passed = !0,
                st.current = !0,
                _e.score += 1,
                _e.score % 5 === 0 && _e.score !== ie.current) {
                    const Rn = u4(_e.score, Date.now() - J.current, _e.birdY, _e.velocity, ae.current, Q.current, !1);
                    ne.current.push(Rn),
                    ie.current = _e.score
                }
                if (_e.score % 10 === 0 && (_e.speed += .5),
                [10, 25, 50, 75, 100, 150, 200].includes(_e.score)) {
                    const Rn = ["#FFD700", "#FF6B6B", "#4ECDC4", "#95E1D3", "#F38181", "#AA96DA", "#FCBAD3"]
                      , Zt = Math.min(Math.floor(_e.score / 25), Rn.length - 1);
                    A(Rn[Zt]),
                    H({
                        x: Ve * .3,
                        y: _e.birdY + ce.current.birdHeight / 2
                    }),
                    L(Jt => Jt + 1)
                }
                Ow(s, .5, G),
                n(UPe())
            }
        }
        ),
        Ue) {
            C(!0),
            N.current && clearTimeout(N.current),
            N.current = setTimeout( () => {
                C(!1),
                N.current = null
            }
            , 500),
            ct();
            return
        }
        const qe = mt.current
          , At = Math.abs(_e.birdY - qe.birdY) > .1
          , De = Math.abs(_e.rotation - qe.rotation) > .1
          , Me = _e.score !== qe.score;
        if (At || De || Me || st.current) {
            const Pe = st.current ? [..._e.pipes] : qe.pipes;
            mt.current = {
                birdY: _e.birdY,
                rotation: _e.rotation,
                pipes: Pe,
                score: _e.score
            },
            Oe({
                birdY: _e.birdY,
                rotation: _e.rotation,
                pipes: Pe,
                score: _e.score
            }),
            st.current = !1
        }
        Ct.current = requestAnimationFrame(Xe)
    }
    , [n, G, ct])
      , Et = () => {
        ot.current = null,
        M(!1),
        J.current = Date.now(),
        ne.current = [],
        ie.current = 0,
        ae.current = 0,
        st.current = !1,
        mt.current = {
            birdY: window.innerHeight * .3,
            rotation: 0,
            pipes: [],
            score: 0
        },
        Oe({
            birdY: window.innerHeight * .3,
            rotation: 0,
            pipes: [],
            score: 0
        });
        const se = u4(0, 0, window.innerHeight * .3, 0, 0, Q.current, !1);
        ne.current.push(se),
        me.current = {
            birdY: window.innerHeight * .3,
            velocity: 0,
            rotation: 0,
            pipes: [],
            isPlaying: !0,
            score: 0,
            speed: ce.current.pipeSpeed,
            spawnedCount: 0,
            hasStarted: !1,
            groundPos: 0
        },
        z(!1);
        const fe = window.innerHeight
          , _e = Math.floor(fe * .35)
          , Qe = Math.floor(fe * .06)
          , Ve = fe - ce.current.groundHeight - _e - Qe
          , jt = Math.max(Qe, Ve)
          , dt = Math.floor(Math.random() * (jt - Qe + 1)) + Qe
          , Qt = dt + _e
          , Nn = fe - ce.current.groundHeight - Qt + Math.floor(fe * .12);
        me.current.pipes.push({
            id: Date.now(),
            x: window.innerWidth + 100,
            topHeight: dt,
            bottomPipeY: Qt,
            bottomPipeHeight: Math.max(0, Nn),
            width: ce.current.pipeWidth,
            passed: !1,
            isAlt: !1
        }),
        me.current.spawnedCount++,
        n(FPe()),
        n(jPe()),
        o.current && o.current.focus(),
        Ct.current && cancelAnimationFrame(Ct.current),
        Ct.current = requestAnimationFrame(Xe)
    }
      , St = V.useCallback(se => {
        if (!p && e.status !== "GAME_OVER" && e.status !== "NEW_GAME" && !(se.target.tagName === "BUTTON" && (se.target.textContent?.includes("") || se.target.textContent?.includes(""))) && (se && se.type !== "touchstart" && se.preventDefault(),
        !!me.current.isPlaying)) {
            if (me.current.isPlaying && !me.current.hasStarted) {
                me.current.hasStarted = !0,
                z(!0),
                me.current.velocity = ce.current.jumpStrength,
                ae.current++,
                Ow(t, .4, G);
                return
            }
            me.current.velocity = ce.current.jumpStrength,
            ae.current++,
            Ow(t, .4, G)
        }
    }
    , [G, e.status, p]);
    V.useEffect( () => {
        const se = o.current;
        if (!se)
            return;
        const fe = ge => {
            (ge.code === "Space" || ge.code === "ArrowUp" || ge.code === "KeyW") && (ge.preventDefault(),
            St(ge))
        }
        ;
        return se.focus(),
        se.addEventListener("keydown", fe),
        se.addEventListener("touchstart", St, {
            passive: !1
        }),
        se.addEventListener("mousedown", St),
        () => {
            se.removeEventListener("keydown", fe),
            se.removeEventListener("touchstart", St),
            se.removeEventListener("mousedown", St)
        }
    }
    , [St]);
    const ut = se => {
        se.stopPropagation(),
        g(!0)
    }
      , cn = async () => {
        b(!0);
        const se = uy();
        W.current = se;
        const fe = await I("game_start");
        v.current = await I("game_end"),
        S.current && clearInterval(S.current),
        S.current = setInterval(async () => {
            try {
                if (!me.current.isPlaying)
                    return;
                const _e = await I("game_end");
                _e && (v.current = _e)
            } catch (_e) {
                console.debug("End-game token refresh failed:", _e)
            }
        }
        , 110 * 1e3);
        const ge = await wG({
            gameId: h,
            clientSeed: se
        }, fe);
        if (ge?.status !== "success")
            return b(!1),
            Ze.error(ge?.message);
        u(),
        U.current = ge?.data?.sessionId || uy(),
        Q.current = ge?.data?.serverSeed || "",
        g(!1),
        b(!1),
        Et()
    }
      , _t = V.useCallback( () => {
        g(!1)
    }
    , [])
      , ee = tje(Ee.score)
      , K = se => se === "day" ? {
        image: c4,
        color: "#70c5ce"
    } : se === "winter" ? {
        image: XPe,
        color: "#b8d4e3"
    } : {
        image: KPe,
        color: "#0a0a1a"
    }
      , X = V.useRef($.current.image)
      , re = V.useRef(null);
    return V.useEffect( () => {
        const se = K(ee);
        return X.current !== se.image && (re.current && (clearTimeout(re.current),
        re.current = null),
        D(fe => {
            const _e = {
                current: {
                    ...fe.current,
                    opacity: 0
                },
                next: {
                    ...se,
                    opacity: 1
                }
            };
            return re.current = setTimeout( () => {
                D({
                    current: {
                        ...se,
                        opacity: 1
                    },
                    next: {
                        ...se,
                        opacity: 0
                    }
                }),
                re.current = null
            }
            , 2e3),
            X.current = se.image,
            _e
        }
        )),
        () => {
            re.current && (clearTimeout(re.current),
            re.current = null)
        }
    }
    , [ee]),
    V.useEffect( () => () => {
        S.current && clearInterval(S.current),
        N.current && (clearTimeout(N.current),
        N.current = null),
        _.current && (clearTimeout(_.current),
        _.current = null)
    }
    , []),
    m.jsxs("div", {
        ref: o,
        className: `game-div ${E ? "shake" : ""}`,
        onClick: St,
        tabIndex: -1,
        style: {
            width: "100%",
            height: "100vh",
            overflow: "hidden",
            position: "relative",
            backgroundColor: $.current.color,
            outline: "none"
        },
        children: [m.jsx("div", {
            style: {
                position: "absolute",
                top: 0,
                left: 0,
                width: "100%",
                height: "100%",
                backgroundImage: `url(${$.current.image})`,
                backgroundSize: "cover",
                backgroundPosition: "center",
                backgroundRepeat: "no-repeat",
                opacity: $.current.opacity,
                transition: "opacity 2s ease-in-out",
                zIndex: 0
            }
        }), m.jsx("div", {
            style: {
                position: "absolute",
                top: 0,
                left: 0,
                width: "100%",
                height: "100%",
                backgroundImage: `url(${$.next.image})`,
                backgroundSize: "cover",
                backgroundPosition: "center",
                backgroundRepeat: "no-repeat",
                opacity: $.next.opacity,
                transition: "opacity 2s ease-in-out",
                zIndex: 0
            }
        }), m.jsxs("div", {
            style: {
                position: "relative",
                zIndex: 1,
                width: "100%",
                height: "100%",
                overflow: "hidden"
            },
            children: [m.jsxs("div", {
                style: {
                    position: "absolute",
                    top: "20px",
                    right: "60px",
                    display: "flex",
                    flexDirection: "row",
                    alignItems: "center",
                    gap: "15px",
                    zIndex: 100,
                    pointerEvents: "none",
                    boxSizing: "border-box"
                },
                children: [m.jsx("button", {
                    onClick: se => {
                        se.stopPropagation(),
                        se.preventDefault();
                        const fe = !G;
                        Y(fe),
                        localStorage.setItem("flappyBirdAudioMuted", fe.toString())
                    }
                    ,
                    onTouchStart: se => {
                        se.stopPropagation(),
                        se.preventDefault()
                    }
                    ,
                    onMouseDown: se => {
                        se.preventDefault()
                    }
                    ,
                    style: {
                        width: "50px",
                        height: "50px",
                        borderRadius: "50%",
                        background: "rgba(0, 0, 0, 0.6)",
                        border: "2px solid rgba(255, 255, 255, 0.3)",
                        color: "white",
                        fontSize: "24px",
                        cursor: "pointer",
                        display: "flex",
                        alignItems: "center",
                        justifyContent: "center",
                        transition: "all 0.2s",
                        backdropFilter: "blur(4px)",
                        pointerEvents: "auto",
                        touchAction: "none",
                        userSelect: "none"
                    },
                    onMouseEnter: se => se.currentTarget.style.background = "rgba(0, 0, 0, 0.8)",
                    onMouseLeave: se => se.currentTarget.style.background = "rgba(0, 0, 0, 0.6)",
                    children: G ? "" : ""
                }), e.status === "PLAYING" && m.jsxs("div", {
                    style: {
                        background: "rgba(0, 0, 0, 0.6)",
                        backdropFilter: "blur(4px)",
                        borderRadius: "12px",
                        padding: "10px 14px",
                        border: "2px solid rgba(255, 255, 255, 0.2)",
                        display: "flex",
                        flexDirection: "column",
                        alignItems: "flex-center",
                        gap: "4px",
                        pointerEvents: "none",
                        whiteSpace: "nowrap",
                        boxSizing: "border-box",
                        textAlign: "center"
                    },
                    children: [m.jsx("div", {
                        style: {
                            fontSize: "12px",
                            opacity: .8,
                            textTransform: "uppercase",
                            letterSpacing: "1px",
                            color: "white",
                            textAlign: "center"
                        },
                        children: "Best"
                    }), m.jsx("div", {
                        style: {
                            fontSize: "28px",
                            color: P ? "#FF6B6B" : "#FFD700",
                            fontWeight: "bold",
                            textShadow: "0 0 10px rgba(255, 215, 0, 0.5)",
                            animation: P ? "pulse 1s infinite" : "none",
                            lineHeight: "1"
                        },
                        children: k
                    })]
                })]
            }), m.jsx("audio", {
                ref: r,
                src: QPe,
                preload: "auto"
            }), m.jsx("audio", {
                ref: s,
                src: ZPe,
                preload: "auto"
            }), m.jsx("audio", {
                ref: t,
                src: JPe,
                preload: "auto"
            }), m.jsx($Pe, {}), m.jsx(HPe, {}), m.jsx(w7e, {
                y: Ee.birdY,
                x: xe.width * .3,
                width: ce.current.birdWidth,
                height: ce.current.birdHeight,
                rotation: Ee.rotation,
                birdSkin: eje(Ee.score)
            }), m.jsx(C7e, {
                pipes: Ee.pipes
            }), m.jsx("div", {
                ref: i,
                style: {
                    position: "absolute",
                    bottom: 0,
                    left: 0,
                    width: "100%",
                    height: `${ce.current.groundHeight}px`,
                    zIndex: 30,
                    background: `url(${v7e}) repeat-x`,
                    backgroundSize: "auto 100%"
                }
            }), e.status === "PLAYING" && !O && m.jsxs("div", {
                style: {
                    position: "absolute",
                    top: 0,
                    left: 0,
                    right: 0,
                    bottom: 0,
                    display: "flex",
                    flexDirection: "column",
                    alignItems: "center",
                    justifyContent: "center",
                    zIndex: 45,
                    pointerEvents: "none"
                },
                children: [m.jsx("div", {
                    style: {
                        textAlign: "center",
                        fontSize: window.innerWidth < 768 ? "18px" : "24px",
                        color: "white",
                        fontWeight: "bold",
                        textShadow: "2px 2px 8px rgba(0, 0, 0, 0.8)",
                        padding: "12px 24px",
                        borderRadius: "8px",
                        background: "rgba(0, 0, 0, 0.5)",
                        backdropFilter: "blur(4px)",
                        whiteSpace: "nowrap",
                        animation: "pulse 2s infinite"
                    },
                    children: window.innerWidth < 768 ? "Tap to start" : "Click or press Space to start"
                }), window.innerWidth < 768 && m.jsx("div", {
                    style: {
                        marginTop: "16px",
                        textAlign: "center",
                        fontSize: "14px",
                        color: "white",
                        fontWeight: "normal",
                        padding: "8px 16px",
                        borderRadius: "8px",
                        background: "rgba(0, 0, 0, 0.4)",
                        backdropFilter: "blur(4px)",
                        opacity: .9
                    },
                    children: "For the best experience, play in vertical mode."
                })]
            }), e.status === "PLAYING" && m.jsx("div", {
                style: {
                    position: "absolute",
                    top: "10%",
                    width: "100%",
                    textAlign: "center",
                    fontSize: "60px",
                    color: "white",
                    fontWeight: "bold",
                    zIndex: 40,
                    textShadow: "2px 2px 4px black",
                    pointerEvents: "none"
                },
                className: "score-display-top",
                children: Ee.score
            }), m.jsx(VPe, {
                trigger: R,
                x: q.x,
                y: q.y,
                count: 60,
                color: j
            }), e.status === "NEW_GAME" && m.jsxs("div", {
                style: {
                    position: "absolute",
                    top: 0,
                    left: 0,
                    width: "100%",
                    height: "100%",
                    display: "flex",
                    flexDirection: "column",
                    alignItems: "center",
                    justifyContent: "center",
                    zIndex: 50,
                    background: "rgba(0,0,0,0.3)",
                    backdropFilter: "blur(4px)"
                },
                children: [m.jsx("h1", {
                    className: "game-title",
                    children: "Awebo Bird"
                }), m.jsx("button", {
                    className: "start-button",
                    onClick: ut,
                    children: "Start"
                })]
            }), e.status === "GAME_OVER" && m.jsx("div", {
                style: {
                    position: "absolute",
                    top: 0,
                    left: 0,
                    width: "100%",
                    height: "100%",
                    display: "flex",
                    flexDirection: "column",
                    alignItems: "center",
                    justifyContent: "center",
                    zIndex: 50,
                    background: "rgba(0,0,0,0.65)",
                    backdropFilter: "blur(8px)"
                },
                children: m.jsxs("div", {
                    className: "card-container",
                    children: [m.jsx("h1", {
                        className: "game-over-title",
                        children: "Game Over"
                    }), m.jsxs("div", {
                        className: "score-card",
                        children: [m.jsx("div", {
                            className: "score-label",
                            children: "Score"
                        }), m.jsx("div", {
                            className: "score-value",
                            children: Ee.score
                        })]
                    }), k > 0 && m.jsxs("div", {
                        style: {
                            marginTop: "20px",
                            padding: "15px 30px",
                            background: "rgba(255, 255, 255, 0.1)",
                            borderRadius: "15px",
                            border: "2px solid rgba(255, 215, 0, 0.3)"
                        },
                        children: [m.jsx("div", {
                            style: {
                                fontSize: "18px",
                                color: "#000",
                                marginBottom: "8px",
                                textTransform: "uppercase",
                                letterSpacing: "2px"
                            },
                            children: "Best Score"
                        }), m.jsx("div", {
                            style: {
                                fontSize: "36px",
                                color: "#FFD700",
                                fontWeight: "bold",
                                textShadow: "0 0 10px rgba(255, 215, 0, 0.5)"
                            },
                            children: k
                        }), P && m.jsx("div", {
                            style: {
                                marginTop: "8px",
                                fontSize: "14px",
                                color: "#FF6B6B",
                                fontWeight: "bold",
                                animation: "pulse 1s infinite"
                            },
                            children: " NEW RECORD! "
                        })]
                    }), m.jsx("div", {
                        onClick: se => {
                            se.stopPropagation(),
                            ut(se)
                        }
                        ,
                        style: {
                            cursor: "pointer",
                            transition: "transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1)",
                            filter: "drop-shadow(0 10px 15px rgba(0, 0, 0, 0.2))"
                        },
                        onMouseEnter: se => se.currentTarget.style.transform = "scale(1.1) rotate(0deg)",
                        onMouseLeave: se => se.currentTarget.style.transform = "scale(1) rotate(0deg)",
                        children: m.jsx("button", {
                            className: "start-button",
                            onClick: se => {
                                se.stopPropagation(),
                                ut(se)
                            }
                            ,
                            children: "Restart"
                        })
                    })]
                })
            })]
        }), m.jsx(qPe, {
            gameFees: a?.AWEBO_GAME_FEES_IN_L1XS,
            walletInfo: d,
            balance: l,
            handleConfirm: cn,
            isOpen: p,
            onClose: _t,
            gameLogo: RW,
            isSubmitting: w
        })]
    })
}
const sje = {
    bird: {
        y: 216,
        rotation: 0
    }
}
  , JW = Zk({
    name: "bird",
    initialState: sje,
    reducers: {
        fly: (n, e) => {
            n.bird.y -= 60,
            n.bird.rotation = -30
        }
        ,
        fall: (n, e) => {
            n.bird.y += 15,
            n.bird.rotation = 0
        }
        ,
        birdReset: (n, e) => {
            n.bird.y = 216,
            n.bird.rotation = 0
        }
    }
})
  , {fly: b9e, fall: w9e, birdReset: v9e} = JW.actions
  , ije = JW.reducer
  , oje = {
    startPosition: {
        x: 288
    },
    pipes: [{
        height: 150
    }]
}
  , eY = Zk({
    name: "pipe",
    initialState: oje,
    reducers: {
        pipeRun: (n, e) => {
            if (!n.pipes.length)
                return;
            const t = e.payload?.speed || 10;
            n.startPosition.x -= t
        }
        ,
        generatePipe: (n, e) => {
            const t = Math.round(Math.random() * 150) + 100;
            n.pipes = [...n.pipes, {
                height: t
            }]
        }
        ,
        pipeReset: (n, e) => {
            n.startPosition.x = 288,
            n.pipes = [{
                height: 150
            }]
        }
    }
})
  , {pipeRun: x9e, generatePipe: E9e, pipeReset: S9e} = eY.actions
  , aje = eY.reducer
  , lje = APe({
    reducer: {
        game: zPe,
        bird: ije,
        pipe: aje
    }
});
function cje() {
    return m.jsx($7e, {
        store: lje,
        children: m.jsx(rje, {})
    })
}
const uje = () => {
    const n = kr()
      , [e,t] = V.useState(!1)
      , [r,s] = V.useState(null)
      , {backendConfig: i} = Hs()
      , {showGameHistory: o, setShowGameHistory: a, history: l, isFullscreen: u, toggleFullscreen: d, gameHistoryRef: h} = $x(X2);
    return m.jsxs("div", {
        className: u ? "" : "py-10 px-4",
        children: [m.jsxs("div", {
            className: `game-area ${u ? "" : "p-4 border border-white rounded-2xl"}  transition-all duration-300 ${u ? "fixed inset-0 z-[9999] w-screen h-screen m-0 p-2 bg-black" : "relative bg-black/50"}`,
            style: u ? {
                top: 0,
                left: 0,
                right: 0,
                bottom: 0
            } : {},
            children: [!u && m.jsxs("div", {
                className: "flex items-center justify-between lg:mb-4 mb-0",
                children: [m.jsxs("div", {
                    className: "flex items-center gap-4",
                    children: [m.jsx("button", {
                        onClick: () => n(-1),
                        className: "bg-[#314258] w-10 h-10 rounded-full flex items-center justify-center hover:bg-[#3d5269] transition-colors",
                        children: m.jsx("svg", {
                            xmlns: "http://www.w3.org/2000/svg",
                            fill: "none",
                            viewBox: "0 0 24 24",
                            strokeWidth: 1.5,
                            stroke: "currentColor",
                            className: "size-6",
                            children: m.jsx("path", {
                                strokeLinecap: "round",
                                strokeLinejoin: "round",
                                d: "M10.5 19.5 3 12m0 0 7.5-7.5M3 12h18"
                            })
                        })
                    }), m.jsx("img", {
                        src: RW,
                        className: "w-24 h-auto md:block hidden"
                    })]
                }), m.jsxs("div", {
                    className: "flex items-center gap-2",
                    children: [m.jsxs("button", {
                        onClick: () => a(!0),
                        className: "bg-white rounded-2xl text-black px-4 py-2 flex items-center text-base cursor-pointer gap-1.5 hover:bg-gray-100 transition-colors",
                        children: [m.jsx("svg", {
                            xmlns: "http://www.w3.org/2000/svg",
                            fill: "none",
                            viewBox: "0 0 24 24",
                            strokeWidth: 1.5,
                            stroke: "currentColor",
                            className: "size-6",
                            children: m.jsx("path", {
                                strokeLinecap: "round",
                                strokeLinejoin: "round",
                                d: "M12 6v6h4.5m4.5 0a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"
                            })
                        }), "Game History"]
                    }), m.jsx("button", {
                        onClick: d,
                        className: "w-10 h-10 rounded-full bg-black/50 flex items-center justify-center hover:bg-black/70 transition-colors",
                        title: "Enter Fullscreen",
                        children: m.jsx("svg", {
                            xmlns: "http://www.w3.org/2000/svg",
                            fill: "none",
                            viewBox: "0 0 24 24",
                            strokeWidth: 1.5,
                            stroke: "currentColor",
                            className: "size-6",
                            children: m.jsx("path", {
                                strokeLinecap: "round",
                                strokeLinejoin: "round",
                                d: "M3.75 3.75v4.5m0-4.5h4.5m-4.5 0L9 9M3.75 20.25v-4.5m0 4.5h4.5m-4.5 0L9 15M20.25 3.75h-4.5m4.5 0v4.5m0-4.5L15 9m5.25 11.25h-4.5m4.5 0v-4.5m0 4.5L15 15"
                            })
                        })
                    })]
                })]
            }), m.jsxs("div", {
                className: "play-area pt-4 md:pt-0 rounded-2xl overflow-hidden relative ",
                children: [u && m.jsx("div", {
                    className: "absolute top-4 right-4 z-51",
                    children: m.jsx("button", {
                        onClick: d,
                        className: "w-12 h-12 rounded-full bg-black/70 flex items-center justify-center hover:bg-black/90 transition-colors border-2 border-white/20",
                        title: "Exit Fullscreen (ESC)",
                        children: m.jsx("svg", {
                            xmlns: "http://www.w3.org/2000/svg",
                            fill: "none",
                            viewBox: "0 0 24 24",
                            strokeWidth: 2,
                            stroke: "currentColor",
                            className: "size-6 text-white",
                            children: m.jsx("path", {
                                strokeLinecap: "round",
                                strokeLinejoin: "round",
                                d: "M9 9V4.5M9 9H4.5M9 9 3.75 3.75M9 15v4.5M9 15H4.5M9 15l-5.25 5.25M15 9h4.5M15 9V4.5M15 9l5.25-5.25M15 15h4.5M15 15v4.5m0-4.5 5.25 5.25"
                            })
                        })
                    })
                }), m.jsx(cje, {}), m.jsx(BW, {
                    isOpen: i?.AWEBO_ENABLED === 0 || i?.AWEBO_ENABLED === "0",
                    onClose: () => {}
                })]
            }), o && !u && m.jsxs("div", {
                ref: h,
                className: "gameHistory bg-black/90 p-4 border border-white rounded-2xl absolute top-0 right-0 max-w-[500px] w-full z-50 h-full overflow-y-auto",
                children: [m.jsxs("div", {
                    className: "flex items-center justify-start gap-2 mb-4",
                    children: [m.jsx("button", {
                        onClick: () => a(!1),
                        className: "rounded-2xl text-white flex items-center text-base cursor-pointer gap-1.5",
                        children: m.jsx("svg", {
                            xmlns: "http://www.w3.org/2000/svg",
                            fill: "none",
                            viewBox: "0 0 24 24",
                            strokeWidth: 1.5,
                            stroke: "currentColor",
                            className: "size-6",
                            children: m.jsx("path", {
                                strokeLinecap: "round",
                                strokeLinejoin: "round",
                                d: "M15.75 19.5 8.25 12l7.5-7.5"
                            })
                        })
                    }), m.jsx("h3", {
                        className: "text-white text-xl font-bold",
                        children: "Game History"
                    })]
                }), m.jsxs("div", {
                    className: "flex flex-col gap-2",
                    children: [m.jsxs("div", {
                        className: "grid grid-cols-3 px-4 pb-1 uppercase opacity-70 text-sm",
                        children: [m.jsx("p", {
                            children: "ID"
                        }), m.jsx("p", {
                            children: "Start Time"
                        }), m.jsx("p", {
                            children: "Score"
                        })]
                    }), l?.map( (p, g) => {
                        const w = new Date(p?.createdAt)
                          , b = w.toLocaleString("en-IN", {
                            month: "short"
                        }) + " " + w.toLocaleString("en-IN", {
                            day: "2-digit"
                        }) + ", " + w.toLocaleString("en-IN", {
                            hour: "2-digit",
                            minute: "2-digit",
                            hour12: !0
                        }).toLowerCase();
                        return m.jsxs("div", {
                            className: "grid grid-cols-3 bg-[#182637] px-4 py-3 rounded-sm mb-1",
                            children: [m.jsx("a", {
                                href: "#",
                                children: zo(p?.sessionId)
                            }), m.jsx("p", {
                                children: b
                            }), m.jsxs("p", {
                                children: [wn(p?.outcomeValue), " Points"]
                            })]
                        }, g)
                    }
                    )]
                })]
            })]
        }), m.jsx(MW, {
            isOpen: e,
            onClose: () => t(!1),
            data: r
        })]
    })
}
;
function dje() {
    return V.useEffect( () => {
        const n = s => (s.preventDefault(),
        s.stopPropagation(),
        !1)
          , e = s => {
            const i = s.key?.toLowerCase() || ""
              , o = s.metaKey || s.keyCode === 91 || s.keyCode === 93
              , a = s.ctrlKey;
            if (s.key === "F12" || s.keyCode === 123 || a && s.shiftKey && (i === "i" || i === "j" || s.keyCode === 73 || s.keyCode === 74) || a && (i === "u" || i === "s" || s.keyCode === 85 || s.keyCode === 83) || o && s.altKey && (i === "i" || i === "j" || s.keyCode === 73 || s.keyCode === 74) || o && s.shiftKey && (i === "i" || i === "j" || s.keyCode === 73 || s.keyCode === 74) || o && (i === "u" || i === "s" || s.keyCode === 85 || s.keyCode === 83))
                return s.preventDefault(),
                s.stopImmediatePropagation(),
                !1
        }
          , t = () => {
            const i = window.outerWidth - window.innerWidth > 160
              , o = window.outerHeight - window.innerHeight > 160;
            (i || o) && (window.blur(),
            window.focus(),
            document.body.focus())
        }
        ;
        document.addEventListener("contextmenu", n, !0),
        document.addEventListener("keydown", e, !0),
        window.addEventListener("contextmenu", n, !0),
        window.addEventListener("keydown", e, !0);
        const r = setInterval(t, 500);
        return () => {
            document.removeEventListener("contextmenu", n, !0),
            document.removeEventListener("keydown", e, !0),
            window.removeEventListener("contextmenu", n, !0),
            window.removeEventListener("keydown", e, !0),
            clearInterval(r)
        }
    }
    , []),
    V.useEffect( () => {
        (async () => {
            const n = S0("userInfo");
            n.success && n?.walletAddress && await Ji.setActiveWallet(n.walletType, n.walletType)
        }
        )()
    }
    , []),
    m.jsxs(O5e, {
        children: [m.jsxs(cL, {
            children: [m.jsxs(Vn, {
                element: m.jsx(iDe, {}),
                children: [m.jsx(Vn, {
                    path: "/",
                    element: m.jsx(UA, {})
                }), m.jsx(Vn, {
                    path: "/twitter-success/:isSharedSuccess",
                    element: m.jsx(UA, {})
                }), m.jsx(Vn, {
                    path: "/deposit",
                    element: m.jsx(fP, {})
                }), m.jsx(Vn, {
                    path: "/deposit/:merchantOrderId",
                    element: m.jsx(fP, {})
                }), m.jsx(Vn, {
                    path: "/alchemy/:merchantOrderId",
                    element: m.jsx(zTe, {})
                }), m.jsx(Vn, {
                    path: "/leaderboard/all-games",
                    element: m.jsx(ag, {
                        initialTab: "all-games"
                    })
                }), m.jsx(Vn, {
                    path: "/leaderboard/biscuit-run",
                    element: m.jsx(ag, {
                        initialTab: "today"
                    })
                }), m.jsx(Vn, {
                    path: "/leaderboard/jackpot-winners",
                    element: m.jsx(ag, {
                        initialTab: "jackpot-winners"
                    })
                }), m.jsx(Vn, {
                    path: "/leaderboard/awebo-bird",
                    element: m.jsx(ag, {
                        initialTab: "awebo"
                    })
                }), m.jsx(Vn, {
                    path: "/leaderboard",
                    element: m.jsx(ag, {})
                }), m.jsx(Vn, {
                    path: "/landing",
                    element: m.jsx(UA, {})
                }), m.jsx(Vn, {
                    path: "/my-profile",
                    element: m.jsx(tDe, {})
                }), m.jsx(Vn, {
                    path: "/biscuit-run/:gameId",
                    element: m.jsx(vTe, {})
                }), m.jsx(Vn, {
                    path: "/crash-game/:gameId/*",
                    element: m.jsx(jTe, {})
                }), m.jsx(Vn, {
                    path: "/plinko-game/:gameId/*",
                    element: m.jsx(b7e, {})
                }), m.jsx(Vn, {
                    path: "/awebo-bird/:gameId",
                    element: m.jsx(uje, {})
                })]
            }), m.jsx(Vn, {
                path: "/login",
                element: m.jsx(EAe, {})
            }), m.jsx(Vn, {
                path: "/create-account",
                element: m.jsx(nDe, {})
            }), m.jsx(Vn, {
                path: "/verify/*",
                element: m.jsx(UTe, {})
            }), m.jsx(Vn, {
                path: "/forgot-password/*",
                element: m.jsx($Te, {})
            }), m.jsx(Vn, {
                path: "/terms-and-conditions",
                element: m.jsx(iCe, {})
            }), m.jsx(Vn, {
                path: "/verify-games",
                element: m.jsx(HTe, {})
            })]
        }), m.jsx(AAe, {})]
    })
}
window.Buffer = Mt.Buffer;
{
    const n = window.__REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (n)
        for (const e in n)
            n[e] = typeof n[e] == "function" ? () => {}
            : null
}
yX.createRoot(document.getElementById("root")).render(m.jsx(V.StrictMode, {
    children: m.jsx(MQ, {
        children: m.jsx(tZ, {
            type: "v3",
            siteKey: "6LdFGgQsAAAAAL8eDSS_YSUBBNevqgnkVZJkaCy3",
            scriptProps: {
                async: !0,
                defer: !0,
                appendTo: "head"
            },
            children: m.jsx(dje, {})
        })
    })
}));
export {iy as A, y_ as B, Bpe as C, i0e as D, Phe as E, Tc as F, Of as G, Fu as H, Xf as I, Ex as J, Pa as K, _o as L, Oa as M, AV as N, Cie as O, iR as P, O$ as Q, BM as R, Jp as S, Xv as T, l_ as U, ra as V, Z8 as W, ro as X, V$ as Y, g_ as _, je as a, Dc as b, Mle as c, Xae as d, Dg as e, Bo as f, Fo as g, D0 as h, Vue as i, Oue as j, sue as k, jpe as l, Gce as m, no as n, Obe as o, m1e as p, ta as q, iue as r, rC as s, Ni as t, Qf as u, K_ as v, Ii as w, swe as x, Y_ as y, Sx as z};
